[
  {
    "function_name": "gfs2_rlist_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2600-2612",
    "snippet": "void gfs2_rlist_free(struct gfs2_rgrp_list *rlist)\n{\n\tunsigned int x;\n\n\tkfree(rlist->rl_rgd);\n\n\tif (rlist->rl_ghs) {\n\t\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\t\tgfs2_holder_uninit(&rlist->rl_ghs[x]);\n\t\tkfree(rlist->rl_ghs);\n\t\trlist->rl_ghs = NULL;\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rlist->rl_ghs"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_holder_uninit",
          "args": [
            "&rlist->rl_ghs[x]"
          ],
          "line": 2608
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "841-847",
          "snippet": "void gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_uninit(struct gfs2_holder *gh)\n{\n\tput_pid(gh->gh_owner_pid);\n\tgfs2_glock_put(gh->gh_gl);\n\tgh->gh_gl = NULL;\n\tgh->gh_ip = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rlist->rl_rgd"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rlist_free(struct gfs2_rgrp_list *rlist)\n{\n\tunsigned int x;\n\n\tkfree(rlist->rl_rgd);\n\n\tif (rlist->rl_ghs) {\n\t\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\t\tgfs2_holder_uninit(&rlist->rl_ghs[x]);\n\t\tkfree(rlist->rl_ghs);\n\t\trlist->rl_ghs = NULL;\n\t}\n}"
  },
  {
    "function_name": "gfs2_rlist_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2582-2592",
    "snippet": "void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state)\n{\n\tunsigned int x;\n\n\trlist->rl_ghs = kcalloc(rlist->rl_rgrps, sizeof(struct gfs2_holder),\n\t\t\t\tGFP_NOFS | __GFP_NOFAIL);\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tgfs2_holder_init(rlist->rl_rgd[x]->rd_gl,\n\t\t\t\tstate, 0,\n\t\t\t\t&rlist->rl_ghs[x]);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_holder_init",
          "args": [
            "rlist->rl_rgd[x]->rd_gl",
            "state",
            "0",
            "&rlist->rl_ghs[x]"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_holder_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "801-813",
          "snippet": "void gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_holder_init(struct gfs2_glock *gl, unsigned int state, unsigned flags,\n\t\t      struct gfs2_holder *gh)\n{\n\tINIT_LIST_HEAD(&gh->gh_list);\n\tgh->gh_gl = gl;\n\tgh->gh_ip = _RET_IP_;\n\tgh->gh_owner_pid = get_pid(task_pid(current));\n\tgh->gh_state = state;\n\tgh->gh_flags = flags;\n\tgh->gh_error = 0;\n\tgh->gh_iflags = 0;\n\tgfs2_glock_hold(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "rlist->rl_rgrps",
            "sizeof(struct gfs2_holder)",
            "GFP_NOFS | __GFP_NOFAIL"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state)\n{\n\tunsigned int x;\n\n\trlist->rl_ghs = kcalloc(rlist->rl_rgrps, sizeof(struct gfs2_holder),\n\t\t\t\tGFP_NOFS | __GFP_NOFAIL);\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tgfs2_holder_init(rlist->rl_rgd[x]->rd_gl,\n\t\t\t\tstate, 0,\n\t\t\t\t&rlist->rl_ghs[x]);\n}"
  },
  {
    "function_name": "gfs2_rlist_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2527-2570",
    "snippet": "void gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,\n\t\t    u64 block)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd **tmp;\n\tunsigned int new_space;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(sdp, !rlist->rl_ghs))\n\t\treturn;\n\n\tif (ip->i_rgd && rgrp_contains_block(ip->i_rgd, block))\n\t\trgd = ip->i_rgd;\n\telse\n\t\trgd = gfs2_blk2rgrpd(sdp, block, 1);\n\tif (!rgd) {\n\t\tfs_err(sdp, \"rlist_add: no rgrp for block %llu\\n\", (unsigned long long)block);\n\t\treturn;\n\t}\n\tip->i_rgd = rgd;\n\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tif (rlist->rl_rgd[x] == rgd)\n\t\t\treturn;\n\n\tif (rlist->rl_rgrps == rlist->rl_space) {\n\t\tnew_space = rlist->rl_space + 10;\n\n\t\ttmp = kcalloc(new_space, sizeof(struct gfs2_rgrpd *),\n\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\n\t\tif (rlist->rl_rgd) {\n\t\t\tmemcpy(tmp, rlist->rl_rgd,\n\t\t\t       rlist->rl_space * sizeof(struct gfs2_rgrpd *));\n\t\t\tkfree(rlist->rl_rgd);\n\t\t}\n\n\t\trlist->rl_space = new_space;\n\t\trlist->rl_rgd = tmp;\n\t}\n\n\trlist->rl_rgd[rlist->rl_rgrps++] = rgd;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rlist->rl_rgd"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "rlist->rl_rgd",
            "rlist->rl_space * sizeof(struct gfs2_rgrpd *)"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "new_space",
            "sizeof(struct gfs2_rgrpd *)",
            "GFP_NOFS | __GFP_NOFAIL"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"rlist_add: no rgrp for block %llu\\n\"",
            "(unsigned long long)block"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_blk2rgrpd",
          "args": [
            "sdp",
            "block",
            "1"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_blk2rgrpd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "503-532",
          "snippet": "struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rgrp_contains_block",
          "args": [
            "ip->i_rgd",
            "block"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "rgrp_contains_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "487-492",
          "snippet": "static inline int rgrp_contains_block(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tu64 first = rgd->rd_data0;\n\tu64 last = first + rgd->rd_data;\n\treturn first <= block && block < last;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int rgrp_contains_block(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tu64 first = rgd->rd_data0;\n\tu64 last = first + rgd->rd_data;\n\treturn first <= block && block < last;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "!rlist->rl_ghs"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,\n\t\t    u64 block)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd **tmp;\n\tunsigned int new_space;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(sdp, !rlist->rl_ghs))\n\t\treturn;\n\n\tif (ip->i_rgd && rgrp_contains_block(ip->i_rgd, block))\n\t\trgd = ip->i_rgd;\n\telse\n\t\trgd = gfs2_blk2rgrpd(sdp, block, 1);\n\tif (!rgd) {\n\t\tfs_err(sdp, \"rlist_add: no rgrp for block %llu\\n\", (unsigned long long)block);\n\t\treturn;\n\t}\n\tip->i_rgd = rgd;\n\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tif (rlist->rl_rgd[x] == rgd)\n\t\t\treturn;\n\n\tif (rlist->rl_rgrps == rlist->rl_space) {\n\t\tnew_space = rlist->rl_space + 10;\n\n\t\ttmp = kcalloc(new_space, sizeof(struct gfs2_rgrpd *),\n\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\n\t\tif (rlist->rl_rgd) {\n\t\t\tmemcpy(tmp, rlist->rl_rgd,\n\t\t\t       rlist->rl_space * sizeof(struct gfs2_rgrpd *));\n\t\t\tkfree(rlist->rl_rgd);\n\t\t}\n\n\t\trlist->rl_space = new_space;\n\t\trlist->rl_rgd = tmp;\n\t}\n\n\trlist->rl_rgd[rlist->rl_rgrps++] = rgd;\n}"
  },
  {
    "function_name": "gfs2_check_blk_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2493-2513",
    "snippet": "int gfs2_check_blk_type(struct gfs2_sbd *sdp, u64 no_addr, unsigned int type)\n{\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_holder rgd_gh;\n\tint error = -EINVAL;\n\n\trgd = gfs2_blk2rgrpd(sdp, no_addr, 1);\n\tif (!rgd)\n\t\tgoto fail;\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_SHARED, 0, &rgd_gh);\n\tif (error)\n\t\tgoto fail;\n\n\tif (gfs2_get_block_type(rgd, no_addr) != type)\n\t\terror = -ESTALE;\n\n\tgfs2_glock_dq_uninit(&rgd_gh);\nfail:\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&rgd_gh"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_get_block_type",
          "args": [
            "rgd",
            "no_addr"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2097-2106",
          "snippet": "static unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tstruct gfs2_rbm rbm = { .rgd = rgd, };\n\tint ret;\n\n\tret = gfs2_rbm_from_block(&rbm, block);\n\tWARN_ON_ONCE(ret != 0);\n\n\treturn gfs2_testbit(&rbm);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tstruct gfs2_rbm rbm = { .rgd = rgd, };\n\tint ret;\n\n\tret = gfs2_rbm_from_block(&rbm, block);\n\tWARN_ON_ONCE(ret != 0);\n\n\treturn gfs2_testbit(&rbm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "rgd->rd_gl",
            "LM_ST_SHARED",
            "0",
            "&rgd_gh"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_blk2rgrpd",
          "args": [
            "sdp",
            "no_addr",
            "1"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_blk2rgrpd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "503-532",
          "snippet": "struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_check_blk_type(struct gfs2_sbd *sdp, u64 no_addr, unsigned int type)\n{\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_holder rgd_gh;\n\tint error = -EINVAL;\n\n\trgd = gfs2_blk2rgrpd(sdp, no_addr, 1);\n\tif (!rgd)\n\t\tgoto fail;\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_SHARED, 0, &rgd_gh);\n\tif (error)\n\t\tgoto fail;\n\n\tif (gfs2_get_block_type(rgd, no_addr) != type)\n\t\terror = -ESTALE;\n\n\tgfs2_glock_dq_uninit(&rgd_gh);\nfail:\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_free_di",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2474-2480",
    "snippet": "void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip)\n{\n\tgfs2_free_uninit_di(rgd, ip->i_no_addr);\n\ttrace_gfs2_block_alloc(ip, rgd, ip->i_no_addr, 1, GFS2_BLKST_FREE);\n\tgfs2_quota_change(ip, -1, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tgfs2_meta_wipe(ip, ip->i_no_addr, 1);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_meta_wipe",
          "args": [
            "ip",
            "ip->i_no_addr",
            "1"
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_wipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "305-324",
          "snippet": "void gfs2_meta_wipe(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh;\n\n\twhile (blen) {\n\t\tbh = gfs2_getbuf(ip->i_gl, bstart, NO_CREATE);\n\t\tif (bh) {\n\t\t\tlock_buffer(bh);\n\t\t\tgfs2_log_lock(sdp);\n\t\t\tgfs2_remove_from_journal(bh, current->journal_info, 1);\n\t\t\tgfs2_log_unlock(sdp);\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tbstart++;\n\t\tblen--;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_meta_wipe(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh;\n\n\twhile (blen) {\n\t\tbh = gfs2_getbuf(ip->i_gl, bstart, NO_CREATE);\n\t\tif (bh) {\n\t\t\tlock_buffer(bh);\n\t\t\tgfs2_log_lock(sdp);\n\t\t\tgfs2_remove_from_journal(bh, current->journal_info, 1);\n\t\t\tgfs2_log_unlock(sdp);\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tbstart++;\n\t\tblen--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_change",
          "args": [
            "ip",
            "-1",
            "ip->i_inode.i_uid",
            "ip->i_inode.i_gid"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1145-1164",
          "snippet": "void gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_gfs2_block_alloc",
          "args": [
            "ip",
            "rgd",
            "ip->i_no_addr",
            "1",
            "GFS2_BLKST_FREE"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_free_uninit_di",
          "args": [
            "rgd",
            "ip->i_no_addr"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_free_uninit_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2450-2471",
          "snippet": "static void gfs2_free_uninit_di(struct gfs2_rgrpd *rgd, u64 blkno)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_rgrpd *tmp_rgd;\n\n\ttmp_rgd = rgblk_free(sdp, blkno, 1, GFS2_BLKST_FREE);\n\tif (!tmp_rgd)\n\t\treturn;\n\tgfs2_assert_withdraw(sdp, rgd == tmp_rgd);\n\n\tif (!rgd->rd_dinodes)\n\t\tgfs2_consist_rgrpd(rgd);\n\trgd->rd_dinodes--;\n\trgd->rd_free++;\n\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\tupdate_rgrp_lvb_unlinked(rgd, -1);\n\n\tgfs2_statfs_change(sdp, 0, +1, -1);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_free_uninit_di(struct gfs2_rgrpd *rgd, u64 blkno)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_rgrpd *tmp_rgd;\n\n\ttmp_rgd = rgblk_free(sdp, blkno, 1, GFS2_BLKST_FREE);\n\tif (!tmp_rgd)\n\t\treturn;\n\tgfs2_assert_withdraw(sdp, rgd == tmp_rgd);\n\n\tif (!rgd->rd_dinodes)\n\t\tgfs2_consist_rgrpd(rgd);\n\trgd->rd_dinodes--;\n\trgd->rd_free++;\n\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\tupdate_rgrp_lvb_unlinked(rgd, -1);\n\n\tgfs2_statfs_change(sdp, 0, +1, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip)\n{\n\tgfs2_free_uninit_di(rgd, ip->i_no_addr);\n\ttrace_gfs2_block_alloc(ip, rgd, ip->i_no_addr, 1, GFS2_BLKST_FREE);\n\tgfs2_quota_change(ip, -1, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tgfs2_meta_wipe(ip, ip->i_no_addr, 1);\n}"
  },
  {
    "function_name": "gfs2_free_uninit_di",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2450-2471",
    "snippet": "static void gfs2_free_uninit_di(struct gfs2_rgrpd *rgd, u64 blkno)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_rgrpd *tmp_rgd;\n\n\ttmp_rgd = rgblk_free(sdp, blkno, 1, GFS2_BLKST_FREE);\n\tif (!tmp_rgd)\n\t\treturn;\n\tgfs2_assert_withdraw(sdp, rgd == tmp_rgd);\n\n\tif (!rgd->rd_dinodes)\n\t\tgfs2_consist_rgrpd(rgd);\n\trgd->rd_dinodes--;\n\trgd->rd_free++;\n\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\tupdate_rgrp_lvb_unlinked(rgd, -1);\n\n\tgfs2_statfs_change(sdp, 0, +1, -1);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_statfs_change",
          "args": [
            "sdp",
            "0",
            "+1",
            "-1"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_statfs_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "515-548",
          "snippet": "void gfs2_statfs_change(struct gfs2_sbd *sdp, s64 total, s64 free,\n\t\t\ts64 dinodes)\n{\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct buffer_head *l_bh;\n\ts64 x, y;\n\tint need_sync = 0;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\tif (error)\n\t\treturn;\n\n\tgfs2_trans_add_meta(l_ip->i_gl, l_bh);\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tl_sc->sc_total += total;\n\tl_sc->sc_free += free;\n\tl_sc->sc_dinodes += dinodes;\n\tgfs2_statfs_change_out(l_sc, l_bh->b_data + sizeof(struct gfs2_dinode));\n\tif (sdp->sd_args.ar_statfs_percent) {\n\t\tx = 100 * l_sc->sc_free;\n\t\ty = m_sc->sc_free * sdp->sd_args.ar_statfs_percent;\n\t\tif (x >= y || x <= -y)\n\t\t\tneed_sync = 1;\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tbrelse(l_bh);\n\tif (need_sync)\n\t\tgfs2_wake_up_statfs(sdp);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_statfs_change(struct gfs2_sbd *sdp, s64 total, s64 free,\n\t\t\ts64 dinodes)\n{\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct buffer_head *l_bh;\n\ts64 x, y;\n\tint need_sync = 0;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\tif (error)\n\t\treturn;\n\n\tgfs2_trans_add_meta(l_ip->i_gl, l_bh);\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tl_sc->sc_total += total;\n\tl_sc->sc_free += free;\n\tl_sc->sc_dinodes += dinodes;\n\tgfs2_statfs_change_out(l_sc, l_bh->b_data + sizeof(struct gfs2_dinode));\n\tif (sdp->sd_args.ar_statfs_percent) {\n\t\tx = 100 * l_sc->sc_free;\n\t\ty = m_sc->sc_free * sdp->sd_args.ar_statfs_percent;\n\t\tif (x >= y || x <= -y)\n\t\t\tneed_sync = 1;\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tbrelse(l_bh);\n\tif (need_sync)\n\t\tgfs2_wake_up_statfs(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rgrp_lvb_unlinked",
          "args": [
            "rgd",
            "-1"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "update_rgrp_lvb_unlinked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1104-1109",
          "snippet": "static void update_rgrp_lvb_unlinked(struct gfs2_rgrpd *rgd, u32 change)\n{\n\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n\tu32 unlinked = be32_to_cpu(rgl->rl_unlinked) + change;\n\trgl->rl_unlinked = cpu_to_be32(unlinked);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void update_rgrp_lvb_unlinked(struct gfs2_rgrpd *rgd, u32 change)\n{\n\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n\tu32 unlinked = be32_to_cpu(rgl->rl_unlinked) + change;\n\trgl->rl_unlinked = cpu_to_be32(unlinked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_ondisk2lvb",
          "args": [
            "rgd->rd_rgl",
            "rgd->rd_bits[0].bi_bh->b_data"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_ondisk2lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1092-1102",
          "snippet": "static void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_out",
          "args": [
            "rgd",
            "rgd->rd_bits[0].bi_bh->b_data"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1068-1078",
          "snippet": "static void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrp *str = buf;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tstr->__pad = cpu_to_be32(0);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrp *str = buf;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tstr->__pad = cpu_to_be32(0);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "rgd->rd_gl",
            "rgd->rd_bits[0].bi_bh"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist_rgrpd",
          "args": [
            "rgd"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "sdp",
            "rgd == tmp_rgd"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgblk_free",
          "args": [
            "sdp",
            "blkno",
            "1",
            "GFS2_BLKST_FREE"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "rgblk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2152-2184",
          "snippet": "static struct gfs2_rgrpd *rgblk_free(struct gfs2_sbd *sdp, u64 bstart,\n\t\t\t\t     u32 blen, unsigned char new_state)\n{\n\tstruct gfs2_rbm rbm;\n\tstruct gfs2_bitmap *bi, *bi_prev = NULL;\n\n\trbm.rgd = gfs2_blk2rgrpd(sdp, bstart, 1);\n\tif (!rbm.rgd) {\n\t\tif (gfs2_consist(sdp))\n\t\t\tfs_err(sdp, \"block = %llu\\n\", (unsigned long long)bstart);\n\t\treturn NULL;\n\t}\n\n\tgfs2_rbm_from_block(&rbm, bstart);\n\twhile (blen--) {\n\t\tbi = rbm_bi(&rbm);\n\t\tif (bi != bi_prev) {\n\t\t\tif (!bi->bi_clone) {\n\t\t\t\tbi->bi_clone = kmalloc(bi->bi_bh->b_size,\n\t\t\t\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\t\t\t\tmemcpy(bi->bi_clone + bi->bi_offset,\n\t\t\t\t       bi->bi_bh->b_data + bi->bi_offset,\n\t\t\t\t       bi->bi_len);\n\t\t\t}\n\t\t\tgfs2_trans_add_meta(rbm.rgd->rd_gl, bi->bi_bh);\n\t\t\tbi_prev = bi;\n\t\t}\n\t\tgfs2_setbit(&rbm, false, new_state);\n\t\tgfs2_rbm_incr(&rbm);\n\t}\n\n\treturn rbm.rgd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_rgrpd *rgblk_free(struct gfs2_sbd *sdp, u64 bstart,\n\t\t\t\t     u32 blen, unsigned char new_state)\n{\n\tstruct gfs2_rbm rbm;\n\tstruct gfs2_bitmap *bi, *bi_prev = NULL;\n\n\trbm.rgd = gfs2_blk2rgrpd(sdp, bstart, 1);\n\tif (!rbm.rgd) {\n\t\tif (gfs2_consist(sdp))\n\t\t\tfs_err(sdp, \"block = %llu\\n\", (unsigned long long)bstart);\n\t\treturn NULL;\n\t}\n\n\tgfs2_rbm_from_block(&rbm, bstart);\n\twhile (blen--) {\n\t\tbi = rbm_bi(&rbm);\n\t\tif (bi != bi_prev) {\n\t\t\tif (!bi->bi_clone) {\n\t\t\t\tbi->bi_clone = kmalloc(bi->bi_bh->b_size,\n\t\t\t\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\t\t\t\tmemcpy(bi->bi_clone + bi->bi_offset,\n\t\t\t\t       bi->bi_bh->b_data + bi->bi_offset,\n\t\t\t\t       bi->bi_len);\n\t\t\t}\n\t\t\tgfs2_trans_add_meta(rbm.rgd->rd_gl, bi->bi_bh);\n\t\t\tbi_prev = bi;\n\t\t}\n\t\tgfs2_setbit(&rbm, false, new_state);\n\t\tgfs2_rbm_incr(&rbm);\n\t}\n\n\treturn rbm.rgd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_free_uninit_di(struct gfs2_rgrpd *rgd, u64 blkno)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_rgrpd *tmp_rgd;\n\n\ttmp_rgd = rgblk_free(sdp, blkno, 1, GFS2_BLKST_FREE);\n\tif (!tmp_rgd)\n\t\treturn;\n\tgfs2_assert_withdraw(sdp, rgd == tmp_rgd);\n\n\tif (!rgd->rd_dinodes)\n\t\tgfs2_consist_rgrpd(rgd);\n\trgd->rd_dinodes--;\n\trgd->rd_free++;\n\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\tupdate_rgrp_lvb_unlinked(rgd, -1);\n\n\tgfs2_statfs_change(sdp, 0, +1, -1);\n}"
  },
  {
    "function_name": "gfs2_unlink_di",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2433-2448",
    "snippet": "void gfs2_unlink_di(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_rgrpd *rgd;\n\tu64 blkno = ip->i_no_addr;\n\n\trgd = rgblk_free(sdp, blkno, 1, GFS2_BLKST_UNLINKED);\n\tif (!rgd)\n\t\treturn;\n\ttrace_gfs2_block_alloc(ip, rgd, blkno, 1, GFS2_BLKST_UNLINKED);\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\tupdate_rgrp_lvb_unlinked(rgd, 1);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_rgrp_lvb_unlinked",
          "args": [
            "rgd",
            "1"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "update_rgrp_lvb_unlinked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1104-1109",
          "snippet": "static void update_rgrp_lvb_unlinked(struct gfs2_rgrpd *rgd, u32 change)\n{\n\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n\tu32 unlinked = be32_to_cpu(rgl->rl_unlinked) + change;\n\trgl->rl_unlinked = cpu_to_be32(unlinked);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void update_rgrp_lvb_unlinked(struct gfs2_rgrpd *rgd, u32 change)\n{\n\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n\tu32 unlinked = be32_to_cpu(rgl->rl_unlinked) + change;\n\trgl->rl_unlinked = cpu_to_be32(unlinked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_ondisk2lvb",
          "args": [
            "rgd->rd_rgl",
            "rgd->rd_bits[0].bi_bh->b_data"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_ondisk2lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1092-1102",
          "snippet": "static void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_out",
          "args": [
            "rgd",
            "rgd->rd_bits[0].bi_bh->b_data"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1068-1078",
          "snippet": "static void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrp *str = buf;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tstr->__pad = cpu_to_be32(0);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrp *str = buf;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tstr->__pad = cpu_to_be32(0);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "rgd->rd_gl",
            "rgd->rd_bits[0].bi_bh"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_gfs2_block_alloc",
          "args": [
            "ip",
            "rgd",
            "blkno",
            "1",
            "GFS2_BLKST_UNLINKED"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgblk_free",
          "args": [
            "sdp",
            "blkno",
            "1",
            "GFS2_BLKST_UNLINKED"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "rgblk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2152-2184",
          "snippet": "static struct gfs2_rgrpd *rgblk_free(struct gfs2_sbd *sdp, u64 bstart,\n\t\t\t\t     u32 blen, unsigned char new_state)\n{\n\tstruct gfs2_rbm rbm;\n\tstruct gfs2_bitmap *bi, *bi_prev = NULL;\n\n\trbm.rgd = gfs2_blk2rgrpd(sdp, bstart, 1);\n\tif (!rbm.rgd) {\n\t\tif (gfs2_consist(sdp))\n\t\t\tfs_err(sdp, \"block = %llu\\n\", (unsigned long long)bstart);\n\t\treturn NULL;\n\t}\n\n\tgfs2_rbm_from_block(&rbm, bstart);\n\twhile (blen--) {\n\t\tbi = rbm_bi(&rbm);\n\t\tif (bi != bi_prev) {\n\t\t\tif (!bi->bi_clone) {\n\t\t\t\tbi->bi_clone = kmalloc(bi->bi_bh->b_size,\n\t\t\t\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\t\t\t\tmemcpy(bi->bi_clone + bi->bi_offset,\n\t\t\t\t       bi->bi_bh->b_data + bi->bi_offset,\n\t\t\t\t       bi->bi_len);\n\t\t\t}\n\t\t\tgfs2_trans_add_meta(rbm.rgd->rd_gl, bi->bi_bh);\n\t\t\tbi_prev = bi;\n\t\t}\n\t\tgfs2_setbit(&rbm, false, new_state);\n\t\tgfs2_rbm_incr(&rbm);\n\t}\n\n\treturn rbm.rgd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_rgrpd *rgblk_free(struct gfs2_sbd *sdp, u64 bstart,\n\t\t\t\t     u32 blen, unsigned char new_state)\n{\n\tstruct gfs2_rbm rbm;\n\tstruct gfs2_bitmap *bi, *bi_prev = NULL;\n\n\trbm.rgd = gfs2_blk2rgrpd(sdp, bstart, 1);\n\tif (!rbm.rgd) {\n\t\tif (gfs2_consist(sdp))\n\t\t\tfs_err(sdp, \"block = %llu\\n\", (unsigned long long)bstart);\n\t\treturn NULL;\n\t}\n\n\tgfs2_rbm_from_block(&rbm, bstart);\n\twhile (blen--) {\n\t\tbi = rbm_bi(&rbm);\n\t\tif (bi != bi_prev) {\n\t\t\tif (!bi->bi_clone) {\n\t\t\t\tbi->bi_clone = kmalloc(bi->bi_bh->b_size,\n\t\t\t\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\t\t\t\tmemcpy(bi->bi_clone + bi->bi_offset,\n\t\t\t\t       bi->bi_bh->b_data + bi->bi_offset,\n\t\t\t\t       bi->bi_len);\n\t\t\t}\n\t\t\tgfs2_trans_add_meta(rbm.rgd->rd_gl, bi->bi_bh);\n\t\t\tbi_prev = bi;\n\t\t}\n\t\tgfs2_setbit(&rbm, false, new_state);\n\t\tgfs2_rbm_incr(&rbm);\n\t}\n\n\treturn rbm.rgd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_unlink_di(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_rgrpd *rgd;\n\tu64 blkno = ip->i_no_addr;\n\n\trgd = rgblk_free(sdp, blkno, 1, GFS2_BLKST_UNLINKED);\n\tif (!rgd)\n\t\treturn;\n\ttrace_gfs2_block_alloc(ip, rgd, blkno, 1, GFS2_BLKST_UNLINKED);\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\tupdate_rgrp_lvb_unlinked(rgd, 1);\n}"
  },
  {
    "function_name": "gfs2_free_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2424-2431",
    "snippet": "void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\t__gfs2_free_blocks(ip, bstart, blen, 1);\n\tgfs2_statfs_change(sdp, 0, +blen, 0);\n\tgfs2_quota_change(ip, -(s64)blen, ip->i_inode.i_uid, ip->i_inode.i_gid);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_change",
          "args": [
            "ip",
            "-(s64)blen",
            "ip->i_inode.i_uid",
            "ip->i_inode.i_gid"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1145-1164",
          "snippet": "void gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_statfs_change",
          "args": [
            "sdp",
            "0",
            "+blen",
            "0"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_statfs_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "515-548",
          "snippet": "void gfs2_statfs_change(struct gfs2_sbd *sdp, s64 total, s64 free,\n\t\t\ts64 dinodes)\n{\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct buffer_head *l_bh;\n\ts64 x, y;\n\tint need_sync = 0;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\tif (error)\n\t\treturn;\n\n\tgfs2_trans_add_meta(l_ip->i_gl, l_bh);\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tl_sc->sc_total += total;\n\tl_sc->sc_free += free;\n\tl_sc->sc_dinodes += dinodes;\n\tgfs2_statfs_change_out(l_sc, l_bh->b_data + sizeof(struct gfs2_dinode));\n\tif (sdp->sd_args.ar_statfs_percent) {\n\t\tx = 100 * l_sc->sc_free;\n\t\ty = m_sc->sc_free * sdp->sd_args.ar_statfs_percent;\n\t\tif (x >= y || x <= -y)\n\t\t\tneed_sync = 1;\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tbrelse(l_bh);\n\tif (need_sync)\n\t\tgfs2_wake_up_statfs(sdp);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_statfs_change(struct gfs2_sbd *sdp, s64 total, s64 free,\n\t\t\ts64 dinodes)\n{\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct buffer_head *l_bh;\n\ts64 x, y;\n\tint need_sync = 0;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\tif (error)\n\t\treturn;\n\n\tgfs2_trans_add_meta(l_ip->i_gl, l_bh);\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tl_sc->sc_total += total;\n\tl_sc->sc_free += free;\n\tl_sc->sc_dinodes += dinodes;\n\tgfs2_statfs_change_out(l_sc, l_bh->b_data + sizeof(struct gfs2_dinode));\n\tif (sdp->sd_args.ar_statfs_percent) {\n\t\tx = 100 * l_sc->sc_free;\n\t\ty = m_sc->sc_free * sdp->sd_args.ar_statfs_percent;\n\t\tif (x >= y || x <= -y)\n\t\t\tneed_sync = 1;\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tbrelse(l_bh);\n\tif (need_sync)\n\t\tgfs2_wake_up_statfs(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfs2_free_blocks",
          "args": [
            "ip",
            "bstart",
            "blen",
            "1"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2396-2414",
          "snippet": "void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rgblk_free(sdp, bstart, blen, GFS2_BLKST_FREE);\n\tif (!rgd)\n\t\treturn;\n\ttrace_gfs2_block_alloc(ip, rgd, bstart, blen, GFS2_BLKST_FREE);\n\trgd->rd_free += blen;\n\trgd->rd_flags &= ~GFS2_RGF_TRIMMED;\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\n\t/* Directories keep their data in the metadata address space */\n\tif (meta || ip->i_depth)\n\t\tgfs2_meta_wipe(ip, bstart, blen);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rgblk_free(sdp, bstart, blen, GFS2_BLKST_FREE);\n\tif (!rgd)\n\t\treturn;\n\ttrace_gfs2_block_alloc(ip, rgd, bstart, blen, GFS2_BLKST_FREE);\n\trgd->rd_free += blen;\n\trgd->rd_flags &= ~GFS2_RGF_TRIMMED;\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\n\t/* Directories keep their data in the metadata address space */\n\tif (meta || ip->i_depth)\n\t\tgfs2_meta_wipe(ip, bstart, blen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\t__gfs2_free_blocks(ip, bstart, blen, 1);\n\tgfs2_statfs_change(sdp, 0, +blen, 0);\n\tgfs2_quota_change(ip, -(s64)blen, ip->i_inode.i_uid, ip->i_inode.i_gid);\n}"
  },
  {
    "function_name": "__gfs2_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2396-2414",
    "snippet": "void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rgblk_free(sdp, bstart, blen, GFS2_BLKST_FREE);\n\tif (!rgd)\n\t\treturn;\n\ttrace_gfs2_block_alloc(ip, rgd, bstart, blen, GFS2_BLKST_FREE);\n\trgd->rd_free += blen;\n\trgd->rd_flags &= ~GFS2_RGF_TRIMMED;\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\n\t/* Directories keep their data in the metadata address space */\n\tif (meta || ip->i_depth)\n\t\tgfs2_meta_wipe(ip, bstart, blen);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_meta_wipe",
          "args": [
            "ip",
            "bstart",
            "blen"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_wipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "305-324",
          "snippet": "void gfs2_meta_wipe(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh;\n\n\twhile (blen) {\n\t\tbh = gfs2_getbuf(ip->i_gl, bstart, NO_CREATE);\n\t\tif (bh) {\n\t\t\tlock_buffer(bh);\n\t\t\tgfs2_log_lock(sdp);\n\t\t\tgfs2_remove_from_journal(bh, current->journal_info, 1);\n\t\t\tgfs2_log_unlock(sdp);\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tbstart++;\n\t\tblen--;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_meta_wipe(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *bh;\n\n\twhile (blen) {\n\t\tbh = gfs2_getbuf(ip->i_gl, bstart, NO_CREATE);\n\t\tif (bh) {\n\t\t\tlock_buffer(bh);\n\t\t\tgfs2_log_lock(sdp);\n\t\t\tgfs2_remove_from_journal(bh, current->journal_info, 1);\n\t\t\tgfs2_log_unlock(sdp);\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tbstart++;\n\t\tblen--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_ondisk2lvb",
          "args": [
            "rgd->rd_rgl",
            "rgd->rd_bits[0].bi_bh->b_data"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_ondisk2lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1092-1102",
          "snippet": "static void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_out",
          "args": [
            "rgd",
            "rgd->rd_bits[0].bi_bh->b_data"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1068-1078",
          "snippet": "static void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrp *str = buf;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tstr->__pad = cpu_to_be32(0);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrp *str = buf;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tstr->__pad = cpu_to_be32(0);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "rgd->rd_gl",
            "rgd->rd_bits[0].bi_bh"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_gfs2_block_alloc",
          "args": [
            "ip",
            "rgd",
            "bstart",
            "blen",
            "GFS2_BLKST_FREE"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgblk_free",
          "args": [
            "sdp",
            "bstart",
            "blen",
            "GFS2_BLKST_FREE"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "rgblk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2152-2184",
          "snippet": "static struct gfs2_rgrpd *rgblk_free(struct gfs2_sbd *sdp, u64 bstart,\n\t\t\t\t     u32 blen, unsigned char new_state)\n{\n\tstruct gfs2_rbm rbm;\n\tstruct gfs2_bitmap *bi, *bi_prev = NULL;\n\n\trbm.rgd = gfs2_blk2rgrpd(sdp, bstart, 1);\n\tif (!rbm.rgd) {\n\t\tif (gfs2_consist(sdp))\n\t\t\tfs_err(sdp, \"block = %llu\\n\", (unsigned long long)bstart);\n\t\treturn NULL;\n\t}\n\n\tgfs2_rbm_from_block(&rbm, bstart);\n\twhile (blen--) {\n\t\tbi = rbm_bi(&rbm);\n\t\tif (bi != bi_prev) {\n\t\t\tif (!bi->bi_clone) {\n\t\t\t\tbi->bi_clone = kmalloc(bi->bi_bh->b_size,\n\t\t\t\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\t\t\t\tmemcpy(bi->bi_clone + bi->bi_offset,\n\t\t\t\t       bi->bi_bh->b_data + bi->bi_offset,\n\t\t\t\t       bi->bi_len);\n\t\t\t}\n\t\t\tgfs2_trans_add_meta(rbm.rgd->rd_gl, bi->bi_bh);\n\t\t\tbi_prev = bi;\n\t\t}\n\t\tgfs2_setbit(&rbm, false, new_state);\n\t\tgfs2_rbm_incr(&rbm);\n\t}\n\n\treturn rbm.rgd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_rgrpd *rgblk_free(struct gfs2_sbd *sdp, u64 bstart,\n\t\t\t\t     u32 blen, unsigned char new_state)\n{\n\tstruct gfs2_rbm rbm;\n\tstruct gfs2_bitmap *bi, *bi_prev = NULL;\n\n\trbm.rgd = gfs2_blk2rgrpd(sdp, bstart, 1);\n\tif (!rbm.rgd) {\n\t\tif (gfs2_consist(sdp))\n\t\t\tfs_err(sdp, \"block = %llu\\n\", (unsigned long long)bstart);\n\t\treturn NULL;\n\t}\n\n\tgfs2_rbm_from_block(&rbm, bstart);\n\twhile (blen--) {\n\t\tbi = rbm_bi(&rbm);\n\t\tif (bi != bi_prev) {\n\t\t\tif (!bi->bi_clone) {\n\t\t\t\tbi->bi_clone = kmalloc(bi->bi_bh->b_size,\n\t\t\t\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\t\t\t\tmemcpy(bi->bi_clone + bi->bi_offset,\n\t\t\t\t       bi->bi_bh->b_data + bi->bi_offset,\n\t\t\t\t       bi->bi_len);\n\t\t\t}\n\t\t\tgfs2_trans_add_meta(rbm.rgd->rd_gl, bi->bi_bh);\n\t\t\tbi_prev = bi;\n\t\t}\n\t\tgfs2_setbit(&rbm, false, new_state);\n\t\tgfs2_rbm_incr(&rbm);\n\t}\n\n\treturn rbm.rgd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rgblk_free(sdp, bstart, blen, GFS2_BLKST_FREE);\n\tif (!rgd)\n\t\treturn;\n\ttrace_gfs2_block_alloc(ip, rgd, bstart, blen, GFS2_BLKST_FREE);\n\trgd->rd_free += blen;\n\trgd->rd_flags &= ~GFS2_RGF_TRIMMED;\n\tgfs2_trans_add_meta(rgd->rd_gl, rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rgd, rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, rgd->rd_bits[0].bi_bh->b_data);\n\n\t/* Directories keep their data in the metadata address space */\n\tif (meta || ip->i_depth)\n\t\tgfs2_meta_wipe(ip, bstart, blen);\n}"
  },
  {
    "function_name": "gfs2_alloc_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2304-2385",
    "snippet": "int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rgrp_error",
          "args": [
            "rbm.rgd"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2213-2221",
          "snippet": "static void gfs2_rgrp_error(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tfs_warn(sdp, \"rgrp %llu has an error, marking it readonly until umount\\n\",\n\t\t(unsigned long long)rgd->rd_addr);\n\tfs_warn(sdp, \"umount on all nodes and run fsck.gfs2 to fix the error\\n\");\n\tgfs2_rgrp_dump(NULL, rgd->rd_gl);\n\trgd->rd_flags |= GFS2_RDF_ERROR;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_error(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tfs_warn(sdp, \"rgrp %llu has an error, marking it readonly until umount\\n\",\n\t\t(unsigned long long)rgd->rd_addr);\n\tfs_warn(sdp, \"umount on all nodes and run fsck.gfs2 to fix the error\\n\");\n\tgfs2_rgrp_dump(NULL, rgd->rd_gl);\n\trgd->rd_flags |= GFS2_RDF_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_gfs2_block_alloc",
          "args": [
            "ip",
            "rbm.rgd",
            "block",
            "*nblocks",
            "dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_quota_change",
          "args": [
            "ip",
            "*nblocks",
            "ip->i_inode.i_uid",
            "ip->i_inode.i_gid"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1145-1164",
          "snippet": "void gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_change(struct gfs2_inode *ip, s64 change,\n\t\t       kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(GFS2_SB(&ip->i_inode), change))\n\t\treturn;\n\tif (ip->i_diskflags & GFS2_DIF_SYSTEM)\n\t\treturn;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t    qid_eq(qd->qd_id, make_kqid_gid(gid))) {\n\t\t\tdo_qc(qd, change);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_unrevoke",
          "args": [
            "sdp",
            "block",
            "*nblocks"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_unrevoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "259-278",
          "snippet": "void gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_statfs_change",
          "args": [
            "sdp",
            "0",
            "-(s64)*nblocks",
            "dinode ? 1 : 0"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_statfs_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "515-548",
          "snippet": "void gfs2_statfs_change(struct gfs2_sbd *sdp, s64 total, s64 free,\n\t\t\ts64 dinodes)\n{\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct buffer_head *l_bh;\n\ts64 x, y;\n\tint need_sync = 0;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\tif (error)\n\t\treturn;\n\n\tgfs2_trans_add_meta(l_ip->i_gl, l_bh);\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tl_sc->sc_total += total;\n\tl_sc->sc_free += free;\n\tl_sc->sc_dinodes += dinodes;\n\tgfs2_statfs_change_out(l_sc, l_bh->b_data + sizeof(struct gfs2_dinode));\n\tif (sdp->sd_args.ar_statfs_percent) {\n\t\tx = 100 * l_sc->sc_free;\n\t\ty = m_sc->sc_free * sdp->sd_args.ar_statfs_percent;\n\t\tif (x >= y || x <= -y)\n\t\t\tneed_sync = 1;\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tbrelse(l_bh);\n\tif (need_sync)\n\t\tgfs2_wake_up_statfs(sdp);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_statfs_change(struct gfs2_sbd *sdp, s64 total, s64 free,\n\t\t\ts64 dinodes)\n{\n\tstruct gfs2_inode *l_ip = GFS2_I(sdp->sd_sc_inode);\n\tstruct gfs2_statfs_change_host *l_sc = &sdp->sd_statfs_local;\n\tstruct gfs2_statfs_change_host *m_sc = &sdp->sd_statfs_master;\n\tstruct buffer_head *l_bh;\n\ts64 x, y;\n\tint need_sync = 0;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(l_ip, &l_bh);\n\tif (error)\n\t\treturn;\n\n\tgfs2_trans_add_meta(l_ip->i_gl, l_bh);\n\n\tspin_lock(&sdp->sd_statfs_spin);\n\tl_sc->sc_total += total;\n\tl_sc->sc_free += free;\n\tl_sc->sc_dinodes += dinodes;\n\tgfs2_statfs_change_out(l_sc, l_bh->b_data + sizeof(struct gfs2_dinode));\n\tif (sdp->sd_args.ar_statfs_percent) {\n\t\tx = 100 * l_sc->sc_free;\n\t\ty = m_sc->sc_free * sdp->sd_args.ar_statfs_percent;\n\t\tif (x >= y || x <= -y)\n\t\t\tneed_sync = 1;\n\t}\n\tspin_unlock(&sdp->sd_statfs_spin);\n\n\tbrelse(l_bh);\n\tif (need_sync)\n\t\tgfs2_wake_up_statfs(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_ondisk2lvb",
          "args": [
            "rbm.rgd->rd_rgl",
            "rbm.rgd->rd_bits[0].bi_bh->b_data"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_ondisk2lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1092-1102",
          "snippet": "static void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_out",
          "args": [
            "rbm.rgd",
            "rbm.rgd->rd_bits[0].bi_bh->b_data"
          ],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1068-1078",
          "snippet": "static void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrp *str = buf;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tstr->__pad = cpu_to_be32(0);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrp *str = buf;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tstr->__pad = cpu_to_be32(0);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "rbm.rgd->rd_gl",
            "rbm.rgd->rd_bits[0].bi_bh"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"nblocks=%u\\n\"",
            "*nblocks"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ip->i_goal"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_adjust_reservation",
          "args": [
            "ip",
            "&rbm",
            "*nblocks"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_adjust_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2234-2262",
          "snippet": "static void gfs2_adjust_reservation(struct gfs2_inode *ip,\n\t\t\t\t    const struct gfs2_rbm *rbm, unsigned len)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tstruct gfs2_rgrpd *rgd = rbm->rgd;\n\tunsigned rlen;\n\tu64 block;\n\tint ret;\n\n\tspin_lock(&rgd->rd_rsspin);\n\tif (gfs2_rs_active(rs)) {\n\t\tif (gfs2_rbm_eq(&rs->rs_rbm, rbm)) {\n\t\t\tblock = gfs2_rbm_to_block(rbm);\n\t\t\tret = gfs2_rbm_from_block(&rs->rs_rbm, block + len);\n\t\t\trlen = min(rs->rs_free, len);\n\t\t\trs->rs_free -= rlen;\n\t\t\trgd->rd_reserved -= rlen;\n\t\t\ttrace_gfs2_rs(rs, TRACE_RS_CLAIM);\n\t\t\tif (rs->rs_free && !ret)\n\t\t\t\tgoto out;\n\t\t\t/* We used up our block reservation, so we should\n\t\t\t   reserve more blocks next time. */\n\t\t\tatomic_add(RGRP_RSRV_ADDBLKS, &rs->rs_sizehint);\n\t\t}\n\t\t__rs_deltree(rs);\n\t}\nout:\n\tspin_unlock(&rgd->rd_rsspin);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_adjust_reservation(struct gfs2_inode *ip,\n\t\t\t\t    const struct gfs2_rbm *rbm, unsigned len)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tstruct gfs2_rgrpd *rgd = rbm->rgd;\n\tunsigned rlen;\n\tu64 block;\n\tint ret;\n\n\tspin_lock(&rgd->rd_rsspin);\n\tif (gfs2_rs_active(rs)) {\n\t\tif (gfs2_rbm_eq(&rs->rs_rbm, rbm)) {\n\t\t\tblock = gfs2_rbm_to_block(rbm);\n\t\t\tret = gfs2_rbm_from_block(&rs->rs_rbm, block + len);\n\t\t\trlen = min(rs->rs_free, len);\n\t\t\trs->rs_free -= rlen;\n\t\t\trgd->rd_reserved -= rlen;\n\t\t\ttrace_gfs2_rs(rs, TRACE_RS_CLAIM);\n\t\t\tif (rs->rs_free && !ret)\n\t\t\t\tgoto out;\n\t\t\t/* We used up our block reservation, so we should\n\t\t\t   reserve more blocks next time. */\n\t\t\tatomic_add(RGRP_RSRV_ADDBLKS, &rs->rs_sizehint);\n\t\t}\n\t\t__rs_deltree(rs);\n\t}\nout:\n\tspin_unlock(&rgd->rd_rsspin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_active",
          "args": [
            "ip->i_res"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.h",
          "lines": "79-82",
          "snippet": "static inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_to_block",
          "args": [
            "&rbm"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "117-121",
          "snippet": "static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_alloc_extent",
          "args": [
            "&rbm",
            "dinode",
            "nblocks"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_alloc_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2118-2140",
          "snippet": "static void gfs2_alloc_extent(const struct gfs2_rbm *rbm, bool dinode,\n\t\t\t     unsigned int *n)\n{\n\tstruct gfs2_rbm pos = { .rgd = rbm->rgd, };\n\tconst unsigned int elen = *n;\n\tu64 block;\n\tint ret;\n\n\t*n = 1;\n\tblock = gfs2_rbm_to_block(rbm);\n\tgfs2_trans_add_meta(rbm->rgd->rd_gl, rbm_bi(rbm)->bi_bh);\n\tgfs2_setbit(rbm, true, dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\tblock++;\n\twhile (*n < elen) {\n\t\tret = gfs2_rbm_from_block(&pos, block);\n\t\tif (ret || gfs2_testbit(&pos) != GFS2_BLKST_FREE)\n\t\t\tbreak;\n\t\tgfs2_trans_add_meta(pos.rgd->rd_gl, rbm_bi(&pos)->bi_bh);\n\t\tgfs2_setbit(&pos, true, GFS2_BLKST_USED);\n\t\t(*n)++;\n\t\tblock++;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_alloc_extent(const struct gfs2_rbm *rbm, bool dinode,\n\t\t\t     unsigned int *n)\n{\n\tstruct gfs2_rbm pos = { .rgd = rbm->rgd, };\n\tconst unsigned int elen = *n;\n\tu64 block;\n\tint ret;\n\n\t*n = 1;\n\tblock = gfs2_rbm_to_block(rbm);\n\tgfs2_trans_add_meta(rbm->rgd->rd_gl, rbm_bi(rbm)->bi_bh);\n\tgfs2_setbit(rbm, true, dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\tblock++;\n\twhile (*n < elen) {\n\t\tret = gfs2_rbm_from_block(&pos, block);\n\t\tif (ret || gfs2_testbit(&pos) != GFS2_BLKST_FREE)\n\t\t\tbreak;\n\t\tgfs2_trans_add_meta(pos.rgd->rd_gl, rbm_bi(&pos)->bi_bh);\n\t\tgfs2_setbit(&pos, true, GFS2_BLKST_USED);\n\t\t(*n)++;\n\t\tblock++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_warn",
          "args": [
            "sdp",
            "\"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\"",
            "(unsigned long long)ip->i_no_addr",
            "error",
            "*nblocks",
            "test_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags)",
            "rbm.rgd->rd_extfail_pt"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "befs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "40-51",
          "snippet": "void\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "GBF_FULL",
            "&rbm.rgd->rd_bits->bi_flags"
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_find",
          "args": [
            "&rbm",
            "GFS2_BLKST_FREE",
            "NULL",
            "NULL",
            "false",
            "NULL"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1652-1752",
          "snippet": "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap)\n{\n\tstruct buffer_head *bh;\n\tint initial_bii;\n\tu32 initial_offset;\n\tint first_bii = rbm->bii;\n\tu32 first_offset = rbm->offset;\n\tu32 offset;\n\tu8 *buffer;\n\tint n = 0;\n\tint iters = rbm->rgd->rd_length;\n\tint ret;\n\tstruct gfs2_bitmap *bi;\n\tstruct gfs2_extent maxext = { .rbm.rgd = rbm->rgd, };\n\n\t/* If we are not starting at the beginning of a bitmap, then we\n\t * need to add one to the bitmap count to ensure that we search\n\t * the starting bitmap twice.\n\t */\n\tif (rbm->offset != 0)\n\t\titers++;\n\n\twhile(1) {\n\t\tbi = rbm_bi(rbm);\n\t\tif (test_bit(GBF_FULL, &bi->bi_flags) &&\n\t\t    (state == GFS2_BLKST_FREE))\n\t\t\tgoto next_bitmap;\n\n\t\tbh = bi->bi_bh;\n\t\tbuffer = bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bh));\n\t\tif (state != GFS2_BLKST_UNLINKED && bi->bi_clone)\n\t\t\tbuffer = bi->bi_clone + bi->bi_offset;\n\t\tinitial_offset = rbm->offset;\n\t\toffset = gfs2_bitfit(buffer, bi->bi_len, rbm->offset, state);\n\t\tif (offset == BFITNOENT)\n\t\t\tgoto bitmap_full;\n\t\trbm->offset = offset;\n\t\tif (ip == NULL)\n\t\t\treturn 0;\n\n\t\tinitial_bii = rbm->bii;\n\t\tret = gfs2_reservation_check_and_update(rbm, ip,\n\t\t\t\t\t\t\tminext ? *minext : 0,\n\t\t\t\t\t\t\t&maxext);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret > 0) {\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto next_iter;\n\t\t}\n\t\tif (ret == -E2BIG) {\n\t\t\trbm->bii = 0;\n\t\t\trbm->offset = 0;\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto res_covered_end_of_rgrp;\n\t\t}\n\t\treturn ret;\n\nbitmap_full:\t/* Mark bitmap as full and fall through */\n\t\tif ((state == GFS2_BLKST_FREE) && initial_offset == 0) {\n\t\t\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\t\t\tset_bit(GBF_FULL, &bi->bi_flags);\n\t\t}\n\nnext_bitmap:\t/* Find next bitmap in the rgrp */\n\t\trbm->offset = 0;\n\t\trbm->bii++;\n\t\tif (rbm->bii == rbm->rgd->rd_length)\n\t\t\trbm->bii = 0;\nres_covered_end_of_rgrp:\n\t\tif ((rbm->bii == 0) && nowrap)\n\t\t\tbreak;\n\t\tn++;\nnext_iter:\n\t\tif (n >= iters)\n\t\t\tbreak;\n\t}\n\n\tif (minext == NULL || state != GFS2_BLKST_FREE)\n\t\treturn -ENOSPC;\n\n\t/* If the extent was too small, and it's smaller than the smallest\n\t   to have failed before, remember for future reference that it's\n\t   useless to search this rgrp again for this amount or more. */\n\tif ((first_offset == 0) && (first_bii == 0) &&\n\t    (*minext < rbm->rgd->rd_extfail_pt))\n\t\trbm->rgd->rd_extfail_pt = *minext;\n\n\t/* If the maximum extent we found is big enough to fulfill the\n\t   minimum requirements, use it anyway. */\n\tif (maxext.len) {\n\t\t*rbm = maxext.rbm;\n\t\t*minext = maxext.len;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BFITNOENT ((u32)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define BFITNOENT ((u32)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap)\n{\n\tstruct buffer_head *bh;\n\tint initial_bii;\n\tu32 initial_offset;\n\tint first_bii = rbm->bii;\n\tu32 first_offset = rbm->offset;\n\tu32 offset;\n\tu8 *buffer;\n\tint n = 0;\n\tint iters = rbm->rgd->rd_length;\n\tint ret;\n\tstruct gfs2_bitmap *bi;\n\tstruct gfs2_extent maxext = { .rbm.rgd = rbm->rgd, };\n\n\t/* If we are not starting at the beginning of a bitmap, then we\n\t * need to add one to the bitmap count to ensure that we search\n\t * the starting bitmap twice.\n\t */\n\tif (rbm->offset != 0)\n\t\titers++;\n\n\twhile(1) {\n\t\tbi = rbm_bi(rbm);\n\t\tif (test_bit(GBF_FULL, &bi->bi_flags) &&\n\t\t    (state == GFS2_BLKST_FREE))\n\t\t\tgoto next_bitmap;\n\n\t\tbh = bi->bi_bh;\n\t\tbuffer = bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bh));\n\t\tif (state != GFS2_BLKST_UNLINKED && bi->bi_clone)\n\t\t\tbuffer = bi->bi_clone + bi->bi_offset;\n\t\tinitial_offset = rbm->offset;\n\t\toffset = gfs2_bitfit(buffer, bi->bi_len, rbm->offset, state);\n\t\tif (offset == BFITNOENT)\n\t\t\tgoto bitmap_full;\n\t\trbm->offset = offset;\n\t\tif (ip == NULL)\n\t\t\treturn 0;\n\n\t\tinitial_bii = rbm->bii;\n\t\tret = gfs2_reservation_check_and_update(rbm, ip,\n\t\t\t\t\t\t\tminext ? *minext : 0,\n\t\t\t\t\t\t\t&maxext);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret > 0) {\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto next_iter;\n\t\t}\n\t\tif (ret == -E2BIG) {\n\t\t\trbm->bii = 0;\n\t\t\trbm->offset = 0;\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto res_covered_end_of_rgrp;\n\t\t}\n\t\treturn ret;\n\nbitmap_full:\t/* Mark bitmap as full and fall through */\n\t\tif ((state == GFS2_BLKST_FREE) && initial_offset == 0) {\n\t\t\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\t\t\tset_bit(GBF_FULL, &bi->bi_flags);\n\t\t}\n\nnext_bitmap:\t/* Find next bitmap in the rgrp */\n\t\trbm->offset = 0;\n\t\trbm->bii++;\n\t\tif (rbm->bii == rbm->rgd->rd_length)\n\t\t\trbm->bii = 0;\nres_covered_end_of_rgrp:\n\t\tif ((rbm->bii == 0) && nowrap)\n\t\t\tbreak;\n\t\tn++;\nnext_iter:\n\t\tif (n >= iters)\n\t\t\tbreak;\n\t}\n\n\tif (minext == NULL || state != GFS2_BLKST_FREE)\n\t\treturn -ENOSPC;\n\n\t/* If the extent was too small, and it's smaller than the smallest\n\t   to have failed before, remember for future reference that it's\n\t   useless to search this rgrp again for this amount or more. */\n\tif ((first_offset == 0) && (first_bii == 0) &&\n\t    (*minext < rbm->rgd->rd_extfail_pt))\n\t\trbm->rgd->rd_extfail_pt = *minext;\n\n\t/* If the maximum extent we found is big enough to fulfill the\n\t   minimum requirements, use it anyway. */\n\tif (maxext.len) {\n\t\t*rbm = maxext.rbm;\n\t\t*minext = maxext.len;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_set_alloc_start",
          "args": [
            "&rbm",
            "ip",
            "dinode"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_alloc_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2275-2291",
          "snippet": "static void gfs2_set_alloc_start(struct gfs2_rbm *rbm,\n\t\t\t\t const struct gfs2_inode *ip, bool dinode)\n{\n\tu64 goal;\n\n\tif (gfs2_rs_active(ip->i_res)) {\n\t\t*rbm = ip->i_res->rs_rbm;\n\t\treturn;\n\t}\n\n\tif (!dinode && rgrp_contains_block(rbm->rgd, ip->i_goal))\n\t\tgoal = ip->i_goal;\n\telse\n\t\tgoal = rbm->rgd->rd_last_alloc + rbm->rgd->rd_data0;\n\n\tgfs2_rbm_from_block(rbm, goal);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_set_alloc_start(struct gfs2_rbm *rbm,\n\t\t\t\t const struct gfs2_inode *ip, bool dinode)\n{\n\tu64 goal;\n\n\tif (gfs2_rs_active(ip->i_res)) {\n\t\t*rbm = ip->i_res->rs_rbm;\n\t\treturn;\n\t}\n\n\tif (!dinode && rgrp_contains_block(rbm->rgd, ip->i_goal))\n\t\tgoal = ip->i_goal;\n\telse\n\t\tgoal = rbm->rgd->rd_last_alloc + rbm->rgd->rd_data0;\n\n\tgfs2_rbm_from_block(rbm, goal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "gfs2_set_alloc_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2275-2291",
    "snippet": "static void gfs2_set_alloc_start(struct gfs2_rbm *rbm,\n\t\t\t\t const struct gfs2_inode *ip, bool dinode)\n{\n\tu64 goal;\n\n\tif (gfs2_rs_active(ip->i_res)) {\n\t\t*rbm = ip->i_res->rs_rbm;\n\t\treturn;\n\t}\n\n\tif (!dinode && rgrp_contains_block(rbm->rgd, ip->i_goal))\n\t\tgoal = ip->i_goal;\n\telse\n\t\tgoal = rbm->rgd->rd_last_alloc + rbm->rgd->rd_data0;\n\n\tgfs2_rbm_from_block(rbm, goal);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rbm_from_block",
          "args": [
            "rbm",
            "goal"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_from_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "261-282",
          "snippet": "static int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rgrp_contains_block",
          "args": [
            "rbm->rgd",
            "ip->i_goal"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "rgrp_contains_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "487-492",
          "snippet": "static inline int rgrp_contains_block(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tu64 first = rgd->rd_data0;\n\tu64 last = first + rgd->rd_data;\n\treturn first <= block && block < last;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int rgrp_contains_block(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tu64 first = rgd->rd_data0;\n\tu64 last = first + rgd->rd_data;\n\treturn first <= block && block < last;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_active",
          "args": [
            "ip->i_res"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.h",
          "lines": "79-82",
          "snippet": "static inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_set_alloc_start(struct gfs2_rbm *rbm,\n\t\t\t\t const struct gfs2_inode *ip, bool dinode)\n{\n\tu64 goal;\n\n\tif (gfs2_rs_active(ip->i_res)) {\n\t\t*rbm = ip->i_res->rs_rbm;\n\t\treturn;\n\t}\n\n\tif (!dinode && rgrp_contains_block(rbm->rgd, ip->i_goal))\n\t\tgoal = ip->i_goal;\n\telse\n\t\tgoal = rbm->rgd->rd_last_alloc + rbm->rgd->rd_data0;\n\n\tgfs2_rbm_from_block(rbm, goal);\n}"
  },
  {
    "function_name": "gfs2_adjust_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2234-2262",
    "snippet": "static void gfs2_adjust_reservation(struct gfs2_inode *ip,\n\t\t\t\t    const struct gfs2_rbm *rbm, unsigned len)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tstruct gfs2_rgrpd *rgd = rbm->rgd;\n\tunsigned rlen;\n\tu64 block;\n\tint ret;\n\n\tspin_lock(&rgd->rd_rsspin);\n\tif (gfs2_rs_active(rs)) {\n\t\tif (gfs2_rbm_eq(&rs->rs_rbm, rbm)) {\n\t\t\tblock = gfs2_rbm_to_block(rbm);\n\t\t\tret = gfs2_rbm_from_block(&rs->rs_rbm, block + len);\n\t\t\trlen = min(rs->rs_free, len);\n\t\t\trs->rs_free -= rlen;\n\t\t\trgd->rd_reserved -= rlen;\n\t\t\ttrace_gfs2_rs(rs, TRACE_RS_CLAIM);\n\t\t\tif (rs->rs_free && !ret)\n\t\t\t\tgoto out;\n\t\t\t/* We used up our block reservation, so we should\n\t\t\t   reserve more blocks next time. */\n\t\t\tatomic_add(RGRP_RSRV_ADDBLKS, &rs->rs_sizehint);\n\t\t}\n\t\t__rs_deltree(rs);\n\t}\nout:\n\tspin_unlock(&rgd->rd_rsspin);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rs_deltree",
          "args": [
            "rs"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "__rs_deltree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "635-661",
          "snippet": "static void __rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (!gfs2_rs_active(rs))\n\t\treturn;\n\n\trgd = rs->rs_rbm.rgd;\n\ttrace_gfs2_rs(rs, TRACE_RS_TREEDEL);\n\trb_erase(&rs->rs_node, &rgd->rd_rstree);\n\tRB_CLEAR_NODE(&rs->rs_node);\n\n\tif (rs->rs_free) {\n\t\tstruct gfs2_bitmap *bi = rbm_bi(&rs->rs_rbm);\n\n\t\t/* return reserved blocks to the rgrp */\n\t\tBUG_ON(rs->rs_rbm.rgd->rd_reserved < rs->rs_free);\n\t\trs->rs_rbm.rgd->rd_reserved -= rs->rs_free;\n\t\t/* The rgrp extent failure point is likely not to increase;\n\t\t   it will only do so if the freed blocks are somehow\n\t\t   contiguous with a span of free blocks that follows. Still,\n\t\t   it will force the number to be recalculated later. */\n\t\trgd->rd_extfail_pt += rs->rs_free;\n\t\trs->rs_free = 0;\n\t\tclear_bit(GBF_FULL, &bi->bi_flags);\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void __rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (!gfs2_rs_active(rs))\n\t\treturn;\n\n\trgd = rs->rs_rbm.rgd;\n\ttrace_gfs2_rs(rs, TRACE_RS_TREEDEL);\n\trb_erase(&rs->rs_node, &rgd->rd_rstree);\n\tRB_CLEAR_NODE(&rs->rs_node);\n\n\tif (rs->rs_free) {\n\t\tstruct gfs2_bitmap *bi = rbm_bi(&rs->rs_rbm);\n\n\t\t/* return reserved blocks to the rgrp */\n\t\tBUG_ON(rs->rs_rbm.rgd->rd_reserved < rs->rs_free);\n\t\trs->rs_rbm.rgd->rd_reserved -= rs->rs_free;\n\t\t/* The rgrp extent failure point is likely not to increase;\n\t\t   it will only do so if the freed blocks are somehow\n\t\t   contiguous with a span of free blocks that follows. Still,\n\t\t   it will force the number to be recalculated later. */\n\t\trgd->rd_extfail_pt += rs->rs_free;\n\t\trs->rs_free = 0;\n\t\tclear_bit(GBF_FULL, &bi->bi_flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "RGRP_RSRV_ADDBLKS",
            "&rs->rs_sizehint"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_gfs2_rs",
          "args": [
            "rs",
            "TRACE_RS_CLAIM"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "rs->rs_free",
            "len"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_from_block",
          "args": [
            "&rs->rs_rbm",
            "block + len"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_from_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "261-282",
          "snippet": "static int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_to_block",
          "args": [
            "rbm"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "117-121",
          "snippet": "static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_eq",
          "args": [
            "&rs->rs_rbm",
            "rbm"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "123-128",
          "snippet": "static inline bool gfs2_rbm_eq(const struct gfs2_rbm *rbm1,\n\t\t\t       const struct gfs2_rbm *rbm2)\n{\n\treturn (rbm1->rgd == rbm2->rgd) && (rbm1->bii == rbm2->bii) &&\n\t       (rbm1->offset == rbm2->offset);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline bool gfs2_rbm_eq(const struct gfs2_rbm *rbm1,\n\t\t\t       const struct gfs2_rbm *rbm2)\n{\n\treturn (rbm1->rgd == rbm2->rgd) && (rbm1->bii == rbm2->bii) &&\n\t       (rbm1->offset == rbm2->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_active",
          "args": [
            "rs"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.h",
          "lines": "79-82",
          "snippet": "static inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_adjust_reservation(struct gfs2_inode *ip,\n\t\t\t\t    const struct gfs2_rbm *rbm, unsigned len)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tstruct gfs2_rgrpd *rgd = rbm->rgd;\n\tunsigned rlen;\n\tu64 block;\n\tint ret;\n\n\tspin_lock(&rgd->rd_rsspin);\n\tif (gfs2_rs_active(rs)) {\n\t\tif (gfs2_rbm_eq(&rs->rs_rbm, rbm)) {\n\t\t\tblock = gfs2_rbm_to_block(rbm);\n\t\t\tret = gfs2_rbm_from_block(&rs->rs_rbm, block + len);\n\t\t\trlen = min(rs->rs_free, len);\n\t\t\trs->rs_free -= rlen;\n\t\t\trgd->rd_reserved -= rlen;\n\t\t\ttrace_gfs2_rs(rs, TRACE_RS_CLAIM);\n\t\t\tif (rs->rs_free && !ret)\n\t\t\t\tgoto out;\n\t\t\t/* We used up our block reservation, so we should\n\t\t\t   reserve more blocks next time. */\n\t\t\tatomic_add(RGRP_RSRV_ADDBLKS, &rs->rs_sizehint);\n\t\t}\n\t\t__rs_deltree(rs);\n\t}\nout:\n\tspin_unlock(&rgd->rd_rsspin);\n}"
  },
  {
    "function_name": "gfs2_rgrp_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2213-2221",
    "snippet": "static void gfs2_rgrp_error(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tfs_warn(sdp, \"rgrp %llu has an error, marking it readonly until umount\\n\",\n\t\t(unsigned long long)rgd->rd_addr);\n\tfs_warn(sdp, \"umount on all nodes and run fsck.gfs2 to fix the error\\n\");\n\tgfs2_rgrp_dump(NULL, rgd->rd_gl);\n\trgd->rd_flags |= GFS2_RDF_ERROR;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rgrp_dump",
          "args": [
            "NULL",
            "rgd->rd_gl"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2193-2211",
          "snippet": "void gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl)\n{\n\tstruct gfs2_rgrpd *rgd = gl->gl_object;\n\tstruct gfs2_blkreserv *trs;\n\tconst struct rb_node *n;\n\n\tif (rgd == NULL)\n\t\treturn;\n\tgfs2_print_dbg(seq, \" R: n:%llu f:%02x b:%u/%u i:%u r:%u e:%u\\n\",\n\t\t       (unsigned long long)rgd->rd_addr, rgd->rd_flags,\n\t\t       rgd->rd_free, rgd->rd_free_clone, rgd->rd_dinodes,\n\t\t       rgd->rd_reserved, rgd->rd_extfail_pt);\n\tspin_lock(&rgd->rd_rsspin);\n\tfor (n = rb_first(&rgd->rd_rstree); n; n = rb_next(&trs->rs_node)) {\n\t\ttrs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\tdump_rs(seq, trs);\n\t}\n\tspin_unlock(&rgd->rd_rsspin);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl)\n{\n\tstruct gfs2_rgrpd *rgd = gl->gl_object;\n\tstruct gfs2_blkreserv *trs;\n\tconst struct rb_node *n;\n\n\tif (rgd == NULL)\n\t\treturn;\n\tgfs2_print_dbg(seq, \" R: n:%llu f:%02x b:%u/%u i:%u r:%u e:%u\\n\",\n\t\t       (unsigned long long)rgd->rd_addr, rgd->rd_flags,\n\t\t       rgd->rd_free, rgd->rd_free_clone, rgd->rd_dinodes,\n\t\t       rgd->rd_reserved, rgd->rd_extfail_pt);\n\tspin_lock(&rgd->rd_rsspin);\n\tfor (n = rb_first(&rgd->rd_rstree); n; n = rb_next(&trs->rs_node)) {\n\t\ttrs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\tdump_rs(seq, trs);\n\t}\n\tspin_unlock(&rgd->rd_rsspin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_warn",
          "args": [
            "sdp",
            "\"umount on all nodes and run fsck.gfs2 to fix the error\\n\""
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "befs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "40-51",
          "snippet": "void\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_error(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tfs_warn(sdp, \"rgrp %llu has an error, marking it readonly until umount\\n\",\n\t\t(unsigned long long)rgd->rd_addr);\n\tfs_warn(sdp, \"umount on all nodes and run fsck.gfs2 to fix the error\\n\");\n\tgfs2_rgrp_dump(NULL, rgd->rd_gl);\n\trgd->rd_flags |= GFS2_RDF_ERROR;\n}"
  },
  {
    "function_name": "gfs2_rgrp_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2193-2211",
    "snippet": "void gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl)\n{\n\tstruct gfs2_rgrpd *rgd = gl->gl_object;\n\tstruct gfs2_blkreserv *trs;\n\tconst struct rb_node *n;\n\n\tif (rgd == NULL)\n\t\treturn;\n\tgfs2_print_dbg(seq, \" R: n:%llu f:%02x b:%u/%u i:%u r:%u e:%u\\n\",\n\t\t       (unsigned long long)rgd->rd_addr, rgd->rd_flags,\n\t\t       rgd->rd_free, rgd->rd_free_clone, rgd->rd_dinodes,\n\t\t       rgd->rd_reserved, rgd->rd_extfail_pt);\n\tspin_lock(&rgd->rd_rsspin);\n\tfor (n = rb_first(&rgd->rd_rstree); n; n = rb_next(&trs->rs_node)) {\n\t\ttrs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\tdump_rs(seq, trs);\n\t}\n\tspin_unlock(&rgd->rd_rsspin);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_rs",
          "args": [
            "seq",
            "trs"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "dump_rs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "622-628",
          "snippet": "static void dump_rs(struct seq_file *seq, const struct gfs2_blkreserv *rs)\n{\n\tgfs2_print_dbg(seq, \"  B: n:%llu s:%llu b:%u f:%u\\n\",\n\t\t       (unsigned long long)rs->rs_inum,\n\t\t       (unsigned long long)gfs2_rbm_to_block(&rs->rs_rbm),\n\t\t       rs->rs_rbm.offset, rs->rs_free);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void dump_rs(struct seq_file *seq, const struct gfs2_blkreserv *rs)\n{\n\tgfs2_print_dbg(seq, \"  B: n:%llu s:%llu b:%u f:%u\\n\",\n\t\t       (unsigned long long)rs->rs_inum,\n\t\t       (unsigned long long)gfs2_rbm_to_block(&rs->rs_rbm),\n\t\t       rs->rs_rbm.offset, rs->rs_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structgfs2_blkreserv",
            "rs_node"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&trs->rs_node"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&rgd->rd_rstree"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_print_dbg",
          "args": [
            "seq",
            "\" R: n:%llu f:%02x b:%u/%u i:%u r:%u e:%u\\n\"",
            "(unsigned long long)rgd->rd_addr",
            "rgd->rd_flags",
            "rgd->rd_free",
            "rgd->rd_free_clone",
            "rgd->rd_dinodes",
            "rgd->rd_reserved",
            "rgd->rd_extfail_pt"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_print_dbg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "897-914",
          "snippet": "void gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (seq) {\n\t\tseq_vprintf(seq, fmt, args);\n\t} else {\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tpr_err(\"%pV\", &vaf);\n\t}\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (seq) {\n\t\tseq_vprintf(seq, fmt, args);\n\t} else {\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tpr_err(\"%pV\", &vaf);\n\t}\n\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl)\n{\n\tstruct gfs2_rgrpd *rgd = gl->gl_object;\n\tstruct gfs2_blkreserv *trs;\n\tconst struct rb_node *n;\n\n\tif (rgd == NULL)\n\t\treturn;\n\tgfs2_print_dbg(seq, \" R: n:%llu f:%02x b:%u/%u i:%u r:%u e:%u\\n\",\n\t\t       (unsigned long long)rgd->rd_addr, rgd->rd_flags,\n\t\t       rgd->rd_free, rgd->rd_free_clone, rgd->rd_dinodes,\n\t\t       rgd->rd_reserved, rgd->rd_extfail_pt);\n\tspin_lock(&rgd->rd_rsspin);\n\tfor (n = rb_first(&rgd->rd_rstree); n; n = rb_next(&trs->rs_node)) {\n\t\ttrs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\tdump_rs(seq, trs);\n\t}\n\tspin_unlock(&rgd->rd_rsspin);\n}"
  },
  {
    "function_name": "rgblk_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2152-2184",
    "snippet": "static struct gfs2_rgrpd *rgblk_free(struct gfs2_sbd *sdp, u64 bstart,\n\t\t\t\t     u32 blen, unsigned char new_state)\n{\n\tstruct gfs2_rbm rbm;\n\tstruct gfs2_bitmap *bi, *bi_prev = NULL;\n\n\trbm.rgd = gfs2_blk2rgrpd(sdp, bstart, 1);\n\tif (!rbm.rgd) {\n\t\tif (gfs2_consist(sdp))\n\t\t\tfs_err(sdp, \"block = %llu\\n\", (unsigned long long)bstart);\n\t\treturn NULL;\n\t}\n\n\tgfs2_rbm_from_block(&rbm, bstart);\n\twhile (blen--) {\n\t\tbi = rbm_bi(&rbm);\n\t\tif (bi != bi_prev) {\n\t\t\tif (!bi->bi_clone) {\n\t\t\t\tbi->bi_clone = kmalloc(bi->bi_bh->b_size,\n\t\t\t\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\t\t\t\tmemcpy(bi->bi_clone + bi->bi_offset,\n\t\t\t\t       bi->bi_bh->b_data + bi->bi_offset,\n\t\t\t\t       bi->bi_len);\n\t\t\t}\n\t\t\tgfs2_trans_add_meta(rbm.rgd->rd_gl, bi->bi_bh);\n\t\t\tbi_prev = bi;\n\t\t}\n\t\tgfs2_setbit(&rbm, false, new_state);\n\t\tgfs2_rbm_incr(&rbm);\n\t}\n\n\treturn rbm.rgd;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rbm_incr",
          "args": [
            "&rbm"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_incr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "296-308",
          "snippet": "static bool gfs2_rbm_incr(struct gfs2_rbm *rbm)\n{\n\tif (rbm->offset + 1 < rbm_bi(rbm)->bi_blocks) { /* in the same bitmap */\n\t\trbm->offset++;\n\t\treturn false;\n\t}\n\tif (rbm->bii == rbm->rgd->rd_length - 1) /* at the last bitmap */\n\t\treturn true;\n\n\trbm->offset = 0;\n\trbm->bii++;\n\treturn false;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic bool gfs2_rbm_incr(struct gfs2_rbm *rbm)\n{\n\tif (rbm->offset + 1 < rbm_bi(rbm)->bi_blocks) { /* in the same bitmap */\n\t\trbm->offset++;\n\t\treturn false;\n\t}\n\tif (rbm->bii == rbm->rgd->rd_length - 1) /* at the last bitmap */\n\t\treturn true;\n\n\trbm->offset = 0;\n\trbm->bii++;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_setbit",
          "args": [
            "&rbm",
            "false",
            "new_state"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_setbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "88-121",
          "snippet": "static inline void gfs2_setbit(const struct gfs2_rbm *rbm, bool do_clone,\n\t\t\t       unsigned char new_state)\n{\n\tunsigned char *byte1, *byte2, *end, cur_state;\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tunsigned int buflen = bi->bi_len;\n\tconst unsigned int bit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\tbyte1 = bi->bi_bh->b_data + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\tend = bi->bi_bh->b_data + bi->bi_offset + buflen;\n\n\tBUG_ON(byte1 >= end);\n\n\tcur_state = (*byte1 >> bit) & GFS2_BIT_MASK;\n\n\tif (unlikely(!valid_change[new_state * 4 + cur_state])) {\n\t\tpr_warn(\"buf_blk = 0x%x old_state=%d, new_state=%d\\n\",\n\t\t\trbm->offset, cur_state, new_state);\n\t\tpr_warn(\"rgrp=0x%llx bi_start=0x%x\\n\",\n\t\t\t(unsigned long long)rbm->rgd->rd_addr, bi->bi_start);\n\t\tpr_warn(\"bi_offset=0x%x bi_len=0x%x\\n\",\n\t\t\tbi->bi_offset, bi->bi_len);\n\t\tdump_stack();\n\t\tgfs2_consist_rgrpd(rbm->rgd);\n\t\treturn;\n\t}\n\t*byte1 ^= (cur_state ^ new_state) << bit;\n\n\tif (do_clone && bi->bi_clone) {\n\t\tbyte2 = bi->bi_clone + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\t\tcur_state = (*byte2 >> bit) & GFS2_BIT_MASK;\n\t\t*byte2 ^= (cur_state ^ new_state) << bit;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char valid_change[16] = {\n\t        /* current */\n\t/* n */ 0, 1, 1, 1,\n\t/* e */ 1, 0, 0, 0,\n\t/* w */ 0, 0, 0, 1,\n\t        1, 0, 0, 0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic const char valid_change[16] = {\n\t        /* current */\n\t/* n */ 0, 1, 1, 1,\n\t/* e */ 1, 0, 0, 0,\n\t/* w */ 0, 0, 0, 1,\n\t        1, 0, 0, 0\n};\n\nstatic inline void gfs2_setbit(const struct gfs2_rbm *rbm, bool do_clone,\n\t\t\t       unsigned char new_state)\n{\n\tunsigned char *byte1, *byte2, *end, cur_state;\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tunsigned int buflen = bi->bi_len;\n\tconst unsigned int bit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\tbyte1 = bi->bi_bh->b_data + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\tend = bi->bi_bh->b_data + bi->bi_offset + buflen;\n\n\tBUG_ON(byte1 >= end);\n\n\tcur_state = (*byte1 >> bit) & GFS2_BIT_MASK;\n\n\tif (unlikely(!valid_change[new_state * 4 + cur_state])) {\n\t\tpr_warn(\"buf_blk = 0x%x old_state=%d, new_state=%d\\n\",\n\t\t\trbm->offset, cur_state, new_state);\n\t\tpr_warn(\"rgrp=0x%llx bi_start=0x%x\\n\",\n\t\t\t(unsigned long long)rbm->rgd->rd_addr, bi->bi_start);\n\t\tpr_warn(\"bi_offset=0x%x bi_len=0x%x\\n\",\n\t\t\tbi->bi_offset, bi->bi_len);\n\t\tdump_stack();\n\t\tgfs2_consist_rgrpd(rbm->rgd);\n\t\treturn;\n\t}\n\t*byte1 ^= (cur_state ^ new_state) << bit;\n\n\tif (do_clone && bi->bi_clone) {\n\t\tbyte2 = bi->bi_clone + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\t\tcur_state = (*byte2 >> bit) & GFS2_BIT_MASK;\n\t\t*byte2 ^= (cur_state ^ new_state) << bit;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "rbm.rgd->rd_gl",
            "bi->bi_bh"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bi->bi_clone + bi->bi_offset",
            "bi->bi_bh->b_data + bi->bi_offset",
            "bi->bi_len"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "bi->bi_bh->b_size",
            "GFP_NOFS | __GFP_NOFAIL"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbm_bi",
          "args": [
            "&rbm"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "rbm_bi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "112-115",
          "snippet": "static inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_from_block",
          "args": [
            "&rbm",
            "bstart"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_from_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "261-282",
          "snippet": "static int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"block = %llu\\n\"",
            "(unsigned long long)bstart"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist",
          "args": [
            "sdp"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_blk2rgrpd",
          "args": [
            "sdp",
            "bstart",
            "1"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_blk2rgrpd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "503-532",
          "snippet": "struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_rgrpd *rgblk_free(struct gfs2_sbd *sdp, u64 bstart,\n\t\t\t\t     u32 blen, unsigned char new_state)\n{\n\tstruct gfs2_rbm rbm;\n\tstruct gfs2_bitmap *bi, *bi_prev = NULL;\n\n\trbm.rgd = gfs2_blk2rgrpd(sdp, bstart, 1);\n\tif (!rbm.rgd) {\n\t\tif (gfs2_consist(sdp))\n\t\t\tfs_err(sdp, \"block = %llu\\n\", (unsigned long long)bstart);\n\t\treturn NULL;\n\t}\n\n\tgfs2_rbm_from_block(&rbm, bstart);\n\twhile (blen--) {\n\t\tbi = rbm_bi(&rbm);\n\t\tif (bi != bi_prev) {\n\t\t\tif (!bi->bi_clone) {\n\t\t\t\tbi->bi_clone = kmalloc(bi->bi_bh->b_size,\n\t\t\t\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\t\t\t\tmemcpy(bi->bi_clone + bi->bi_offset,\n\t\t\t\t       bi->bi_bh->b_data + bi->bi_offset,\n\t\t\t\t       bi->bi_len);\n\t\t\t}\n\t\t\tgfs2_trans_add_meta(rbm.rgd->rd_gl, bi->bi_bh);\n\t\t\tbi_prev = bi;\n\t\t}\n\t\tgfs2_setbit(&rbm, false, new_state);\n\t\tgfs2_rbm_incr(&rbm);\n\t}\n\n\treturn rbm.rgd;\n}"
  },
  {
    "function_name": "gfs2_alloc_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2118-2140",
    "snippet": "static void gfs2_alloc_extent(const struct gfs2_rbm *rbm, bool dinode,\n\t\t\t     unsigned int *n)\n{\n\tstruct gfs2_rbm pos = { .rgd = rbm->rgd, };\n\tconst unsigned int elen = *n;\n\tu64 block;\n\tint ret;\n\n\t*n = 1;\n\tblock = gfs2_rbm_to_block(rbm);\n\tgfs2_trans_add_meta(rbm->rgd->rd_gl, rbm_bi(rbm)->bi_bh);\n\tgfs2_setbit(rbm, true, dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\tblock++;\n\twhile (*n < elen) {\n\t\tret = gfs2_rbm_from_block(&pos, block);\n\t\tif (ret || gfs2_testbit(&pos) != GFS2_BLKST_FREE)\n\t\t\tbreak;\n\t\tgfs2_trans_add_meta(pos.rgd->rd_gl, rbm_bi(&pos)->bi_bh);\n\t\tgfs2_setbit(&pos, true, GFS2_BLKST_USED);\n\t\t(*n)++;\n\t\tblock++;\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_setbit",
          "args": [
            "&pos",
            "true",
            "GFS2_BLKST_USED"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_setbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "88-121",
          "snippet": "static inline void gfs2_setbit(const struct gfs2_rbm *rbm, bool do_clone,\n\t\t\t       unsigned char new_state)\n{\n\tunsigned char *byte1, *byte2, *end, cur_state;\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tunsigned int buflen = bi->bi_len;\n\tconst unsigned int bit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\tbyte1 = bi->bi_bh->b_data + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\tend = bi->bi_bh->b_data + bi->bi_offset + buflen;\n\n\tBUG_ON(byte1 >= end);\n\n\tcur_state = (*byte1 >> bit) & GFS2_BIT_MASK;\n\n\tif (unlikely(!valid_change[new_state * 4 + cur_state])) {\n\t\tpr_warn(\"buf_blk = 0x%x old_state=%d, new_state=%d\\n\",\n\t\t\trbm->offset, cur_state, new_state);\n\t\tpr_warn(\"rgrp=0x%llx bi_start=0x%x\\n\",\n\t\t\t(unsigned long long)rbm->rgd->rd_addr, bi->bi_start);\n\t\tpr_warn(\"bi_offset=0x%x bi_len=0x%x\\n\",\n\t\t\tbi->bi_offset, bi->bi_len);\n\t\tdump_stack();\n\t\tgfs2_consist_rgrpd(rbm->rgd);\n\t\treturn;\n\t}\n\t*byte1 ^= (cur_state ^ new_state) << bit;\n\n\tif (do_clone && bi->bi_clone) {\n\t\tbyte2 = bi->bi_clone + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\t\tcur_state = (*byte2 >> bit) & GFS2_BIT_MASK;\n\t\t*byte2 ^= (cur_state ^ new_state) << bit;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char valid_change[16] = {\n\t        /* current */\n\t/* n */ 0, 1, 1, 1,\n\t/* e */ 1, 0, 0, 0,\n\t/* w */ 0, 0, 0, 1,\n\t        1, 0, 0, 0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic const char valid_change[16] = {\n\t        /* current */\n\t/* n */ 0, 1, 1, 1,\n\t/* e */ 1, 0, 0, 0,\n\t/* w */ 0, 0, 0, 1,\n\t        1, 0, 0, 0\n};\n\nstatic inline void gfs2_setbit(const struct gfs2_rbm *rbm, bool do_clone,\n\t\t\t       unsigned char new_state)\n{\n\tunsigned char *byte1, *byte2, *end, cur_state;\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tunsigned int buflen = bi->bi_len;\n\tconst unsigned int bit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\tbyte1 = bi->bi_bh->b_data + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\tend = bi->bi_bh->b_data + bi->bi_offset + buflen;\n\n\tBUG_ON(byte1 >= end);\n\n\tcur_state = (*byte1 >> bit) & GFS2_BIT_MASK;\n\n\tif (unlikely(!valid_change[new_state * 4 + cur_state])) {\n\t\tpr_warn(\"buf_blk = 0x%x old_state=%d, new_state=%d\\n\",\n\t\t\trbm->offset, cur_state, new_state);\n\t\tpr_warn(\"rgrp=0x%llx bi_start=0x%x\\n\",\n\t\t\t(unsigned long long)rbm->rgd->rd_addr, bi->bi_start);\n\t\tpr_warn(\"bi_offset=0x%x bi_len=0x%x\\n\",\n\t\t\tbi->bi_offset, bi->bi_len);\n\t\tdump_stack();\n\t\tgfs2_consist_rgrpd(rbm->rgd);\n\t\treturn;\n\t}\n\t*byte1 ^= (cur_state ^ new_state) << bit;\n\n\tif (do_clone && bi->bi_clone) {\n\t\tbyte2 = bi->bi_clone + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\t\tcur_state = (*byte2 >> bit) & GFS2_BIT_MASK;\n\t\t*byte2 ^= (cur_state ^ new_state) << bit;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "pos.rgd->rd_gl",
            "rbm_bi(&pos)->bi_bh"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbm_bi",
          "args": [
            "&pos"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "rbm_bi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "112-115",
          "snippet": "static inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_testbit",
          "args": [
            "&pos"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_testbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "130-141",
          "snippet": "static inline u8 gfs2_testbit(const struct gfs2_rbm *rbm)\n{\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tconst u8 *buffer = bi->bi_bh->b_data + bi->bi_offset;\n\tconst u8 *byte;\n\tunsigned int bit;\n\n\tbyte = buffer + (rbm->offset / GFS2_NBBY);\n\tbit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\treturn (*byte >> bit) & GFS2_BIT_MASK;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline u8 gfs2_testbit(const struct gfs2_rbm *rbm)\n{\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tconst u8 *buffer = bi->bi_bh->b_data + bi->bi_offset;\n\tconst u8 *byte;\n\tunsigned int bit;\n\n\tbyte = buffer + (rbm->offset / GFS2_NBBY);\n\tbit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\treturn (*byte >> bit) & GFS2_BIT_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_from_block",
          "args": [
            "&pos",
            "block"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_from_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "261-282",
          "snippet": "static int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_to_block",
          "args": [
            "rbm"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "117-121",
          "snippet": "static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_alloc_extent(const struct gfs2_rbm *rbm, bool dinode,\n\t\t\t     unsigned int *n)\n{\n\tstruct gfs2_rbm pos = { .rgd = rbm->rgd, };\n\tconst unsigned int elen = *n;\n\tu64 block;\n\tint ret;\n\n\t*n = 1;\n\tblock = gfs2_rbm_to_block(rbm);\n\tgfs2_trans_add_meta(rbm->rgd->rd_gl, rbm_bi(rbm)->bi_bh);\n\tgfs2_setbit(rbm, true, dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\tblock++;\n\twhile (*n < elen) {\n\t\tret = gfs2_rbm_from_block(&pos, block);\n\t\tif (ret || gfs2_testbit(&pos) != GFS2_BLKST_FREE)\n\t\t\tbreak;\n\t\tgfs2_trans_add_meta(pos.rgd->rd_gl, rbm_bi(&pos)->bi_bh);\n\t\tgfs2_setbit(&pos, true, GFS2_BLKST_USED);\n\t\t(*n)++;\n\t\tblock++;\n\t}\n}"
  },
  {
    "function_name": "gfs2_get_block_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2097-2106",
    "snippet": "static unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tstruct gfs2_rbm rbm = { .rgd = rgd, };\n\tint ret;\n\n\tret = gfs2_rbm_from_block(&rbm, block);\n\tWARN_ON_ONCE(ret != 0);\n\n\treturn gfs2_testbit(&rbm);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_testbit",
          "args": [
            "&rbm"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_testbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "130-141",
          "snippet": "static inline u8 gfs2_testbit(const struct gfs2_rbm *rbm)\n{\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tconst u8 *buffer = bi->bi_bh->b_data + bi->bi_offset;\n\tconst u8 *byte;\n\tunsigned int bit;\n\n\tbyte = buffer + (rbm->offset / GFS2_NBBY);\n\tbit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\treturn (*byte >> bit) & GFS2_BIT_MASK;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline u8 gfs2_testbit(const struct gfs2_rbm *rbm)\n{\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tconst u8 *buffer = bi->bi_bh->b_data + bi->bi_offset;\n\tconst u8 *byte;\n\tunsigned int bit;\n\n\tbyte = buffer + (rbm->offset / GFS2_NBBY);\n\tbit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\treturn (*byte >> bit) & GFS2_BIT_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret != 0"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_from_block",
          "args": [
            "&rbm",
            "block"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_from_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "261-282",
          "snippet": "static int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic unsigned char gfs2_get_block_type(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tstruct gfs2_rbm rbm = { .rgd = rgd, };\n\tint ret;\n\n\tret = gfs2_rbm_from_block(&rbm, block);\n\tWARN_ON_ONCE(ret != 0);\n\n\treturn gfs2_testbit(&rbm);\n}"
  },
  {
    "function_name": "gfs2_inplace_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "2081-2087",
    "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&rs->rs_rgd_gh"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
  },
  {
    "function_name": "gfs2_inplace_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1952-2072",
    "snippet": "int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define NO_BLOCK ((u64)~0)"
    ],
    "globals_used": [
      "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_log_flush",
          "args": [
            "sdp",
            "NULL",
            "NORMAL_FLUSH"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "704-787",
          "snippet": "void gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_ri_update",
          "args": [
            "ip"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ri_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "994-1010",
          "snippet": "static int gfs2_ri_update(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tdo {\n\t\terror = read_rindex_entry(ip);\n\t} while (error == 0);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tset_rgrp_preferences(sdp);\n\n\tsdp->sd_rindex_uptodate = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ri_update(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tdo {\n\t\terror = read_rindex_entry(ip);\n\t} while (error == 0);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tset_rgrp_preferences(sdp);\n\n\tsdp->sd_rindex_uptodate = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_rindex"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_select_rgrp",
          "args": [
            "&rs->rs_rbm.rgd",
            "begin"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_select_rgrp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1911-1923",
          "snippet": "static bool gfs2_select_rgrp(struct gfs2_rgrpd **pos, const struct gfs2_rgrpd *begin)\n{\n\tstruct gfs2_rgrpd *rgd = *pos;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\n\trgd = gfs2_rgrpd_get_next(rgd);\n\tif (rgd == NULL)\n\t\trgd = gfs2_rgrpd_get_first(sdp);\n\t*pos = rgd;\n\tif (rgd != begin) /* If we didn't wrap */\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic bool gfs2_select_rgrp(struct gfs2_rgrpd **pos, const struct gfs2_rgrpd *begin)\n{\n\tstruct gfs2_rgrpd *rgd = *pos;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\n\trgd = gfs2_rgrpd_get_next(rgd);\n\tif (rgd == NULL)\n\t\trgd = gfs2_rgrpd_get_first(sdp);\n\t*pos = rgd;\n\tif (rgd != begin) /* If we didn't wrap */\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&rs->rs_rgd_gh"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_deltree",
          "args": [
            "rs"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_deltree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "668-678",
          "snippet": "void gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rbm.rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rbm.rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rs_active",
          "args": [
            "rs"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.h",
          "lines": "79-82",
          "snippet": "static inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_rgrp_unlink",
          "args": [
            "rs->rs_rbm.rgd",
            "&last_unlinked",
            "ip->i_no_addr"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "try_rgrp_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1764-1818",
          "snippet": "static void try_rgrp_unlink(struct gfs2_rgrpd *rgd, u64 *last_unlinked, u64 skip)\n{\n\tu64 block;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl;\n\tstruct gfs2_inode *ip;\n\tint error;\n\tint found = 0;\n\tstruct gfs2_rbm rbm = { .rgd = rgd, .bii = 0, .offset = 0 };\n\n\twhile (1) {\n\t\tdown_write(&sdp->sd_log_flush_lock);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_UNLINKED, NULL, NULL,\n\t\t\t\t      true, NULL);\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\tif (error == -ENOSPC)\n\t\t\tbreak;\n\t\tif (WARN_ON_ONCE(error))\n\t\t\tbreak;\n\n\t\tblock = gfs2_rbm_to_block(&rbm);\n\t\tif (gfs2_rbm_from_block(&rbm, block + 1))\n\t\t\tbreak;\n\t\tif (*last_unlinked != NO_BLOCK && block <= *last_unlinked)\n\t\t\tcontinue;\n\t\tif (block == skip)\n\t\t\tcontinue;\n\t\t*last_unlinked = block;\n\n\t\terror = gfs2_glock_get(sdp, block, &gfs2_inode_glops, CREATE, &gl);\n\t\tif (error)\n\t\t\tcontinue;\n\n\t\t/* If the inode is already in cache, we can ignore it here\n\t\t * because the existing inode disposal code will deal with\n\t\t * it when all refs have gone away. Accessing gl_object like\n\t\t * this is not safe in general. Here it is ok because we do\n\t\t * not dereference the pointer, and we only need an approx\n\t\t * answer to whether it is NULL or not.\n\t\t */\n\t\tip = gl->gl_object;\n\n\t\tif (ip || queue_work(gfs2_delete_workqueue, &gl->gl_delete) == 0)\n\t\t\tgfs2_glock_put(gl);\n\t\telse\n\t\t\tfound++;\n\n\t\t/* Limit reclaim to sensible number of tasks */\n\t\tif (found > NR_CPUS)\n\t\t\treturn;\n\t}\n\n\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\treturn;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NO_BLOCK ((u64)~0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic void try_rgrp_unlink(struct gfs2_rgrpd *rgd, u64 *last_unlinked, u64 skip)\n{\n\tu64 block;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl;\n\tstruct gfs2_inode *ip;\n\tint error;\n\tint found = 0;\n\tstruct gfs2_rbm rbm = { .rgd = rgd, .bii = 0, .offset = 0 };\n\n\twhile (1) {\n\t\tdown_write(&sdp->sd_log_flush_lock);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_UNLINKED, NULL, NULL,\n\t\t\t\t      true, NULL);\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\tif (error == -ENOSPC)\n\t\t\tbreak;\n\t\tif (WARN_ON_ONCE(error))\n\t\t\tbreak;\n\n\t\tblock = gfs2_rbm_to_block(&rbm);\n\t\tif (gfs2_rbm_from_block(&rbm, block + 1))\n\t\t\tbreak;\n\t\tif (*last_unlinked != NO_BLOCK && block <= *last_unlinked)\n\t\t\tcontinue;\n\t\tif (block == skip)\n\t\t\tcontinue;\n\t\t*last_unlinked = block;\n\n\t\terror = gfs2_glock_get(sdp, block, &gfs2_inode_glops, CREATE, &gl);\n\t\tif (error)\n\t\t\tcontinue;\n\n\t\t/* If the inode is already in cache, we can ignore it here\n\t\t * because the existing inode disposal code will deal with\n\t\t * it when all refs have gone away. Accessing gl_object like\n\t\t * this is not safe in general. Here it is ok because we do\n\t\t * not dereference the pointer, and we only need an approx\n\t\t * answer to whether it is NULL or not.\n\t\t */\n\t\tip = gl->gl_object;\n\n\t\tif (ip || queue_work(gfs2_delete_workqueue, &gl->gl_delete) == 0)\n\t\t\tgfs2_glock_put(gl);\n\t\telse\n\t\t\tfound++;\n\n\t\t/* Limit reclaim to sensible number of tasks */\n\t\tif (found > NR_CPUS)\n\t\t\treturn;\n\t}\n\n\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rg_mblk_search",
          "args": [
            "rs->rs_rbm.rgd",
            "ip",
            "ap"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "rg_mblk_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1485-1524",
          "snippet": "static void rg_mblk_search(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip,\n\t\t\t   const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_rbm rbm = { .rgd = rgd, };\n\tu64 goal;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tu32 extlen;\n\tu32 free_blocks = rgd->rd_free_clone - rgd->rd_reserved;\n\tint ret;\n\tstruct inode *inode = &ip->i_inode;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\textlen = 1;\n\telse {\n\t\textlen = max_t(u32, atomic_read(&rs->rs_sizehint), ap->target);\n\t\textlen = clamp(extlen, RGRP_RSRV_MINBLKS, free_blocks);\n\t}\n\tif ((rgd->rd_free_clone < rgd->rd_reserved) || (free_blocks < extlen))\n\t\treturn;\n\n\t/* Find bitmap block that contains bits for goal block */\n\tif (rgrp_contains_block(rgd, ip->i_goal))\n\t\tgoal = ip->i_goal;\n\telse\n\t\tgoal = rgd->rd_last_alloc + rgd->rd_data0;\n\n\tif (WARN_ON(gfs2_rbm_from_block(&rbm, goal)))\n\t\treturn;\n\n\tret = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, &extlen, ip, true, ap);\n\tif (ret == 0) {\n\t\trs->rs_rbm = rbm;\n\t\trs->rs_free = extlen;\n\t\trs->rs_inum = ip->i_no_addr;\n\t\trs_insert(ip);\n\t} else {\n\t\tif (goal == rgd->rd_last_alloc + rgd->rd_data0)\n\t\t\trgd->rd_last_alloc = 0;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nstatic void rg_mblk_search(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip,\n\t\t\t   const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_rbm rbm = { .rgd = rgd, };\n\tu64 goal;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tu32 extlen;\n\tu32 free_blocks = rgd->rd_free_clone - rgd->rd_reserved;\n\tint ret;\n\tstruct inode *inode = &ip->i_inode;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\textlen = 1;\n\telse {\n\t\textlen = max_t(u32, atomic_read(&rs->rs_sizehint), ap->target);\n\t\textlen = clamp(extlen, RGRP_RSRV_MINBLKS, free_blocks);\n\t}\n\tif ((rgd->rd_free_clone < rgd->rd_reserved) || (free_blocks < extlen))\n\t\treturn;\n\n\t/* Find bitmap block that contains bits for goal block */\n\tif (rgrp_contains_block(rgd, ip->i_goal))\n\t\tgoal = ip->i_goal;\n\telse\n\t\tgoal = rgd->rd_last_alloc + rgd->rd_data0;\n\n\tif (WARN_ON(gfs2_rbm_from_block(&rbm, goal)))\n\t\treturn;\n\n\tret = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, &extlen, ip, true, ap);\n\tif (ret == 0) {\n\t\trs->rs_rbm = rbm;\n\t\trs->rs_free = extlen;\n\t\trs->rs_inum = ip->i_no_addr;\n\t\trs_insert(ip);\n\t} else {\n\t\tif (goal == rgd->rd_last_alloc + rgd->rd_data0)\n\t\t\trgd->rd_last_alloc = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_bh_get",
          "args": [
            "rs->rs_rbm.rgd"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_bh_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1146-1211",
          "snippet": "static int gfs2_rgrp_bh_get(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\tunsigned int length = rgd->rd_length;\n\tstruct gfs2_bitmap *bi;\n\tunsigned int x, y;\n\tint error;\n\n\tif (rgd->rd_bits[0].bi_bh != NULL)\n\t\treturn 0;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\t\terror = gfs2_meta_read(gl, rgd->rd_addr + x, 0, &bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tfor (y = length; y--;) {\n\t\tbi = rgd->rd_bits + y;\n\t\terror = gfs2_meta_wait(sdp, bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tif (gfs2_metatype_check(sdp, bi->bi_bh, y ? GFS2_METATYPE_RB :\n\t\t\t\t\t      GFS2_METATYPE_RG)) {\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!(rgd->rd_flags & GFS2_RDF_UPTODATE)) {\n\t\tfor (x = 0; x < length; x++)\n\t\t\tclear_bit(GBF_FULL, &rgd->rd_bits[x].bi_flags);\n\t\tgfs2_rgrp_in(rgd, (rgd->rd_bits[0].bi_bh)->b_data);\n\t\trgd->rd_flags |= (GFS2_RDF_UPTODATE | GFS2_RDF_CHECK);\n\t\trgd->rd_free_clone = rgd->rd_free;\n\t\t/* max out the rgrp allocation failure point */\n\t\trgd->rd_extfail_pt = rgd->rd_free;\n\t}\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic) {\n\t\trgd->rd_rgl->rl_unlinked = cpu_to_be32(count_unlinked(rgd));\n\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl,\n\t\t\t\t     rgd->rd_bits[0].bi_bh->b_data);\n\t}\n\telse if (sdp->sd_args.ar_rgrplvb) {\n\t\tif (!gfs2_rgrp_lvb_valid(rgd)){\n\t\t\tgfs2_consist_rgrpd(rgd);\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\t}\n\treturn 0;\n\nfail:\n\twhile (x--) {\n\t\tbi = rgd->rd_bits + x;\n\t\tbrelse(bi->bi_bh);\n\t\tbi->bi_bh = NULL;\n\t\tgfs2_assert_warn(sdp, !bi->bi_clone);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rgrp_bh_get(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\tunsigned int length = rgd->rd_length;\n\tstruct gfs2_bitmap *bi;\n\tunsigned int x, y;\n\tint error;\n\n\tif (rgd->rd_bits[0].bi_bh != NULL)\n\t\treturn 0;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\t\terror = gfs2_meta_read(gl, rgd->rd_addr + x, 0, &bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tfor (y = length; y--;) {\n\t\tbi = rgd->rd_bits + y;\n\t\terror = gfs2_meta_wait(sdp, bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tif (gfs2_metatype_check(sdp, bi->bi_bh, y ? GFS2_METATYPE_RB :\n\t\t\t\t\t      GFS2_METATYPE_RG)) {\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!(rgd->rd_flags & GFS2_RDF_UPTODATE)) {\n\t\tfor (x = 0; x < length; x++)\n\t\t\tclear_bit(GBF_FULL, &rgd->rd_bits[x].bi_flags);\n\t\tgfs2_rgrp_in(rgd, (rgd->rd_bits[0].bi_bh)->b_data);\n\t\trgd->rd_flags |= (GFS2_RDF_UPTODATE | GFS2_RDF_CHECK);\n\t\trgd->rd_free_clone = rgd->rd_free;\n\t\t/* max out the rgrp allocation failure point */\n\t\trgd->rd_extfail_pt = rgd->rd_free;\n\t}\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic) {\n\t\trgd->rd_rgl->rl_unlinked = cpu_to_be32(count_unlinked(rgd));\n\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl,\n\t\t\t\t     rgd->rd_bits[0].bi_bh->b_data);\n\t}\n\telse if (sdp->sd_args.ar_rgrplvb) {\n\t\tif (!gfs2_rgrp_lvb_valid(rgd)){\n\t\t\tgfs2_consist_rgrpd(rgd);\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\t}\n\treturn 0;\n\nfail:\n\twhile (x--) {\n\t\tbi = rgd->rd_bits + x;\n\t\tbrelse(bi->bi_bh);\n\t\tbi->bi_bh = NULL;\n\t\tgfs2_assert_warn(sdp, !bi->bi_clone);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_rgrp_lvb",
          "args": [
            "rs->rs_rbm.rgd"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "update_rgrp_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1213-1234",
          "snippet": "static int update_rgrp_lvb(struct gfs2_rgrpd *rgd)\n{\n\tu32 rl_flags;\n\n\tif (rgd->rd_flags & GFS2_RDF_UPTODATE)\n\t\treturn 0;\n\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic)\n\t\treturn gfs2_rgrp_bh_get(rgd);\n\n\trl_flags = be32_to_cpu(rgd->rd_rgl->rl_flags);\n\trl_flags &= ~GFS2_RDF_MASK;\n\trgd->rd_flags &= GFS2_RDF_MASK;\n\trgd->rd_flags |= (rl_flags | GFS2_RDF_UPTODATE | GFS2_RDF_CHECK);\n\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\trgd->rd_free = be32_to_cpu(rgd->rd_rgl->rl_free);\n\trgd->rd_free_clone = rgd->rd_free;\n\trgd->rd_dinodes = be32_to_cpu(rgd->rd_rgl->rl_dinodes);\n\trgd->rd_igeneration = be64_to_cpu(rgd->rd_rgl->rl_igeneration);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int update_rgrp_lvb(struct gfs2_rgrpd *rgd)\n{\n\tu32 rl_flags;\n\n\tif (rgd->rd_flags & GFS2_RDF_UPTODATE)\n\t\treturn 0;\n\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic)\n\t\treturn gfs2_rgrp_bh_get(rgd);\n\n\trl_flags = be32_to_cpu(rgd->rd_rgl->rl_flags);\n\trl_flags &= ~GFS2_RDF_MASK;\n\trgd->rd_flags &= GFS2_RDF_MASK;\n\trgd->rd_flags |= (rl_flags | GFS2_RDF_UPTODATE | GFS2_RDF_CHECK);\n\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\trgd->rd_free = be32_to_cpu(rgd->rd_rgl->rl_free);\n\trgd->rd_free_clone = rgd->rd_free;\n\trgd->rd_dinodes = be32_to_cpu(rgd->rd_rgl->rl_dinodes);\n\trgd->rd_igeneration = be64_to_cpu(rgd->rd_rgl->rl_igeneration);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_congested",
          "args": [
            "rs->rs_rbm.rgd",
            "loops"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_congested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1847-1882",
          "snippet": "static bool gfs2_rgrp_congested(const struct gfs2_rgrpd *rgd, int loops)\n{\n\tconst struct gfs2_glock *gl = rgd->rd_gl;\n\tconst struct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_lkstats *st;\n\ts64 r_dcount, l_dcount;\n\ts64 r_srttb, l_srttb;\n\ts64 srttb_diff;\n\ts64 sqr_diff;\n\ts64 var;\n\n\tpreempt_disable();\n\tst = &this_cpu_ptr(sdp->sd_lkstats)->lkstats[LM_TYPE_RGRP];\n\tr_srttb = st->stats[GFS2_LKS_SRTTB];\n\tr_dcount = st->stats[GFS2_LKS_DCOUNT];\n\tvar = st->stats[GFS2_LKS_SRTTVARB] +\n\t      gl->gl_stats.stats[GFS2_LKS_SRTTVARB];\n\tpreempt_enable();\n\n\tl_srttb = gl->gl_stats.stats[GFS2_LKS_SRTTB];\n\tl_dcount = gl->gl_stats.stats[GFS2_LKS_DCOUNT];\n\n\tif ((l_dcount < 1) || (r_dcount < 1) || (r_srttb == 0))\n\t\treturn false;\n\n\tsrttb_diff = r_srttb - l_srttb;\n\tsqr_diff = srttb_diff * srttb_diff;\n\n\tvar *= 2;\n\tif (l_dcount < 8 || r_dcount < 8)\n\t\tvar *= 2;\n\tif (loops == 1)\n\t\tvar *= 2;\n\n\treturn ((srttb_diff < 0) && (sqr_diff > var));\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic bool gfs2_rgrp_congested(const struct gfs2_rgrpd *rgd, int loops)\n{\n\tconst struct gfs2_glock *gl = rgd->rd_gl;\n\tconst struct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_lkstats *st;\n\ts64 r_dcount, l_dcount;\n\ts64 r_srttb, l_srttb;\n\ts64 srttb_diff;\n\ts64 sqr_diff;\n\ts64 var;\n\n\tpreempt_disable();\n\tst = &this_cpu_ptr(sdp->sd_lkstats)->lkstats[LM_TYPE_RGRP];\n\tr_srttb = st->stats[GFS2_LKS_SRTTB];\n\tr_dcount = st->stats[GFS2_LKS_DCOUNT];\n\tvar = st->stats[GFS2_LKS_SRTTVARB] +\n\t      gl->gl_stats.stats[GFS2_LKS_SRTTVARB];\n\tpreempt_enable();\n\n\tl_srttb = gl->gl_stats.stats[GFS2_LKS_SRTTB];\n\tl_dcount = gl->gl_stats.stats[GFS2_LKS_DCOUNT];\n\n\tif ((l_dcount < 1) || (r_dcount < 1) || (r_srttb == 0))\n\t\treturn false;\n\n\tsrttb_diff = r_srttb - l_srttb;\n\tsqr_diff = srttb_diff * srttb_diff;\n\n\tvar *= 2;\n\tif (l_dcount < 8 || r_dcount < 8)\n\t\tvar *= 2;\n\tif (loops == 1)\n\t\tvar *= 2;\n\n\treturn ((srttb_diff < 0) && (sqr_diff > var));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "rs->rs_rbm.rgd->rd_gl",
            "LM_ST_EXCLUSIVE",
            "flags",
            "&rs->rs_rgd_gh"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_used_recently",
          "args": [
            "rs",
            "1000"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_used_recently",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1891-1900",
          "snippet": "static bool gfs2_rgrp_used_recently(const struct gfs2_blkreserv *rs,\n\t\t\t\t    u64 msecs)\n{\n\tu64 tdiff;\n\n\ttdiff = ktime_to_ns(ktime_sub(ktime_get_real(),\n                            rs->rs_rbm.rgd->rd_gl->gl_dstamp));\n\n\treturn tdiff > (msecs * 1000 * 1000);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic bool gfs2_rgrp_used_recently(const struct gfs2_blkreserv *rs,\n\t\t\t\t    u64 msecs)\n{\n\tu64 tdiff;\n\n\ttdiff = ktime_to_ns(ktime_sub(ktime_get_real(),\n                            rs->rs_rbm.rgd->rd_gl->gl_dstamp));\n\n\treturn tdiff > (msecs * 1000 * 1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fast_to_acquire",
          "args": [
            "rs->rs_rbm.rgd"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "fast_to_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1931-1942",
          "snippet": "static inline int fast_to_acquire(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\n\tif (gl->gl_state != LM_ST_UNLOCKED && list_empty(&gl->gl_holders) &&\n\t    !test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags) &&\n\t    !test_bit(GLF_DEMOTE, &gl->gl_flags))\n\t\treturn 1;\n\tif (rgd->rd_flags & GFS2_RDF_PREFERRED)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int fast_to_acquire(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\n\tif (gl->gl_state != LM_ST_UNLOCKED && list_empty(&gl->gl_holders) &&\n\t    !test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags) &&\n\t    !test_bit(GLF_DEMOTE, &gl->gl_flags))\n\t\treturn 1;\n\tif (rgd->rd_flags & GFS2_RDF_PREFERRED)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_is_locked_by_me",
          "args": [
            "rs->rs_rbm.rgd->rd_gl"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_is_locked_by_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "138-157",
          "snippet": "static inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nstatic inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_orlov_skip",
          "args": [
            "ip"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_orlov_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1902-1909",
          "snippet": "static u32 gfs2_orlov_skip(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu32 skip;\n\n\tget_random_bytes(&skip, sizeof(skip));\n\treturn skip % sdp->sd_rgrps;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u32 gfs2_orlov_skip(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu32 skip;\n\n\tget_random_bytes(&skip, sizeof(skip));\n\treturn skip % sdp->sd_rgrps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_inode.i_mode"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_blk2rgrpd",
          "args": [
            "sdp",
            "ip->i_goal",
            "1"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_blk2rgrpd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "503-532",
          "snippet": "struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_and_update_goal",
          "args": [
            "ip"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_update_goal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "580-585",
          "snippet": "void check_and_update_goal(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tif (!ip->i_goal || gfs2_blk2rgrpd(sdp, ip->i_goal, 1) == NULL)\n\t\tip->i_goal = ip->i_no_addr;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid check_and_update_goal(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tif (!ip->i_goal || gfs2_blk2rgrpd(sdp, ip->i_goal, 1) == NULL)\n\t\tip->i_goal = ip->i_no_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rgrp_contains_block",
          "args": [
            "ip->i_rgd",
            "ip->i_goal"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "rgrp_contains_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "487-492",
          "snippet": "static inline int rgrp_contains_block(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tu64 first = rgd->rd_data0;\n\tu64 last = first + rgd->rd_data;\n\treturn first <= block && block < last;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int rgrp_contains_block(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tu64 first = rgd->rd_data0;\n\tu64 last = first + rgd->rd_data;\n\treturn first <= block && block < last;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "ap->target"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "fast_to_acquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1931-1942",
    "snippet": "static inline int fast_to_acquire(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\n\tif (gl->gl_state != LM_ST_UNLOCKED && list_empty(&gl->gl_holders) &&\n\t    !test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags) &&\n\t    !test_bit(GLF_DEMOTE, &gl->gl_flags))\n\t\treturn 1;\n\tif (rgd->rd_flags & GFS2_RDF_PREFERRED)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "GLF_DEMOTE",
            "&gl->gl_flags"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&gl->gl_holders"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int fast_to_acquire(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\n\tif (gl->gl_state != LM_ST_UNLOCKED && list_empty(&gl->gl_holders) &&\n\t    !test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags) &&\n\t    !test_bit(GLF_DEMOTE, &gl->gl_flags))\n\t\treturn 1;\n\tif (rgd->rd_flags & GFS2_RDF_PREFERRED)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_select_rgrp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1911-1923",
    "snippet": "static bool gfs2_select_rgrp(struct gfs2_rgrpd **pos, const struct gfs2_rgrpd *begin)\n{\n\tstruct gfs2_rgrpd *rgd = *pos;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\n\trgd = gfs2_rgrpd_get_next(rgd);\n\tif (rgd == NULL)\n\t\trgd = gfs2_rgrpd_get_first(sdp);\n\t*pos = rgd;\n\tif (rgd != begin) /* If we didn't wrap */\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rgrpd_get_first",
          "args": [
            "sdp"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrpd_get_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "541-552",
          "snippet": "struct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp)\n{\n\tconst struct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_first(&sdp->sd_rindex_tree);\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn rgd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp)\n{\n\tconst struct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_first(&sdp->sd_rindex_tree);\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn rgd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrpd_get_next",
          "args": [
            "rgd"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrpd_get_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "561-578",
          "snippet": "struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tconst struct rb_node *n;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_next(&rgd->rd_node);\n\tif (n == NULL)\n\t\tn = rb_first(&sdp->sd_rindex_tree);\n\n\tif (unlikely(&rgd->rd_node == n)) {\n\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\treturn NULL;\n\t}\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\treturn rgd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tconst struct rb_node *n;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_next(&rgd->rd_node);\n\tif (n == NULL)\n\t\tn = rb_first(&sdp->sd_rindex_tree);\n\n\tif (unlikely(&rgd->rd_node == n)) {\n\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\treturn NULL;\n\t}\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\treturn rgd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic bool gfs2_select_rgrp(struct gfs2_rgrpd **pos, const struct gfs2_rgrpd *begin)\n{\n\tstruct gfs2_rgrpd *rgd = *pos;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\n\trgd = gfs2_rgrpd_get_next(rgd);\n\tif (rgd == NULL)\n\t\trgd = gfs2_rgrpd_get_first(sdp);\n\t*pos = rgd;\n\tif (rgd != begin) /* If we didn't wrap */\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "gfs2_orlov_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1902-1909",
    "snippet": "static u32 gfs2_orlov_skip(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu32 skip;\n\n\tget_random_bytes(&skip, sizeof(skip));\n\treturn skip % sdp->sd_rgrps;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&skip",
            "sizeof(skip)"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u32 gfs2_orlov_skip(const struct gfs2_inode *ip)\n{\n\tconst struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tu32 skip;\n\n\tget_random_bytes(&skip, sizeof(skip));\n\treturn skip % sdp->sd_rgrps;\n}"
  },
  {
    "function_name": "gfs2_rgrp_used_recently",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1891-1900",
    "snippet": "static bool gfs2_rgrp_used_recently(const struct gfs2_blkreserv *rs,\n\t\t\t\t    u64 msecs)\n{\n\tu64 tdiff;\n\n\ttdiff = ktime_to_ns(ktime_sub(ktime_get_real(),\n                            rs->rs_rbm.rgd->rd_gl->gl_dstamp));\n\n\treturn tdiff > (msecs * 1000 * 1000);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(ktime_get_real(),\n                            rs->rs_rbm.rgd->rd_gl->gl_dstamp)"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get_real()",
            "rs->rs_rbm.rgd->rd_gl->gl_dstamp"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real",
          "args": [],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic bool gfs2_rgrp_used_recently(const struct gfs2_blkreserv *rs,\n\t\t\t\t    u64 msecs)\n{\n\tu64 tdiff;\n\n\ttdiff = ktime_to_ns(ktime_sub(ktime_get_real(),\n                            rs->rs_rbm.rgd->rd_gl->gl_dstamp));\n\n\treturn tdiff > (msecs * 1000 * 1000);\n}"
  },
  {
    "function_name": "gfs2_rgrp_congested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1847-1882",
    "snippet": "static bool gfs2_rgrp_congested(const struct gfs2_rgrpd *rgd, int loops)\n{\n\tconst struct gfs2_glock *gl = rgd->rd_gl;\n\tconst struct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_lkstats *st;\n\ts64 r_dcount, l_dcount;\n\ts64 r_srttb, l_srttb;\n\ts64 srttb_diff;\n\ts64 sqr_diff;\n\ts64 var;\n\n\tpreempt_disable();\n\tst = &this_cpu_ptr(sdp->sd_lkstats)->lkstats[LM_TYPE_RGRP];\n\tr_srttb = st->stats[GFS2_LKS_SRTTB];\n\tr_dcount = st->stats[GFS2_LKS_DCOUNT];\n\tvar = st->stats[GFS2_LKS_SRTTVARB] +\n\t      gl->gl_stats.stats[GFS2_LKS_SRTTVARB];\n\tpreempt_enable();\n\n\tl_srttb = gl->gl_stats.stats[GFS2_LKS_SRTTB];\n\tl_dcount = gl->gl_stats.stats[GFS2_LKS_DCOUNT];\n\n\tif ((l_dcount < 1) || (r_dcount < 1) || (r_srttb == 0))\n\t\treturn false;\n\n\tsrttb_diff = r_srttb - l_srttb;\n\tsqr_diff = srttb_diff * srttb_diff;\n\n\tvar *= 2;\n\tif (l_dcount < 8 || r_dcount < 8)\n\t\tvar *= 2;\n\tif (loops == 1)\n\t\tvar *= 2;\n\n\treturn ((srttb_diff < 0) && (sqr_diff > var));\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "sdp->sd_lkstats"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic bool gfs2_rgrp_congested(const struct gfs2_rgrpd *rgd, int loops)\n{\n\tconst struct gfs2_glock *gl = rgd->rd_gl;\n\tconst struct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_lkstats *st;\n\ts64 r_dcount, l_dcount;\n\ts64 r_srttb, l_srttb;\n\ts64 srttb_diff;\n\ts64 sqr_diff;\n\ts64 var;\n\n\tpreempt_disable();\n\tst = &this_cpu_ptr(sdp->sd_lkstats)->lkstats[LM_TYPE_RGRP];\n\tr_srttb = st->stats[GFS2_LKS_SRTTB];\n\tr_dcount = st->stats[GFS2_LKS_DCOUNT];\n\tvar = st->stats[GFS2_LKS_SRTTVARB] +\n\t      gl->gl_stats.stats[GFS2_LKS_SRTTVARB];\n\tpreempt_enable();\n\n\tl_srttb = gl->gl_stats.stats[GFS2_LKS_SRTTB];\n\tl_dcount = gl->gl_stats.stats[GFS2_LKS_DCOUNT];\n\n\tif ((l_dcount < 1) || (r_dcount < 1) || (r_srttb == 0))\n\t\treturn false;\n\n\tsrttb_diff = r_srttb - l_srttb;\n\tsqr_diff = srttb_diff * srttb_diff;\n\n\tvar *= 2;\n\tif (l_dcount < 8 || r_dcount < 8)\n\t\tvar *= 2;\n\tif (loops == 1)\n\t\tvar *= 2;\n\n\treturn ((srttb_diff < 0) && (sqr_diff > var));\n}"
  },
  {
    "function_name": "try_rgrp_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1764-1818",
    "snippet": "static void try_rgrp_unlink(struct gfs2_rgrpd *rgd, u64 *last_unlinked, u64 skip)\n{\n\tu64 block;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl;\n\tstruct gfs2_inode *ip;\n\tint error;\n\tint found = 0;\n\tstruct gfs2_rbm rbm = { .rgd = rgd, .bii = 0, .offset = 0 };\n\n\twhile (1) {\n\t\tdown_write(&sdp->sd_log_flush_lock);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_UNLINKED, NULL, NULL,\n\t\t\t\t      true, NULL);\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\tif (error == -ENOSPC)\n\t\t\tbreak;\n\t\tif (WARN_ON_ONCE(error))\n\t\t\tbreak;\n\n\t\tblock = gfs2_rbm_to_block(&rbm);\n\t\tif (gfs2_rbm_from_block(&rbm, block + 1))\n\t\t\tbreak;\n\t\tif (*last_unlinked != NO_BLOCK && block <= *last_unlinked)\n\t\t\tcontinue;\n\t\tif (block == skip)\n\t\t\tcontinue;\n\t\t*last_unlinked = block;\n\n\t\terror = gfs2_glock_get(sdp, block, &gfs2_inode_glops, CREATE, &gl);\n\t\tif (error)\n\t\t\tcontinue;\n\n\t\t/* If the inode is already in cache, we can ignore it here\n\t\t * because the existing inode disposal code will deal with\n\t\t * it when all refs have gone away. Accessing gl_object like\n\t\t * this is not safe in general. Here it is ok because we do\n\t\t * not dereference the pointer, and we only need an approx\n\t\t * answer to whether it is NULL or not.\n\t\t */\n\t\tip = gl->gl_object;\n\n\t\tif (ip || queue_work(gfs2_delete_workqueue, &gl->gl_delete) == 0)\n\t\t\tgfs2_glock_put(gl);\n\t\telse\n\t\t\tfound++;\n\n\t\t/* Limit reclaim to sensible number of tasks */\n\t\tif (found > NR_CPUS)\n\t\t\treturn;\n\t}\n\n\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\treturn;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define NO_BLOCK ((u64)~0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_put",
          "args": [
            "gl"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "193-212",
          "snippet": "void gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "gfs2_delete_workqueue",
            "&gl->gl_delete"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_get",
          "args": [
            "sdp",
            "block",
            "&gfs2_inode_glops",
            "CREATE",
            "&gl"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "702-790",
          "snippet": "int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];\n\nint gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_from_block",
          "args": [
            "&rbm",
            "block + 1"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_from_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "261-282",
          "snippet": "static int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_to_block",
          "args": [
            "&rbm"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "117-121",
          "snippet": "static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "error"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sdp->sd_log_flush_lock"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_find",
          "args": [
            "&rbm",
            "GFS2_BLKST_UNLINKED",
            "NULL",
            "NULL",
            "true",
            "NULL"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1652-1752",
          "snippet": "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap)\n{\n\tstruct buffer_head *bh;\n\tint initial_bii;\n\tu32 initial_offset;\n\tint first_bii = rbm->bii;\n\tu32 first_offset = rbm->offset;\n\tu32 offset;\n\tu8 *buffer;\n\tint n = 0;\n\tint iters = rbm->rgd->rd_length;\n\tint ret;\n\tstruct gfs2_bitmap *bi;\n\tstruct gfs2_extent maxext = { .rbm.rgd = rbm->rgd, };\n\n\t/* If we are not starting at the beginning of a bitmap, then we\n\t * need to add one to the bitmap count to ensure that we search\n\t * the starting bitmap twice.\n\t */\n\tif (rbm->offset != 0)\n\t\titers++;\n\n\twhile(1) {\n\t\tbi = rbm_bi(rbm);\n\t\tif (test_bit(GBF_FULL, &bi->bi_flags) &&\n\t\t    (state == GFS2_BLKST_FREE))\n\t\t\tgoto next_bitmap;\n\n\t\tbh = bi->bi_bh;\n\t\tbuffer = bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bh));\n\t\tif (state != GFS2_BLKST_UNLINKED && bi->bi_clone)\n\t\t\tbuffer = bi->bi_clone + bi->bi_offset;\n\t\tinitial_offset = rbm->offset;\n\t\toffset = gfs2_bitfit(buffer, bi->bi_len, rbm->offset, state);\n\t\tif (offset == BFITNOENT)\n\t\t\tgoto bitmap_full;\n\t\trbm->offset = offset;\n\t\tif (ip == NULL)\n\t\t\treturn 0;\n\n\t\tinitial_bii = rbm->bii;\n\t\tret = gfs2_reservation_check_and_update(rbm, ip,\n\t\t\t\t\t\t\tminext ? *minext : 0,\n\t\t\t\t\t\t\t&maxext);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret > 0) {\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto next_iter;\n\t\t}\n\t\tif (ret == -E2BIG) {\n\t\t\trbm->bii = 0;\n\t\t\trbm->offset = 0;\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto res_covered_end_of_rgrp;\n\t\t}\n\t\treturn ret;\n\nbitmap_full:\t/* Mark bitmap as full and fall through */\n\t\tif ((state == GFS2_BLKST_FREE) && initial_offset == 0) {\n\t\t\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\t\t\tset_bit(GBF_FULL, &bi->bi_flags);\n\t\t}\n\nnext_bitmap:\t/* Find next bitmap in the rgrp */\n\t\trbm->offset = 0;\n\t\trbm->bii++;\n\t\tif (rbm->bii == rbm->rgd->rd_length)\n\t\t\trbm->bii = 0;\nres_covered_end_of_rgrp:\n\t\tif ((rbm->bii == 0) && nowrap)\n\t\t\tbreak;\n\t\tn++;\nnext_iter:\n\t\tif (n >= iters)\n\t\t\tbreak;\n\t}\n\n\tif (minext == NULL || state != GFS2_BLKST_FREE)\n\t\treturn -ENOSPC;\n\n\t/* If the extent was too small, and it's smaller than the smallest\n\t   to have failed before, remember for future reference that it's\n\t   useless to search this rgrp again for this amount or more. */\n\tif ((first_offset == 0) && (first_bii == 0) &&\n\t    (*minext < rbm->rgd->rd_extfail_pt))\n\t\trbm->rgd->rd_extfail_pt = *minext;\n\n\t/* If the maximum extent we found is big enough to fulfill the\n\t   minimum requirements, use it anyway. */\n\tif (maxext.len) {\n\t\t*rbm = maxext.rbm;\n\t\t*minext = maxext.len;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BFITNOENT ((u32)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define BFITNOENT ((u32)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap)\n{\n\tstruct buffer_head *bh;\n\tint initial_bii;\n\tu32 initial_offset;\n\tint first_bii = rbm->bii;\n\tu32 first_offset = rbm->offset;\n\tu32 offset;\n\tu8 *buffer;\n\tint n = 0;\n\tint iters = rbm->rgd->rd_length;\n\tint ret;\n\tstruct gfs2_bitmap *bi;\n\tstruct gfs2_extent maxext = { .rbm.rgd = rbm->rgd, };\n\n\t/* If we are not starting at the beginning of a bitmap, then we\n\t * need to add one to the bitmap count to ensure that we search\n\t * the starting bitmap twice.\n\t */\n\tif (rbm->offset != 0)\n\t\titers++;\n\n\twhile(1) {\n\t\tbi = rbm_bi(rbm);\n\t\tif (test_bit(GBF_FULL, &bi->bi_flags) &&\n\t\t    (state == GFS2_BLKST_FREE))\n\t\t\tgoto next_bitmap;\n\n\t\tbh = bi->bi_bh;\n\t\tbuffer = bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bh));\n\t\tif (state != GFS2_BLKST_UNLINKED && bi->bi_clone)\n\t\t\tbuffer = bi->bi_clone + bi->bi_offset;\n\t\tinitial_offset = rbm->offset;\n\t\toffset = gfs2_bitfit(buffer, bi->bi_len, rbm->offset, state);\n\t\tif (offset == BFITNOENT)\n\t\t\tgoto bitmap_full;\n\t\trbm->offset = offset;\n\t\tif (ip == NULL)\n\t\t\treturn 0;\n\n\t\tinitial_bii = rbm->bii;\n\t\tret = gfs2_reservation_check_and_update(rbm, ip,\n\t\t\t\t\t\t\tminext ? *minext : 0,\n\t\t\t\t\t\t\t&maxext);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret > 0) {\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto next_iter;\n\t\t}\n\t\tif (ret == -E2BIG) {\n\t\t\trbm->bii = 0;\n\t\t\trbm->offset = 0;\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto res_covered_end_of_rgrp;\n\t\t}\n\t\treturn ret;\n\nbitmap_full:\t/* Mark bitmap as full and fall through */\n\t\tif ((state == GFS2_BLKST_FREE) && initial_offset == 0) {\n\t\t\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\t\t\tset_bit(GBF_FULL, &bi->bi_flags);\n\t\t}\n\nnext_bitmap:\t/* Find next bitmap in the rgrp */\n\t\trbm->offset = 0;\n\t\trbm->bii++;\n\t\tif (rbm->bii == rbm->rgd->rd_length)\n\t\t\trbm->bii = 0;\nres_covered_end_of_rgrp:\n\t\tif ((rbm->bii == 0) && nowrap)\n\t\t\tbreak;\n\t\tn++;\nnext_iter:\n\t\tif (n >= iters)\n\t\t\tbreak;\n\t}\n\n\tif (minext == NULL || state != GFS2_BLKST_FREE)\n\t\treturn -ENOSPC;\n\n\t/* If the extent was too small, and it's smaller than the smallest\n\t   to have failed before, remember for future reference that it's\n\t   useless to search this rgrp again for this amount or more. */\n\tif ((first_offset == 0) && (first_bii == 0) &&\n\t    (*minext < rbm->rgd->rd_extfail_pt))\n\t\trbm->rgd->rd_extfail_pt = *minext;\n\n\t/* If the maximum extent we found is big enough to fulfill the\n\t   minimum requirements, use it anyway. */\n\tif (maxext.len) {\n\t\t*rbm = maxext.rbm;\n\t\t*minext = maxext.len;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sdp->sd_log_flush_lock"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic void try_rgrp_unlink(struct gfs2_rgrpd *rgd, u64 *last_unlinked, u64 skip)\n{\n\tu64 block;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl;\n\tstruct gfs2_inode *ip;\n\tint error;\n\tint found = 0;\n\tstruct gfs2_rbm rbm = { .rgd = rgd, .bii = 0, .offset = 0 };\n\n\twhile (1) {\n\t\tdown_write(&sdp->sd_log_flush_lock);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_UNLINKED, NULL, NULL,\n\t\t\t\t      true, NULL);\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\tif (error == -ENOSPC)\n\t\t\tbreak;\n\t\tif (WARN_ON_ONCE(error))\n\t\t\tbreak;\n\n\t\tblock = gfs2_rbm_to_block(&rbm);\n\t\tif (gfs2_rbm_from_block(&rbm, block + 1))\n\t\t\tbreak;\n\t\tif (*last_unlinked != NO_BLOCK && block <= *last_unlinked)\n\t\t\tcontinue;\n\t\tif (block == skip)\n\t\t\tcontinue;\n\t\t*last_unlinked = block;\n\n\t\terror = gfs2_glock_get(sdp, block, &gfs2_inode_glops, CREATE, &gl);\n\t\tif (error)\n\t\t\tcontinue;\n\n\t\t/* If the inode is already in cache, we can ignore it here\n\t\t * because the existing inode disposal code will deal with\n\t\t * it when all refs have gone away. Accessing gl_object like\n\t\t * this is not safe in general. Here it is ok because we do\n\t\t * not dereference the pointer, and we only need an approx\n\t\t * answer to whether it is NULL or not.\n\t\t */\n\t\tip = gl->gl_object;\n\n\t\tif (ip || queue_work(gfs2_delete_workqueue, &gl->gl_delete) == 0)\n\t\t\tgfs2_glock_put(gl);\n\t\telse\n\t\t\tfound++;\n\n\t\t/* Limit reclaim to sensible number of tasks */\n\t\tif (found > NR_CPUS)\n\t\t\treturn;\n\t}\n\n\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\treturn;\n}"
  },
  {
    "function_name": "gfs2_rbm_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1652-1752",
    "snippet": "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap)\n{\n\tstruct buffer_head *bh;\n\tint initial_bii;\n\tu32 initial_offset;\n\tint first_bii = rbm->bii;\n\tu32 first_offset = rbm->offset;\n\tu32 offset;\n\tu8 *buffer;\n\tint n = 0;\n\tint iters = rbm->rgd->rd_length;\n\tint ret;\n\tstruct gfs2_bitmap *bi;\n\tstruct gfs2_extent maxext = { .rbm.rgd = rbm->rgd, };\n\n\t/* If we are not starting at the beginning of a bitmap, then we\n\t * need to add one to the bitmap count to ensure that we search\n\t * the starting bitmap twice.\n\t */\n\tif (rbm->offset != 0)\n\t\titers++;\n\n\twhile(1) {\n\t\tbi = rbm_bi(rbm);\n\t\tif (test_bit(GBF_FULL, &bi->bi_flags) &&\n\t\t    (state == GFS2_BLKST_FREE))\n\t\t\tgoto next_bitmap;\n\n\t\tbh = bi->bi_bh;\n\t\tbuffer = bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bh));\n\t\tif (state != GFS2_BLKST_UNLINKED && bi->bi_clone)\n\t\t\tbuffer = bi->bi_clone + bi->bi_offset;\n\t\tinitial_offset = rbm->offset;\n\t\toffset = gfs2_bitfit(buffer, bi->bi_len, rbm->offset, state);\n\t\tif (offset == BFITNOENT)\n\t\t\tgoto bitmap_full;\n\t\trbm->offset = offset;\n\t\tif (ip == NULL)\n\t\t\treturn 0;\n\n\t\tinitial_bii = rbm->bii;\n\t\tret = gfs2_reservation_check_and_update(rbm, ip,\n\t\t\t\t\t\t\tminext ? *minext : 0,\n\t\t\t\t\t\t\t&maxext);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret > 0) {\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto next_iter;\n\t\t}\n\t\tif (ret == -E2BIG) {\n\t\t\trbm->bii = 0;\n\t\t\trbm->offset = 0;\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto res_covered_end_of_rgrp;\n\t\t}\n\t\treturn ret;\n\nbitmap_full:\t/* Mark bitmap as full and fall through */\n\t\tif ((state == GFS2_BLKST_FREE) && initial_offset == 0) {\n\t\t\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\t\t\tset_bit(GBF_FULL, &bi->bi_flags);\n\t\t}\n\nnext_bitmap:\t/* Find next bitmap in the rgrp */\n\t\trbm->offset = 0;\n\t\trbm->bii++;\n\t\tif (rbm->bii == rbm->rgd->rd_length)\n\t\t\trbm->bii = 0;\nres_covered_end_of_rgrp:\n\t\tif ((rbm->bii == 0) && nowrap)\n\t\t\tbreak;\n\t\tn++;\nnext_iter:\n\t\tif (n >= iters)\n\t\t\tbreak;\n\t}\n\n\tif (minext == NULL || state != GFS2_BLKST_FREE)\n\t\treturn -ENOSPC;\n\n\t/* If the extent was too small, and it's smaller than the smallest\n\t   to have failed before, remember for future reference that it's\n\t   useless to search this rgrp again for this amount or more. */\n\tif ((first_offset == 0) && (first_bii == 0) &&\n\t    (*minext < rbm->rgd->rd_extfail_pt))\n\t\trbm->rgd->rd_extfail_pt = *minext;\n\n\t/* If the maximum extent we found is big enough to fulfill the\n\t   minimum requirements, use it anyway. */\n\tif (maxext.len) {\n\t\t*rbm = maxext.rbm;\n\t\t*minext = maxext.len;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define BFITNOENT ((u32)~0)"
    ],
    "globals_used": [
      "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "GBF_FULL",
            "&bi->bi_flags"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbm_bi",
          "args": [
            "rbm"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "rbm_bi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "112-115",
          "snippet": "static inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_reservation_check_and_update",
          "args": [
            "rbm",
            "ip",
            "minext ? *minext : 0",
            "&maxext"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_reservation_check_and_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1590-1630",
          "snippet": "static int gfs2_reservation_check_and_update(struct gfs2_rbm *rbm,\n\t\t\t\t\t     const struct gfs2_inode *ip,\n\t\t\t\t\t     u32 minext,\n\t\t\t\t\t     struct gfs2_extent *maxext)\n{\n\tu64 block = gfs2_rbm_to_block(rbm);\n\tu32 extlen = 1;\n\tu64 nblock;\n\tint ret;\n\n\t/*\n\t * If we have a minimum extent length, then skip over any extent\n\t * which is less than the min extent length in size.\n\t */\n\tif (minext) {\n\t\textlen = gfs2_free_extlen(rbm, minext);\n\t\tif (extlen <= maxext->len)\n\t\t\tgoto fail;\n\t}\n\n\t/*\n\t * Check the extent which has been found against the reservations\n\t * and skip if parts of it are already reserved\n\t */\n\tnblock = gfs2_next_unreserved_block(rbm->rgd, block, extlen, ip);\n\tif (nblock == block) {\n\t\tif (!minext || extlen >= minext)\n\t\t\treturn 0;\n\n\t\tif (extlen > maxext->len) {\n\t\t\tmaxext->len = extlen;\n\t\t\tmaxext->rbm = *rbm;\n\t\t}\nfail:\n\t\tnblock = block + extlen;\n\t}\n\tret = gfs2_rbm_from_block(rbm, nblock);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_reservation_check_and_update(struct gfs2_rbm *rbm,\n\t\t\t\t\t     const struct gfs2_inode *ip,\n\t\t\t\t\t     u32 minext,\n\t\t\t\t\t     struct gfs2_extent *maxext)\n{\n\tu64 block = gfs2_rbm_to_block(rbm);\n\tu32 extlen = 1;\n\tu64 nblock;\n\tint ret;\n\n\t/*\n\t * If we have a minimum extent length, then skip over any extent\n\t * which is less than the min extent length in size.\n\t */\n\tif (minext) {\n\t\textlen = gfs2_free_extlen(rbm, minext);\n\t\tif (extlen <= maxext->len)\n\t\t\tgoto fail;\n\t}\n\n\t/*\n\t * Check the extent which has been found against the reservations\n\t * and skip if parts of it are already reserved\n\t */\n\tnblock = gfs2_next_unreserved_block(rbm->rgd, block, extlen, ip);\n\tif (nblock == block) {\n\t\tif (!minext || extlen >= minext)\n\t\t\treturn 0;\n\n\t\tif (extlen > maxext->len) {\n\t\t\tmaxext->len = extlen;\n\t\t\tmaxext->rbm = *rbm;\n\t\t}\nfail:\n\t\tnblock = block + extlen;\n\t}\n\tret = gfs2_rbm_from_block(rbm, nblock);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_bitfit",
          "args": [
            "buffer",
            "bi->bi_len",
            "rbm->offset",
            "state"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_bitfit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "218-246",
          "snippet": "static u32 gfs2_bitfit(const u8 *buf, const unsigned int len,\n\t\t       u32 goal, u8 state)\n{\n\tu32 spoint = (goal << 1) & ((8*sizeof(u64)) - 1);\n\tconst __le64 *ptr = ((__le64 *)buf) + (goal >> 5);\n\tconst __le64 *end = (__le64 *)(buf + ALIGN(len, sizeof(u64)));\n\tu64 tmp;\n\tu64 mask = 0x5555555555555555ULL;\n\tu32 bit;\n\n\t/* Mask off bits we don't care about at the start of the search */\n\tmask <<= spoint;\n\ttmp = gfs2_bit_search(ptr, mask, state);\n\tptr++;\n\twhile(tmp == 0 && ptr < end) {\n\t\ttmp = gfs2_bit_search(ptr, 0x5555555555555555ULL, state);\n\t\tptr++;\n\t}\n\t/* Mask off any bits which are more than len bytes from the start */\n\tif (ptr == end && (len & (sizeof(u64) - 1)))\n\t\ttmp &= (((u64)~0) >> (64 - 8*(len & (sizeof(u64) - 1))));\n\t/* Didn't find anything, so return */\n\tif (tmp == 0)\n\t\treturn BFITNOENT;\n\tptr--;\n\tbit = __ffs64(tmp);\n\tbit /= 2;\t/* two bits per entry in the bitmap */\n\treturn (((const unsigned char *)ptr - buf) * GFS2_NBBY) + bit;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BFITNOENT ((u32)~0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define BFITNOENT ((u32)~0)\n\nstatic u32 gfs2_bitfit(const u8 *buf, const unsigned int len,\n\t\t       u32 goal, u8 state)\n{\n\tu32 spoint = (goal << 1) & ((8*sizeof(u64)) - 1);\n\tconst __le64 *ptr = ((__le64 *)buf) + (goal >> 5);\n\tconst __le64 *end = (__le64 *)(buf + ALIGN(len, sizeof(u64)));\n\tu64 tmp;\n\tu64 mask = 0x5555555555555555ULL;\n\tu32 bit;\n\n\t/* Mask off bits we don't care about at the start of the search */\n\tmask <<= spoint;\n\ttmp = gfs2_bit_search(ptr, mask, state);\n\tptr++;\n\twhile(tmp == 0 && ptr < end) {\n\t\ttmp = gfs2_bit_search(ptr, 0x5555555555555555ULL, state);\n\t\tptr++;\n\t}\n\t/* Mask off any bits which are more than len bytes from the start */\n\tif (ptr == end && (len & (sizeof(u64) - 1)))\n\t\ttmp &= (((u64)~0) >> (64 - 8*(len & (sizeof(u64) - 1))));\n\t/* Didn't find anything, so return */\n\tif (tmp == 0)\n\t\treturn BFITNOENT;\n\tptr--;\n\tbit = __ffs64(tmp);\n\tbit /= 2;\t/* two bits per entry in the bitmap */\n\treturn (((const unsigned char *)ptr - buf) * GFS2_NBBY) + bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "GBF_FULL",
            "&bi->bi_flags"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define BFITNOENT ((u32)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap)\n{\n\tstruct buffer_head *bh;\n\tint initial_bii;\n\tu32 initial_offset;\n\tint first_bii = rbm->bii;\n\tu32 first_offset = rbm->offset;\n\tu32 offset;\n\tu8 *buffer;\n\tint n = 0;\n\tint iters = rbm->rgd->rd_length;\n\tint ret;\n\tstruct gfs2_bitmap *bi;\n\tstruct gfs2_extent maxext = { .rbm.rgd = rbm->rgd, };\n\n\t/* If we are not starting at the beginning of a bitmap, then we\n\t * need to add one to the bitmap count to ensure that we search\n\t * the starting bitmap twice.\n\t */\n\tif (rbm->offset != 0)\n\t\titers++;\n\n\twhile(1) {\n\t\tbi = rbm_bi(rbm);\n\t\tif (test_bit(GBF_FULL, &bi->bi_flags) &&\n\t\t    (state == GFS2_BLKST_FREE))\n\t\t\tgoto next_bitmap;\n\n\t\tbh = bi->bi_bh;\n\t\tbuffer = bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bh));\n\t\tif (state != GFS2_BLKST_UNLINKED && bi->bi_clone)\n\t\t\tbuffer = bi->bi_clone + bi->bi_offset;\n\t\tinitial_offset = rbm->offset;\n\t\toffset = gfs2_bitfit(buffer, bi->bi_len, rbm->offset, state);\n\t\tif (offset == BFITNOENT)\n\t\t\tgoto bitmap_full;\n\t\trbm->offset = offset;\n\t\tif (ip == NULL)\n\t\t\treturn 0;\n\n\t\tinitial_bii = rbm->bii;\n\t\tret = gfs2_reservation_check_and_update(rbm, ip,\n\t\t\t\t\t\t\tminext ? *minext : 0,\n\t\t\t\t\t\t\t&maxext);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret > 0) {\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto next_iter;\n\t\t}\n\t\tif (ret == -E2BIG) {\n\t\t\trbm->bii = 0;\n\t\t\trbm->offset = 0;\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto res_covered_end_of_rgrp;\n\t\t}\n\t\treturn ret;\n\nbitmap_full:\t/* Mark bitmap as full and fall through */\n\t\tif ((state == GFS2_BLKST_FREE) && initial_offset == 0) {\n\t\t\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\t\t\tset_bit(GBF_FULL, &bi->bi_flags);\n\t\t}\n\nnext_bitmap:\t/* Find next bitmap in the rgrp */\n\t\trbm->offset = 0;\n\t\trbm->bii++;\n\t\tif (rbm->bii == rbm->rgd->rd_length)\n\t\t\trbm->bii = 0;\nres_covered_end_of_rgrp:\n\t\tif ((rbm->bii == 0) && nowrap)\n\t\t\tbreak;\n\t\tn++;\nnext_iter:\n\t\tif (n >= iters)\n\t\t\tbreak;\n\t}\n\n\tif (minext == NULL || state != GFS2_BLKST_FREE)\n\t\treturn -ENOSPC;\n\n\t/* If the extent was too small, and it's smaller than the smallest\n\t   to have failed before, remember for future reference that it's\n\t   useless to search this rgrp again for this amount or more. */\n\tif ((first_offset == 0) && (first_bii == 0) &&\n\t    (*minext < rbm->rgd->rd_extfail_pt))\n\t\trbm->rgd->rd_extfail_pt = *minext;\n\n\t/* If the maximum extent we found is big enough to fulfill the\n\t   minimum requirements, use it anyway. */\n\tif (maxext.len) {\n\t\t*rbm = maxext.rbm;\n\t\t*minext = maxext.len;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "gfs2_reservation_check_and_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1590-1630",
    "snippet": "static int gfs2_reservation_check_and_update(struct gfs2_rbm *rbm,\n\t\t\t\t\t     const struct gfs2_inode *ip,\n\t\t\t\t\t     u32 minext,\n\t\t\t\t\t     struct gfs2_extent *maxext)\n{\n\tu64 block = gfs2_rbm_to_block(rbm);\n\tu32 extlen = 1;\n\tu64 nblock;\n\tint ret;\n\n\t/*\n\t * If we have a minimum extent length, then skip over any extent\n\t * which is less than the min extent length in size.\n\t */\n\tif (minext) {\n\t\textlen = gfs2_free_extlen(rbm, minext);\n\t\tif (extlen <= maxext->len)\n\t\t\tgoto fail;\n\t}\n\n\t/*\n\t * Check the extent which has been found against the reservations\n\t * and skip if parts of it are already reserved\n\t */\n\tnblock = gfs2_next_unreserved_block(rbm->rgd, block, extlen, ip);\n\tif (nblock == block) {\n\t\tif (!minext || extlen >= minext)\n\t\t\treturn 0;\n\n\t\tif (extlen > maxext->len) {\n\t\t\tmaxext->len = extlen;\n\t\t\tmaxext->rbm = *rbm;\n\t\t}\nfail:\n\t\tnblock = block + extlen;\n\t}\n\tret = gfs2_rbm_from_block(rbm, nblock);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rbm_from_block",
          "args": [
            "rbm",
            "nblock"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_from_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "261-282",
          "snippet": "static int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_next_unreserved_block",
          "args": [
            "rbm->rgd",
            "block",
            "extlen",
            "ip"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_next_unreserved_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1539-1572",
          "snippet": "static u64 gfs2_next_unreserved_block(struct gfs2_rgrpd *rgd, u64 block,\n\t\t\t\t      u32 length,\n\t\t\t\t      const struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs;\n\tstruct rb_node *n;\n\tint rc;\n\n\tspin_lock(&rgd->rd_rsspin);\n\tn = rgd->rd_rstree.rb_node;\n\twhile (n) {\n\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\trc = rs_cmp(block, length, rs);\n\t\tif (rc < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (rc > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (n) {\n\t\twhile ((rs_cmp(block, length, rs) == 0) && (ip->i_res != rs)) {\n\t\t\tblock = gfs2_rbm_to_block(&rs->rs_rbm) + rs->rs_free;\n\t\t\tn = n->rb_right;\n\t\t\tif (n == NULL)\n\t\t\t\tbreak;\n\t\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\t}\n\t}\n\n\tspin_unlock(&rgd->rd_rsspin);\n\treturn block;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u64 gfs2_next_unreserved_block(struct gfs2_rgrpd *rgd, u64 block,\n\t\t\t\t      u32 length,\n\t\t\t\t      const struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs;\n\tstruct rb_node *n;\n\tint rc;\n\n\tspin_lock(&rgd->rd_rsspin);\n\tn = rgd->rd_rstree.rb_node;\n\twhile (n) {\n\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\trc = rs_cmp(block, length, rs);\n\t\tif (rc < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (rc > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (n) {\n\t\twhile ((rs_cmp(block, length, rs) == 0) && (ip->i_res != rs)) {\n\t\t\tblock = gfs2_rbm_to_block(&rs->rs_rbm) + rs->rs_free;\n\t\t\tn = n->rb_right;\n\t\t\tif (n == NULL)\n\t\t\t\tbreak;\n\t\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\t}\n\t}\n\n\tspin_unlock(&rgd->rd_rsspin);\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_free_extlen",
          "args": [
            "rbm",
            "minext"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_free_extlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "353-402",
          "snippet": "static u32 gfs2_free_extlen(const struct gfs2_rbm *rrbm, u32 len)\n{\n\tstruct gfs2_rbm rbm = *rrbm;\n\tu32 n_unaligned = rbm.offset & 3;\n\tu32 size = len;\n\tu32 bytes;\n\tu32 chunk_size;\n\tu8 *ptr, *start, *end;\n\tu64 block;\n\tstruct gfs2_bitmap *bi;\n\n\tif (n_unaligned &&\n\t    gfs2_unaligned_extlen(&rbm, 4 - n_unaligned, &len))\n\t\tgoto out;\n\n\tn_unaligned = len & 3;\n\t/* Start is now byte aligned */\n\twhile (len > 3) {\n\t\tbi = rbm_bi(&rbm);\n\t\tstart = bi->bi_bh->b_data;\n\t\tif (bi->bi_clone)\n\t\t\tstart = bi->bi_clone;\n\t\tend = start + bi->bi_bh->b_size;\n\t\tstart += bi->bi_offset;\n\t\tBUG_ON(rbm.offset & 3);\n\t\tstart += (rbm.offset / GFS2_NBBY);\n\t\tbytes = min_t(u32, len / GFS2_NBBY, (end - start));\n\t\tptr = memchr_inv(start, 0, bytes);\n\t\tchunk_size = ((ptr == NULL) ? bytes : (ptr - start));\n\t\tchunk_size *= GFS2_NBBY;\n\t\tBUG_ON(len < chunk_size);\n\t\tlen -= chunk_size;\n\t\tblock = gfs2_rbm_to_block(&rbm);\n\t\tif (gfs2_rbm_from_block(&rbm, block + chunk_size)) {\n\t\t\tn_unaligned = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ptr) {\n\t\t\tn_unaligned = 3;\n\t\t\tbreak;\n\t\t}\n\t\tn_unaligned = len & 3;\n\t}\n\n\t/* Deal with any bits left over at the end */\n\tif (n_unaligned)\n\t\tgfs2_unaligned_extlen(&rbm, n_unaligned, &len);\nout:\n\treturn size - len;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u32 gfs2_free_extlen(const struct gfs2_rbm *rrbm, u32 len)\n{\n\tstruct gfs2_rbm rbm = *rrbm;\n\tu32 n_unaligned = rbm.offset & 3;\n\tu32 size = len;\n\tu32 bytes;\n\tu32 chunk_size;\n\tu8 *ptr, *start, *end;\n\tu64 block;\n\tstruct gfs2_bitmap *bi;\n\n\tif (n_unaligned &&\n\t    gfs2_unaligned_extlen(&rbm, 4 - n_unaligned, &len))\n\t\tgoto out;\n\n\tn_unaligned = len & 3;\n\t/* Start is now byte aligned */\n\twhile (len > 3) {\n\t\tbi = rbm_bi(&rbm);\n\t\tstart = bi->bi_bh->b_data;\n\t\tif (bi->bi_clone)\n\t\t\tstart = bi->bi_clone;\n\t\tend = start + bi->bi_bh->b_size;\n\t\tstart += bi->bi_offset;\n\t\tBUG_ON(rbm.offset & 3);\n\t\tstart += (rbm.offset / GFS2_NBBY);\n\t\tbytes = min_t(u32, len / GFS2_NBBY, (end - start));\n\t\tptr = memchr_inv(start, 0, bytes);\n\t\tchunk_size = ((ptr == NULL) ? bytes : (ptr - start));\n\t\tchunk_size *= GFS2_NBBY;\n\t\tBUG_ON(len < chunk_size);\n\t\tlen -= chunk_size;\n\t\tblock = gfs2_rbm_to_block(&rbm);\n\t\tif (gfs2_rbm_from_block(&rbm, block + chunk_size)) {\n\t\t\tn_unaligned = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ptr) {\n\t\t\tn_unaligned = 3;\n\t\t\tbreak;\n\t\t}\n\t\tn_unaligned = len & 3;\n\t}\n\n\t/* Deal with any bits left over at the end */\n\tif (n_unaligned)\n\t\tgfs2_unaligned_extlen(&rbm, n_unaligned, &len);\nout:\n\treturn size - len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_to_block",
          "args": [
            "rbm"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "117-121",
          "snippet": "static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_reservation_check_and_update(struct gfs2_rbm *rbm,\n\t\t\t\t\t     const struct gfs2_inode *ip,\n\t\t\t\t\t     u32 minext,\n\t\t\t\t\t     struct gfs2_extent *maxext)\n{\n\tu64 block = gfs2_rbm_to_block(rbm);\n\tu32 extlen = 1;\n\tu64 nblock;\n\tint ret;\n\n\t/*\n\t * If we have a minimum extent length, then skip over any extent\n\t * which is less than the min extent length in size.\n\t */\n\tif (minext) {\n\t\textlen = gfs2_free_extlen(rbm, minext);\n\t\tif (extlen <= maxext->len)\n\t\t\tgoto fail;\n\t}\n\n\t/*\n\t * Check the extent which has been found against the reservations\n\t * and skip if parts of it are already reserved\n\t */\n\tnblock = gfs2_next_unreserved_block(rbm->rgd, block, extlen, ip);\n\tif (nblock == block) {\n\t\tif (!minext || extlen >= minext)\n\t\t\treturn 0;\n\n\t\tif (extlen > maxext->len) {\n\t\t\tmaxext->len = extlen;\n\t\t\tmaxext->rbm = *rbm;\n\t\t}\nfail:\n\t\tnblock = block + extlen;\n\t}\n\tret = gfs2_rbm_from_block(rbm, nblock);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 1;\n}"
  },
  {
    "function_name": "gfs2_next_unreserved_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1539-1572",
    "snippet": "static u64 gfs2_next_unreserved_block(struct gfs2_rgrpd *rgd, u64 block,\n\t\t\t\t      u32 length,\n\t\t\t\t      const struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs;\n\tstruct rb_node *n;\n\tint rc;\n\n\tspin_lock(&rgd->rd_rsspin);\n\tn = rgd->rd_rstree.rb_node;\n\twhile (n) {\n\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\trc = rs_cmp(block, length, rs);\n\t\tif (rc < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (rc > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (n) {\n\t\twhile ((rs_cmp(block, length, rs) == 0) && (ip->i_res != rs)) {\n\t\t\tblock = gfs2_rbm_to_block(&rs->rs_rbm) + rs->rs_free;\n\t\t\tn = n->rb_right;\n\t\t\tif (n == NULL)\n\t\t\t\tbreak;\n\t\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\t}\n\t}\n\n\tspin_unlock(&rgd->rd_rsspin);\n\treturn block;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structgfs2_blkreserv",
            "rs_node"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_to_block",
          "args": [
            "&rs->rs_rbm"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "117-121",
          "snippet": "static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rs_cmp",
          "args": [
            "block",
            "length",
            "rs"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "rs_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "186-195",
          "snippet": "static inline int rs_cmp(u64 blk, u32 len, struct gfs2_blkreserv *rs)\n{\n\tu64 startblk = gfs2_rbm_to_block(&rs->rs_rbm);\n\n\tif (blk >= startblk + rs->rs_free)\n\t\treturn 1;\n\tif (blk + len - 1 < startblk)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int rs_cmp(u64 blk, u32 len, struct gfs2_blkreserv *rs)\n{\n\tu64 startblk = gfs2_rbm_to_block(&rs->rs_rbm);\n\n\tif (blk >= startblk + rs->rs_free)\n\t\treturn 1;\n\tif (blk + len - 1 < startblk)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structgfs2_blkreserv",
            "rs_node"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u64 gfs2_next_unreserved_block(struct gfs2_rgrpd *rgd, u64 block,\n\t\t\t\t      u32 length,\n\t\t\t\t      const struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs;\n\tstruct rb_node *n;\n\tint rc;\n\n\tspin_lock(&rgd->rd_rsspin);\n\tn = rgd->rd_rstree.rb_node;\n\twhile (n) {\n\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\trc = rs_cmp(block, length, rs);\n\t\tif (rc < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (rc > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (n) {\n\t\twhile ((rs_cmp(block, length, rs) == 0) && (ip->i_res != rs)) {\n\t\t\tblock = gfs2_rbm_to_block(&rs->rs_rbm) + rs->rs_free;\n\t\t\tn = n->rb_right;\n\t\t\tif (n == NULL)\n\t\t\t\tbreak;\n\t\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\t}\n\t}\n\n\tspin_unlock(&rgd->rd_rsspin);\n\treturn block;\n}"
  },
  {
    "function_name": "rg_mblk_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1485-1524",
    "snippet": "static void rg_mblk_search(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip,\n\t\t\t   const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_rbm rbm = { .rgd = rgd, };\n\tu64 goal;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tu32 extlen;\n\tu32 free_blocks = rgd->rd_free_clone - rgd->rd_reserved;\n\tint ret;\n\tstruct inode *inode = &ip->i_inode;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\textlen = 1;\n\telse {\n\t\textlen = max_t(u32, atomic_read(&rs->rs_sizehint), ap->target);\n\t\textlen = clamp(extlen, RGRP_RSRV_MINBLKS, free_blocks);\n\t}\n\tif ((rgd->rd_free_clone < rgd->rd_reserved) || (free_blocks < extlen))\n\t\treturn;\n\n\t/* Find bitmap block that contains bits for goal block */\n\tif (rgrp_contains_block(rgd, ip->i_goal))\n\t\tgoal = ip->i_goal;\n\telse\n\t\tgoal = rgd->rd_last_alloc + rgd->rd_data0;\n\n\tif (WARN_ON(gfs2_rbm_from_block(&rbm, goal)))\n\t\treturn;\n\n\tret = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, &extlen, ip, true, ap);\n\tif (ret == 0) {\n\t\trs->rs_rbm = rbm;\n\t\trs->rs_free = extlen;\n\t\trs->rs_inum = ip->i_no_addr;\n\t\trs_insert(ip);\n\t} else {\n\t\tif (goal == rgd->rd_last_alloc + rgd->rd_data0)\n\t\t\trgd->rd_last_alloc = 0;\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rs_insert",
          "args": [
            "ip"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "rs_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1439-1475",
          "snippet": "static void rs_insert(struct gfs2_inode *ip)\n{\n\tstruct rb_node **newn, *parent = NULL;\n\tint rc;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tstruct gfs2_rgrpd *rgd = rs->rs_rbm.rgd;\n\tu64 fsblock = gfs2_rbm_to_block(&rs->rs_rbm);\n\n\tBUG_ON(gfs2_rs_active(rs));\n\n\tspin_lock(&rgd->rd_rsspin);\n\tnewn = &rgd->rd_rstree.rb_node;\n\twhile (*newn) {\n\t\tstruct gfs2_blkreserv *cur =\n\t\t\trb_entry(*newn, struct gfs2_blkreserv, rs_node);\n\n\t\tparent = *newn;\n\t\trc = rs_cmp(fsblock, rs->rs_free, cur);\n\t\tif (rc > 0)\n\t\t\tnewn = &((*newn)->rb_right);\n\t\telse if (rc < 0)\n\t\t\tnewn = &((*newn)->rb_left);\n\t\telse {\n\t\t\tspin_unlock(&rgd->rd_rsspin);\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\trb_link_node(&rs->rs_node, parent, newn);\n\trb_insert_color(&rs->rs_node, &rgd->rd_rstree);\n\n\t/* Do our rgrp accounting for the reservation */\n\trgd->rd_reserved += rs->rs_free; /* blocks reserved */\n\tspin_unlock(&rgd->rd_rsspin);\n\ttrace_gfs2_rs(rs, TRACE_RS_INSERT);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void rs_insert(struct gfs2_inode *ip)\n{\n\tstruct rb_node **newn, *parent = NULL;\n\tint rc;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tstruct gfs2_rgrpd *rgd = rs->rs_rbm.rgd;\n\tu64 fsblock = gfs2_rbm_to_block(&rs->rs_rbm);\n\n\tBUG_ON(gfs2_rs_active(rs));\n\n\tspin_lock(&rgd->rd_rsspin);\n\tnewn = &rgd->rd_rstree.rb_node;\n\twhile (*newn) {\n\t\tstruct gfs2_blkreserv *cur =\n\t\t\trb_entry(*newn, struct gfs2_blkreserv, rs_node);\n\n\t\tparent = *newn;\n\t\trc = rs_cmp(fsblock, rs->rs_free, cur);\n\t\tif (rc > 0)\n\t\t\tnewn = &((*newn)->rb_right);\n\t\telse if (rc < 0)\n\t\t\tnewn = &((*newn)->rb_left);\n\t\telse {\n\t\t\tspin_unlock(&rgd->rd_rsspin);\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\trb_link_node(&rs->rs_node, parent, newn);\n\trb_insert_color(&rs->rs_node, &rgd->rd_rstree);\n\n\t/* Do our rgrp accounting for the reservation */\n\trgd->rd_reserved += rs->rs_free; /* blocks reserved */\n\tspin_unlock(&rgd->rd_rsspin);\n\ttrace_gfs2_rs(rs, TRACE_RS_INSERT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_find",
          "args": [
            "&rbm",
            "GFS2_BLKST_FREE",
            "&extlen",
            "ip",
            "true",
            "ap"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1652-1752",
          "snippet": "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap)\n{\n\tstruct buffer_head *bh;\n\tint initial_bii;\n\tu32 initial_offset;\n\tint first_bii = rbm->bii;\n\tu32 first_offset = rbm->offset;\n\tu32 offset;\n\tu8 *buffer;\n\tint n = 0;\n\tint iters = rbm->rgd->rd_length;\n\tint ret;\n\tstruct gfs2_bitmap *bi;\n\tstruct gfs2_extent maxext = { .rbm.rgd = rbm->rgd, };\n\n\t/* If we are not starting at the beginning of a bitmap, then we\n\t * need to add one to the bitmap count to ensure that we search\n\t * the starting bitmap twice.\n\t */\n\tif (rbm->offset != 0)\n\t\titers++;\n\n\twhile(1) {\n\t\tbi = rbm_bi(rbm);\n\t\tif (test_bit(GBF_FULL, &bi->bi_flags) &&\n\t\t    (state == GFS2_BLKST_FREE))\n\t\t\tgoto next_bitmap;\n\n\t\tbh = bi->bi_bh;\n\t\tbuffer = bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bh));\n\t\tif (state != GFS2_BLKST_UNLINKED && bi->bi_clone)\n\t\t\tbuffer = bi->bi_clone + bi->bi_offset;\n\t\tinitial_offset = rbm->offset;\n\t\toffset = gfs2_bitfit(buffer, bi->bi_len, rbm->offset, state);\n\t\tif (offset == BFITNOENT)\n\t\t\tgoto bitmap_full;\n\t\trbm->offset = offset;\n\t\tif (ip == NULL)\n\t\t\treturn 0;\n\n\t\tinitial_bii = rbm->bii;\n\t\tret = gfs2_reservation_check_and_update(rbm, ip,\n\t\t\t\t\t\t\tminext ? *minext : 0,\n\t\t\t\t\t\t\t&maxext);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret > 0) {\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto next_iter;\n\t\t}\n\t\tif (ret == -E2BIG) {\n\t\t\trbm->bii = 0;\n\t\t\trbm->offset = 0;\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto res_covered_end_of_rgrp;\n\t\t}\n\t\treturn ret;\n\nbitmap_full:\t/* Mark bitmap as full and fall through */\n\t\tif ((state == GFS2_BLKST_FREE) && initial_offset == 0) {\n\t\t\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\t\t\tset_bit(GBF_FULL, &bi->bi_flags);\n\t\t}\n\nnext_bitmap:\t/* Find next bitmap in the rgrp */\n\t\trbm->offset = 0;\n\t\trbm->bii++;\n\t\tif (rbm->bii == rbm->rgd->rd_length)\n\t\t\trbm->bii = 0;\nres_covered_end_of_rgrp:\n\t\tif ((rbm->bii == 0) && nowrap)\n\t\t\tbreak;\n\t\tn++;\nnext_iter:\n\t\tif (n >= iters)\n\t\t\tbreak;\n\t}\n\n\tif (minext == NULL || state != GFS2_BLKST_FREE)\n\t\treturn -ENOSPC;\n\n\t/* If the extent was too small, and it's smaller than the smallest\n\t   to have failed before, remember for future reference that it's\n\t   useless to search this rgrp again for this amount or more. */\n\tif ((first_offset == 0) && (first_bii == 0) &&\n\t    (*minext < rbm->rgd->rd_extfail_pt))\n\t\trbm->rgd->rd_extfail_pt = *minext;\n\n\t/* If the maximum extent we found is big enough to fulfill the\n\t   minimum requirements, use it anyway. */\n\tif (maxext.len) {\n\t\t*rbm = maxext.rbm;\n\t\t*minext = maxext.len;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BFITNOENT ((u32)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define BFITNOENT ((u32)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap)\n{\n\tstruct buffer_head *bh;\n\tint initial_bii;\n\tu32 initial_offset;\n\tint first_bii = rbm->bii;\n\tu32 first_offset = rbm->offset;\n\tu32 offset;\n\tu8 *buffer;\n\tint n = 0;\n\tint iters = rbm->rgd->rd_length;\n\tint ret;\n\tstruct gfs2_bitmap *bi;\n\tstruct gfs2_extent maxext = { .rbm.rgd = rbm->rgd, };\n\n\t/* If we are not starting at the beginning of a bitmap, then we\n\t * need to add one to the bitmap count to ensure that we search\n\t * the starting bitmap twice.\n\t */\n\tif (rbm->offset != 0)\n\t\titers++;\n\n\twhile(1) {\n\t\tbi = rbm_bi(rbm);\n\t\tif (test_bit(GBF_FULL, &bi->bi_flags) &&\n\t\t    (state == GFS2_BLKST_FREE))\n\t\t\tgoto next_bitmap;\n\n\t\tbh = bi->bi_bh;\n\t\tbuffer = bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bh));\n\t\tif (state != GFS2_BLKST_UNLINKED && bi->bi_clone)\n\t\t\tbuffer = bi->bi_clone + bi->bi_offset;\n\t\tinitial_offset = rbm->offset;\n\t\toffset = gfs2_bitfit(buffer, bi->bi_len, rbm->offset, state);\n\t\tif (offset == BFITNOENT)\n\t\t\tgoto bitmap_full;\n\t\trbm->offset = offset;\n\t\tif (ip == NULL)\n\t\t\treturn 0;\n\n\t\tinitial_bii = rbm->bii;\n\t\tret = gfs2_reservation_check_and_update(rbm, ip,\n\t\t\t\t\t\t\tminext ? *minext : 0,\n\t\t\t\t\t\t\t&maxext);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret > 0) {\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto next_iter;\n\t\t}\n\t\tif (ret == -E2BIG) {\n\t\t\trbm->bii = 0;\n\t\t\trbm->offset = 0;\n\t\t\tn += (rbm->bii - initial_bii);\n\t\t\tgoto res_covered_end_of_rgrp;\n\t\t}\n\t\treturn ret;\n\nbitmap_full:\t/* Mark bitmap as full and fall through */\n\t\tif ((state == GFS2_BLKST_FREE) && initial_offset == 0) {\n\t\t\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\t\t\tset_bit(GBF_FULL, &bi->bi_flags);\n\t\t}\n\nnext_bitmap:\t/* Find next bitmap in the rgrp */\n\t\trbm->offset = 0;\n\t\trbm->bii++;\n\t\tif (rbm->bii == rbm->rgd->rd_length)\n\t\t\trbm->bii = 0;\nres_covered_end_of_rgrp:\n\t\tif ((rbm->bii == 0) && nowrap)\n\t\t\tbreak;\n\t\tn++;\nnext_iter:\n\t\tif (n >= iters)\n\t\t\tbreak;\n\t}\n\n\tif (minext == NULL || state != GFS2_BLKST_FREE)\n\t\treturn -ENOSPC;\n\n\t/* If the extent was too small, and it's smaller than the smallest\n\t   to have failed before, remember for future reference that it's\n\t   useless to search this rgrp again for this amount or more. */\n\tif ((first_offset == 0) && (first_bii == 0) &&\n\t    (*minext < rbm->rgd->rd_extfail_pt))\n\t\trbm->rgd->rd_extfail_pt = *minext;\n\n\t/* If the maximum extent we found is big enough to fulfill the\n\t   minimum requirements, use it anyway. */\n\tif (maxext.len) {\n\t\t*rbm = maxext.rbm;\n\t\t*minext = maxext.len;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "gfs2_rbm_from_block(&rbm, goal)"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_from_block",
          "args": [
            "&rbm",
            "goal"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_from_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "261-282",
          "snippet": "static int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rgrp_contains_block",
          "args": [
            "rgd",
            "ip->i_goal"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "rgrp_contains_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "487-492",
          "snippet": "static inline int rgrp_contains_block(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tu64 first = rgd->rd_data0;\n\tu64 last = first + rgd->rd_data;\n\treturn first <= block && block < last;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int rgrp_contains_block(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tu64 first = rgd->rd_data0;\n\tu64 last = first + rgd->rd_data;\n\treturn first <= block && block < last;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "extlen",
            "RGRP_RSRV_MINBLKS",
            "free_blocks"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u32",
            "atomic_read(&rs->rs_sizehint)",
            "ap->target"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rs->rs_sizehint"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nstatic void rg_mblk_search(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip,\n\t\t\t   const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_rbm rbm = { .rgd = rgd, };\n\tu64 goal;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tu32 extlen;\n\tu32 free_blocks = rgd->rd_free_clone - rgd->rd_reserved;\n\tint ret;\n\tstruct inode *inode = &ip->i_inode;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\textlen = 1;\n\telse {\n\t\textlen = max_t(u32, atomic_read(&rs->rs_sizehint), ap->target);\n\t\textlen = clamp(extlen, RGRP_RSRV_MINBLKS, free_blocks);\n\t}\n\tif ((rgd->rd_free_clone < rgd->rd_reserved) || (free_blocks < extlen))\n\t\treturn;\n\n\t/* Find bitmap block that contains bits for goal block */\n\tif (rgrp_contains_block(rgd, ip->i_goal))\n\t\tgoal = ip->i_goal;\n\telse\n\t\tgoal = rgd->rd_last_alloc + rgd->rd_data0;\n\n\tif (WARN_ON(gfs2_rbm_from_block(&rbm, goal)))\n\t\treturn;\n\n\tret = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, &extlen, ip, true, ap);\n\tif (ret == 0) {\n\t\trs->rs_rbm = rbm;\n\t\trs->rs_free = extlen;\n\t\trs->rs_inum = ip->i_no_addr;\n\t\trs_insert(ip);\n\t} else {\n\t\tif (goal == rgd->rd_last_alloc + rgd->rd_data0)\n\t\t\trgd->rd_last_alloc = 0;\n\t}\n}"
  },
  {
    "function_name": "rs_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1439-1475",
    "snippet": "static void rs_insert(struct gfs2_inode *ip)\n{\n\tstruct rb_node **newn, *parent = NULL;\n\tint rc;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tstruct gfs2_rgrpd *rgd = rs->rs_rbm.rgd;\n\tu64 fsblock = gfs2_rbm_to_block(&rs->rs_rbm);\n\n\tBUG_ON(gfs2_rs_active(rs));\n\n\tspin_lock(&rgd->rd_rsspin);\n\tnewn = &rgd->rd_rstree.rb_node;\n\twhile (*newn) {\n\t\tstruct gfs2_blkreserv *cur =\n\t\t\trb_entry(*newn, struct gfs2_blkreserv, rs_node);\n\n\t\tparent = *newn;\n\t\trc = rs_cmp(fsblock, rs->rs_free, cur);\n\t\tif (rc > 0)\n\t\t\tnewn = &((*newn)->rb_right);\n\t\telse if (rc < 0)\n\t\t\tnewn = &((*newn)->rb_left);\n\t\telse {\n\t\t\tspin_unlock(&rgd->rd_rsspin);\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\trb_link_node(&rs->rs_node, parent, newn);\n\trb_insert_color(&rs->rs_node, &rgd->rd_rstree);\n\n\t/* Do our rgrp accounting for the reservation */\n\trgd->rd_reserved += rs->rs_free; /* blocks reserved */\n\tspin_unlock(&rgd->rd_rsspin);\n\ttrace_gfs2_rs(rs, TRACE_RS_INSERT);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_gfs2_rs",
          "args": [
            "rs",
            "TRACE_RS_INSERT"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&rs->rs_node",
            "&rgd->rd_rstree"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&rs->rs_node",
            "parent",
            "newn"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rs_cmp",
          "args": [
            "fsblock",
            "rs->rs_free",
            "cur"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "rs_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "186-195",
          "snippet": "static inline int rs_cmp(u64 blk, u32 len, struct gfs2_blkreserv *rs)\n{\n\tu64 startblk = gfs2_rbm_to_block(&rs->rs_rbm);\n\n\tif (blk >= startblk + rs->rs_free)\n\t\treturn 1;\n\tif (blk + len - 1 < startblk)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int rs_cmp(u64 blk, u32 len, struct gfs2_blkreserv *rs)\n{\n\tu64 startblk = gfs2_rbm_to_block(&rs->rs_rbm);\n\n\tif (blk >= startblk + rs->rs_free)\n\t\treturn 1;\n\tif (blk + len - 1 < startblk)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*newn",
            "structgfs2_blkreserv",
            "rs_node"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "gfs2_rs_active(rs)"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rs_active",
          "args": [
            "rs"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.h",
          "lines": "79-82",
          "snippet": "static inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_to_block",
          "args": [
            "&rs->rs_rbm"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "117-121",
          "snippet": "static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void rs_insert(struct gfs2_inode *ip)\n{\n\tstruct rb_node **newn, *parent = NULL;\n\tint rc;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tstruct gfs2_rgrpd *rgd = rs->rs_rbm.rgd;\n\tu64 fsblock = gfs2_rbm_to_block(&rs->rs_rbm);\n\n\tBUG_ON(gfs2_rs_active(rs));\n\n\tspin_lock(&rgd->rd_rsspin);\n\tnewn = &rgd->rd_rstree.rb_node;\n\twhile (*newn) {\n\t\tstruct gfs2_blkreserv *cur =\n\t\t\trb_entry(*newn, struct gfs2_blkreserv, rs_node);\n\n\t\tparent = *newn;\n\t\trc = rs_cmp(fsblock, rs->rs_free, cur);\n\t\tif (rc > 0)\n\t\t\tnewn = &((*newn)->rb_right);\n\t\telse if (rc < 0)\n\t\t\tnewn = &((*newn)->rb_left);\n\t\telse {\n\t\t\tspin_unlock(&rgd->rd_rsspin);\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\trb_link_node(&rs->rs_node, parent, newn);\n\trb_insert_color(&rs->rs_node, &rgd->rd_rstree);\n\n\t/* Do our rgrp accounting for the reservation */\n\trgd->rd_reserved += rs->rs_free; /* blocks reserved */\n\tspin_unlock(&rgd->rd_rsspin);\n\ttrace_gfs2_rs(rs, TRACE_RS_INSERT);\n}"
  },
  {
    "function_name": "gfs2_fitrim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1342-1432",
    "snippet": "int gfs2_fitrim(struct file *filp, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct request_queue *q = bdev_get_queue(sdp->sd_vfs->s_bdev);\n\tstruct buffer_head *bh;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd *rgd_end;\n\tstruct gfs2_holder gh;\n\tstruct fstrim_range r;\n\tint ret = 0;\n\tu64 amt;\n\tu64 trimmed = 0;\n\tu64 start, end, minlen;\n\tunsigned int x;\n\tunsigned bs_shift = sdp->sd_sb.sb_bsize_shift;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&r, argp, sizeof(r)))\n\t\treturn -EFAULT;\n\n\tret = gfs2_rindex_update(sdp);\n\tif (ret)\n\t\treturn ret;\n\n\tstart = r.start >> bs_shift;\n\tend = start + (r.len >> bs_shift);\n\tminlen = max_t(u64, r.minlen,\n\t\t       q->limits.discard_granularity) >> bs_shift;\n\n\tif (end <= start || minlen > sdp->sd_max_rg_data)\n\t\treturn -EINVAL;\n\n\trgd = gfs2_blk2rgrpd(sdp, start, 0);\n\trgd_end = gfs2_blk2rgrpd(sdp, end, 0);\n\n\tif ((gfs2_rgrpd_get_first(sdp) == gfs2_rgrpd_get_next(rgd_end))\n\t    && (start > rgd_end->rd_data0 + rgd_end->rd_data))\n\t\treturn -EINVAL; /* start is beyond the end of the fs */\n\n\twhile (1) {\n\n\t\tret = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(rgd->rd_flags & GFS2_RGF_TRIMMED)) {\n\t\t\t/* Trim each bitmap in the rgrp */\n\t\t\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\t\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\t\t\tret = gfs2_rgrp_send_discards(sdp,\n\t\t\t\t\t\trgd->rd_data0, NULL, bi, minlen,\n\t\t\t\t\t\t&amt);\n\t\t\t\tif (ret) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&gh);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\ttrimmed += amt;\n\t\t\t}\n\n\t\t\t/* Mark rgrp as having been trimmed */\n\t\t\tret = gfs2_trans_begin(sdp, RES_RG_HDR, 0);\n\t\t\tif (ret == 0) {\n\t\t\t\tbh = rgd->rd_bits[0].bi_bh;\n\t\t\t\trgd->rd_flags |= GFS2_RGF_TRIMMED;\n\t\t\t\tgfs2_trans_add_meta(rgd->rd_gl, bh);\n\t\t\t\tgfs2_rgrp_out(rgd, bh->b_data);\n\t\t\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, bh->b_data);\n\t\t\t\tgfs2_trans_end(sdp);\n\t\t\t}\n\t\t}\n\t\tgfs2_glock_dq_uninit(&gh);\n\n\t\tif (rgd == rgd_end)\n\t\t\tbreak;\n\n\t\trgd = gfs2_rgrpd_get_next(rgd);\n\t}\n\nout:\n\tr.len = trimmed << bs_shift;\n\tif (copy_to_user(argp, &r, sizeof(r)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&r",
            "sizeof(r)"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rgrpd_get_next",
          "args": [
            "rgd"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrpd_get_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "561-578",
          "snippet": "struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tconst struct rb_node *n;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_next(&rgd->rd_node);\n\tif (n == NULL)\n\t\tn = rb_first(&sdp->sd_rindex_tree);\n\n\tif (unlikely(&rgd->rd_node == n)) {\n\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\treturn NULL;\n\t}\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\treturn rgd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tconst struct rb_node *n;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_next(&rgd->rd_node);\n\tif (n == NULL)\n\t\tn = rb_first(&sdp->sd_rindex_tree);\n\n\tif (unlikely(&rgd->rd_node == n)) {\n\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\treturn NULL;\n\t}\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\treturn rgd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&gh"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_ondisk2lvb",
          "args": [
            "rgd->rd_rgl",
            "bh->b_data"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_ondisk2lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1092-1102",
          "snippet": "static void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_out",
          "args": [
            "rgd",
            "bh->b_data"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1068-1078",
          "snippet": "static void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrp *str = buf;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tstr->__pad = cpu_to_be32(0);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrp *str = buf;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tstr->__pad = cpu_to_be32(0);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "rgd->rd_gl",
            "bh"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "RES_RG_HDR",
            "0"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_send_discards",
          "args": [
            "sdp",
            "rgd->rd_data0",
            "NULL",
            "bi",
            "minlen",
            "&amt"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_send_discards",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1267-1332",
          "snippet": "int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tu64 blk;\n\tsector_t start = 0;\n\tsector_t nr_blks = 0;\n\tint rv;\n\tunsigned int x;\n\tu32 trimmed = 0;\n\tu8 diff;\n\n\tfor (x = 0; x < bi->bi_len; x++) {\n\t\tconst u8 *clone = bi->bi_clone ? bi->bi_clone : bi->bi_bh->b_data;\n\t\tclone += bi->bi_offset;\n\t\tclone += x;\n\t\tif (bh) {\n\t\t\tconst u8 *orig = bh->b_data + bi->bi_offset + x;\n\t\t\tdiff = ~(*orig | (*orig >> 1)) & (*clone | (*clone >> 1));\n\t\t} else {\n\t\t\tdiff = ~(*clone | (*clone >> 1));\n\t\t}\n\t\tdiff &= 0x55;\n\t\tif (diff == 0)\n\t\t\tcontinue;\n\t\tblk = offset + ((bi->bi_start + x) * GFS2_NBBY);\n\t\twhile(diff) {\n\t\t\tif (diff & 1) {\n\t\t\t\tif (nr_blks == 0)\n\t\t\t\t\tgoto start_new_extent;\n\t\t\t\tif ((start + nr_blks) != blk) {\n\t\t\t\t\tif (nr_blks >= minlen) {\n\t\t\t\t\t\trv = sb_issue_discard(sb,\n\t\t\t\t\t\t\tstart, nr_blks,\n\t\t\t\t\t\t\tGFP_NOFS, 0);\n\t\t\t\t\t\tif (rv)\n\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\ttrimmed += nr_blks;\n\t\t\t\t\t}\n\t\t\t\t\tnr_blks = 0;\nstart_new_extent:\n\t\t\t\t\tstart = blk;\n\t\t\t\t}\n\t\t\t\tnr_blks++;\n\t\t\t}\n\t\t\tdiff >>= 2;\n\t\t\tblk++;\n\t\t}\n\t}\n\tif (nr_blks >= minlen) {\n\t\trv = sb_issue_discard(sb, start, nr_blks, GFP_NOFS, 0);\n\t\tif (rv)\n\t\t\tgoto fail;\n\t\ttrimmed += nr_blks;\n\t}\n\tif (ptrimmed)\n\t\t*ptrimmed = trimmed;\n\treturn 0;\n\nfail:\n\tif (sdp->sd_args.ar_discard)\n\t\tfs_warn(sdp, \"error %d on discard request, turning discards off for this filesystem\", rv);\n\tsdp->sd_args.ar_discard = 0;\n\treturn -EIO;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tu64 blk;\n\tsector_t start = 0;\n\tsector_t nr_blks = 0;\n\tint rv;\n\tunsigned int x;\n\tu32 trimmed = 0;\n\tu8 diff;\n\n\tfor (x = 0; x < bi->bi_len; x++) {\n\t\tconst u8 *clone = bi->bi_clone ? bi->bi_clone : bi->bi_bh->b_data;\n\t\tclone += bi->bi_offset;\n\t\tclone += x;\n\t\tif (bh) {\n\t\t\tconst u8 *orig = bh->b_data + bi->bi_offset + x;\n\t\t\tdiff = ~(*orig | (*orig >> 1)) & (*clone | (*clone >> 1));\n\t\t} else {\n\t\t\tdiff = ~(*clone | (*clone >> 1));\n\t\t}\n\t\tdiff &= 0x55;\n\t\tif (diff == 0)\n\t\t\tcontinue;\n\t\tblk = offset + ((bi->bi_start + x) * GFS2_NBBY);\n\t\twhile(diff) {\n\t\t\tif (diff & 1) {\n\t\t\t\tif (nr_blks == 0)\n\t\t\t\t\tgoto start_new_extent;\n\t\t\t\tif ((start + nr_blks) != blk) {\n\t\t\t\t\tif (nr_blks >= minlen) {\n\t\t\t\t\t\trv = sb_issue_discard(sb,\n\t\t\t\t\t\t\tstart, nr_blks,\n\t\t\t\t\t\t\tGFP_NOFS, 0);\n\t\t\t\t\t\tif (rv)\n\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\ttrimmed += nr_blks;\n\t\t\t\t\t}\n\t\t\t\t\tnr_blks = 0;\nstart_new_extent:\n\t\t\t\t\tstart = blk;\n\t\t\t\t}\n\t\t\t\tnr_blks++;\n\t\t\t}\n\t\t\tdiff >>= 2;\n\t\t\tblk++;\n\t\t}\n\t}\n\tif (nr_blks >= minlen) {\n\t\trv = sb_issue_discard(sb, start, nr_blks, GFP_NOFS, 0);\n\t\tif (rv)\n\t\t\tgoto fail;\n\t\ttrimmed += nr_blks;\n\t}\n\tif (ptrimmed)\n\t\t*ptrimmed = trimmed;\n\treturn 0;\n\nfail:\n\tif (sdp->sd_args.ar_discard)\n\t\tfs_warn(sdp, \"error %d on discard request, turning discards off for this filesystem\", rv);\n\tsdp->sd_args.ar_discard = 0;\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "rgd->rd_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&gh"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrpd_get_first",
          "args": [
            "sdp"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrpd_get_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "541-552",
          "snippet": "struct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp)\n{\n\tconst struct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_first(&sdp->sd_rindex_tree);\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn rgd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp)\n{\n\tconst struct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_first(&sdp->sd_rindex_tree);\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn rgd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_blk2rgrpd",
          "args": [
            "sdp",
            "end",
            "0"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_blk2rgrpd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "503-532",
          "snippet": "struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "r.minlen",
            "q->limits.discard_granularity"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&r",
            "argp",
            "sizeof(r)"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "sdp->sd_vfs->s_bdev"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_fitrim(struct file *filp, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct request_queue *q = bdev_get_queue(sdp->sd_vfs->s_bdev);\n\tstruct buffer_head *bh;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd *rgd_end;\n\tstruct gfs2_holder gh;\n\tstruct fstrim_range r;\n\tint ret = 0;\n\tu64 amt;\n\tu64 trimmed = 0;\n\tu64 start, end, minlen;\n\tunsigned int x;\n\tunsigned bs_shift = sdp->sd_sb.sb_bsize_shift;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!blk_queue_discard(q))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&r, argp, sizeof(r)))\n\t\treturn -EFAULT;\n\n\tret = gfs2_rindex_update(sdp);\n\tif (ret)\n\t\treturn ret;\n\n\tstart = r.start >> bs_shift;\n\tend = start + (r.len >> bs_shift);\n\tminlen = max_t(u64, r.minlen,\n\t\t       q->limits.discard_granularity) >> bs_shift;\n\n\tif (end <= start || minlen > sdp->sd_max_rg_data)\n\t\treturn -EINVAL;\n\n\trgd = gfs2_blk2rgrpd(sdp, start, 0);\n\trgd_end = gfs2_blk2rgrpd(sdp, end, 0);\n\n\tif ((gfs2_rgrpd_get_first(sdp) == gfs2_rgrpd_get_next(rgd_end))\n\t    && (start > rgd_end->rd_data0 + rgd_end->rd_data))\n\t\treturn -EINVAL; /* start is beyond the end of the fs */\n\n\twhile (1) {\n\n\t\tret = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(rgd->rd_flags & GFS2_RGF_TRIMMED)) {\n\t\t\t/* Trim each bitmap in the rgrp */\n\t\t\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\t\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\t\t\tret = gfs2_rgrp_send_discards(sdp,\n\t\t\t\t\t\trgd->rd_data0, NULL, bi, minlen,\n\t\t\t\t\t\t&amt);\n\t\t\t\tif (ret) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&gh);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\ttrimmed += amt;\n\t\t\t}\n\n\t\t\t/* Mark rgrp as having been trimmed */\n\t\t\tret = gfs2_trans_begin(sdp, RES_RG_HDR, 0);\n\t\t\tif (ret == 0) {\n\t\t\t\tbh = rgd->rd_bits[0].bi_bh;\n\t\t\t\trgd->rd_flags |= GFS2_RGF_TRIMMED;\n\t\t\t\tgfs2_trans_add_meta(rgd->rd_gl, bh);\n\t\t\t\tgfs2_rgrp_out(rgd, bh->b_data);\n\t\t\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl, bh->b_data);\n\t\t\t\tgfs2_trans_end(sdp);\n\t\t\t}\n\t\t}\n\t\tgfs2_glock_dq_uninit(&gh);\n\n\t\tif (rgd == rgd_end)\n\t\t\tbreak;\n\n\t\trgd = gfs2_rgrpd_get_next(rgd);\n\t}\n\nout:\n\tr.len = trimmed << bs_shift;\n\tif (copy_to_user(argp, &r, sizeof(r)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_rgrp_send_discards",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1267-1332",
    "snippet": "int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tu64 blk;\n\tsector_t start = 0;\n\tsector_t nr_blks = 0;\n\tint rv;\n\tunsigned int x;\n\tu32 trimmed = 0;\n\tu8 diff;\n\n\tfor (x = 0; x < bi->bi_len; x++) {\n\t\tconst u8 *clone = bi->bi_clone ? bi->bi_clone : bi->bi_bh->b_data;\n\t\tclone += bi->bi_offset;\n\t\tclone += x;\n\t\tif (bh) {\n\t\t\tconst u8 *orig = bh->b_data + bi->bi_offset + x;\n\t\t\tdiff = ~(*orig | (*orig >> 1)) & (*clone | (*clone >> 1));\n\t\t} else {\n\t\t\tdiff = ~(*clone | (*clone >> 1));\n\t\t}\n\t\tdiff &= 0x55;\n\t\tif (diff == 0)\n\t\t\tcontinue;\n\t\tblk = offset + ((bi->bi_start + x) * GFS2_NBBY);\n\t\twhile(diff) {\n\t\t\tif (diff & 1) {\n\t\t\t\tif (nr_blks == 0)\n\t\t\t\t\tgoto start_new_extent;\n\t\t\t\tif ((start + nr_blks) != blk) {\n\t\t\t\t\tif (nr_blks >= minlen) {\n\t\t\t\t\t\trv = sb_issue_discard(sb,\n\t\t\t\t\t\t\tstart, nr_blks,\n\t\t\t\t\t\t\tGFP_NOFS, 0);\n\t\t\t\t\t\tif (rv)\n\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\ttrimmed += nr_blks;\n\t\t\t\t\t}\n\t\t\t\t\tnr_blks = 0;\nstart_new_extent:\n\t\t\t\t\tstart = blk;\n\t\t\t\t}\n\t\t\t\tnr_blks++;\n\t\t\t}\n\t\t\tdiff >>= 2;\n\t\t\tblk++;\n\t\t}\n\t}\n\tif (nr_blks >= minlen) {\n\t\trv = sb_issue_discard(sb, start, nr_blks, GFP_NOFS, 0);\n\t\tif (rv)\n\t\t\tgoto fail;\n\t\ttrimmed += nr_blks;\n\t}\n\tif (ptrimmed)\n\t\t*ptrimmed = trimmed;\n\treturn 0;\n\nfail:\n\tif (sdp->sd_args.ar_discard)\n\t\tfs_warn(sdp, \"error %d on discard request, turning discards off for this filesystem\", rv);\n\tsdp->sd_args.ar_discard = 0;\n\treturn -EIO;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_warn",
          "args": [
            "sdp",
            "\"error %d on discard request, turning discards off for this filesystem\"",
            "rv"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "befs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "40-51",
          "snippet": "void\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_issue_discard",
          "args": [
            "sb",
            "start",
            "nr_blks",
            "GFP_NOFS",
            "0"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_issue_discard",
          "args": [
            "sb",
            "start",
            "nr_blks",
            "GFP_NOFS",
            "0"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed)\n{\n\tstruct super_block *sb = sdp->sd_vfs;\n\tu64 blk;\n\tsector_t start = 0;\n\tsector_t nr_blks = 0;\n\tint rv;\n\tunsigned int x;\n\tu32 trimmed = 0;\n\tu8 diff;\n\n\tfor (x = 0; x < bi->bi_len; x++) {\n\t\tconst u8 *clone = bi->bi_clone ? bi->bi_clone : bi->bi_bh->b_data;\n\t\tclone += bi->bi_offset;\n\t\tclone += x;\n\t\tif (bh) {\n\t\t\tconst u8 *orig = bh->b_data + bi->bi_offset + x;\n\t\t\tdiff = ~(*orig | (*orig >> 1)) & (*clone | (*clone >> 1));\n\t\t} else {\n\t\t\tdiff = ~(*clone | (*clone >> 1));\n\t\t}\n\t\tdiff &= 0x55;\n\t\tif (diff == 0)\n\t\t\tcontinue;\n\t\tblk = offset + ((bi->bi_start + x) * GFS2_NBBY);\n\t\twhile(diff) {\n\t\t\tif (diff & 1) {\n\t\t\t\tif (nr_blks == 0)\n\t\t\t\t\tgoto start_new_extent;\n\t\t\t\tif ((start + nr_blks) != blk) {\n\t\t\t\t\tif (nr_blks >= minlen) {\n\t\t\t\t\t\trv = sb_issue_discard(sb,\n\t\t\t\t\t\t\tstart, nr_blks,\n\t\t\t\t\t\t\tGFP_NOFS, 0);\n\t\t\t\t\t\tif (rv)\n\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\ttrimmed += nr_blks;\n\t\t\t\t\t}\n\t\t\t\t\tnr_blks = 0;\nstart_new_extent:\n\t\t\t\t\tstart = blk;\n\t\t\t\t}\n\t\t\t\tnr_blks++;\n\t\t\t}\n\t\t\tdiff >>= 2;\n\t\t\tblk++;\n\t\t}\n\t}\n\tif (nr_blks >= minlen) {\n\t\trv = sb_issue_discard(sb, start, nr_blks, GFP_NOFS, 0);\n\t\tif (rv)\n\t\t\tgoto fail;\n\t\ttrimmed += nr_blks;\n\t}\n\tif (ptrimmed)\n\t\t*ptrimmed = trimmed;\n\treturn 0;\n\nfail:\n\tif (sdp->sd_args.ar_discard)\n\t\tfs_warn(sdp, \"error %d on discard request, turning discards off for this filesystem\", rv);\n\tsdp->sd_args.ar_discard = 0;\n\treturn -EIO;\n}"
  },
  {
    "function_name": "gfs2_rgrp_go_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1252-1265",
    "snippet": "void gfs2_rgrp_go_unlock(struct gfs2_holder *gh)\n{\n\tstruct gfs2_rgrpd *rgd = gh->gh_gl->gl_object;\n\tint x, length = rgd->rd_length;\n\n\tfor (x = 0; x < length; x++) {\n\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\tif (bi->bi_bh) {\n\t\t\tbrelse(bi->bi_bh);\n\t\t\tbi->bi_bh = NULL;\n\t\t}\n\t}\n\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bi->bi_bh"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rgrp_go_unlock(struct gfs2_holder *gh)\n{\n\tstruct gfs2_rgrpd *rgd = gh->gh_gl->gl_object;\n\tint x, length = rgd->rd_length;\n\n\tfor (x = 0; x < length; x++) {\n\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\tif (bi->bi_bh) {\n\t\t\tbrelse(bi->bi_bh);\n\t\t\tbi->bi_bh = NULL;\n\t\t}\n\t}\n\n}"
  },
  {
    "function_name": "gfs2_rgrp_go_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1236-1244",
    "snippet": "int gfs2_rgrp_go_lock(struct gfs2_holder *gh)\n{\n\tstruct gfs2_rgrpd *rgd = gh->gh_gl->gl_object;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\n\tif (gh->gh_flags & GL_SKIP && sdp->sd_args.ar_rgrplvb)\n\t\treturn 0;\n\treturn gfs2_rgrp_bh_get(rgd);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rgrp_bh_get",
          "args": [
            "rgd"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_bh_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1146-1211",
          "snippet": "static int gfs2_rgrp_bh_get(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\tunsigned int length = rgd->rd_length;\n\tstruct gfs2_bitmap *bi;\n\tunsigned int x, y;\n\tint error;\n\n\tif (rgd->rd_bits[0].bi_bh != NULL)\n\t\treturn 0;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\t\terror = gfs2_meta_read(gl, rgd->rd_addr + x, 0, &bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tfor (y = length; y--;) {\n\t\tbi = rgd->rd_bits + y;\n\t\terror = gfs2_meta_wait(sdp, bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tif (gfs2_metatype_check(sdp, bi->bi_bh, y ? GFS2_METATYPE_RB :\n\t\t\t\t\t      GFS2_METATYPE_RG)) {\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!(rgd->rd_flags & GFS2_RDF_UPTODATE)) {\n\t\tfor (x = 0; x < length; x++)\n\t\t\tclear_bit(GBF_FULL, &rgd->rd_bits[x].bi_flags);\n\t\tgfs2_rgrp_in(rgd, (rgd->rd_bits[0].bi_bh)->b_data);\n\t\trgd->rd_flags |= (GFS2_RDF_UPTODATE | GFS2_RDF_CHECK);\n\t\trgd->rd_free_clone = rgd->rd_free;\n\t\t/* max out the rgrp allocation failure point */\n\t\trgd->rd_extfail_pt = rgd->rd_free;\n\t}\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic) {\n\t\trgd->rd_rgl->rl_unlinked = cpu_to_be32(count_unlinked(rgd));\n\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl,\n\t\t\t\t     rgd->rd_bits[0].bi_bh->b_data);\n\t}\n\telse if (sdp->sd_args.ar_rgrplvb) {\n\t\tif (!gfs2_rgrp_lvb_valid(rgd)){\n\t\t\tgfs2_consist_rgrpd(rgd);\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\t}\n\treturn 0;\n\nfail:\n\twhile (x--) {\n\t\tbi = rgd->rd_bits + x;\n\t\tbrelse(bi->bi_bh);\n\t\tbi->bi_bh = NULL;\n\t\tgfs2_assert_warn(sdp, !bi->bi_clone);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rgrp_bh_get(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\tunsigned int length = rgd->rd_length;\n\tstruct gfs2_bitmap *bi;\n\tunsigned int x, y;\n\tint error;\n\n\tif (rgd->rd_bits[0].bi_bh != NULL)\n\t\treturn 0;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\t\terror = gfs2_meta_read(gl, rgd->rd_addr + x, 0, &bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tfor (y = length; y--;) {\n\t\tbi = rgd->rd_bits + y;\n\t\terror = gfs2_meta_wait(sdp, bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tif (gfs2_metatype_check(sdp, bi->bi_bh, y ? GFS2_METATYPE_RB :\n\t\t\t\t\t      GFS2_METATYPE_RG)) {\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!(rgd->rd_flags & GFS2_RDF_UPTODATE)) {\n\t\tfor (x = 0; x < length; x++)\n\t\t\tclear_bit(GBF_FULL, &rgd->rd_bits[x].bi_flags);\n\t\tgfs2_rgrp_in(rgd, (rgd->rd_bits[0].bi_bh)->b_data);\n\t\trgd->rd_flags |= (GFS2_RDF_UPTODATE | GFS2_RDF_CHECK);\n\t\trgd->rd_free_clone = rgd->rd_free;\n\t\t/* max out the rgrp allocation failure point */\n\t\trgd->rd_extfail_pt = rgd->rd_free;\n\t}\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic) {\n\t\trgd->rd_rgl->rl_unlinked = cpu_to_be32(count_unlinked(rgd));\n\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl,\n\t\t\t\t     rgd->rd_bits[0].bi_bh->b_data);\n\t}\n\telse if (sdp->sd_args.ar_rgrplvb) {\n\t\tif (!gfs2_rgrp_lvb_valid(rgd)){\n\t\t\tgfs2_consist_rgrpd(rgd);\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\t}\n\treturn 0;\n\nfail:\n\twhile (x--) {\n\t\tbi = rgd->rd_bits + x;\n\t\tbrelse(bi->bi_bh);\n\t\tbi->bi_bh = NULL;\n\t\tgfs2_assert_warn(sdp, !bi->bi_clone);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rgrp_go_lock(struct gfs2_holder *gh)\n{\n\tstruct gfs2_rgrpd *rgd = gh->gh_gl->gl_object;\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\n\tif (gh->gh_flags & GL_SKIP && sdp->sd_args.ar_rgrplvb)\n\t\treturn 0;\n\treturn gfs2_rgrp_bh_get(rgd);\n}"
  },
  {
    "function_name": "update_rgrp_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1213-1234",
    "snippet": "static int update_rgrp_lvb(struct gfs2_rgrpd *rgd)\n{\n\tu32 rl_flags;\n\n\tif (rgd->rd_flags & GFS2_RDF_UPTODATE)\n\t\treturn 0;\n\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic)\n\t\treturn gfs2_rgrp_bh_get(rgd);\n\n\trl_flags = be32_to_cpu(rgd->rd_rgl->rl_flags);\n\trl_flags &= ~GFS2_RDF_MASK;\n\trgd->rd_flags &= GFS2_RDF_MASK;\n\trgd->rd_flags |= (rl_flags | GFS2_RDF_UPTODATE | GFS2_RDF_CHECK);\n\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\trgd->rd_free = be32_to_cpu(rgd->rd_rgl->rl_free);\n\trgd->rd_free_clone = rgd->rd_free;\n\trgd->rd_dinodes = be32_to_cpu(rgd->rd_rgl->rl_dinodes);\n\trgd->rd_igeneration = be64_to_cpu(rgd->rd_rgl->rl_igeneration);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "rgd->rd_rgl->rl_igeneration"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rgd->rd_rgl->rl_dinodes"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rgd->rd_rgl->rl_free"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rgd->rd_rgl->rl_flags"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_bh_get",
          "args": [
            "rgd"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_bh_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1146-1211",
          "snippet": "static int gfs2_rgrp_bh_get(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\tunsigned int length = rgd->rd_length;\n\tstruct gfs2_bitmap *bi;\n\tunsigned int x, y;\n\tint error;\n\n\tif (rgd->rd_bits[0].bi_bh != NULL)\n\t\treturn 0;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\t\terror = gfs2_meta_read(gl, rgd->rd_addr + x, 0, &bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tfor (y = length; y--;) {\n\t\tbi = rgd->rd_bits + y;\n\t\terror = gfs2_meta_wait(sdp, bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tif (gfs2_metatype_check(sdp, bi->bi_bh, y ? GFS2_METATYPE_RB :\n\t\t\t\t\t      GFS2_METATYPE_RG)) {\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!(rgd->rd_flags & GFS2_RDF_UPTODATE)) {\n\t\tfor (x = 0; x < length; x++)\n\t\t\tclear_bit(GBF_FULL, &rgd->rd_bits[x].bi_flags);\n\t\tgfs2_rgrp_in(rgd, (rgd->rd_bits[0].bi_bh)->b_data);\n\t\trgd->rd_flags |= (GFS2_RDF_UPTODATE | GFS2_RDF_CHECK);\n\t\trgd->rd_free_clone = rgd->rd_free;\n\t\t/* max out the rgrp allocation failure point */\n\t\trgd->rd_extfail_pt = rgd->rd_free;\n\t}\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic) {\n\t\trgd->rd_rgl->rl_unlinked = cpu_to_be32(count_unlinked(rgd));\n\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl,\n\t\t\t\t     rgd->rd_bits[0].bi_bh->b_data);\n\t}\n\telse if (sdp->sd_args.ar_rgrplvb) {\n\t\tif (!gfs2_rgrp_lvb_valid(rgd)){\n\t\t\tgfs2_consist_rgrpd(rgd);\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\t}\n\treturn 0;\n\nfail:\n\twhile (x--) {\n\t\tbi = rgd->rd_bits + x;\n\t\tbrelse(bi->bi_bh);\n\t\tbi->bi_bh = NULL;\n\t\tgfs2_assert_warn(sdp, !bi->bi_clone);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rgrp_bh_get(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\tunsigned int length = rgd->rd_length;\n\tstruct gfs2_bitmap *bi;\n\tunsigned int x, y;\n\tint error;\n\n\tif (rgd->rd_bits[0].bi_bh != NULL)\n\t\treturn 0;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\t\terror = gfs2_meta_read(gl, rgd->rd_addr + x, 0, &bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tfor (y = length; y--;) {\n\t\tbi = rgd->rd_bits + y;\n\t\terror = gfs2_meta_wait(sdp, bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tif (gfs2_metatype_check(sdp, bi->bi_bh, y ? GFS2_METATYPE_RB :\n\t\t\t\t\t      GFS2_METATYPE_RG)) {\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!(rgd->rd_flags & GFS2_RDF_UPTODATE)) {\n\t\tfor (x = 0; x < length; x++)\n\t\t\tclear_bit(GBF_FULL, &rgd->rd_bits[x].bi_flags);\n\t\tgfs2_rgrp_in(rgd, (rgd->rd_bits[0].bi_bh)->b_data);\n\t\trgd->rd_flags |= (GFS2_RDF_UPTODATE | GFS2_RDF_CHECK);\n\t\trgd->rd_free_clone = rgd->rd_free;\n\t\t/* max out the rgrp allocation failure point */\n\t\trgd->rd_extfail_pt = rgd->rd_free;\n\t}\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic) {\n\t\trgd->rd_rgl->rl_unlinked = cpu_to_be32(count_unlinked(rgd));\n\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl,\n\t\t\t\t     rgd->rd_bits[0].bi_bh->b_data);\n\t}\n\telse if (sdp->sd_args.ar_rgrplvb) {\n\t\tif (!gfs2_rgrp_lvb_valid(rgd)){\n\t\t\tgfs2_consist_rgrpd(rgd);\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\t}\n\treturn 0;\n\nfail:\n\twhile (x--) {\n\t\tbi = rgd->rd_bits + x;\n\t\tbrelse(bi->bi_bh);\n\t\tbi->bi_bh = NULL;\n\t\tgfs2_assert_warn(sdp, !bi->bi_clone);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_MAGIC"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int update_rgrp_lvb(struct gfs2_rgrpd *rgd)\n{\n\tu32 rl_flags;\n\n\tif (rgd->rd_flags & GFS2_RDF_UPTODATE)\n\t\treturn 0;\n\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic)\n\t\treturn gfs2_rgrp_bh_get(rgd);\n\n\trl_flags = be32_to_cpu(rgd->rd_rgl->rl_flags);\n\trl_flags &= ~GFS2_RDF_MASK;\n\trgd->rd_flags &= GFS2_RDF_MASK;\n\trgd->rd_flags |= (rl_flags | GFS2_RDF_UPTODATE | GFS2_RDF_CHECK);\n\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\trgd->rd_free = be32_to_cpu(rgd->rd_rgl->rl_free);\n\trgd->rd_free_clone = rgd->rd_free;\n\trgd->rd_dinodes = be32_to_cpu(rgd->rd_rgl->rl_dinodes);\n\trgd->rd_igeneration = be64_to_cpu(rgd->rd_rgl->rl_igeneration);\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_rgrp_bh_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1146-1211",
    "snippet": "static int gfs2_rgrp_bh_get(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\tunsigned int length = rgd->rd_length;\n\tstruct gfs2_bitmap *bi;\n\tunsigned int x, y;\n\tint error;\n\n\tif (rgd->rd_bits[0].bi_bh != NULL)\n\t\treturn 0;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\t\terror = gfs2_meta_read(gl, rgd->rd_addr + x, 0, &bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tfor (y = length; y--;) {\n\t\tbi = rgd->rd_bits + y;\n\t\terror = gfs2_meta_wait(sdp, bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tif (gfs2_metatype_check(sdp, bi->bi_bh, y ? GFS2_METATYPE_RB :\n\t\t\t\t\t      GFS2_METATYPE_RG)) {\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!(rgd->rd_flags & GFS2_RDF_UPTODATE)) {\n\t\tfor (x = 0; x < length; x++)\n\t\t\tclear_bit(GBF_FULL, &rgd->rd_bits[x].bi_flags);\n\t\tgfs2_rgrp_in(rgd, (rgd->rd_bits[0].bi_bh)->b_data);\n\t\trgd->rd_flags |= (GFS2_RDF_UPTODATE | GFS2_RDF_CHECK);\n\t\trgd->rd_free_clone = rgd->rd_free;\n\t\t/* max out the rgrp allocation failure point */\n\t\trgd->rd_extfail_pt = rgd->rd_free;\n\t}\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic) {\n\t\trgd->rd_rgl->rl_unlinked = cpu_to_be32(count_unlinked(rgd));\n\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl,\n\t\t\t\t     rgd->rd_bits[0].bi_bh->b_data);\n\t}\n\telse if (sdp->sd_args.ar_rgrplvb) {\n\t\tif (!gfs2_rgrp_lvb_valid(rgd)){\n\t\t\tgfs2_consist_rgrpd(rgd);\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\t}\n\treturn 0;\n\nfail:\n\twhile (x--) {\n\t\tbi = rgd->rd_bits + x;\n\t\tbrelse(bi->bi_bh);\n\t\tbi->bi_bh = NULL;\n\t\tgfs2_assert_warn(sdp, !bi->bi_clone);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_assert_warn",
          "args": [
            "sdp",
            "!bi->bi_clone"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bi->bi_bh"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist_rgrpd",
          "args": [
            "rgd"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_lvb_valid",
          "args": [
            "rgd"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_lvb_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1080-1090",
          "snippet": "static int gfs2_rgrp_lvb_valid(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n\tstruct gfs2_rgrp *str = (struct gfs2_rgrp *)rgd->rd_bits[0].bi_bh->b_data;\n\n\tif (rgl->rl_flags != str->rg_flags || rgl->rl_free != str->rg_free ||\n\t    rgl->rl_dinodes != str->rg_dinodes ||\n\t    rgl->rl_igeneration != str->rg_igeneration)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rgrp_lvb_valid(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n\tstruct gfs2_rgrp *str = (struct gfs2_rgrp *)rgd->rd_bits[0].bi_bh->b_data;\n\n\tif (rgl->rl_flags != str->rg_flags || rgl->rl_free != str->rg_free ||\n\t    rgl->rl_dinodes != str->rg_dinodes ||\n\t    rgl->rl_igeneration != str->rg_igeneration)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_ondisk2lvb",
          "args": [
            "rgd->rd_rgl",
            "rgd->rd_bits[0].bi_bh->b_data"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_ondisk2lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1092-1102",
          "snippet": "static void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "count_unlinked(rgd)"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_unlinked",
          "args": [
            "rgd"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "count_unlinked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1111-1133",
          "snippet": "static u32 count_unlinked(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_bitmap *bi;\n\tconst u32 length = rgd->rd_length;\n\tconst u8 *buffer = NULL;\n\tu32 i, goal, count = 0;\n\n\tfor (i = 0, bi = rgd->rd_bits; i < length; i++, bi++) {\n\t\tgoal = 0;\n\t\tbuffer = bi->bi_bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bi->bi_bh));\n\t\twhile (goal < bi->bi_len * GFS2_NBBY) {\n\t\t\tgoal = gfs2_bitfit(buffer, bi->bi_len, goal,\n\t\t\t\t\t   GFS2_BLKST_UNLINKED);\n\t\t\tif (goal == BFITNOENT)\n\t\t\t\tbreak;\n\t\t\tcount++;\n\t\t\tgoal++;\n\t\t}\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BFITNOENT ((u32)~0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define BFITNOENT ((u32)~0)\n\nstatic u32 count_unlinked(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_bitmap *bi;\n\tconst u32 length = rgd->rd_length;\n\tconst u8 *buffer = NULL;\n\tu32 i, goal, count = 0;\n\n\tfor (i = 0, bi = rgd->rd_bits; i < length; i++, bi++) {\n\t\tgoal = 0;\n\t\tbuffer = bi->bi_bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bi->bi_bh));\n\t\twhile (goal < bi->bi_len * GFS2_NBBY) {\n\t\t\tgoal = gfs2_bitfit(buffer, bi->bi_len, goal,\n\t\t\t\t\t   GFS2_BLKST_UNLINKED);\n\t\t\tif (goal == BFITNOENT)\n\t\t\t\tbreak;\n\t\t\tcount++;\n\t\t\tgoal++;\n\t\t}\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_MAGIC"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rgrp_in",
          "args": [
            "rgd",
            "(rgd->rd_bits[0].bi_bh)->b_data"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrp_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1054-1066",
          "snippet": "static void gfs2_rgrp_in(struct gfs2_rgrpd *rgd, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\tu32 rg_flags;\n\n\trg_flags = be32_to_cpu(str->rg_flags);\n\trg_flags &= ~GFS2_RDF_MASK;\n\trgd->rd_flags &= GFS2_RDF_MASK;\n\trgd->rd_flags |= rg_flags;\n\trgd->rd_free = be32_to_cpu(str->rg_free);\n\trgd->rd_dinodes = be32_to_cpu(str->rg_dinodes);\n\trgd->rd_igeneration = be64_to_cpu(str->rg_igeneration);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_in(struct gfs2_rgrpd *rgd, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\tu32 rg_flags;\n\n\trg_flags = be32_to_cpu(str->rg_flags);\n\trg_flags &= ~GFS2_RDF_MASK;\n\trgd->rd_flags &= GFS2_RDF_MASK;\n\trgd->rd_flags |= rg_flags;\n\trgd->rd_free = be32_to_cpu(str->rg_free);\n\trgd->rd_dinodes = be32_to_cpu(str->rg_dinodes);\n\trgd->rd_igeneration = be64_to_cpu(str->rg_igeneration);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "GBF_FULL",
            "&rgd->rd_bits[x].bi_flags"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_check",
          "args": [
            "sdp",
            "bi->bi_bh",
            "y ? GFS2_METATYPE_RB :\n\t\t\t\t\t      GFS2_METATYPE_RG"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_wait",
          "args": [
            "sdp",
            "bi->bi_bh"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "245-262",
          "snippet": "int gfs2_meta_wait(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\twait_on_buffer(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\treturn -EIO;\n\t}\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_wait(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\twait_on_buffer(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\treturn -EIO;\n\t}\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_read",
          "args": [
            "gl",
            "rgd->rd_addr + x",
            "0",
            "&bi->bi_bh"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "200-235",
          "snippet": "int gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rgrp_bh_get(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\tunsigned int length = rgd->rd_length;\n\tstruct gfs2_bitmap *bi;\n\tunsigned int x, y;\n\tint error;\n\n\tif (rgd->rd_bits[0].bi_bh != NULL)\n\t\treturn 0;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\t\terror = gfs2_meta_read(gl, rgd->rd_addr + x, 0, &bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tfor (y = length; y--;) {\n\t\tbi = rgd->rd_bits + y;\n\t\terror = gfs2_meta_wait(sdp, bi->bi_bh);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tif (gfs2_metatype_check(sdp, bi->bi_bh, y ? GFS2_METATYPE_RB :\n\t\t\t\t\t      GFS2_METATYPE_RG)) {\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!(rgd->rd_flags & GFS2_RDF_UPTODATE)) {\n\t\tfor (x = 0; x < length; x++)\n\t\t\tclear_bit(GBF_FULL, &rgd->rd_bits[x].bi_flags);\n\t\tgfs2_rgrp_in(rgd, (rgd->rd_bits[0].bi_bh)->b_data);\n\t\trgd->rd_flags |= (GFS2_RDF_UPTODATE | GFS2_RDF_CHECK);\n\t\trgd->rd_free_clone = rgd->rd_free;\n\t\t/* max out the rgrp allocation failure point */\n\t\trgd->rd_extfail_pt = rgd->rd_free;\n\t}\n\tif (cpu_to_be32(GFS2_MAGIC) != rgd->rd_rgl->rl_magic) {\n\t\trgd->rd_rgl->rl_unlinked = cpu_to_be32(count_unlinked(rgd));\n\t\tgfs2_rgrp_ondisk2lvb(rgd->rd_rgl,\n\t\t\t\t     rgd->rd_bits[0].bi_bh->b_data);\n\t}\n\telse if (sdp->sd_args.ar_rgrplvb) {\n\t\tif (!gfs2_rgrp_lvb_valid(rgd)){\n\t\t\tgfs2_consist_rgrpd(rgd);\n\t\t\terror = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rgd->rd_rgl->rl_unlinked == 0)\n\t\t\trgd->rd_flags &= ~GFS2_RDF_CHECK;\n\t}\n\treturn 0;\n\nfail:\n\twhile (x--) {\n\t\tbi = rgd->rd_bits + x;\n\t\tbrelse(bi->bi_bh);\n\t\tbi->bi_bh = NULL;\n\t\tgfs2_assert_warn(sdp, !bi->bi_clone);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "count_unlinked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1111-1133",
    "snippet": "static u32 count_unlinked(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_bitmap *bi;\n\tconst u32 length = rgd->rd_length;\n\tconst u8 *buffer = NULL;\n\tu32 i, goal, count = 0;\n\n\tfor (i = 0, bi = rgd->rd_bits; i < length; i++, bi++) {\n\t\tgoal = 0;\n\t\tbuffer = bi->bi_bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bi->bi_bh));\n\t\twhile (goal < bi->bi_len * GFS2_NBBY) {\n\t\t\tgoal = gfs2_bitfit(buffer, bi->bi_len, goal,\n\t\t\t\t\t   GFS2_BLKST_UNLINKED);\n\t\t\tif (goal == BFITNOENT)\n\t\t\t\tbreak;\n\t\t\tcount++;\n\t\t\tgoal++;\n\t\t}\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define BFITNOENT ((u32)~0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_bitfit",
          "args": [
            "buffer",
            "bi->bi_len",
            "goal",
            "GFS2_BLKST_UNLINKED"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_bitfit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "218-246",
          "snippet": "static u32 gfs2_bitfit(const u8 *buf, const unsigned int len,\n\t\t       u32 goal, u8 state)\n{\n\tu32 spoint = (goal << 1) & ((8*sizeof(u64)) - 1);\n\tconst __le64 *ptr = ((__le64 *)buf) + (goal >> 5);\n\tconst __le64 *end = (__le64 *)(buf + ALIGN(len, sizeof(u64)));\n\tu64 tmp;\n\tu64 mask = 0x5555555555555555ULL;\n\tu32 bit;\n\n\t/* Mask off bits we don't care about at the start of the search */\n\tmask <<= spoint;\n\ttmp = gfs2_bit_search(ptr, mask, state);\n\tptr++;\n\twhile(tmp == 0 && ptr < end) {\n\t\ttmp = gfs2_bit_search(ptr, 0x5555555555555555ULL, state);\n\t\tptr++;\n\t}\n\t/* Mask off any bits which are more than len bytes from the start */\n\tif (ptr == end && (len & (sizeof(u64) - 1)))\n\t\ttmp &= (((u64)~0) >> (64 - 8*(len & (sizeof(u64) - 1))));\n\t/* Didn't find anything, so return */\n\tif (tmp == 0)\n\t\treturn BFITNOENT;\n\tptr--;\n\tbit = __ffs64(tmp);\n\tbit /= 2;\t/* two bits per entry in the bitmap */\n\treturn (((const unsigned char *)ptr - buf) * GFS2_NBBY) + bit;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BFITNOENT ((u32)~0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define BFITNOENT ((u32)~0)\n\nstatic u32 gfs2_bitfit(const u8 *buf, const unsigned int len,\n\t\t       u32 goal, u8 state)\n{\n\tu32 spoint = (goal << 1) & ((8*sizeof(u64)) - 1);\n\tconst __le64 *ptr = ((__le64 *)buf) + (goal >> 5);\n\tconst __le64 *end = (__le64 *)(buf + ALIGN(len, sizeof(u64)));\n\tu64 tmp;\n\tu64 mask = 0x5555555555555555ULL;\n\tu32 bit;\n\n\t/* Mask off bits we don't care about at the start of the search */\n\tmask <<= spoint;\n\ttmp = gfs2_bit_search(ptr, mask, state);\n\tptr++;\n\twhile(tmp == 0 && ptr < end) {\n\t\ttmp = gfs2_bit_search(ptr, 0x5555555555555555ULL, state);\n\t\tptr++;\n\t}\n\t/* Mask off any bits which are more than len bytes from the start */\n\tif (ptr == end && (len & (sizeof(u64) - 1)))\n\t\ttmp &= (((u64)~0) >> (64 - 8*(len & (sizeof(u64) - 1))));\n\t/* Didn't find anything, so return */\n\tif (tmp == 0)\n\t\treturn BFITNOENT;\n\tptr--;\n\tbit = __ffs64(tmp);\n\tbit /= 2;\t/* two bits per entry in the bitmap */\n\treturn (((const unsigned char *)ptr - buf) * GFS2_NBBY) + bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!buffer_uptodate(bi->bi_bh)"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bi->bi_bh"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define BFITNOENT ((u32)~0)\n\nstatic u32 count_unlinked(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_bitmap *bi;\n\tconst u32 length = rgd->rd_length;\n\tconst u8 *buffer = NULL;\n\tu32 i, goal, count = 0;\n\n\tfor (i = 0, bi = rgd->rd_bits; i < length; i++, bi++) {\n\t\tgoal = 0;\n\t\tbuffer = bi->bi_bh->b_data + bi->bi_offset;\n\t\tWARN_ON(!buffer_uptodate(bi->bi_bh));\n\t\twhile (goal < bi->bi_len * GFS2_NBBY) {\n\t\t\tgoal = gfs2_bitfit(buffer, bi->bi_len, goal,\n\t\t\t\t\t   GFS2_BLKST_UNLINKED);\n\t\t\tif (goal == BFITNOENT)\n\t\t\t\tbreak;\n\t\t\tcount++;\n\t\t\tgoal++;\n\t\t}\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "update_rgrp_lvb_unlinked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1104-1109",
    "snippet": "static void update_rgrp_lvb_unlinked(struct gfs2_rgrpd *rgd, u32 change)\n{\n\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n\tu32 unlinked = be32_to_cpu(rgl->rl_unlinked) + change;\n\trgl->rl_unlinked = cpu_to_be32(unlinked);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "unlinked"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rgl->rl_unlinked"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void update_rgrp_lvb_unlinked(struct gfs2_rgrpd *rgd, u32 change)\n{\n\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n\tu32 unlinked = be32_to_cpu(rgl->rl_unlinked) + change;\n\trgl->rl_unlinked = cpu_to_be32(unlinked);\n}"
  },
  {
    "function_name": "gfs2_rgrp_ondisk2lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1092-1102",
    "snippet": "static void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_MAGIC"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_ondisk2lvb(struct gfs2_rgrp_lvb *rgl, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\n\trgl->rl_magic = cpu_to_be32(GFS2_MAGIC);\n\trgl->rl_flags = str->rg_flags;\n\trgl->rl_free = str->rg_free;\n\trgl->rl_dinodes = str->rg_dinodes;\n\trgl->rl_igeneration = str->rg_igeneration;\n\trgl->__pad = 0UL;\n}"
  },
  {
    "function_name": "gfs2_rgrp_lvb_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1080-1090",
    "snippet": "static int gfs2_rgrp_lvb_valid(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n\tstruct gfs2_rgrp *str = (struct gfs2_rgrp *)rgd->rd_bits[0].bi_bh->b_data;\n\n\tif (rgl->rl_flags != str->rg_flags || rgl->rl_free != str->rg_free ||\n\t    rgl->rl_dinodes != str->rg_dinodes ||\n\t    rgl->rl_igeneration != str->rg_igeneration)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rgrp_lvb_valid(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_rgrp_lvb *rgl = rgd->rd_rgl;\n\tstruct gfs2_rgrp *str = (struct gfs2_rgrp *)rgd->rd_bits[0].bi_bh->b_data;\n\n\tif (rgl->rl_flags != str->rg_flags || rgl->rl_free != str->rg_free ||\n\t    rgl->rl_dinodes != str->rg_dinodes ||\n\t    rgl->rl_igeneration != str->rg_igeneration)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "gfs2_rgrp_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1068-1078",
    "snippet": "static void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrp *str = buf;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tstr->__pad = cpu_to_be32(0);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&str->rg_reserved",
            "0",
            "sizeof(str->rg_reserved)"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "rgd->rd_igeneration"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "rgd->rd_dinodes"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "rgd->rd_free"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "rgd->rd_flags & ~GFS2_RDF_MASK"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_out(struct gfs2_rgrpd *rgd, void *buf)\n{\n\tstruct gfs2_rgrp *str = buf;\n\n\tstr->rg_flags = cpu_to_be32(rgd->rd_flags & ~GFS2_RDF_MASK);\n\tstr->rg_free = cpu_to_be32(rgd->rd_free);\n\tstr->rg_dinodes = cpu_to_be32(rgd->rd_dinodes);\n\tstr->__pad = cpu_to_be32(0);\n\tstr->rg_igeneration = cpu_to_be64(rgd->rd_igeneration);\n\tmemset(&str->rg_reserved, 0, sizeof(str->rg_reserved));\n}"
  },
  {
    "function_name": "gfs2_rgrp_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1054-1066",
    "snippet": "static void gfs2_rgrp_in(struct gfs2_rgrpd *rgd, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\tu32 rg_flags;\n\n\trg_flags = be32_to_cpu(str->rg_flags);\n\trg_flags &= ~GFS2_RDF_MASK;\n\trgd->rd_flags &= GFS2_RDF_MASK;\n\trgd->rd_flags |= rg_flags;\n\trgd->rd_free = be32_to_cpu(str->rg_free);\n\trgd->rd_dinodes = be32_to_cpu(str->rg_dinodes);\n\trgd->rd_igeneration = be64_to_cpu(str->rg_igeneration);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->rg_igeneration"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->rg_dinodes"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->rg_free"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->rg_flags"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rgrp_in(struct gfs2_rgrpd *rgd, const void *buf)\n{\n\tconst struct gfs2_rgrp *str = buf;\n\tu32 rg_flags;\n\n\trg_flags = be32_to_cpu(str->rg_flags);\n\trg_flags &= ~GFS2_RDF_MASK;\n\trgd->rd_flags &= GFS2_RDF_MASK;\n\trgd->rd_flags |= rg_flags;\n\trgd->rd_free = be32_to_cpu(str->rg_free);\n\trgd->rd_dinodes = be32_to_cpu(str->rg_dinodes);\n\trgd->rd_igeneration = be64_to_cpu(str->rg_igeneration);\n}"
  },
  {
    "function_name": "gfs2_rindex_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "1029-1052",
    "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&ri_gh"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_ri_update",
          "args": [
            "ip"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ri_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "994-1010",
          "snippet": "static int gfs2_ri_update(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tdo {\n\t\terror = read_rindex_entry(ip);\n\t} while (error == 0);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tset_rgrp_preferences(sdp);\n\n\tsdp->sd_rindex_uptodate = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ri_update(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tdo {\n\t\terror = read_rindex_entry(ip);\n\t} while (error == 0);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tset_rgrp_preferences(sdp);\n\n\tsdp->sd_rindex_uptodate = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "gl",
            "LM_ST_SHARED",
            "0",
            "&ri_gh"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_is_locked_by_me",
          "args": [
            "gl"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_is_locked_by_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "138-157",
          "snippet": "static inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nstatic inline struct gfs2_holder *gfs2_glock_is_locked_by_me(struct gfs2_glock *gl)\n{\n\tstruct gfs2_holder *gh;\n\tstruct pid *pid;\n\n\t/* Look in glock's list of holders for one with current task as owner */\n\tspin_lock(&gl->gl_spin);\n\tpid = task_pid(current);\n\tlist_for_each_entry(gh, &gl->gl_holders, gh_list) {\n\t\tif (!test_bit(HIF_HOLDER, &gh->gh_iflags))\n\t\t\tbreak;\n\t\tif (gh->gh_owner_pid == pid)\n\t\t\tgoto out;\n\t}\n\tgh = NULL;\nout:\n\tspin_unlock(&gl->gl_spin);\n\n\treturn gh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_rindex"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_ri_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "994-1010",
    "snippet": "static int gfs2_ri_update(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tdo {\n\t\terror = read_rindex_entry(ip);\n\t} while (error == 0);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tset_rgrp_preferences(sdp);\n\n\tsdp->sd_rindex_uptodate = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_rgrp_preferences",
          "args": [
            "sdp"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "set_rgrp_preferences",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "965-985",
          "snippet": "static void set_rgrp_preferences(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_rgrpd *rgd, *first;\n\tint i;\n\n\t/* Skip an initial number of rgrps, based on this node's journal ID.\n\t   That should start each node out on its own set. */\n\trgd = gfs2_rgrpd_get_first(sdp);\n\tfor (i = 0; i < sdp->sd_lockstruct.ls_jid; i++)\n\t\trgd = gfs2_rgrpd_get_next(rgd);\n\tfirst = rgd;\n\n\tdo {\n\t\trgd->rd_flags |= GFS2_RDF_PREFERRED;\n\t\tfor (i = 0; i < sdp->sd_journals; i++) {\n\t\t\trgd = gfs2_rgrpd_get_next(rgd);\n\t\t\tif (rgd == first)\n\t\t\t\tbreak;\n\t\t}\n\t} while (rgd != first);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void set_rgrp_preferences(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_rgrpd *rgd, *first;\n\tint i;\n\n\t/* Skip an initial number of rgrps, based on this node's journal ID.\n\t   That should start each node out on its own set. */\n\trgd = gfs2_rgrpd_get_first(sdp);\n\tfor (i = 0; i < sdp->sd_lockstruct.ls_jid; i++)\n\t\trgd = gfs2_rgrpd_get_next(rgd);\n\tfirst = rgd;\n\n\tdo {\n\t\trgd->rd_flags |= GFS2_RDF_PREFERRED;\n\t\tfor (i = 0; i < sdp->sd_journals; i++) {\n\t\t\trgd = gfs2_rgrpd_get_next(rgd);\n\t\t\tif (rgd == first)\n\t\t\t\tbreak;\n\t\t}\n\t} while (rgd != first);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_rindex_entry",
          "args": [
            "ip"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "read_rindex_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "895-955",
          "snippet": "static int read_rindex_entry(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tconst unsigned bsize = sdp->sd_sb.sb_bsize;\n\tloff_t pos = sdp->sd_rgrps * sizeof(struct gfs2_rindex);\n\tstruct gfs2_rindex buf;\n\tint error;\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (pos >= i_size_read(&ip->i_inode))\n\t\treturn 1;\n\n\terror = gfs2_internal_read(ip, (char *)&buf, &pos,\n\t\t\t\t   sizeof(struct gfs2_rindex));\n\n\tif (error != sizeof(struct gfs2_rindex))\n\t\treturn (error == 0) ? 1 : error;\n\n\trgd = kmem_cache_zalloc(gfs2_rgrpd_cachep, GFP_NOFS);\n\terror = -ENOMEM;\n\tif (!rgd)\n\t\treturn error;\n\n\trgd->rd_sbd = sdp;\n\trgd->rd_addr = be64_to_cpu(buf.ri_addr);\n\trgd->rd_length = be32_to_cpu(buf.ri_length);\n\trgd->rd_data0 = be64_to_cpu(buf.ri_data0);\n\trgd->rd_data = be32_to_cpu(buf.ri_data);\n\trgd->rd_bitbytes = be32_to_cpu(buf.ri_bitbytes);\n\tspin_lock_init(&rgd->rd_rsspin);\n\n\terror = compute_bitstructs(rgd);\n\tif (error)\n\t\tgoto fail;\n\n\terror = gfs2_glock_get(sdp, rgd->rd_addr,\n\t\t\t       &gfs2_rgrp_glops, CREATE, &rgd->rd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\trgd->rd_gl->gl_object = rgd;\n\trgd->rd_gl->gl_vm.start = rgd->rd_addr * bsize;\n\trgd->rd_gl->gl_vm.end = rgd->rd_gl->gl_vm.start + (rgd->rd_length * bsize) - 1;\n\trgd->rd_rgl = (struct gfs2_rgrp_lvb *)rgd->rd_gl->gl_lksb.sb_lvbptr;\n\trgd->rd_flags &= ~(GFS2_RDF_UPTODATE | GFS2_RDF_PREFERRED);\n\tif (rgd->rd_data > sdp->sd_max_rg_data)\n\t\tsdp->sd_max_rg_data = rgd->rd_data;\n\tspin_lock(&sdp->sd_rindex_spin);\n\terror = rgd_insert(rgd);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\tif (!error)\n\t\treturn 0;\n\n\terror = 0; /* someone else read in the rgrp; free it and ignore it */\n\tgfs2_glock_put(rgd->rd_gl);\n\nfail:\n\tkfree(rgd->rd_bits);\n\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int read_rindex_entry(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tconst unsigned bsize = sdp->sd_sb.sb_bsize;\n\tloff_t pos = sdp->sd_rgrps * sizeof(struct gfs2_rindex);\n\tstruct gfs2_rindex buf;\n\tint error;\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (pos >= i_size_read(&ip->i_inode))\n\t\treturn 1;\n\n\terror = gfs2_internal_read(ip, (char *)&buf, &pos,\n\t\t\t\t   sizeof(struct gfs2_rindex));\n\n\tif (error != sizeof(struct gfs2_rindex))\n\t\treturn (error == 0) ? 1 : error;\n\n\trgd = kmem_cache_zalloc(gfs2_rgrpd_cachep, GFP_NOFS);\n\terror = -ENOMEM;\n\tif (!rgd)\n\t\treturn error;\n\n\trgd->rd_sbd = sdp;\n\trgd->rd_addr = be64_to_cpu(buf.ri_addr);\n\trgd->rd_length = be32_to_cpu(buf.ri_length);\n\trgd->rd_data0 = be64_to_cpu(buf.ri_data0);\n\trgd->rd_data = be32_to_cpu(buf.ri_data);\n\trgd->rd_bitbytes = be32_to_cpu(buf.ri_bitbytes);\n\tspin_lock_init(&rgd->rd_rsspin);\n\n\terror = compute_bitstructs(rgd);\n\tif (error)\n\t\tgoto fail;\n\n\terror = gfs2_glock_get(sdp, rgd->rd_addr,\n\t\t\t       &gfs2_rgrp_glops, CREATE, &rgd->rd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\trgd->rd_gl->gl_object = rgd;\n\trgd->rd_gl->gl_vm.start = rgd->rd_addr * bsize;\n\trgd->rd_gl->gl_vm.end = rgd->rd_gl->gl_vm.start + (rgd->rd_length * bsize) - 1;\n\trgd->rd_rgl = (struct gfs2_rgrp_lvb *)rgd->rd_gl->gl_lksb.sb_lvbptr;\n\trgd->rd_flags &= ~(GFS2_RDF_UPTODATE | GFS2_RDF_PREFERRED);\n\tif (rgd->rd_data > sdp->sd_max_rg_data)\n\t\tsdp->sd_max_rg_data = rgd->rd_data;\n\tspin_lock(&sdp->sd_rindex_spin);\n\terror = rgd_insert(rgd);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\tif (!error)\n\t\treturn 0;\n\n\terror = 0; /* someone else read in the rgrp; free it and ignore it */\n\tgfs2_glock_put(rgd->rd_gl);\n\nfail:\n\tkfree(rgd->rd_bits);\n\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ri_update(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tdo {\n\t\terror = read_rindex_entry(ip);\n\t} while (error == 0);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tset_rgrp_preferences(sdp);\n\n\tsdp->sd_rindex_uptodate = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "set_rgrp_preferences",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "965-985",
    "snippet": "static void set_rgrp_preferences(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_rgrpd *rgd, *first;\n\tint i;\n\n\t/* Skip an initial number of rgrps, based on this node's journal ID.\n\t   That should start each node out on its own set. */\n\trgd = gfs2_rgrpd_get_first(sdp);\n\tfor (i = 0; i < sdp->sd_lockstruct.ls_jid; i++)\n\t\trgd = gfs2_rgrpd_get_next(rgd);\n\tfirst = rgd;\n\n\tdo {\n\t\trgd->rd_flags |= GFS2_RDF_PREFERRED;\n\t\tfor (i = 0; i < sdp->sd_journals; i++) {\n\t\t\trgd = gfs2_rgrpd_get_next(rgd);\n\t\t\tif (rgd == first)\n\t\t\t\tbreak;\n\t\t}\n\t} while (rgd != first);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rgrpd_get_next",
          "args": [
            "rgd"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrpd_get_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "561-578",
          "snippet": "struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tconst struct rb_node *n;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_next(&rgd->rd_node);\n\tif (n == NULL)\n\t\tn = rb_first(&sdp->sd_rindex_tree);\n\n\tif (unlikely(&rgd->rd_node == n)) {\n\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\treturn NULL;\n\t}\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\treturn rgd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tconst struct rb_node *n;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_next(&rgd->rd_node);\n\tif (n == NULL)\n\t\tn = rb_first(&sdp->sd_rindex_tree);\n\n\tif (unlikely(&rgd->rd_node == n)) {\n\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\treturn NULL;\n\t}\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\treturn rgd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rgrpd_get_first",
          "args": [
            "sdp"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rgrpd_get_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "541-552",
          "snippet": "struct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp)\n{\n\tconst struct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_first(&sdp->sd_rindex_tree);\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn rgd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp)\n{\n\tconst struct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_first(&sdp->sd_rindex_tree);\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn rgd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void set_rgrp_preferences(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_rgrpd *rgd, *first;\n\tint i;\n\n\t/* Skip an initial number of rgrps, based on this node's journal ID.\n\t   That should start each node out on its own set. */\n\trgd = gfs2_rgrpd_get_first(sdp);\n\tfor (i = 0; i < sdp->sd_lockstruct.ls_jid; i++)\n\t\trgd = gfs2_rgrpd_get_next(rgd);\n\tfirst = rgd;\n\n\tdo {\n\t\trgd->rd_flags |= GFS2_RDF_PREFERRED;\n\t\tfor (i = 0; i < sdp->sd_journals; i++) {\n\t\t\trgd = gfs2_rgrpd_get_next(rgd);\n\t\t\tif (rgd == first)\n\t\t\t\tbreak;\n\t\t}\n\t} while (rgd != first);\n}"
  },
  {
    "function_name": "read_rindex_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "895-955",
    "snippet": "static int read_rindex_entry(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tconst unsigned bsize = sdp->sd_sb.sb_bsize;\n\tloff_t pos = sdp->sd_rgrps * sizeof(struct gfs2_rindex);\n\tstruct gfs2_rindex buf;\n\tint error;\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (pos >= i_size_read(&ip->i_inode))\n\t\treturn 1;\n\n\terror = gfs2_internal_read(ip, (char *)&buf, &pos,\n\t\t\t\t   sizeof(struct gfs2_rindex));\n\n\tif (error != sizeof(struct gfs2_rindex))\n\t\treturn (error == 0) ? 1 : error;\n\n\trgd = kmem_cache_zalloc(gfs2_rgrpd_cachep, GFP_NOFS);\n\terror = -ENOMEM;\n\tif (!rgd)\n\t\treturn error;\n\n\trgd->rd_sbd = sdp;\n\trgd->rd_addr = be64_to_cpu(buf.ri_addr);\n\trgd->rd_length = be32_to_cpu(buf.ri_length);\n\trgd->rd_data0 = be64_to_cpu(buf.ri_data0);\n\trgd->rd_data = be32_to_cpu(buf.ri_data);\n\trgd->rd_bitbytes = be32_to_cpu(buf.ri_bitbytes);\n\tspin_lock_init(&rgd->rd_rsspin);\n\n\terror = compute_bitstructs(rgd);\n\tif (error)\n\t\tgoto fail;\n\n\terror = gfs2_glock_get(sdp, rgd->rd_addr,\n\t\t\t       &gfs2_rgrp_glops, CREATE, &rgd->rd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\trgd->rd_gl->gl_object = rgd;\n\trgd->rd_gl->gl_vm.start = rgd->rd_addr * bsize;\n\trgd->rd_gl->gl_vm.end = rgd->rd_gl->gl_vm.start + (rgd->rd_length * bsize) - 1;\n\trgd->rd_rgl = (struct gfs2_rgrp_lvb *)rgd->rd_gl->gl_lksb.sb_lvbptr;\n\trgd->rd_flags &= ~(GFS2_RDF_UPTODATE | GFS2_RDF_PREFERRED);\n\tif (rgd->rd_data > sdp->sd_max_rg_data)\n\t\tsdp->sd_max_rg_data = rgd->rd_data;\n\tspin_lock(&sdp->sd_rindex_spin);\n\terror = rgd_insert(rgd);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\tif (!error)\n\t\treturn 0;\n\n\terror = 0; /* someone else read in the rgrp; free it and ignore it */\n\tgfs2_glock_put(rgd->rd_gl);\n\nfail:\n\tkfree(rgd->rd_bits);\n\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "gfs2_rgrpd_cachep",
            "rgd"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rgd->rd_bits"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_put",
          "args": [
            "rgd->rd_gl"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "193-212",
          "snippet": "void gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_rindex_spin"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rgd_insert",
          "args": [
            "rgd"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "rgd_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "863-886",
          "snippet": "static int rgd_insert(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct rb_node **newn = &sdp->sd_rindex_tree.rb_node, *parent = NULL;\n\n\t/* Figure out where to put new node */\n\twhile (*newn) {\n\t\tstruct gfs2_rgrpd *cur = rb_entry(*newn, struct gfs2_rgrpd,\n\t\t\t\t\t\t  rd_node);\n\n\t\tparent = *newn;\n\t\tif (rgd->rd_addr < cur->rd_addr)\n\t\t\tnewn = &((*newn)->rb_left);\n\t\telse if (rgd->rd_addr > cur->rd_addr)\n\t\t\tnewn = &((*newn)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&rgd->rd_node, parent, newn);\n\trb_insert_color(&rgd->rd_node, &sdp->sd_rindex_tree);\n\tsdp->sd_rgrps++;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int rgd_insert(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct rb_node **newn = &sdp->sd_rindex_tree.rb_node, *parent = NULL;\n\n\t/* Figure out where to put new node */\n\twhile (*newn) {\n\t\tstruct gfs2_rgrpd *cur = rb_entry(*newn, struct gfs2_rgrpd,\n\t\t\t\t\t\t  rd_node);\n\n\t\tparent = *newn;\n\t\tif (rgd->rd_addr < cur->rd_addr)\n\t\t\tnewn = &((*newn)->rb_left);\n\t\telse if (rgd->rd_addr > cur->rd_addr)\n\t\t\tnewn = &((*newn)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&rgd->rd_node, parent, newn);\n\trb_insert_color(&rgd->rd_node, &sdp->sd_rindex_tree);\n\tsdp->sd_rgrps++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_rindex_spin"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_get",
          "args": [
            "sdp",
            "rgd->rd_addr",
            "&gfs2_rgrp_glops",
            "CREATE",
            "&rgd->rd_gl"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "702-790",
          "snippet": "int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head gl_hash_table[GFS2_GL_HASH_SIZE];\n\nint gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,\n\t\t   const struct gfs2_glock_operations *glops, int create,\n\t\t   struct gfs2_glock **glp)\n{\n\tstruct super_block *s = sdp->sd_vfs;\n\tstruct lm_lockname name = { .ln_number = number, .ln_type = glops->go_type };\n\tstruct gfs2_glock *gl, *tmp;\n\tunsigned int hash = gl_hash(sdp, &name);\n\tstruct address_space *mapping;\n\tstruct kmem_cache *cachep;\n\n\trcu_read_lock();\n\tgl = search_bucket(hash, sdp, &name);\n\trcu_read_unlock();\n\n\t*glp = gl;\n\tif (gl)\n\t\treturn 0;\n\tif (!create)\n\t\treturn -ENOENT;\n\n\tif (glops->go_flags & GLOF_ASPACE)\n\t\tcachep = gfs2_glock_aspace_cachep;\n\telse\n\t\tcachep = gfs2_glock_cachep;\n\tgl = kmem_cache_alloc(cachep, GFP_NOFS);\n\tif (!gl)\n\t\treturn -ENOMEM;\n\n\tmemset(&gl->gl_lksb, 0, sizeof(struct dlm_lksb));\n\n\tif (glops->go_flags & GLOF_LVB) {\n\t\tgl->gl_lksb.sb_lvbptr = kzalloc(GFS2_MIN_LVB_SIZE, GFP_NOFS);\n\t\tif (!gl->gl_lksb.sb_lvbptr) {\n\t\t\tkmem_cache_free(cachep, gl);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tatomic_inc(&sdp->sd_glock_disposal);\n\tgl->gl_sbd = sdp;\n\tgl->gl_flags = 0;\n\tgl->gl_name = name;\n\tgl->gl_lockref.count = 1;\n\tgl->gl_state = LM_ST_UNLOCKED;\n\tgl->gl_target = LM_ST_UNLOCKED;\n\tgl->gl_demote_state = LM_ST_EXCLUSIVE;\n\tgl->gl_hash = hash;\n\tgl->gl_ops = glops;\n\tgl->gl_dstamp = ktime_set(0, 0);\n\tpreempt_disable();\n\t/* We use the global stats to estimate the initial per-glock stats */\n\tgl->gl_stats = this_cpu_ptr(sdp->sd_lkstats)->lkstats[glops->go_type];\n\tpreempt_enable();\n\tgl->gl_stats.stats[GFS2_LKS_DCOUNT] = 0;\n\tgl->gl_stats.stats[GFS2_LKS_QCOUNT] = 0;\n\tgl->gl_tchange = jiffies;\n\tgl->gl_object = NULL;\n\tgl->gl_hold_time = GL_GLOCK_DFT_HOLD;\n\tINIT_DELAYED_WORK(&gl->gl_work, glock_work_func);\n\tINIT_WORK(&gl->gl_delete, delete_work_func);\n\n\tmapping = gfs2_glock2aspace(gl);\n\tif (mapping) {\n                mapping->a_ops = &gfs2_meta_aops;\n\t\tmapping->host = s->s_bdev->bd_inode;\n\t\tmapping->flags = 0;\n\t\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\t\tmapping->private_data = NULL;\n\t\tmapping->writeback_index = 0;\n\t}\n\n\tspin_lock_bucket(hash);\n\ttmp = search_bucket(hash, sdp, &name);\n\tif (tmp) {\n\t\tspin_unlock_bucket(hash);\n\t\tkfree(gl->gl_lksb.sb_lvbptr);\n\t\tkmem_cache_free(cachep, gl);\n\t\tatomic_dec(&sdp->sd_glock_disposal);\n\t\tgl = tmp;\n\t} else {\n\t\thlist_bl_add_head_rcu(&gl->gl_list, &gl_hash_table[hash]);\n\t\tspin_unlock_bucket(hash);\n\t}\n\n\t*glp = gl;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compute_bitstructs",
          "args": [
            "rgd"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "compute_bitstructs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "764-834",
          "snippet": "static int compute_bitstructs(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_bitmap *bi;\n\tu32 length = rgd->rd_length; /* # blocks in hdr & bitmap */\n\tu32 bytes_left, bytes;\n\tint x;\n\n\tif (!length)\n\t\treturn -EINVAL;\n\n\trgd->rd_bits = kcalloc(length, sizeof(struct gfs2_bitmap), GFP_NOFS);\n\tif (!rgd->rd_bits)\n\t\treturn -ENOMEM;\n\n\tbytes_left = rgd->rd_bitbytes;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\n\t\tbi->bi_flags = 0;\n\t\t/* small rgrp; bitmap stored completely in header block */\n\t\tif (length == 1) {\n\t\t\tbytes = bytes_left;\n\t\t\tbi->bi_offset = sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_start = 0;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t/* header block */\n\t\t} else if (x == 0) {\n\t\t\tbytes = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_offset = sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_start = 0;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t/* last block */\n\t\t} else if (x + 1 == length) {\n\t\t\tbytes = bytes_left;\n\t\t\tbi->bi_offset = sizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_start = rgd->rd_bitbytes - bytes_left;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t/* other blocks */\n\t\t} else {\n\t\t\tbytes = sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_offset = sizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_start = rgd->rd_bitbytes - bytes_left;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t}\n\n\t\tbytes_left -= bytes;\n\t}\n\n\tif (bytes_left) {\n\t\tgfs2_consist_rgrpd(rgd);\n\t\treturn -EIO;\n\t}\n\tbi = rgd->rd_bits + (length - 1);\n\tif ((bi->bi_start + bi->bi_len) * GFS2_NBBY != rgd->rd_data) {\n\t\tif (gfs2_consist_rgrpd(rgd)) {\n\t\t\tgfs2_rindex_print(rgd);\n\t\t\tfs_err(sdp, \"start=%u len=%u offset=%u\\n\",\n\t\t\t       bi->bi_start, bi->bi_len, bi->bi_offset);\n\t\t}\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int compute_bitstructs(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_bitmap *bi;\n\tu32 length = rgd->rd_length; /* # blocks in hdr & bitmap */\n\tu32 bytes_left, bytes;\n\tint x;\n\n\tif (!length)\n\t\treturn -EINVAL;\n\n\trgd->rd_bits = kcalloc(length, sizeof(struct gfs2_bitmap), GFP_NOFS);\n\tif (!rgd->rd_bits)\n\t\treturn -ENOMEM;\n\n\tbytes_left = rgd->rd_bitbytes;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\n\t\tbi->bi_flags = 0;\n\t\t/* small rgrp; bitmap stored completely in header block */\n\t\tif (length == 1) {\n\t\t\tbytes = bytes_left;\n\t\t\tbi->bi_offset = sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_start = 0;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t/* header block */\n\t\t} else if (x == 0) {\n\t\t\tbytes = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_offset = sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_start = 0;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t/* last block */\n\t\t} else if (x + 1 == length) {\n\t\t\tbytes = bytes_left;\n\t\t\tbi->bi_offset = sizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_start = rgd->rd_bitbytes - bytes_left;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t/* other blocks */\n\t\t} else {\n\t\t\tbytes = sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_offset = sizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_start = rgd->rd_bitbytes - bytes_left;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t}\n\n\t\tbytes_left -= bytes;\n\t}\n\n\tif (bytes_left) {\n\t\tgfs2_consist_rgrpd(rgd);\n\t\treturn -EIO;\n\t}\n\tbi = rgd->rd_bits + (length - 1);\n\tif ((bi->bi_start + bi->bi_len) * GFS2_NBBY != rgd->rd_data) {\n\t\tif (gfs2_consist_rgrpd(rgd)) {\n\t\t\tgfs2_rindex_print(rgd);\n\t\t\tfs_err(sdp, \"start=%u len=%u offset=%u\\n\",\n\t\t\t       bi->bi_start, bi->bi_len, bi->bi_offset);\n\t\t}\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "buf.ri_bitbytes"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "buf.ri_data"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "buf.ri_data0"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "buf.ri_length"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "buf.ri_addr"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "gfs2_rgrpd_cachep",
            "GFP_NOFS"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_internal_read",
          "args": [
            "ip",
            "(char *)&buf",
            "&pos",
            "sizeof(struct gfs2_rindex)"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_internal_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "559-587",
          "snippet": "int gfs2_internal_read(struct gfs2_inode *ip, char *buf, loff_t *pos,\n                       unsigned size)\n{\n\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\tunsigned long index = *pos / PAGE_CACHE_SIZE;\n\tunsigned offset = *pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned copied = 0;\n\tunsigned amt;\n\tstruct page *page;\n\tvoid *p;\n\n\tdo {\n\t\tamt = size - copied;\n\t\tif (offset + size > PAGE_CACHE_SIZE)\n\t\t\tamt = PAGE_CACHE_SIZE - offset;\n\t\tpage = read_cache_page(mapping, index, __gfs2_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tp = kmap_atomic(page);\n\t\tmemcpy(buf + copied, p + offset, amt);\n\t\tkunmap_atomic(p);\n\t\tpage_cache_release(page);\n\t\tcopied += amt;\n\t\tindex++;\n\t\toffset = 0;\n\t} while(copied < size);\n\t(*pos) += size;\n\treturn size;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_internal_read(struct gfs2_inode *ip, char *buf, loff_t *pos,\n                       unsigned size)\n{\n\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\tunsigned long index = *pos / PAGE_CACHE_SIZE;\n\tunsigned offset = *pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned copied = 0;\n\tunsigned amt;\n\tstruct page *page;\n\tvoid *p;\n\n\tdo {\n\t\tamt = size - copied;\n\t\tif (offset + size > PAGE_CACHE_SIZE)\n\t\t\tamt = PAGE_CACHE_SIZE - offset;\n\t\tpage = read_cache_page(mapping, index, __gfs2_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tp = kmap_atomic(page);\n\t\tmemcpy(buf + copied, p + offset, amt);\n\t\tkunmap_atomic(p);\n\t\tpage_cache_release(page);\n\t\tcopied += amt;\n\t\tindex++;\n\t\toffset = 0;\n\t} while(copied < size);\n\t(*pos) += size;\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&ip->i_inode"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int read_rindex_entry(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tconst unsigned bsize = sdp->sd_sb.sb_bsize;\n\tloff_t pos = sdp->sd_rgrps * sizeof(struct gfs2_rindex);\n\tstruct gfs2_rindex buf;\n\tint error;\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (pos >= i_size_read(&ip->i_inode))\n\t\treturn 1;\n\n\terror = gfs2_internal_read(ip, (char *)&buf, &pos,\n\t\t\t\t   sizeof(struct gfs2_rindex));\n\n\tif (error != sizeof(struct gfs2_rindex))\n\t\treturn (error == 0) ? 1 : error;\n\n\trgd = kmem_cache_zalloc(gfs2_rgrpd_cachep, GFP_NOFS);\n\terror = -ENOMEM;\n\tif (!rgd)\n\t\treturn error;\n\n\trgd->rd_sbd = sdp;\n\trgd->rd_addr = be64_to_cpu(buf.ri_addr);\n\trgd->rd_length = be32_to_cpu(buf.ri_length);\n\trgd->rd_data0 = be64_to_cpu(buf.ri_data0);\n\trgd->rd_data = be32_to_cpu(buf.ri_data);\n\trgd->rd_bitbytes = be32_to_cpu(buf.ri_bitbytes);\n\tspin_lock_init(&rgd->rd_rsspin);\n\n\terror = compute_bitstructs(rgd);\n\tif (error)\n\t\tgoto fail;\n\n\terror = gfs2_glock_get(sdp, rgd->rd_addr,\n\t\t\t       &gfs2_rgrp_glops, CREATE, &rgd->rd_gl);\n\tif (error)\n\t\tgoto fail;\n\n\trgd->rd_gl->gl_object = rgd;\n\trgd->rd_gl->gl_vm.start = rgd->rd_addr * bsize;\n\trgd->rd_gl->gl_vm.end = rgd->rd_gl->gl_vm.start + (rgd->rd_length * bsize) - 1;\n\trgd->rd_rgl = (struct gfs2_rgrp_lvb *)rgd->rd_gl->gl_lksb.sb_lvbptr;\n\trgd->rd_flags &= ~(GFS2_RDF_UPTODATE | GFS2_RDF_PREFERRED);\n\tif (rgd->rd_data > sdp->sd_max_rg_data)\n\t\tsdp->sd_max_rg_data = rgd->rd_data;\n\tspin_lock(&sdp->sd_rindex_spin);\n\terror = rgd_insert(rgd);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\tif (!error)\n\t\treturn 0;\n\n\terror = 0; /* someone else read in the rgrp; free it and ignore it */\n\tgfs2_glock_put(rgd->rd_gl);\n\nfail:\n\tkfree(rgd->rd_bits);\n\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\treturn error;\n}"
  },
  {
    "function_name": "rgd_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "863-886",
    "snippet": "static int rgd_insert(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct rb_node **newn = &sdp->sd_rindex_tree.rb_node, *parent = NULL;\n\n\t/* Figure out where to put new node */\n\twhile (*newn) {\n\t\tstruct gfs2_rgrpd *cur = rb_entry(*newn, struct gfs2_rgrpd,\n\t\t\t\t\t\t  rd_node);\n\n\t\tparent = *newn;\n\t\tif (rgd->rd_addr < cur->rd_addr)\n\t\t\tnewn = &((*newn)->rb_left);\n\t\telse if (rgd->rd_addr > cur->rd_addr)\n\t\t\tnewn = &((*newn)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&rgd->rd_node, parent, newn);\n\trb_insert_color(&rgd->rd_node, &sdp->sd_rindex_tree);\n\tsdp->sd_rgrps++;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&rgd->rd_node",
            "&sdp->sd_rindex_tree"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&rgd->rd_node",
            "parent",
            "newn"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*newn",
            "structgfs2_rgrpd",
            "rd_node"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int rgd_insert(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct rb_node **newn = &sdp->sd_rindex_tree.rb_node, *parent = NULL;\n\n\t/* Figure out where to put new node */\n\twhile (*newn) {\n\t\tstruct gfs2_rgrpd *cur = rb_entry(*newn, struct gfs2_rgrpd,\n\t\t\t\t\t\t  rd_node);\n\n\t\tparent = *newn;\n\t\tif (rgd->rd_addr < cur->rd_addr)\n\t\t\tnewn = &((*newn)->rb_left);\n\t\telse if (rgd->rd_addr > cur->rd_addr)\n\t\t\tnewn = &((*newn)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&rgd->rd_node, parent, newn);\n\trb_insert_color(&rgd->rd_node, &sdp->sd_rindex_tree);\n\tsdp->sd_rgrps++;\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_ri_total",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "841-861",
    "snippet": "u64 gfs2_ri_total(struct gfs2_sbd *sdp)\n{\n\tu64 total_data = 0;\t\n\tstruct inode *inode = sdp->sd_rindex;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tchar buf[sizeof(struct gfs2_rindex)];\n\tint error, rgrps;\n\n\tfor (rgrps = 0;; rgrps++) {\n\t\tloff_t pos = rgrps * sizeof(struct gfs2_rindex);\n\n\t\tif (pos + sizeof(struct gfs2_rindex) > i_size_read(inode))\n\t\t\tbreak;\n\t\terror = gfs2_internal_read(ip, buf, &pos,\n\t\t\t\t\t   sizeof(struct gfs2_rindex));\n\t\tif (error != sizeof(struct gfs2_rindex))\n\t\t\tbreak;\n\t\ttotal_data += be32_to_cpu(((struct gfs2_rindex *)buf)->ri_data);\n\t}\n\treturn total_data;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "((struct gfs2_rindex *)buf)->ri_data"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_internal_read",
          "args": [
            "ip",
            "buf",
            "&pos",
            "sizeof(struct gfs2_rindex)"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_internal_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "559-587",
          "snippet": "int gfs2_internal_read(struct gfs2_inode *ip, char *buf, loff_t *pos,\n                       unsigned size)\n{\n\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\tunsigned long index = *pos / PAGE_CACHE_SIZE;\n\tunsigned offset = *pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned copied = 0;\n\tunsigned amt;\n\tstruct page *page;\n\tvoid *p;\n\n\tdo {\n\t\tamt = size - copied;\n\t\tif (offset + size > PAGE_CACHE_SIZE)\n\t\t\tamt = PAGE_CACHE_SIZE - offset;\n\t\tpage = read_cache_page(mapping, index, __gfs2_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tp = kmap_atomic(page);\n\t\tmemcpy(buf + copied, p + offset, amt);\n\t\tkunmap_atomic(p);\n\t\tpage_cache_release(page);\n\t\tcopied += amt;\n\t\tindex++;\n\t\toffset = 0;\n\t} while(copied < size);\n\t(*pos) += size;\n\treturn size;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_internal_read(struct gfs2_inode *ip, char *buf, loff_t *pos,\n                       unsigned size)\n{\n\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\tunsigned long index = *pos / PAGE_CACHE_SIZE;\n\tunsigned offset = *pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned copied = 0;\n\tunsigned amt;\n\tstruct page *page;\n\tvoid *p;\n\n\tdo {\n\t\tamt = size - copied;\n\t\tif (offset + size > PAGE_CACHE_SIZE)\n\t\t\tamt = PAGE_CACHE_SIZE - offset;\n\t\tpage = read_cache_page(mapping, index, __gfs2_readpage, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tp = kmap_atomic(page);\n\t\tmemcpy(buf + copied, p + offset, amt);\n\t\tkunmap_atomic(p);\n\t\tpage_cache_release(page);\n\t\tcopied += amt;\n\t\tindex++;\n\t\toffset = 0;\n\t} while(copied < size);\n\t(*pos) += size;\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nu64 gfs2_ri_total(struct gfs2_sbd *sdp)\n{\n\tu64 total_data = 0;\t\n\tstruct inode *inode = sdp->sd_rindex;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tchar buf[sizeof(struct gfs2_rindex)];\n\tint error, rgrps;\n\n\tfor (rgrps = 0;; rgrps++) {\n\t\tloff_t pos = rgrps * sizeof(struct gfs2_rindex);\n\n\t\tif (pos + sizeof(struct gfs2_rindex) > i_size_read(inode))\n\t\t\tbreak;\n\t\terror = gfs2_internal_read(ip, buf, &pos,\n\t\t\t\t\t   sizeof(struct gfs2_rindex));\n\t\tif (error != sizeof(struct gfs2_rindex))\n\t\t\tbreak;\n\t\ttotal_data += be32_to_cpu(((struct gfs2_rindex *)buf)->ri_data);\n\t}\n\treturn total_data;\n}"
  },
  {
    "function_name": "compute_bitstructs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "764-834",
    "snippet": "static int compute_bitstructs(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_bitmap *bi;\n\tu32 length = rgd->rd_length; /* # blocks in hdr & bitmap */\n\tu32 bytes_left, bytes;\n\tint x;\n\n\tif (!length)\n\t\treturn -EINVAL;\n\n\trgd->rd_bits = kcalloc(length, sizeof(struct gfs2_bitmap), GFP_NOFS);\n\tif (!rgd->rd_bits)\n\t\treturn -ENOMEM;\n\n\tbytes_left = rgd->rd_bitbytes;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\n\t\tbi->bi_flags = 0;\n\t\t/* small rgrp; bitmap stored completely in header block */\n\t\tif (length == 1) {\n\t\t\tbytes = bytes_left;\n\t\t\tbi->bi_offset = sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_start = 0;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t/* header block */\n\t\t} else if (x == 0) {\n\t\t\tbytes = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_offset = sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_start = 0;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t/* last block */\n\t\t} else if (x + 1 == length) {\n\t\t\tbytes = bytes_left;\n\t\t\tbi->bi_offset = sizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_start = rgd->rd_bitbytes - bytes_left;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t/* other blocks */\n\t\t} else {\n\t\t\tbytes = sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_offset = sizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_start = rgd->rd_bitbytes - bytes_left;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t}\n\n\t\tbytes_left -= bytes;\n\t}\n\n\tif (bytes_left) {\n\t\tgfs2_consist_rgrpd(rgd);\n\t\treturn -EIO;\n\t}\n\tbi = rgd->rd_bits + (length - 1);\n\tif ((bi->bi_start + bi->bi_len) * GFS2_NBBY != rgd->rd_data) {\n\t\tif (gfs2_consist_rgrpd(rgd)) {\n\t\t\tgfs2_rindex_print(rgd);\n\t\t\tfs_err(sdp, \"start=%u len=%u offset=%u\\n\",\n\t\t\t       bi->bi_start, bi->bi_len, bi->bi_offset);\n\t\t}\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"start=%u len=%u offset=%u\\n\"",
            "bi->bi_start",
            "bi->bi_len",
            "bi->bi_offset"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_print",
          "args": [
            "rgd"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "746-753",
          "snippet": "static void gfs2_rindex_print(const struct gfs2_rgrpd *rgd)\n{\n\tpr_info(\"ri_addr = %llu\\n\", (unsigned long long)rgd->rd_addr);\n\tpr_info(\"ri_length = %u\\n\", rgd->rd_length);\n\tpr_info(\"ri_data0 = %llu\\n\", (unsigned long long)rgd->rd_data0);\n\tpr_info(\"ri_data = %u\\n\", rgd->rd_data);\n\tpr_info(\"ri_bitbytes = %u\\n\", rgd->rd_bitbytes);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rindex_print(const struct gfs2_rgrpd *rgd)\n{\n\tpr_info(\"ri_addr = %llu\\n\", (unsigned long long)rgd->rd_addr);\n\tpr_info(\"ri_length = %u\\n\", rgd->rd_length);\n\tpr_info(\"ri_data0 = %llu\\n\", (unsigned long long)rgd->rd_data0);\n\tpr_info(\"ri_data = %u\\n\", rgd->rd_data);\n\tpr_info(\"ri_bitbytes = %u\\n\", rgd->rd_bitbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist_rgrpd",
          "args": [
            "rgd"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_rgrpd",
          "args": [
            "rgd"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "length",
            "sizeof(struct gfs2_bitmap)",
            "GFP_NOFS"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int compute_bitstructs(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_bitmap *bi;\n\tu32 length = rgd->rd_length; /* # blocks in hdr & bitmap */\n\tu32 bytes_left, bytes;\n\tint x;\n\n\tif (!length)\n\t\treturn -EINVAL;\n\n\trgd->rd_bits = kcalloc(length, sizeof(struct gfs2_bitmap), GFP_NOFS);\n\tif (!rgd->rd_bits)\n\t\treturn -ENOMEM;\n\n\tbytes_left = rgd->rd_bitbytes;\n\n\tfor (x = 0; x < length; x++) {\n\t\tbi = rgd->rd_bits + x;\n\n\t\tbi->bi_flags = 0;\n\t\t/* small rgrp; bitmap stored completely in header block */\n\t\tif (length == 1) {\n\t\t\tbytes = bytes_left;\n\t\t\tbi->bi_offset = sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_start = 0;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t/* header block */\n\t\t} else if (x == 0) {\n\t\t\tbytes = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_offset = sizeof(struct gfs2_rgrp);\n\t\t\tbi->bi_start = 0;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t/* last block */\n\t\t} else if (x + 1 == length) {\n\t\t\tbytes = bytes_left;\n\t\t\tbi->bi_offset = sizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_start = rgd->rd_bitbytes - bytes_left;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t/* other blocks */\n\t\t} else {\n\t\t\tbytes = sdp->sd_sb.sb_bsize -\n\t\t\t\tsizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_offset = sizeof(struct gfs2_meta_header);\n\t\t\tbi->bi_start = rgd->rd_bitbytes - bytes_left;\n\t\t\tbi->bi_len = bytes;\n\t\t\tbi->bi_blocks = bytes * GFS2_NBBY;\n\t\t}\n\n\t\tbytes_left -= bytes;\n\t}\n\n\tif (bytes_left) {\n\t\tgfs2_consist_rgrpd(rgd);\n\t\treturn -EIO;\n\t}\n\tbi = rgd->rd_bits + (length - 1);\n\tif ((bi->bi_start + bi->bi_len) * GFS2_NBBY != rgd->rd_data) {\n\t\tif (gfs2_consist_rgrpd(rgd)) {\n\t\t\tgfs2_rindex_print(rgd);\n\t\t\tfs_err(sdp, \"start=%u len=%u offset=%u\\n\",\n\t\t\t       bi->bi_start, bi->bi_len, bi->bi_offset);\n\t\t}\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_rindex_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "746-753",
    "snippet": "static void gfs2_rindex_print(const struct gfs2_rgrpd *rgd)\n{\n\tpr_info(\"ri_addr = %llu\\n\", (unsigned long long)rgd->rd_addr);\n\tpr_info(\"ri_length = %u\\n\", rgd->rd_length);\n\tpr_info(\"ri_data0 = %llu\\n\", (unsigned long long)rgd->rd_data0);\n\tpr_info(\"ri_data = %u\\n\", rgd->rd_data);\n\tpr_info(\"ri_bitbytes = %u\\n\", rgd->rd_bitbytes);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ri_bitbytes = %u\\n\"",
            "rgd->rd_bitbytes"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ri_data = %u\\n\"",
            "rgd->rd_data"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ri_data0 = %llu\\n\"",
            "(unsigned long long)rgd->rd_data0"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ri_length = %u\\n\"",
            "rgd->rd_length"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ri_addr = %llu\\n\"",
            "(unsigned long long)rgd->rd_addr"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void gfs2_rindex_print(const struct gfs2_rgrpd *rgd)\n{\n\tpr_info(\"ri_addr = %llu\\n\", (unsigned long long)rgd->rd_addr);\n\tpr_info(\"ri_length = %u\\n\", rgd->rd_length);\n\tpr_info(\"ri_data0 = %llu\\n\", (unsigned long long)rgd->rd_data0);\n\tpr_info(\"ri_data = %u\\n\", rgd->rd_data);\n\tpr_info(\"ri_bitbytes = %u\\n\", rgd->rd_bitbytes);\n}"
  },
  {
    "function_name": "gfs2_clear_rgrpd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "719-744",
    "snippet": "void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_glock *gl;\n\n\twhile ((n = rb_first(&sdp->sd_rindex_tree))) {\n\t\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tgl = rgd->rd_gl;\n\n\t\trb_erase(n, &sdp->sd_rindex_tree);\n\n\t\tif (gl) {\n\t\t\tspin_lock(&gl->gl_spin);\n\t\t\tgl->gl_object = NULL;\n\t\t\tspin_unlock(&gl->gl_spin);\n\t\t\tgfs2_glock_add_to_lru(gl);\n\t\t\tgfs2_glock_put(gl);\n\t\t}\n\n\t\tgfs2_free_clones(rgd);\n\t\tkfree(rgd->rd_bits);\n\t\treturn_all_reservations(rgd);\n\t\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "gfs2_rgrpd_cachep",
            "rgd"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return_all_reservations",
          "args": [
            "rgd"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "return_all_reservations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "706-717",
          "snippet": "static void return_all_reservations(struct gfs2_rgrpd *rgd)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_blkreserv *rs;\n\n\tspin_lock(&rgd->rd_rsspin);\n\twhile ((n = rb_first(&rgd->rd_rstree))) {\n\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\t__rs_deltree(rs);\n\t}\n\tspin_unlock(&rgd->rd_rsspin);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void return_all_reservations(struct gfs2_rgrpd *rgd)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_blkreserv *rs;\n\n\tspin_lock(&rgd->rd_rsspin);\n\twhile ((n = rb_first(&rgd->rd_rstree))) {\n\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\t__rs_deltree(rs);\n\t}\n\tspin_unlock(&rgd->rd_rsspin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rgd->rd_bits"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_free_clones",
          "args": [
            "rgd"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_free_clones",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "587-596",
          "snippet": "void gfs2_free_clones(struct gfs2_rgrpd *rgd)\n{\n\tint x;\n\n\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\tkfree(bi->bi_clone);\n\t\tbi->bi_clone = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_free_clones(struct gfs2_rgrpd *rgd)\n{\n\tint x;\n\n\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\tkfree(bi->bi_clone);\n\t\tbi->bi_clone = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_put",
          "args": [
            "gl"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "193-212",
          "snippet": "void gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_put(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\n\tif (lockref_put_or_lock(&gl->gl_lockref))\n\t\treturn;\n\n\tlockref_mark_dead(&gl->gl_lockref);\n\n\tgfs2_glock_remove_from_lru(gl);\n\tspin_unlock(&gl->gl_lockref.lock);\n\tspin_lock_bucket(gl->gl_hash);\n\thlist_bl_del_rcu(&gl->gl_list);\n\tspin_unlock_bucket(gl->gl_hash);\n\tGLOCK_BUG_ON(gl, !list_empty(&gl->gl_holders));\n\tGLOCK_BUG_ON(gl, mapping && mapping->nrpages);\n\ttrace_gfs2_glock_put(gl);\n\tsdp->sd_lockstruct.ls_ops->lm_put_lock(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_add_to_lru",
          "args": [
            "gl"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_add_to_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "162-174",
          "snippet": "void gfs2_glock_add_to_lru(struct gfs2_glock *gl)\n{\n\tspin_lock(&lru_lock);\n\n\tif (!list_empty(&gl->gl_lru))\n\t\tlist_del_init(&gl->gl_lru);\n\telse\n\t\tatomic_inc(&lru_count);\n\n\tlist_add_tail(&gl->gl_lru, &lru_list);\n\tset_bit(GLF_LRU, &gl->gl_flags);\n\tspin_unlock(&lru_lock);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(lru_list);",
            "static atomic_t lru_count = ATOMIC_INIT(0);",
            "static DEFINE_SPINLOCK(lru_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(lru_list);\nstatic atomic_t lru_count = ATOMIC_INIT(0);\nstatic DEFINE_SPINLOCK(lru_lock);\n\nvoid gfs2_glock_add_to_lru(struct gfs2_glock *gl)\n{\n\tspin_lock(&lru_lock);\n\n\tif (!list_empty(&gl->gl_lru))\n\t\tlist_del_init(&gl->gl_lru);\n\telse\n\t\tatomic_inc(&lru_count);\n\n\tlist_add_tail(&gl->gl_lru, &lru_list);\n\tset_bit(GLF_LRU, &gl->gl_flags);\n\tspin_unlock(&lru_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&gl->gl_spin"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&gl->gl_spin"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "n",
            "&sdp->sd_rindex_tree"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structgfs2_rgrpd",
            "rd_node"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&sdp->sd_rindex_tree"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_clear_rgrpd(struct gfs2_sbd *sdp)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_glock *gl;\n\n\twhile ((n = rb_first(&sdp->sd_rindex_tree))) {\n\t\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tgl = rgd->rd_gl;\n\n\t\trb_erase(n, &sdp->sd_rindex_tree);\n\n\t\tif (gl) {\n\t\t\tspin_lock(&gl->gl_spin);\n\t\t\tgl->gl_object = NULL;\n\t\t\tspin_unlock(&gl->gl_spin);\n\t\t\tgfs2_glock_add_to_lru(gl);\n\t\t\tgfs2_glock_put(gl);\n\t\t}\n\n\t\tgfs2_free_clones(rgd);\n\t\tkfree(rgd->rd_bits);\n\t\treturn_all_reservations(rgd);\n\t\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\t}\n}"
  },
  {
    "function_name": "return_all_reservations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "706-717",
    "snippet": "static void return_all_reservations(struct gfs2_rgrpd *rgd)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_blkreserv *rs;\n\n\tspin_lock(&rgd->rd_rsspin);\n\twhile ((n = rb_first(&rgd->rd_rstree))) {\n\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\t__rs_deltree(rs);\n\t}\n\tspin_unlock(&rgd->rd_rsspin);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rs_deltree",
          "args": [
            "rs"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "__rs_deltree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "635-661",
          "snippet": "static void __rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (!gfs2_rs_active(rs))\n\t\treturn;\n\n\trgd = rs->rs_rbm.rgd;\n\ttrace_gfs2_rs(rs, TRACE_RS_TREEDEL);\n\trb_erase(&rs->rs_node, &rgd->rd_rstree);\n\tRB_CLEAR_NODE(&rs->rs_node);\n\n\tif (rs->rs_free) {\n\t\tstruct gfs2_bitmap *bi = rbm_bi(&rs->rs_rbm);\n\n\t\t/* return reserved blocks to the rgrp */\n\t\tBUG_ON(rs->rs_rbm.rgd->rd_reserved < rs->rs_free);\n\t\trs->rs_rbm.rgd->rd_reserved -= rs->rs_free;\n\t\t/* The rgrp extent failure point is likely not to increase;\n\t\t   it will only do so if the freed blocks are somehow\n\t\t   contiguous with a span of free blocks that follows. Still,\n\t\t   it will force the number to be recalculated later. */\n\t\trgd->rd_extfail_pt += rs->rs_free;\n\t\trs->rs_free = 0;\n\t\tclear_bit(GBF_FULL, &bi->bi_flags);\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void __rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (!gfs2_rs_active(rs))\n\t\treturn;\n\n\trgd = rs->rs_rbm.rgd;\n\ttrace_gfs2_rs(rs, TRACE_RS_TREEDEL);\n\trb_erase(&rs->rs_node, &rgd->rd_rstree);\n\tRB_CLEAR_NODE(&rs->rs_node);\n\n\tif (rs->rs_free) {\n\t\tstruct gfs2_bitmap *bi = rbm_bi(&rs->rs_rbm);\n\n\t\t/* return reserved blocks to the rgrp */\n\t\tBUG_ON(rs->rs_rbm.rgd->rd_reserved < rs->rs_free);\n\t\trs->rs_rbm.rgd->rd_reserved -= rs->rs_free;\n\t\t/* The rgrp extent failure point is likely not to increase;\n\t\t   it will only do so if the freed blocks are somehow\n\t\t   contiguous with a span of free blocks that follows. Still,\n\t\t   it will force the number to be recalculated later. */\n\t\trgd->rd_extfail_pt += rs->rs_free;\n\t\trs->rs_free = 0;\n\t\tclear_bit(GBF_FULL, &bi->bi_flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structgfs2_blkreserv",
            "rs_node"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&rgd->rd_rstree"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void return_all_reservations(struct gfs2_rgrpd *rgd)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_blkreserv *rs;\n\n\tspin_lock(&rgd->rd_rsspin);\n\twhile ((n = rb_first(&rgd->rd_rstree))) {\n\t\trs = rb_entry(n, struct gfs2_blkreserv, rs_node);\n\t\t__rs_deltree(rs);\n\t}\n\tspin_unlock(&rgd->rd_rsspin);\n}"
  },
  {
    "function_name": "gfs2_rs_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "686-696",
    "snippet": "void gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount)\n{\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res && ((wcount == NULL) || (atomic_read(wcount) <= 1))) {\n\t\tgfs2_rs_deltree(ip->i_res);\n\t\tBUG_ON(ip->i_res->rs_free);\n\t\tkmem_cache_free(gfs2_rsrv_cachep, ip->i_res);\n\t\tip->i_res = NULL;\n\t}\n\tup_write(&ip->i_rw_mutex);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "gfs2_rsrv_cachep",
            "ip->i_res"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ip->i_res->rs_free"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rs_deltree",
          "args": [
            "ip->i_res"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_deltree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "668-678",
          "snippet": "void gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rbm.rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rbm.rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "wcount"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount)\n{\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res && ((wcount == NULL) || (atomic_read(wcount) <= 1))) {\n\t\tgfs2_rs_deltree(ip->i_res);\n\t\tBUG_ON(ip->i_res->rs_free);\n\t\tkmem_cache_free(gfs2_rsrv_cachep, ip->i_res);\n\t\tip->i_res = NULL;\n\t}\n\tup_write(&ip->i_rw_mutex);\n}"
  },
  {
    "function_name": "gfs2_rs_deltree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "668-678",
    "snippet": "void gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rbm.rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rs_deltree",
          "args": [
            "rs"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "__rs_deltree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "635-661",
          "snippet": "static void __rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (!gfs2_rs_active(rs))\n\t\treturn;\n\n\trgd = rs->rs_rbm.rgd;\n\ttrace_gfs2_rs(rs, TRACE_RS_TREEDEL);\n\trb_erase(&rs->rs_node, &rgd->rd_rstree);\n\tRB_CLEAR_NODE(&rs->rs_node);\n\n\tif (rs->rs_free) {\n\t\tstruct gfs2_bitmap *bi = rbm_bi(&rs->rs_rbm);\n\n\t\t/* return reserved blocks to the rgrp */\n\t\tBUG_ON(rs->rs_rbm.rgd->rd_reserved < rs->rs_free);\n\t\trs->rs_rbm.rgd->rd_reserved -= rs->rs_free;\n\t\t/* The rgrp extent failure point is likely not to increase;\n\t\t   it will only do so if the freed blocks are somehow\n\t\t   contiguous with a span of free blocks that follows. Still,\n\t\t   it will force the number to be recalculated later. */\n\t\trgd->rd_extfail_pt += rs->rs_free;\n\t\trs->rs_free = 0;\n\t\tclear_bit(GBF_FULL, &bi->bi_flags);\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void __rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (!gfs2_rs_active(rs))\n\t\treturn;\n\n\trgd = rs->rs_rbm.rgd;\n\ttrace_gfs2_rs(rs, TRACE_RS_TREEDEL);\n\trb_erase(&rs->rs_node, &rgd->rd_rstree);\n\tRB_CLEAR_NODE(&rs->rs_node);\n\n\tif (rs->rs_free) {\n\t\tstruct gfs2_bitmap *bi = rbm_bi(&rs->rs_rbm);\n\n\t\t/* return reserved blocks to the rgrp */\n\t\tBUG_ON(rs->rs_rbm.rgd->rd_reserved < rs->rs_free);\n\t\trs->rs_rbm.rgd->rd_reserved -= rs->rs_free;\n\t\t/* The rgrp extent failure point is likely not to increase;\n\t\t   it will only do so if the freed blocks are somehow\n\t\t   contiguous with a span of free blocks that follows. Still,\n\t\t   it will force the number to be recalculated later. */\n\t\trgd->rd_extfail_pt += rs->rs_free;\n\t\trs->rs_free = 0;\n\t\tclear_bit(GBF_FULL, &bi->bi_flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rgd->rd_rsspin"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\trgd = rs->rs_rbm.rgd;\n\tif (rgd) {\n\t\tspin_lock(&rgd->rd_rsspin);\n\t\t__rs_deltree(rs);\n\t\tspin_unlock(&rgd->rd_rsspin);\n\t}\n}"
  },
  {
    "function_name": "__rs_deltree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "635-661",
    "snippet": "static void __rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (!gfs2_rs_active(rs))\n\t\treturn;\n\n\trgd = rs->rs_rbm.rgd;\n\ttrace_gfs2_rs(rs, TRACE_RS_TREEDEL);\n\trb_erase(&rs->rs_node, &rgd->rd_rstree);\n\tRB_CLEAR_NODE(&rs->rs_node);\n\n\tif (rs->rs_free) {\n\t\tstruct gfs2_bitmap *bi = rbm_bi(&rs->rs_rbm);\n\n\t\t/* return reserved blocks to the rgrp */\n\t\tBUG_ON(rs->rs_rbm.rgd->rd_reserved < rs->rs_free);\n\t\trs->rs_rbm.rgd->rd_reserved -= rs->rs_free;\n\t\t/* The rgrp extent failure point is likely not to increase;\n\t\t   it will only do so if the freed blocks are somehow\n\t\t   contiguous with a span of free blocks that follows. Still,\n\t\t   it will force the number to be recalculated later. */\n\t\trgd->rd_extfail_pt += rs->rs_free;\n\t\trs->rs_free = 0;\n\t\tclear_bit(GBF_FULL, &bi->bi_flags);\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "GBF_FULL",
            "&bi->bi_flags"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rs->rs_rbm.rgd->rd_reserved < rs->rs_free"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbm_bi",
          "args": [
            "&rs->rs_rbm"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "rbm_bi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "112-115",
          "snippet": "static inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&rs->rs_node"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&rs->rs_node",
            "&rgd->rd_rstree"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_gfs2_rs",
          "args": [
            "rs",
            "TRACE_RS_TREEDEL"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rs_active",
          "args": [
            "rs"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rs_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.h",
          "lines": "79-82",
          "snippet": "static inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic inline bool gfs2_rs_active(struct gfs2_blkreserv *rs)\n{\n\treturn rs && !RB_EMPTY_NODE(&rs->rs_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void __rs_deltree(struct gfs2_blkreserv *rs)\n{\n\tstruct gfs2_rgrpd *rgd;\n\n\tif (!gfs2_rs_active(rs))\n\t\treturn;\n\n\trgd = rs->rs_rbm.rgd;\n\ttrace_gfs2_rs(rs, TRACE_RS_TREEDEL);\n\trb_erase(&rs->rs_node, &rgd->rd_rstree);\n\tRB_CLEAR_NODE(&rs->rs_node);\n\n\tif (rs->rs_free) {\n\t\tstruct gfs2_bitmap *bi = rbm_bi(&rs->rs_rbm);\n\n\t\t/* return reserved blocks to the rgrp */\n\t\tBUG_ON(rs->rs_rbm.rgd->rd_reserved < rs->rs_free);\n\t\trs->rs_rbm.rgd->rd_reserved -= rs->rs_free;\n\t\t/* The rgrp extent failure point is likely not to increase;\n\t\t   it will only do so if the freed blocks are somehow\n\t\t   contiguous with a span of free blocks that follows. Still,\n\t\t   it will force the number to be recalculated later. */\n\t\trgd->rd_extfail_pt += rs->rs_free;\n\t\trs->rs_free = 0;\n\t\tclear_bit(GBF_FULL, &bi->bi_flags);\n\t}\n}"
  },
  {
    "function_name": "dump_rs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "622-628",
    "snippet": "static void dump_rs(struct seq_file *seq, const struct gfs2_blkreserv *rs)\n{\n\tgfs2_print_dbg(seq, \"  B: n:%llu s:%llu b:%u f:%u\\n\",\n\t\t       (unsigned long long)rs->rs_inum,\n\t\t       (unsigned long long)gfs2_rbm_to_block(&rs->rs_rbm),\n\t\t       rs->rs_rbm.offset, rs->rs_free);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_print_dbg",
          "args": [
            "seq",
            "\"  B: n:%llu s:%llu b:%u f:%u\\n\"",
            "(unsigned long long)rs->rs_inum",
            "(unsigned long long)gfs2_rbm_to_block(&rs->rs_rbm)",
            "rs->rs_rbm.offset",
            "rs->rs_free"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_print_dbg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "897-914",
          "snippet": "void gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (seq) {\n\t\tseq_vprintf(seq, fmt, args);\n\t} else {\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tpr_err(\"%pV\", &vaf);\n\t}\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (seq) {\n\t\tseq_vprintf(seq, fmt, args);\n\t} else {\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tpr_err(\"%pV\", &vaf);\n\t}\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_to_block",
          "args": [
            "&rs->rs_rbm"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "117-121",
          "snippet": "static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void dump_rs(struct seq_file *seq, const struct gfs2_blkreserv *rs)\n{\n\tgfs2_print_dbg(seq, \"  B: n:%llu s:%llu b:%u f:%u\\n\",\n\t\t       (unsigned long long)rs->rs_inum,\n\t\t       (unsigned long long)gfs2_rbm_to_block(&rs->rs_rbm),\n\t\t       rs->rs_rbm.offset, rs->rs_free);\n}"
  },
  {
    "function_name": "gfs2_rs_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "602-620",
    "snippet": "int gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&ip->i_res->rs_node"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "gfs2_rsrv_cachep",
            "GFP_NOFS"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ip->i_rw_mutex"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rs_alloc(struct gfs2_inode *ip)\n{\n\tint error = 0;\n\n\tdown_write(&ip->i_rw_mutex);\n\tif (ip->i_res)\n\t\tgoto out;\n\n\tip->i_res = kmem_cache_zalloc(gfs2_rsrv_cachep, GFP_NOFS);\n\tif (!ip->i_res) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tRB_CLEAR_NODE(&ip->i_res->rs_node);\nout:\n\tup_write(&ip->i_rw_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_free_clones",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "587-596",
    "snippet": "void gfs2_free_clones(struct gfs2_rgrpd *rgd)\n{\n\tint x;\n\n\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\tkfree(bi->bi_clone);\n\t\tbi->bi_clone = NULL;\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bi->bi_clone"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_free_clones(struct gfs2_rgrpd *rgd)\n{\n\tint x;\n\n\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\tkfree(bi->bi_clone);\n\t\tbi->bi_clone = NULL;\n\t}\n}"
  },
  {
    "function_name": "check_and_update_goal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "580-585",
    "snippet": "void check_and_update_goal(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tif (!ip->i_goal || gfs2_blk2rgrpd(sdp, ip->i_goal, 1) == NULL)\n\t\tip->i_goal = ip->i_no_addr;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_blk2rgrpd",
          "args": [
            "sdp",
            "ip->i_goal",
            "1"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_blk2rgrpd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "503-532",
          "snippet": "struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid check_and_update_goal(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tif (!ip->i_goal || gfs2_blk2rgrpd(sdp, ip->i_goal, 1) == NULL)\n\t\tip->i_goal = ip->i_no_addr;\n}"
  },
  {
    "function_name": "gfs2_rgrpd_get_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "561-578",
    "snippet": "struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tconst struct rb_node *n;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_next(&rgd->rd_node);\n\tif (n == NULL)\n\t\tn = rb_first(&sdp->sd_rindex_tree);\n\n\tif (unlikely(&rgd->rd_node == n)) {\n\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\treturn NULL;\n\t}\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\treturn rgd;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_rindex_spin"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structgfs2_rgrpd",
            "rd_node"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "&rgd->rd_node == n"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&sdp->sd_rindex_tree"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&rgd->rd_node"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_rindex_spin"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tconst struct rb_node *n;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_next(&rgd->rd_node);\n\tif (n == NULL)\n\t\tn = rb_first(&sdp->sd_rindex_tree);\n\n\tif (unlikely(&rgd->rd_node == n)) {\n\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\treturn NULL;\n\t}\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\treturn rgd;\n}"
  },
  {
    "function_name": "gfs2_rgrpd_get_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "541-552",
    "snippet": "struct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp)\n{\n\tconst struct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_first(&sdp->sd_rindex_tree);\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn rgd;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_rindex_spin"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structgfs2_rgrpd",
            "rd_node"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&sdp->sd_rindex_tree"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_rindex_spin"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_rgrpd_get_first(struct gfs2_sbd *sdp)\n{\n\tconst struct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = rb_first(&sdp->sd_rindex_tree);\n\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn rgd;\n}"
  },
  {
    "function_name": "gfs2_blk2rgrpd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "503-532",
    "snippet": "struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_rindex_spin"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structgfs2_rgrpd",
            "rd_node"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_rindex_spin"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "rgrp_contains_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "487-492",
    "snippet": "static inline int rgrp_contains_block(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tu64 first = rgd->rd_data0;\n\tu64 last = first + rgd->rd_data;\n\treturn first <= block && block < last;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int rgrp_contains_block(struct gfs2_rgrpd *rgd, u64 block)\n{\n\tu64 first = rgd->rd_data0;\n\tu64 last = first + rgd->rd_data;\n\treturn first <= block && block < last;\n}"
  },
  {
    "function_name": "gfs2_rgrp_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "444-485",
    "snippet": "void gfs2_rgrp_verify(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_bitmap *bi = NULL;\n\tu32 length = rgd->rd_length;\n\tu32 count[4], tmp;\n\tint buf, x;\n\n\tmemset(count, 0, 4 * sizeof(u32));\n\n\t/* Count # blocks in each of 4 possible allocation states */\n\tfor (buf = 0; buf < length; buf++) {\n\t\tbi = rgd->rd_bits + buf;\n\t\tfor (x = 0; x < 4; x++)\n\t\t\tcount[x] += gfs2_bitcount(rgd,\n\t\t\t\t\t\t  bi->bi_bh->b_data +\n\t\t\t\t\t\t  bi->bi_offset,\n\t\t\t\t\t\t  bi->bi_len, x);\n\t}\n\n\tif (count[0] != rgd->rd_free) {\n\t\tif (gfs2_consist_rgrpd(rgd))\n\t\t\tfs_err(sdp, \"free data mismatch:  %u != %u\\n\",\n\t\t\t       count[0], rgd->rd_free);\n\t\treturn;\n\t}\n\n\ttmp = rgd->rd_data - rgd->rd_free - rgd->rd_dinodes;\n\tif (count[1] != tmp) {\n\t\tif (gfs2_consist_rgrpd(rgd))\n\t\t\tfs_err(sdp, \"used data mismatch:  %u != %u\\n\",\n\t\t\t       count[1], tmp);\n\t\treturn;\n\t}\n\n\tif (count[2] + count[3] != rgd->rd_dinodes) {\n\t\tif (gfs2_consist_rgrpd(rgd))\n\t\t\tfs_err(sdp, \"used metadata mismatch:  %u != %u\\n\",\n\t\t\t       count[2] + count[3], rgd->rd_dinodes);\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"used metadata mismatch:  %u != %u\\n\"",
            "count[2] + count[3]",
            "rgd->rd_dinodes"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist_rgrpd",
          "args": [
            "rgd"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_rgrpd",
          "args": [
            "rgd"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_rgrpd",
          "args": [
            "rgd"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_bitcount",
          "args": [
            "rgd",
            "bi->bi_bh->b_data +\n\t\t\t\t\t\t  bi->bi_offset",
            "bi->bi_len",
            "x"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_bitcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "414-436",
          "snippet": "static u32 gfs2_bitcount(struct gfs2_rgrpd *rgd, const u8 *buffer,\n\t\t\t unsigned int buflen, u8 state)\n{\n\tconst u8 *byte = buffer;\n\tconst u8 *end = buffer + buflen;\n\tconst u8 state1 = state << 2;\n\tconst u8 state2 = state << 4;\n\tconst u8 state3 = state << 6;\n\tu32 count = 0;\n\n\tfor (; byte < end; byte++) {\n\t\tif (((*byte) & 0x03) == state)\n\t\t\tcount++;\n\t\tif (((*byte) & 0x0C) == state1)\n\t\t\tcount++;\n\t\tif (((*byte) & 0x30) == state2)\n\t\t\tcount++;\n\t\tif (((*byte) & 0xC0) == state3)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u32 gfs2_bitcount(struct gfs2_rgrpd *rgd, const u8 *buffer,\n\t\t\t unsigned int buflen, u8 state)\n{\n\tconst u8 *byte = buffer;\n\tconst u8 *end = buffer + buflen;\n\tconst u8 state1 = state << 2;\n\tconst u8 state2 = state << 4;\n\tconst u8 state3 = state << 6;\n\tu32 count = 0;\n\n\tfor (; byte < end; byte++) {\n\t\tif (((*byte) & 0x03) == state)\n\t\t\tcount++;\n\t\tif (((*byte) & 0x0C) == state1)\n\t\t\tcount++;\n\t\tif (((*byte) & 0x30) == state2)\n\t\t\tcount++;\n\t\tif (((*byte) & 0xC0) == state3)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "count",
            "0",
            "4 * sizeof(u32)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rgrp_verify(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tstruct gfs2_bitmap *bi = NULL;\n\tu32 length = rgd->rd_length;\n\tu32 count[4], tmp;\n\tint buf, x;\n\n\tmemset(count, 0, 4 * sizeof(u32));\n\n\t/* Count # blocks in each of 4 possible allocation states */\n\tfor (buf = 0; buf < length; buf++) {\n\t\tbi = rgd->rd_bits + buf;\n\t\tfor (x = 0; x < 4; x++)\n\t\t\tcount[x] += gfs2_bitcount(rgd,\n\t\t\t\t\t\t  bi->bi_bh->b_data +\n\t\t\t\t\t\t  bi->bi_offset,\n\t\t\t\t\t\t  bi->bi_len, x);\n\t}\n\n\tif (count[0] != rgd->rd_free) {\n\t\tif (gfs2_consist_rgrpd(rgd))\n\t\t\tfs_err(sdp, \"free data mismatch:  %u != %u\\n\",\n\t\t\t       count[0], rgd->rd_free);\n\t\treturn;\n\t}\n\n\ttmp = rgd->rd_data - rgd->rd_free - rgd->rd_dinodes;\n\tif (count[1] != tmp) {\n\t\tif (gfs2_consist_rgrpd(rgd))\n\t\t\tfs_err(sdp, \"used data mismatch:  %u != %u\\n\",\n\t\t\t       count[1], tmp);\n\t\treturn;\n\t}\n\n\tif (count[2] + count[3] != rgd->rd_dinodes) {\n\t\tif (gfs2_consist_rgrpd(rgd))\n\t\t\tfs_err(sdp, \"used metadata mismatch:  %u != %u\\n\",\n\t\t\t       count[2] + count[3], rgd->rd_dinodes);\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "gfs2_bitcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "414-436",
    "snippet": "static u32 gfs2_bitcount(struct gfs2_rgrpd *rgd, const u8 *buffer,\n\t\t\t unsigned int buflen, u8 state)\n{\n\tconst u8 *byte = buffer;\n\tconst u8 *end = buffer + buflen;\n\tconst u8 state1 = state << 2;\n\tconst u8 state2 = state << 4;\n\tconst u8 state3 = state << 6;\n\tu32 count = 0;\n\n\tfor (; byte < end; byte++) {\n\t\tif (((*byte) & 0x03) == state)\n\t\t\tcount++;\n\t\tif (((*byte) & 0x0C) == state1)\n\t\t\tcount++;\n\t\tif (((*byte) & 0x30) == state2)\n\t\t\tcount++;\n\t\tif (((*byte) & 0xC0) == state3)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u32 gfs2_bitcount(struct gfs2_rgrpd *rgd, const u8 *buffer,\n\t\t\t unsigned int buflen, u8 state)\n{\n\tconst u8 *byte = buffer;\n\tconst u8 *end = buffer + buflen;\n\tconst u8 state1 = state << 2;\n\tconst u8 state2 = state << 4;\n\tconst u8 state3 = state << 6;\n\tu32 count = 0;\n\n\tfor (; byte < end; byte++) {\n\t\tif (((*byte) & 0x03) == state)\n\t\t\tcount++;\n\t\tif (((*byte) & 0x0C) == state1)\n\t\t\tcount++;\n\t\tif (((*byte) & 0x30) == state2)\n\t\t\tcount++;\n\t\tif (((*byte) & 0xC0) == state3)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "gfs2_free_extlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "353-402",
    "snippet": "static u32 gfs2_free_extlen(const struct gfs2_rbm *rrbm, u32 len)\n{\n\tstruct gfs2_rbm rbm = *rrbm;\n\tu32 n_unaligned = rbm.offset & 3;\n\tu32 size = len;\n\tu32 bytes;\n\tu32 chunk_size;\n\tu8 *ptr, *start, *end;\n\tu64 block;\n\tstruct gfs2_bitmap *bi;\n\n\tif (n_unaligned &&\n\t    gfs2_unaligned_extlen(&rbm, 4 - n_unaligned, &len))\n\t\tgoto out;\n\n\tn_unaligned = len & 3;\n\t/* Start is now byte aligned */\n\twhile (len > 3) {\n\t\tbi = rbm_bi(&rbm);\n\t\tstart = bi->bi_bh->b_data;\n\t\tif (bi->bi_clone)\n\t\t\tstart = bi->bi_clone;\n\t\tend = start + bi->bi_bh->b_size;\n\t\tstart += bi->bi_offset;\n\t\tBUG_ON(rbm.offset & 3);\n\t\tstart += (rbm.offset / GFS2_NBBY);\n\t\tbytes = min_t(u32, len / GFS2_NBBY, (end - start));\n\t\tptr = memchr_inv(start, 0, bytes);\n\t\tchunk_size = ((ptr == NULL) ? bytes : (ptr - start));\n\t\tchunk_size *= GFS2_NBBY;\n\t\tBUG_ON(len < chunk_size);\n\t\tlen -= chunk_size;\n\t\tblock = gfs2_rbm_to_block(&rbm);\n\t\tif (gfs2_rbm_from_block(&rbm, block + chunk_size)) {\n\t\t\tn_unaligned = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ptr) {\n\t\t\tn_unaligned = 3;\n\t\t\tbreak;\n\t\t}\n\t\tn_unaligned = len & 3;\n\t}\n\n\t/* Deal with any bits left over at the end */\n\tif (n_unaligned)\n\t\tgfs2_unaligned_extlen(&rbm, n_unaligned, &len);\nout:\n\treturn size - len;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_unaligned_extlen",
          "args": [
            "&rbm",
            "n_unaligned",
            "&len"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_unaligned_extlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "319-336",
          "snippet": "static bool gfs2_unaligned_extlen(struct gfs2_rbm *rbm, u32 n_unaligned, u32 *len)\n{\n\tu32 n;\n\tu8 res;\n\n\tfor (n = 0; n < n_unaligned; n++) {\n\t\tres = gfs2_testbit(rbm);\n\t\tif (res != GFS2_BLKST_FREE)\n\t\t\treturn true;\n\t\t(*len)--;\n\t\tif (*len == 0)\n\t\t\treturn true;\n\t\tif (gfs2_rbm_incr(rbm))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic bool gfs2_unaligned_extlen(struct gfs2_rbm *rbm, u32 n_unaligned, u32 *len)\n{\n\tu32 n;\n\tu8 res;\n\n\tfor (n = 0; n < n_unaligned; n++) {\n\t\tres = gfs2_testbit(rbm);\n\t\tif (res != GFS2_BLKST_FREE)\n\t\t\treturn true;\n\t\t(*len)--;\n\t\tif (*len == 0)\n\t\t\treturn true;\n\t\tif (gfs2_rbm_incr(rbm))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_from_block",
          "args": [
            "&rbm",
            "block + chunk_size"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_from_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "261-282",
          "snippet": "static int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rbm_to_block",
          "args": [
            "&rbm"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "117-121",
          "snippet": "static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len < chunk_size"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "start",
            "0",
            "bytes"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "len / GFS2_NBBY",
            "(end - start)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rbm.offset & 3"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbm_bi",
          "args": [
            "&rbm"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "rbm_bi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "112-115",
          "snippet": "static inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic u32 gfs2_free_extlen(const struct gfs2_rbm *rrbm, u32 len)\n{\n\tstruct gfs2_rbm rbm = *rrbm;\n\tu32 n_unaligned = rbm.offset & 3;\n\tu32 size = len;\n\tu32 bytes;\n\tu32 chunk_size;\n\tu8 *ptr, *start, *end;\n\tu64 block;\n\tstruct gfs2_bitmap *bi;\n\n\tif (n_unaligned &&\n\t    gfs2_unaligned_extlen(&rbm, 4 - n_unaligned, &len))\n\t\tgoto out;\n\n\tn_unaligned = len & 3;\n\t/* Start is now byte aligned */\n\twhile (len > 3) {\n\t\tbi = rbm_bi(&rbm);\n\t\tstart = bi->bi_bh->b_data;\n\t\tif (bi->bi_clone)\n\t\t\tstart = bi->bi_clone;\n\t\tend = start + bi->bi_bh->b_size;\n\t\tstart += bi->bi_offset;\n\t\tBUG_ON(rbm.offset & 3);\n\t\tstart += (rbm.offset / GFS2_NBBY);\n\t\tbytes = min_t(u32, len / GFS2_NBBY, (end - start));\n\t\tptr = memchr_inv(start, 0, bytes);\n\t\tchunk_size = ((ptr == NULL) ? bytes : (ptr - start));\n\t\tchunk_size *= GFS2_NBBY;\n\t\tBUG_ON(len < chunk_size);\n\t\tlen -= chunk_size;\n\t\tblock = gfs2_rbm_to_block(&rbm);\n\t\tif (gfs2_rbm_from_block(&rbm, block + chunk_size)) {\n\t\t\tn_unaligned = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ptr) {\n\t\t\tn_unaligned = 3;\n\t\t\tbreak;\n\t\t}\n\t\tn_unaligned = len & 3;\n\t}\n\n\t/* Deal with any bits left over at the end */\n\tif (n_unaligned)\n\t\tgfs2_unaligned_extlen(&rbm, n_unaligned, &len);\nout:\n\treturn size - len;\n}"
  },
  {
    "function_name": "gfs2_unaligned_extlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "319-336",
    "snippet": "static bool gfs2_unaligned_extlen(struct gfs2_rbm *rbm, u32 n_unaligned, u32 *len)\n{\n\tu32 n;\n\tu8 res;\n\n\tfor (n = 0; n < n_unaligned; n++) {\n\t\tres = gfs2_testbit(rbm);\n\t\tif (res != GFS2_BLKST_FREE)\n\t\t\treturn true;\n\t\t(*len)--;\n\t\tif (*len == 0)\n\t\t\treturn true;\n\t\tif (gfs2_rbm_incr(rbm))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rbm_incr",
          "args": [
            "rbm"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_incr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "296-308",
          "snippet": "static bool gfs2_rbm_incr(struct gfs2_rbm *rbm)\n{\n\tif (rbm->offset + 1 < rbm_bi(rbm)->bi_blocks) { /* in the same bitmap */\n\t\trbm->offset++;\n\t\treturn false;\n\t}\n\tif (rbm->bii == rbm->rgd->rd_length - 1) /* at the last bitmap */\n\t\treturn true;\n\n\trbm->offset = 0;\n\trbm->bii++;\n\treturn false;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic bool gfs2_rbm_incr(struct gfs2_rbm *rbm)\n{\n\tif (rbm->offset + 1 < rbm_bi(rbm)->bi_blocks) { /* in the same bitmap */\n\t\trbm->offset++;\n\t\treturn false;\n\t}\n\tif (rbm->bii == rbm->rgd->rd_length - 1) /* at the last bitmap */\n\t\treturn true;\n\n\trbm->offset = 0;\n\trbm->bii++;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_testbit",
          "args": [
            "rbm"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_testbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "130-141",
          "snippet": "static inline u8 gfs2_testbit(const struct gfs2_rbm *rbm)\n{\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tconst u8 *buffer = bi->bi_bh->b_data + bi->bi_offset;\n\tconst u8 *byte;\n\tunsigned int bit;\n\n\tbyte = buffer + (rbm->offset / GFS2_NBBY);\n\tbit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\treturn (*byte >> bit) & GFS2_BIT_MASK;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline u8 gfs2_testbit(const struct gfs2_rbm *rbm)\n{\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tconst u8 *buffer = bi->bi_bh->b_data + bi->bi_offset;\n\tconst u8 *byte;\n\tunsigned int bit;\n\n\tbyte = buffer + (rbm->offset / GFS2_NBBY);\n\tbit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\treturn (*byte >> bit) & GFS2_BIT_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic bool gfs2_unaligned_extlen(struct gfs2_rbm *rbm, u32 n_unaligned, u32 *len)\n{\n\tu32 n;\n\tu8 res;\n\n\tfor (n = 0; n < n_unaligned; n++) {\n\t\tres = gfs2_testbit(rbm);\n\t\tif (res != GFS2_BLKST_FREE)\n\t\t\treturn true;\n\t\t(*len)--;\n\t\tif (*len == 0)\n\t\t\treturn true;\n\t\tif (gfs2_rbm_incr(rbm))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "gfs2_rbm_incr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "296-308",
    "snippet": "static bool gfs2_rbm_incr(struct gfs2_rbm *rbm)\n{\n\tif (rbm->offset + 1 < rbm_bi(rbm)->bi_blocks) { /* in the same bitmap */\n\t\trbm->offset++;\n\t\treturn false;\n\t}\n\tif (rbm->bii == rbm->rgd->rd_length - 1) /* at the last bitmap */\n\t\treturn true;\n\n\trbm->offset = 0;\n\trbm->bii++;\n\treturn false;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rbm_bi",
          "args": [
            "rbm"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "rbm_bi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "112-115",
          "snippet": "static inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic bool gfs2_rbm_incr(struct gfs2_rbm *rbm)\n{\n\tif (rbm->offset + 1 < rbm_bi(rbm)->bi_blocks) { /* in the same bitmap */\n\t\trbm->offset++;\n\t\treturn false;\n\t}\n\tif (rbm->bii == rbm->rgd->rd_length - 1) /* at the last bitmap */\n\t\treturn true;\n\n\trbm->offset = 0;\n\trbm->bii++;\n\treturn false;\n}"
  },
  {
    "function_name": "gfs2_rbm_from_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "261-282",
    "snippet": "static int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rbm_bi",
          "args": [
            "rbm"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "rbm_bi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "112-115",
          "snippet": "static inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "rblock"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rblock > UINT_MAX"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_rbm_from_block(struct gfs2_rbm *rbm, u64 block)\n{\n\tu64 rblock = block - rbm->rgd->rd_data0;\n\n\tif (WARN_ON_ONCE(rblock > UINT_MAX))\n\t\treturn -EINVAL;\n\tif (block >= rbm->rgd->rd_data0 + rbm->rgd->rd_data)\n\t\treturn -E2BIG;\n\n\trbm->bii = 0;\n\trbm->offset = (u32)(rblock);\n\t/* Check if the block is within the first block */\n\tif (rbm->offset < rbm_bi(rbm)->bi_blocks)\n\t\treturn 0;\n\n\t/* Adjust for the size diff between gfs2_meta_header and gfs2_rgrp */\n\trbm->offset += (sizeof(struct gfs2_rgrp) -\n\t\t\tsizeof(struct gfs2_meta_header)) * GFS2_NBBY;\n\trbm->bii = rbm->offset / rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\trbm->offset -= rbm->bii * rbm->rgd->rd_sbd->sd_blocks_per_bitmap;\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_bitfit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "218-246",
    "snippet": "static u32 gfs2_bitfit(const u8 *buf, const unsigned int len,\n\t\t       u32 goal, u8 state)\n{\n\tu32 spoint = (goal << 1) & ((8*sizeof(u64)) - 1);\n\tconst __le64 *ptr = ((__le64 *)buf) + (goal >> 5);\n\tconst __le64 *end = (__le64 *)(buf + ALIGN(len, sizeof(u64)));\n\tu64 tmp;\n\tu64 mask = 0x5555555555555555ULL;\n\tu32 bit;\n\n\t/* Mask off bits we don't care about at the start of the search */\n\tmask <<= spoint;\n\ttmp = gfs2_bit_search(ptr, mask, state);\n\tptr++;\n\twhile(tmp == 0 && ptr < end) {\n\t\ttmp = gfs2_bit_search(ptr, 0x5555555555555555ULL, state);\n\t\tptr++;\n\t}\n\t/* Mask off any bits which are more than len bytes from the start */\n\tif (ptr == end && (len & (sizeof(u64) - 1)))\n\t\ttmp &= (((u64)~0) >> (64 - 8*(len & (sizeof(u64) - 1))));\n\t/* Didn't find anything, so return */\n\tif (tmp == 0)\n\t\treturn BFITNOENT;\n\tptr--;\n\tbit = __ffs64(tmp);\n\tbit /= 2;\t/* two bits per entry in the bitmap */\n\treturn (((const unsigned char *)ptr - buf) * GFS2_NBBY) + bit;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define BFITNOENT ((u32)~0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ffs64",
          "args": [
            "tmp"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_bit_search",
          "args": [
            "ptr",
            "0x5555555555555555ULL",
            "state"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_bit_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "161-174",
          "snippet": "static inline u64 gfs2_bit_search(const __le64 *ptr, u64 mask, u8 state)\n{\n\tu64 tmp;\n\tstatic const u64 search[] = {\n\t\t[0] = 0xffffffffffffffffULL,\n\t\t[1] = 0xaaaaaaaaaaaaaaaaULL,\n\t\t[2] = 0x5555555555555555ULL,\n\t\t[3] = 0x0000000000000000ULL,\n\t};\n\ttmp = le64_to_cpu(*ptr) ^ search[state];\n\ttmp &= (tmp >> 1);\n\ttmp &= mask;\n\treturn tmp;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline u64 gfs2_bit_search(const __le64 *ptr, u64 mask, u8 state)\n{\n\tu64 tmp;\n\tstatic const u64 search[] = {\n\t\t[0] = 0xffffffffffffffffULL,\n\t\t[1] = 0xaaaaaaaaaaaaaaaaULL,\n\t\t[2] = 0x5555555555555555ULL,\n\t\t[3] = 0x0000000000000000ULL,\n\t};\n\ttmp = le64_to_cpu(*ptr) ^ search[state];\n\ttmp &= (tmp >> 1);\n\ttmp &= mask;\n\treturn tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "len",
            "sizeof(u64)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define BFITNOENT ((u32)~0)\n\nstatic u32 gfs2_bitfit(const u8 *buf, const unsigned int len,\n\t\t       u32 goal, u8 state)\n{\n\tu32 spoint = (goal << 1) & ((8*sizeof(u64)) - 1);\n\tconst __le64 *ptr = ((__le64 *)buf) + (goal >> 5);\n\tconst __le64 *end = (__le64 *)(buf + ALIGN(len, sizeof(u64)));\n\tu64 tmp;\n\tu64 mask = 0x5555555555555555ULL;\n\tu32 bit;\n\n\t/* Mask off bits we don't care about at the start of the search */\n\tmask <<= spoint;\n\ttmp = gfs2_bit_search(ptr, mask, state);\n\tptr++;\n\twhile(tmp == 0 && ptr < end) {\n\t\ttmp = gfs2_bit_search(ptr, 0x5555555555555555ULL, state);\n\t\tptr++;\n\t}\n\t/* Mask off any bits which are more than len bytes from the start */\n\tif (ptr == end && (len & (sizeof(u64) - 1)))\n\t\ttmp &= (((u64)~0) >> (64 - 8*(len & (sizeof(u64) - 1))));\n\t/* Didn't find anything, so return */\n\tif (tmp == 0)\n\t\treturn BFITNOENT;\n\tptr--;\n\tbit = __ffs64(tmp);\n\tbit /= 2;\t/* two bits per entry in the bitmap */\n\treturn (((const unsigned char *)ptr - buf) * GFS2_NBBY) + bit;\n}"
  },
  {
    "function_name": "rs_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "186-195",
    "snippet": "static inline int rs_cmp(u64 blk, u32 len, struct gfs2_blkreserv *rs)\n{\n\tu64 startblk = gfs2_rbm_to_block(&rs->rs_rbm);\n\n\tif (blk >= startblk + rs->rs_free)\n\t\treturn 1;\n\tif (blk + len - 1 < startblk)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_rbm_to_block",
          "args": [
            "&rs->rs_rbm"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rbm_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "117-121",
          "snippet": "static inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline u64 gfs2_rbm_to_block(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_data0 + (rbm_bi(rbm)->bi_start * GFS2_NBBY) +\n\t\trbm->offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline int rs_cmp(u64 blk, u32 len, struct gfs2_blkreserv *rs)\n{\n\tu64 startblk = gfs2_rbm_to_block(&rs->rs_rbm);\n\n\tif (blk >= startblk + rs->rs_free)\n\t\treturn 1;\n\tif (blk + len - 1 < startblk)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_bit_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "161-174",
    "snippet": "static inline u64 gfs2_bit_search(const __le64 *ptr, u64 mask, u8 state)\n{\n\tu64 tmp;\n\tstatic const u64 search[] = {\n\t\t[0] = 0xffffffffffffffffULL,\n\t\t[1] = 0xaaaaaaaaaaaaaaaaULL,\n\t\t[2] = 0x5555555555555555ULL,\n\t\t[3] = 0x0000000000000000ULL,\n\t};\n\ttmp = le64_to_cpu(*ptr) ^ search[state];\n\ttmp &= (tmp >> 1);\n\ttmp &= mask;\n\treturn tmp;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "*ptr"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline u64 gfs2_bit_search(const __le64 *ptr, u64 mask, u8 state)\n{\n\tu64 tmp;\n\tstatic const u64 search[] = {\n\t\t[0] = 0xffffffffffffffffULL,\n\t\t[1] = 0xaaaaaaaaaaaaaaaaULL,\n\t\t[2] = 0x5555555555555555ULL,\n\t\t[3] = 0x0000000000000000ULL,\n\t};\n\ttmp = le64_to_cpu(*ptr) ^ search[state];\n\ttmp &= (tmp >> 1);\n\ttmp &= mask;\n\treturn tmp;\n}"
  },
  {
    "function_name": "gfs2_testbit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "130-141",
    "snippet": "static inline u8 gfs2_testbit(const struct gfs2_rbm *rbm)\n{\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tconst u8 *buffer = bi->bi_bh->b_data + bi->bi_offset;\n\tconst u8 *byte;\n\tunsigned int bit;\n\n\tbyte = buffer + (rbm->offset / GFS2_NBBY);\n\tbit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\treturn (*byte >> bit) & GFS2_BIT_MASK;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rbm_bi",
          "args": [
            "rbm"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "rbm_bi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "112-115",
          "snippet": "static inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline u8 gfs2_testbit(const struct gfs2_rbm *rbm)\n{\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tconst u8 *buffer = bi->bi_bh->b_data + bi->bi_offset;\n\tconst u8 *byte;\n\tunsigned int bit;\n\n\tbyte = buffer + (rbm->offset / GFS2_NBBY);\n\tbit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\treturn (*byte >> bit) & GFS2_BIT_MASK;\n}"
  },
  {
    "function_name": "gfs2_setbit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
    "lines": "88-121",
    "snippet": "static inline void gfs2_setbit(const struct gfs2_rbm *rbm, bool do_clone,\n\t\t\t       unsigned char new_state)\n{\n\tunsigned char *byte1, *byte2, *end, cur_state;\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tunsigned int buflen = bi->bi_len;\n\tconst unsigned int bit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\tbyte1 = bi->bi_bh->b_data + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\tend = bi->bi_bh->b_data + bi->bi_offset + buflen;\n\n\tBUG_ON(byte1 >= end);\n\n\tcur_state = (*byte1 >> bit) & GFS2_BIT_MASK;\n\n\tif (unlikely(!valid_change[new_state * 4 + cur_state])) {\n\t\tpr_warn(\"buf_blk = 0x%x old_state=%d, new_state=%d\\n\",\n\t\t\trbm->offset, cur_state, new_state);\n\t\tpr_warn(\"rgrp=0x%llx bi_start=0x%x\\n\",\n\t\t\t(unsigned long long)rbm->rgd->rd_addr, bi->bi_start);\n\t\tpr_warn(\"bi_offset=0x%x bi_len=0x%x\\n\",\n\t\t\tbi->bi_offset, bi->bi_len);\n\t\tdump_stack();\n\t\tgfs2_consist_rgrpd(rbm->rgd);\n\t\treturn;\n\t}\n\t*byte1 ^= (cur_state ^ new_state) << bit;\n\n\tif (do_clone && bi->bi_clone) {\n\t\tbyte2 = bi->bi_clone + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\t\tcur_state = (*byte2 >> bit) & GFS2_BIT_MASK;\n\t\t*byte2 ^= (cur_state ^ new_state) << bit;\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"inode.h\"",
      "#include \"log.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"super.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/random.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char valid_change[16] = {\n\t        /* current */\n\t/* n */ 0, 1, 1, 1,\n\t/* e */ 1, 0, 0, 0,\n\t/* w */ 0, 0, 0, 1,\n\t        1, 0, 0, 0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_consist_rgrpd",
          "args": [
            "rbm->rgd"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"bi_offset=0x%x bi_len=0x%x\\n\"",
            "bi->bi_offset",
            "bi->bi_len"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"rgrp=0x%llx bi_start=0x%x\\n\"",
            "(unsigned long long)rbm->rgd->rd_addr",
            "bi->bi_start"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"buf_blk = 0x%x old_state=%d, new_state=%d\\n\"",
            "rbm->offset",
            "cur_state",
            "new_state"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!valid_change[new_state * 4 + cur_state]"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "byte1 >= end"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbm_bi",
          "args": [
            "rbm"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "rbm_bi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "112-115",
          "snippet": "static inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_bitmap *rbm_bi(const struct gfs2_rbm *rbm)\n{\n\treturn rbm->rgd->rd_bits + rbm->bii;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic const char valid_change[16] = {\n\t        /* current */\n\t/* n */ 0, 1, 1, 1,\n\t/* e */ 1, 0, 0, 0,\n\t/* w */ 0, 0, 0, 1,\n\t        1, 0, 0, 0\n};\n\nstatic inline void gfs2_setbit(const struct gfs2_rbm *rbm, bool do_clone,\n\t\t\t       unsigned char new_state)\n{\n\tunsigned char *byte1, *byte2, *end, cur_state;\n\tstruct gfs2_bitmap *bi = rbm_bi(rbm);\n\tunsigned int buflen = bi->bi_len;\n\tconst unsigned int bit = (rbm->offset % GFS2_NBBY) * GFS2_BIT_SIZE;\n\n\tbyte1 = bi->bi_bh->b_data + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\tend = bi->bi_bh->b_data + bi->bi_offset + buflen;\n\n\tBUG_ON(byte1 >= end);\n\n\tcur_state = (*byte1 >> bit) & GFS2_BIT_MASK;\n\n\tif (unlikely(!valid_change[new_state * 4 + cur_state])) {\n\t\tpr_warn(\"buf_blk = 0x%x old_state=%d, new_state=%d\\n\",\n\t\t\trbm->offset, cur_state, new_state);\n\t\tpr_warn(\"rgrp=0x%llx bi_start=0x%x\\n\",\n\t\t\t(unsigned long long)rbm->rgd->rd_addr, bi->bi_start);\n\t\tpr_warn(\"bi_offset=0x%x bi_len=0x%x\\n\",\n\t\t\tbi->bi_offset, bi->bi_len);\n\t\tdump_stack();\n\t\tgfs2_consist_rgrpd(rbm->rgd);\n\t\treturn;\n\t}\n\t*byte1 ^= (cur_state ^ new_state) << bit;\n\n\tif (do_clone && bi->bi_clone) {\n\t\tbyte2 = bi->bi_clone + bi->bi_offset + (rbm->offset / GFS2_NBBY);\n\t\tcur_state = (*byte2 >> bit) & GFS2_BIT_MASK;\n\t\t*byte2 ^= (cur_state ^ new_state) << bit;\n\t}\n}"
  }
]