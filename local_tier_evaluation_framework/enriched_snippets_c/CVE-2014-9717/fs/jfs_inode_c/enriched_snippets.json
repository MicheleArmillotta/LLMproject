[
  {
    "function_name": "jfs_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "414-423",
    "snippet": "void jfs_truncate(struct inode *ip)\n{\n\tjfs_info(\"jfs_truncate: size = 0x%lx\", (ulong) ip->i_size);\n\n\tnobh_truncate_page(ip->i_mapping, ip->i_size, jfs_get_block);\n\n\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\tjfs_truncate_nolock(ip, ip->i_size);\n\tIWRITE_UNLOCK(ip);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ip"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_truncate_nolock",
          "args": [
            "ip",
            "ip->i_size"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_truncate_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "374-412",
          "snippet": "void jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t/*\n\t\t * The commit_mutex cannot be taken before txBegin.\n\t\t * txBegin may block and there is a chance the inode\n\t\t * could be marked dirty and need to be committed\n\t\t * before txBegin unblocks\n\t\t */\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = ip->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t/* Truncate isn't always atomic */\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nvoid jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t/*\n\t\t * The commit_mutex cannot be taken before txBegin.\n\t\t * txBegin may block and there is a chance the inode\n\t\t * could be marked dirty and need to be committed\n\t\t * before txBegin unblocks\n\t\t */\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = ip->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t/* Truncate isn't always atomic */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IWRITE_LOCK",
          "args": [
            "ip",
            "RDWRLOCK_NORMAL"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nobh_truncate_page",
          "args": [
            "ip->i_mapping",
            "ip->i_size",
            "jfs_get_block"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "nobh_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2728-2803",
          "snippet": "int nobh_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head map_bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (page_has_buffers(page)) {\nhas_buffers:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn block_truncate_page(mapping, from, get_block);\n\t}\n\n\t/* Find the buffer that contains \"offset\" */\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tmap_bh.b_size = blocksize;\n\tmap_bh.b_state = 0;\n\terr = get_block(inode, iblock, &map_bh, 0);\n\tif (err)\n\t\tgoto unlock;\n\t/* unmapped? It's a hole - nothing to do */\n\tif (!buffer_mapped(&map_bh))\n\t\tgoto unlock;\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (!PageUptodate(page)) {\n\t\terr = mapping->a_ops->readpage(NULL, page);\n\t\tif (err) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto out;\n\t\t}\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (page_has_buffers(page))\n\t\t\tgoto has_buffers;\n\t}\n\tzero_user(page, offset, length);\n\tset_page_dirty(page);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint nobh_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head map_bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (page_has_buffers(page)) {\nhas_buffers:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn block_truncate_page(mapping, from, get_block);\n\t}\n\n\t/* Find the buffer that contains \"offset\" */\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tmap_bh.b_size = blocksize;\n\tmap_bh.b_state = 0;\n\terr = get_block(inode, iblock, &map_bh, 0);\n\tif (err)\n\t\tgoto unlock;\n\t/* unmapped? It's a hole - nothing to do */\n\tif (!buffer_mapped(&map_bh))\n\t\tgoto unlock;\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (!PageUptodate(page)) {\n\t\terr = mapping->a_ops->readpage(NULL, page);\n\t\tif (err) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto out;\n\t\t}\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (page_has_buffers(page))\n\t\t\tgoto has_buffers;\n\t}\n\tzero_user(page, offset, length);\n\tset_page_dirty(page);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_truncate: size = 0x%lx\"",
            "(ulong) ip->i_size"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nvoid jfs_truncate(struct inode *ip)\n{\n\tjfs_info(\"jfs_truncate: size = 0x%lx\", (ulong) ip->i_size);\n\n\tnobh_truncate_page(ip->i_mapping, ip->i_size, jfs_get_block);\n\n\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\tjfs_truncate_nolock(ip, ip->i_size);\n\tIWRITE_UNLOCK(ip);\n}"
  },
  {
    "function_name": "jfs_truncate_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "374-412",
    "snippet": "void jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t/*\n\t\t * The commit_mutex cannot be taken before txBegin.\n\t\t * txBegin may block and there is a chance the inode\n\t\t * could be marked dirty and need to be committed\n\t\t * before txBegin unblocks\n\t\t */\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = ip->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t/* Truncate isn't always atomic */\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&ip",
            "0"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "ip"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtTruncate",
          "args": [
            "tid",
            "ip",
            "length",
            "COMMIT_TRUNCATE | COMMIT_PWMAP"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "xtTruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3162-3692",
          "snippet": "s64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_TRUNCATE_LEAVES 50"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define MAX_TRUNCATE_LEAVES 50\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\ns64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "ip->i_sb",
            "0"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "length >= 0"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nvoid jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t/*\n\t\t * The commit_mutex cannot be taken before txBegin.\n\t\t * txBegin may block and there is a chance the inode\n\t\t * could be marked dirty and need to be committed\n\t\t * before txBegin unblocks\n\t\t */\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = ip->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t/* Truncate isn't always atomic */\n}"
  },
  {
    "function_name": "jfs_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "333-357",
    "snippet": "static ssize_t jfs_direct_IO(int rw, struct kiocb *iocb,\n\tstruct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, jfs_get_block);\n\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = offset + count;\n\n\t\tif (end > isize)\n\t\t\tjfs_write_failed(mapping, end);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_write_failed",
          "args": [
            "mapping",
            "end"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "304-312",
          "snippet": "static void jfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tjfs_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nstatic void jfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tjfs_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(rw & WRITE) && ret < 0"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "jfs_get_block"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nstatic ssize_t jfs_direct_IO(int rw, struct kiocb *iocb,\n\tstruct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, jfs_get_block);\n\n\t/*\n\t * In case of error extending write may have instantiated a few\n\t * blocks outside i_size. Trim these off again.\n\t */\n\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\tloff_t isize = i_size_read(inode);\n\t\tloff_t end = offset + count;\n\n\t\tif (end > isize)\n\t\t\tjfs_write_failed(mapping, end);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "jfs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "328-331",
    "snippet": "static sector_t jfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, jfs_get_block);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "jfs_get_block"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nstatic sector_t jfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, jfs_get_block);\n}"
  },
  {
    "function_name": "jfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "314-326",
    "snippet": "static int jfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = nobh_write_begin(mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\tjfs_get_block);\n\tif (unlikely(ret))\n\t\tjfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "304-312",
          "snippet": "static void jfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tjfs_truncate(inode);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nstatic void jfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tjfs_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nobh_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata",
            "jfs_get_block"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_nobh_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "828-840",
          "snippet": "static int\next2_nobh_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = nobh_write_begin(mapping, pos, len, flags, pagep, fsdata,\n\t\t\t       ext2_get_block);\n\tif (ret < 0)\n\t\text2_write_failed(mapping, pos + len);\n\treturn ret;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nstatic int\next2_nobh_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = nobh_write_begin(mapping, pos, len, flags, pagep, fsdata,\n\t\t\t       ext2_get_block);\n\tif (ret < 0)\n\t\text2_write_failed(mapping, pos + len);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nstatic int jfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = nobh_write_begin(mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\tjfs_get_block);\n\tif (unlikely(ret))\n\t\tjfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "jfs_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "304-312",
    "snippet": "static void jfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tjfs_truncate(inode);\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_truncate",
          "args": [
            "inode"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "414-423",
          "snippet": "void jfs_truncate(struct inode *ip)\n{\n\tjfs_info(\"jfs_truncate: size = 0x%lx\", (ulong) ip->i_size);\n\n\tnobh_truncate_page(ip->i_mapping, ip->i_size, jfs_get_block);\n\n\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\tjfs_truncate_nolock(ip, ip->i_size);\n\tIWRITE_UNLOCK(ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nvoid jfs_truncate(struct inode *ip)\n{\n\tjfs_info(\"jfs_truncate: size = 0x%lx\", (ulong) ip->i_size);\n\n\tnobh_truncate_page(ip->i_mapping, ip->i_size, jfs_get_block);\n\n\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\tjfs_truncate_nolock(ip, ip->i_size);\n\tIWRITE_UNLOCK(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nstatic void jfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tjfs_truncate(inode);\n\t}\n}"
  },
  {
    "function_name": "jfs_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "298-302",
    "snippet": "static int jfs_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, jfs_get_block);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "jfs_get_block"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nstatic int jfs_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, jfs_get_block);\n}"
  },
  {
    "function_name": "jfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "293-296",
    "snippet": "static int jfs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, jfs_get_block);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpage",
          "args": [
            "page",
            "jfs_get_block"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "392-406",
          "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nstatic int jfs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, jfs_get_block);\n}"
  },
  {
    "function_name": "jfs_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "287-291",
    "snippet": "static int jfs_writepages(struct address_space *mapping,\n\t\t\tstruct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, jfs_get_block);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_writepages",
          "args": [
            "mapping",
            "wbc",
            "jfs_get_block"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "675-700",
          "snippet": "int\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nstatic int jfs_writepages(struct address_space *mapping,\n\t\t\tstruct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, jfs_get_block);\n}"
  },
  {
    "function_name": "jfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "282-285",
    "snippet": "static int jfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, jfs_get_block, wbc);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "jfs_get_block",
            "wbc"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nstatic int jfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, jfs_get_block, wbc);\n}"
  },
  {
    "function_name": "jfs_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "196-280",
    "snippet": "int jfs_get_block(struct inode *ip, sector_t lblock,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\ts64 lblock64 = lblock;\n\tint rc = 0;\n\txad_t xad;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen = bh_result->b_size >> ip->i_blkbits;\n\n\t/*\n\t * Take appropriate lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\telse\n\t\tIREAD_LOCK(ip, RDWRLOCK_NORMAL);\n\n\tif (((lblock64 << ip->i_sb->s_blocksize_bits) < ip->i_size) &&\n\t    (!xtLookup(ip, lblock64, xlen, &xflag, &xaddr, &xlen, 0)) &&\n\t    xaddr) {\n\t\tif (xflag & XAD_NOTRECORDED) {\n\t\t\tif (!create)\n\t\t\t\t/*\n\t\t\t\t * Allocated but not recorded, read treats\n\t\t\t\t * this as a hole\n\t\t\t\t */\n\t\t\t\tgoto unlock;\n#ifdef _JFS_4K\n\t\t\tXADoffset(&xad, lblock64);\n\t\t\tXADlength(&xad, xlen);\n\t\t\tXADaddress(&xad, xaddr);\n#else\t\t\t\t/* _JFS_4K */\n\t\t\t/*\n\t\t\t * As long as block size = 4K, this isn't a problem.\n\t\t\t * We should mark the whole page not ABNR, but how\n\t\t\t * will we know to mark the other blocks BH_New?\n\t\t\t */\n\t\t\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\t\t\trc = extRecord(ip, &xad);\n\t\t\tif (rc)\n\t\t\t\tgoto unlock;\n\t\t\tset_buffer_new(bh_result);\n\t\t}\n\n\t\tmap_bh(bh_result, ip->i_sb, xaddr);\n\t\tbh_result->b_size = xlen << ip->i_blkbits;\n\t\tgoto unlock;\n\t}\n\tif (!create)\n\t\tgoto unlock;\n\n\t/*\n\t * Allocate a new block\n\t */\n#ifdef _JFS_4K\n\tif ((rc = extHint(ip, lblock64 << ip->i_sb->s_blocksize_bits, &xad)))\n\t\tgoto unlock;\n\trc = extAlloc(ip, xlen, lblock64, &xad, false);\n\tif (rc)\n\t\tgoto unlock;\n\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, ip->i_sb, addressXAD(&xad));\n\tbh_result->b_size = lengthXAD(&xad) << ip->i_blkbits;\n\n#else\t\t\t\t/* _JFS_4K */\n\t/*\n\t * We need to do whatever it takes to keep all but the last buffers\n\t * in 4K pages - see jfs_write.c\n\t */\n\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\n      unlock:\n\t/*\n\t * Release lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_UNLOCK(ip);\n\telse\n\t\tIREAD_UNLOCK(ip);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IREAD_UNLOCK",
          "args": [
            "ip"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ip"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthXAD",
          "args": [
            "&xad"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "ip->i_sb",
            "addressXAD(&xad)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressXAD",
          "args": [
            "&xad"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extAlloc",
          "args": [
            "ip",
            "xlen",
            "lblock64",
            "&xad",
            "false"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "extAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
          "lines": "85-191",
          "snippet": "int\nextAlloc(struct inode *ip, s64 xlen, s64 pno, xad_t * xp, bool abnr)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nxlen, nxaddr, xoff, hint, xaddr = 0;\n\tint rc;\n\tint xflag;\n\n\t/* This blocks if we are low on resources */\n\ttxBeginAnon(ip->i_sb);\n\n\t/* Avoid race with jfs_commit_inode() */\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t/* validate extent length */\n\tif (xlen > MAXXLEN)\n\t\txlen = MAXXLEN;\n\n\t/* get the page's starting extent offset */\n\txoff = pno << sbi->l2nbperpage;\n\n\t/* check if an allocation hint was provided */\n\tif ((hint = addressXAD(xp))) {\n\t\t/* get the size of the extent described by the hint */\n\t\tnxlen = lengthXAD(xp);\n\n\t\t/* check if the hint is for the portion of the file\n\t\t * immediately previous to the current allocation\n\t\t * request and if hint extent has the same abnr\n\t\t * value as the current request.  if so, we can\n\t\t * extend the hint extent to include the current\n\t\t * extent if we can allocate the blocks immediately\n\t\t * following the hint extent.\n\t\t */\n\t\tif (offsetXAD(xp) + nxlen == xoff &&\n\t\t    abnr == ((xp->flag & XAD_NOTRECORDED) ? true : false))\n\t\t\txaddr = hint + nxlen;\n\n\t\t/* adjust the hint to the last block of the extent */\n\t\thint += (nxlen - 1);\n\t}\n\n\t/* allocate the disk blocks for the extent.  initially, extBalloc()\n\t * will try to allocate disk blocks for the requested size (xlen).\n\t * if this fails (xlen contiguous free blocks not available), it'll\n\t * try to allocate a smaller number of blocks (producing a smaller\n\t * extent), with this smaller number of blocks consisting of the\n\t * requested number of blocks rounded down to the next smaller\n\t * power of 2 number (i.e. 16 -> 8).  it'll continue to round down\n\t * and retry the allocation until the number of blocks to allocate\n\t * is smaller than the number of blocks per page.\n\t */\n\tnxlen = xlen;\n\tif ((rc = extBalloc(ip, hint ? hint : INOHINT(ip), &nxlen, &nxaddr))) {\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, nxlen);\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, (s64) nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn rc;\n\t}\n\n\t/* determine the value of the extent flag */\n\txflag = abnr ? XAD_NOTRECORDED : 0;\n\n\t/* if we can extend the hint extent to cover the current request,\n\t * extend it.  otherwise, insert a new extent to\n\t * cover the current request.\n\t */\n\tif (xaddr && xaddr == nxaddr)\n\t\trc = xtExtend(0, ip, xoff, (int) nxlen, 0);\n\telse\n\t\trc = xtInsert(0, ip, xflag, xoff, (int) nxlen, &nxaddr, 0);\n\n\t/* if the extend or insert failed,\n\t * free the newly allocated blocks and return the error.\n\t */\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, nxlen);\n\t\tdquot_free_block(ip, nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the extent allocation */\n\tXADaddress(xp, nxaddr);\n\tXADlength(xp, nxlen);\n\tXADoffset(xp, xoff);\n\txp->flag = xflag;\n\n\tmark_inode_dirty(ip);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t/*\n\t * COMMIT_SyncList flags an anonymous tlock on page that is on\n\t * sync list.\n\t * We need to commit the inode to get the page written disk.\n\t */\n\tif (test_and_clear_cflag(COMMIT_Synclist,ip))\n\t\tjfs_commit_inode(ip, 0);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int extBalloc(struct inode *, s64, s64 *, s64 *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\n\nint\nextAlloc(struct inode *ip, s64 xlen, s64 pno, xad_t * xp, bool abnr)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\ts64 nxlen, nxaddr, xoff, hint, xaddr = 0;\n\tint rc;\n\tint xflag;\n\n\t/* This blocks if we are low on resources */\n\ttxBeginAnon(ip->i_sb);\n\n\t/* Avoid race with jfs_commit_inode() */\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t/* validate extent length */\n\tif (xlen > MAXXLEN)\n\t\txlen = MAXXLEN;\n\n\t/* get the page's starting extent offset */\n\txoff = pno << sbi->l2nbperpage;\n\n\t/* check if an allocation hint was provided */\n\tif ((hint = addressXAD(xp))) {\n\t\t/* get the size of the extent described by the hint */\n\t\tnxlen = lengthXAD(xp);\n\n\t\t/* check if the hint is for the portion of the file\n\t\t * immediately previous to the current allocation\n\t\t * request and if hint extent has the same abnr\n\t\t * value as the current request.  if so, we can\n\t\t * extend the hint extent to include the current\n\t\t * extent if we can allocate the blocks immediately\n\t\t * following the hint extent.\n\t\t */\n\t\tif (offsetXAD(xp) + nxlen == xoff &&\n\t\t    abnr == ((xp->flag & XAD_NOTRECORDED) ? true : false))\n\t\t\txaddr = hint + nxlen;\n\n\t\t/* adjust the hint to the last block of the extent */\n\t\thint += (nxlen - 1);\n\t}\n\n\t/* allocate the disk blocks for the extent.  initially, extBalloc()\n\t * will try to allocate disk blocks for the requested size (xlen).\n\t * if this fails (xlen contiguous free blocks not available), it'll\n\t * try to allocate a smaller number of blocks (producing a smaller\n\t * extent), with this smaller number of blocks consisting of the\n\t * requested number of blocks rounded down to the next smaller\n\t * power of 2 number (i.e. 16 -> 8).  it'll continue to round down\n\t * and retry the allocation until the number of blocks to allocate\n\t * is smaller than the number of blocks per page.\n\t */\n\tnxlen = xlen;\n\tif ((rc = extBalloc(ip, hint ? hint : INOHINT(ip), &nxlen, &nxaddr))) {\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, nxlen);\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, (s64) nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn rc;\n\t}\n\n\t/* determine the value of the extent flag */\n\txflag = abnr ? XAD_NOTRECORDED : 0;\n\n\t/* if we can extend the hint extent to cover the current request,\n\t * extend it.  otherwise, insert a new extent to\n\t * cover the current request.\n\t */\n\tif (xaddr && xaddr == nxaddr)\n\t\trc = xtExtend(0, ip, xoff, (int) nxlen, 0);\n\telse\n\t\trc = xtInsert(0, ip, xflag, xoff, (int) nxlen, &nxaddr, 0);\n\n\t/* if the extend or insert failed,\n\t * free the newly allocated blocks and return the error.\n\t */\n\tif (rc) {\n\t\tdbFree(ip, nxaddr, nxlen);\n\t\tdquot_free_block(ip, nxlen);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\treturn (rc);\n\t}\n\n\t/* set the results of the extent allocation */\n\tXADaddress(xp, nxaddr);\n\tXADlength(xp, nxlen);\n\tXADoffset(xp, xoff);\n\txp->flag = xflag;\n\n\tmark_inode_dirty(ip);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t/*\n\t * COMMIT_SyncList flags an anonymous tlock on page that is on\n\t * sync list.\n\t * We need to commit the inode to get the page written disk.\n\t */\n\tif (test_and_clear_cflag(COMMIT_Synclist,ip))\n\t\tjfs_commit_inode(ip, 0);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extHint",
          "args": [
            "ip",
            "lblock64 << ip->i_sb->s_blocksize_bits",
            "&xad"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "extHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
          "lines": "364-407",
          "snippet": "int extHint(struct inode *ip, s64 offset, xad_t * xp)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint nbperpage = JFS_SBI(sb)->nbperpage;\n\ts64 prev;\n\tint rc = 0;\n\ts64 xaddr;\n\tint xlen;\n\tint xflag;\n\n\t/* init the hint as \"no hint provided\" */\n\tXADaddress(xp, 0);\n\n\t/* determine the starting extent offset of the page previous\n\t * to the page containing the offset.\n\t */\n\tprev = ((offset & ~POFFSET) >> JFS_SBI(sb)->l2bsize) - nbperpage;\n\n\t/* if the offset is in the first page of the file, no hint provided.\n\t */\n\tif (prev < 0)\n\t\tgoto out;\n\n\trc = xtLookup(ip, prev, nbperpage, &xflag, &xaddr, &xlen, 0);\n\n\tif ((rc == 0) && xlen) {\n\t\tif (xlen != nbperpage) {\n\t\t\tjfs_error(ip->i_sb, \"corrupt xtree\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\tXADaddress(xp, xaddr);\n\t\tXADlength(xp, xlen);\n\t\tXADoffset(xp, prev);\n\t\t/*\n\t\t * only preserve the abnr flag within the xad flags\n\t\t * of the returned hint.\n\t\t */\n\t\txp->flag  = xflag & XAD_NOTRECORDED;\n\t} else\n\t\trc = 0;\n\nout:\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int extBalloc(struct inode *, s64, s64 *, s64 *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int extBalloc(struct inode *, s64, s64 *, s64 *);\n\nint extHint(struct inode *ip, s64 offset, xad_t * xp)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint nbperpage = JFS_SBI(sb)->nbperpage;\n\ts64 prev;\n\tint rc = 0;\n\ts64 xaddr;\n\tint xlen;\n\tint xflag;\n\n\t/* init the hint as \"no hint provided\" */\n\tXADaddress(xp, 0);\n\n\t/* determine the starting extent offset of the page previous\n\t * to the page containing the offset.\n\t */\n\tprev = ((offset & ~POFFSET) >> JFS_SBI(sb)->l2bsize) - nbperpage;\n\n\t/* if the offset is in the first page of the file, no hint provided.\n\t */\n\tif (prev < 0)\n\t\tgoto out;\n\n\trc = xtLookup(ip, prev, nbperpage, &xflag, &xaddr, &xlen, 0);\n\n\tif ((rc == 0) && xlen) {\n\t\tif (xlen != nbperpage) {\n\t\t\tjfs_error(ip->i_sb, \"corrupt xtree\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t\tXADaddress(xp, xaddr);\n\t\tXADlength(xp, xlen);\n\t\tXADoffset(xp, prev);\n\t\t/*\n\t\t * only preserve the abnr flag within the xad flags\n\t\t * of the returned hint.\n\t\t */\n\t\txp->flag  = xflag & XAD_NOTRECORDED;\n\t} else\n\t\trc = 0;\n\nout:\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "ip->i_sb",
            "xaddr"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extRecord",
          "args": [
            "ip",
            "&xad"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "extRecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_extent.c",
          "lines": "424-437",
          "snippet": "int extRecord(struct inode *ip, xad_t * xp)\n{\n\tint rc;\n\n\ttxBeginAnon(ip->i_sb);\n\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t/* update the extent */\n\trc = xtUpdate(0, ip, xp);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nint extRecord(struct inode *ip, xad_t * xp)\n{\n\tint rc;\n\n\ttxBeginAnon(ip->i_sb);\n\n\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t/* update the extent */\n\trc = xtUpdate(0, ip, xp);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADaddress",
          "args": [
            "&xad",
            "xaddr"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADlength",
          "args": [
            "&xad",
            "xlen"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XADoffset",
          "args": [
            "&xad",
            "lblock64"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtLookup",
          "args": [
            "ip",
            "lblock64",
            "xlen",
            "&xflag",
            "&xaddr",
            "&xlen",
            "0"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "xtLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "146-219",
          "snippet": "int xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t/* is lookup offset beyond eof ? */\n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * search for the xad entry covering the logical extent\n\t */\n//search:\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tcompute the physical extent covering logical extent\n\t *\n\t * N.B. search may have failed (e.g., hole in sparse file),\n\t * and returned the index of the next entry.\n\t */\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* is xad found covering start of logical extent ?\n\t * lstart is a page start address,\n\t * i.e., lstart cannot start in a hole;\n\t */\n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * lxd covered by xad\n\t */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t/* initialize new pxd */\n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t/* a page must be fully covered by an xad */\n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t/* is lookup offset beyond eof ? */\n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * search for the xad entry covering the logical extent\n\t */\n//search:\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tcompute the physical extent covering logical extent\n\t *\n\t * N.B. search may have failed (e.g., hole in sparse file),\n\t * and returned the index of the next entry.\n\t */\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* is xad found covering start of logical extent ?\n\t * lstart is a page start address,\n\t * i.e., lstart cannot start in a hole;\n\t */\n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * lxd covered by xad\n\t */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t/* initialize new pxd */\n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t/* a page must be fully covered by an xad */\n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IREAD_LOCK",
          "args": [
            "ip",
            "RDWRLOCK_NORMAL"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_LOCK",
          "args": [
            "ip",
            "RDWRLOCK_NORMAL"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nint jfs_get_block(struct inode *ip, sector_t lblock,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\ts64 lblock64 = lblock;\n\tint rc = 0;\n\txad_t xad;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen = bh_result->b_size >> ip->i_blkbits;\n\n\t/*\n\t * Take appropriate lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\telse\n\t\tIREAD_LOCK(ip, RDWRLOCK_NORMAL);\n\n\tif (((lblock64 << ip->i_sb->s_blocksize_bits) < ip->i_size) &&\n\t    (!xtLookup(ip, lblock64, xlen, &xflag, &xaddr, &xlen, 0)) &&\n\t    xaddr) {\n\t\tif (xflag & XAD_NOTRECORDED) {\n\t\t\tif (!create)\n\t\t\t\t/*\n\t\t\t\t * Allocated but not recorded, read treats\n\t\t\t\t * this as a hole\n\t\t\t\t */\n\t\t\t\tgoto unlock;\n#ifdef _JFS_4K\n\t\t\tXADoffset(&xad, lblock64);\n\t\t\tXADlength(&xad, xlen);\n\t\t\tXADaddress(&xad, xaddr);\n#else\t\t\t\t/* _JFS_4K */\n\t\t\t/*\n\t\t\t * As long as block size = 4K, this isn't a problem.\n\t\t\t * We should mark the whole page not ABNR, but how\n\t\t\t * will we know to mark the other blocks BH_New?\n\t\t\t */\n\t\t\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\t\t\trc = extRecord(ip, &xad);\n\t\t\tif (rc)\n\t\t\t\tgoto unlock;\n\t\t\tset_buffer_new(bh_result);\n\t\t}\n\n\t\tmap_bh(bh_result, ip->i_sb, xaddr);\n\t\tbh_result->b_size = xlen << ip->i_blkbits;\n\t\tgoto unlock;\n\t}\n\tif (!create)\n\t\tgoto unlock;\n\n\t/*\n\t * Allocate a new block\n\t */\n#ifdef _JFS_4K\n\tif ((rc = extHint(ip, lblock64 << ip->i_sb->s_blocksize_bits, &xad)))\n\t\tgoto unlock;\n\trc = extAlloc(ip, xlen, lblock64, &xad, false);\n\tif (rc)\n\t\tgoto unlock;\n\n\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, ip->i_sb, addressXAD(&xad));\n\tbh_result->b_size = lengthXAD(&xad) << ip->i_blkbits;\n\n#else\t\t\t\t/* _JFS_4K */\n\t/*\n\t * We need to do whatever it takes to keep all but the last buffers\n\t * in 4K pages - see jfs_write.c\n\t */\n\tBUG();\n#endif\t\t\t\t/* _JFS_4K */\n\n      unlock:\n\t/*\n\t * Release lock on inode\n\t */\n\tif (create)\n\t\tIWRITE_UNLOCK(ip);\n\telse\n\t\tIREAD_UNLOCK(ip);\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_dirty_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "177-194",
    "snippet": "void jfs_dirty_inode(struct inode *inode, int flags)\n{\n\tstatic int noisy = 5;\n\n\tif (isReadOnly(inode)) {\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\t/* kernel allows writes to devices on read-only\n\t\t\t * partitions and may try to mark inode dirty\n\t\t\t */\n\t\t\tjfs_err(\"jfs_dirty_inode called on read-only volume\");\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn;\n\t}\n\n\tset_cflag(COMMIT_Dirty, inode);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cflag",
          "args": [
            "COMMIT_Dirty",
            "inode"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"Is remount racy?\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_dirty_inode called on read-only volume\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "special_file",
          "args": [
            "inode->i_mode"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isReadOnly",
          "args": [
            "inode"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "isReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "222-227",
          "snippet": "static inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nvoid jfs_dirty_inode(struct inode *inode, int flags)\n{\n\tstatic int noisy = 5;\n\n\tif (isReadOnly(inode)) {\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\t/* kernel allows writes to devices on read-only\n\t\t\t * partitions and may try to mark inode dirty\n\t\t\t */\n\t\t\tjfs_err(\"jfs_dirty_inode called on read-only volume\");\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn;\n\t}\n\n\tset_cflag(COMMIT_Dirty, inode);\n}"
  },
  {
    "function_name": "jfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "149-175",
    "snippet": "void jfs_evict_inode(struct inode *inode)\n{\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\n\t\t\tdiFree(inode);\n\n\t\t\t/*\n\t\t\t * Free the inode from the quota allocation.\n\t\t\t */\n\t\t\tdquot_initialize(inode);\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_drop",
          "args": [
            "inode"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1487-1508",
          "snippet": "void dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_inode",
          "args": [
            "inode"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1792-1819",
          "snippet": "void dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_free_inode(struct inode *inode)\n{\n\tunsigned int cnt;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\tint index;\n\n\tif (!dquot_active(inode))\n\t\treturn;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tint wtype;\n\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\twtype = info_idq_free(dquots[cnt], 1);\n\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\tprepare_warning(&warn[cnt], dquots[cnt], wtype);\n\t\tdquot_decr_inodes(dquots[cnt], 1);\n\t}\n\tspin_unlock(&dq_data_lock);\n\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diFree",
          "args": [
            "inode"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "diFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "863-1307",
          "snippet": "int diFree(struct inode *ip)\n{\n\tint rc;\n\tino_t inum = ip->i_ino;\n\tstruct iag *iagp, *aiagp, *biagp, *ciagp, *diagp;\n\tstruct metapage *mp, *amp, *bmp, *cmp, *dmp;\n\tint iagno, ino, extno, bitno, sword, agno;\n\tint back, fwd;\n\tu32 bitmap, mask;\n\tstruct inode *ipimap = JFS_SBI(ip->i_sb)->ipimap;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\tpxd_t freepxd;\n\ttid_t tid;\n\tstruct inode *iplist[3];\n\tstruct tlock *tlck;\n\tstruct pxd_lock *pxdlock;\n\n\t/*\n\t * This is just to suppress compiler warnings.  The same logic that\n\t * references these variables is used to initialize them.\n\t */\n\taiagp = biagp = ciagp = diagp = NULL;\n\n\t/* get the iag number containing the inode.\n\t */\n\tiagno = INOTOIAG(inum);\n\n\t/* make sure that the iag is contained within\n\t * the map.\n\t */\n\tif (iagno >= imap->im_nextiag) {\n\t\tprint_hex_dump(KERN_ERR, \"imap: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       imap, 32, 0);\n\t\tjfs_error(ip->i_sb, \"inum = %d, iagno = %d, nextiag = %d\\n\",\n\t\t\t  (uint) inum, iagno, imap->im_nextiag);\n\t\treturn -EIO;\n\t}\n\n\t/* get the allocation group for this ino.\n\t */\n\tagno = BLKTOAG(JFS_IP(ip)->agstart, JFS_SBI(ip->i_sb));\n\n\t/* Lock the AG specific inode map information\n\t */\n\tAG_LOCK(imap, agno);\n\n\t/* Obtain read lock in imap inode.  Don't release it until we have\n\t * read all of the IAG's that we are going to.\n\t */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t/* read the iag.\n\t */\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* get the inode number and extent number of the inode within\n\t * the iag and the inode number within the extent.\n\t */\n\tino = inum & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\tmask = HIGHORDER >> bitno;\n\n\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\tjfs_error(ip->i_sb, \"wmap shows inode already free\\n\");\n\t}\n\n\tif (!addressPXD(&iagp->inoext[extno])) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\tjfs_error(ip->i_sb, \"invalid inoext\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute the bitmap for the extent reflecting the freed inode.\n\t */\n\tbitmap = le32_to_cpu(iagp->wmap[extno]) & ~mask;\n\n\tif (imap->im_agctl[agno].numfree > imap->im_agctl[agno].numinos) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");\n\t\treturn -EIO;\n\t}\n\t/*\n\t *\tinode extent still has some inodes or below low water mark:\n\t *\tkeep the inode extent;\n\t */\n\tif (bitmap ||\n\t    imap->im_agctl[agno].numfree < 96 ||\n\t    (imap->im_agctl[agno].numfree < 288 &&\n\t     (((imap->im_agctl[agno].numfree * 100) /\n\t       imap->im_agctl[agno].numinos) <= 25))) {\n\t\t/* if the iag currently has no free inodes (i.e.,\n\t\t * the inode being freed is the first free inode of iag),\n\t\t * insert the iag at head of the inode free list for the ag.\n\t\t */\n\t\tif (iagp->nfreeinos == 0) {\n\t\t\t/* check if there are any iags on the ag inode\n\t\t\t * free list.  if so, read the first one so that\n\t\t\t * we can link the current iag onto the list at\n\t\t\t * the head.\n\t\t\t */\n\t\t\tif ((fwd = imap->im_agctl[agno].inofree) >= 0) {\n\t\t\t\t/* read the iag that currently is the head\n\t\t\t\t * of the list.\n\t\t\t\t */\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp))) {\n\t\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\t\trelease_metapage(mp);\n\t\t\t\t\treturn (rc);\n\t\t\t\t}\n\t\t\t\taiagp = (struct iag *) amp->data;\n\n\t\t\t\t/* make current head point back to the iag.\n\t\t\t\t */\n\t\t\t\taiagp->inofreeback = cpu_to_le32(iagno);\n\n\t\t\t\twrite_metapage(amp);\n\t\t\t}\n\n\t\t\t/* iag points forward to current head and iag\n\t\t\t * becomes the new head of the list.\n\t\t\t */\n\t\t\tiagp->inofreefwd =\n\t\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);\n\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\timap->im_agctl[agno].inofree = iagno;\n\t\t}\n\t\tIREAD_UNLOCK(ipimap);\n\n\t\t/* update the free inode summary map for the extent if\n\t\t * freeing the inode means the extent will now have free\n\t\t * inodes (i.e., the inode being freed is the first free\n\t\t * inode of extent),\n\t\t */\n\t\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\t\tsword = extno >> L2EXTSPERSUM;\n\t\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\t\tiagp->inosmap[sword] &=\n\t\t\t    cpu_to_le32(~(HIGHORDER >> bitno));\n\t\t}\n\n\t\t/* update the bitmap.\n\t\t */\n\t\tiagp->wmap[extno] = cpu_to_le32(bitmap);\n\n\t\t/* update the free inode counts at the iag, ag and\n\t\t * map level.\n\t\t */\n\t\tle32_add_cpu(&iagp->nfreeinos, 1);\n\t\timap->im_agctl[agno].numfree += 1;\n\t\tatomic_inc(&imap->im_numfree);\n\n\t\t/* release the AG inode map lock\n\t\t */\n\t\tAG_UNLOCK(imap, agno);\n\n\t\t/* write the iag */\n\t\twrite_metapage(mp);\n\n\t\treturn (0);\n\t}\n\n\n\t/*\n\t *\tinode extent has become free and above low water mark:\n\t *\tfree the inode extent;\n\t */\n\n\t/*\n\t *\tprepare to update iag list(s) (careful update step 1)\n\t */\n\tamp = bmp = cmp = dmp = NULL;\n\tfwd = back = -1;\n\n\t/* check if the iag currently has no free extents.  if so,\n\t * it will be placed on the head of the ag extent free list.\n\t */\n\tif (iagp->nfreeexts == 0) {\n\t\t/* check if the ag extent free list has any iags.\n\t\t * if so, read the iag at the head of the list now.\n\t\t * this (head) iag will be updated later to reflect\n\t\t * the addition of the current iag at the head of\n\t\t * the list.\n\t\t */\n\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\tgoto error_out;\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\t} else {\n\t\t/* iag has free extents. check if the addition of a free\n\t\t * extent will cause all extents to be free within this\n\t\t * iag.  if so, the iag will be removed from the ag extent\n\t\t * free list and placed on the inode map's free iag list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {\n\t\t\t/* in preparation for removing the iag from the\n\t\t\t * ag extent free list, read the iags preceding\n\t\t\t * and following the iag on the ag extent free\n\t\t\t * list.\n\t\t\t */\n\t\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\taiagp = (struct iag *) amp->data;\n\t\t\t}\n\n\t\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* remove the iag from the ag inode free list if freeing\n\t * this extent cause the iag to have no free inodes.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {\n\t\tint inofreeback = le32_to_cpu(iagp->inofreeback);\n\t\tint inofreefwd = le32_to_cpu(iagp->inofreefwd);\n\n\t\t/* in preparation for removing the iag from the\n\t\t * ag inode free list, read the iags preceding\n\t\t * and following the iag on the ag inode free\n\t\t * list.  before reading these iags, we must make\n\t\t * sure that we already don't have them in hand\n\t\t * from up above, since re-reading an iag (buffer)\n\t\t * we are currently holding would cause a deadlock.\n\t\t */\n\t\tif (inofreefwd >= 0) {\n\n\t\t\tif (inofreefwd == fwd)\n\t\t\t\tciagp = (struct iag *) amp->data;\n\t\t\telse if (inofreefwd == back)\n\t\t\t\tciagp = (struct iag *) bmp->data;\n\t\t\telse {\n\t\t\t\tif ((rc =\n\t\t\t\t     diIAGRead(imap, inofreefwd, &cmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tciagp = (struct iag *) cmp->data;\n\t\t\t}\n\t\t\tassert(ciagp != NULL);\n\t\t}\n\n\t\tif (inofreeback >= 0) {\n\t\t\tif (inofreeback == fwd)\n\t\t\t\tdiagp = (struct iag *) amp->data;\n\t\t\telse if (inofreeback == back)\n\t\t\t\tdiagp = (struct iag *) bmp->data;\n\t\t\telse {\n\t\t\t\tif ((rc =\n\t\t\t\t     diIAGRead(imap, inofreeback, &dmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tdiagp = (struct iag *) dmp->data;\n\t\t\t}\n\t\t\tassert(diagp != NULL);\n\t\t}\n\t}\n\n\tIREAD_UNLOCK(ipimap);\n\n\t/*\n\t * invalidate any page of the inode extent freed from buffer cache;\n\t */\n\tfreepxd = iagp->inoext[extno];\n\tinvalidate_pxd_metapages(ip, freepxd);\n\n\t/*\n\t *\tupdate iag list(s) (careful update step 2)\n\t */\n\t/* add the iag to the ag extent free list if this is the\n\t * first free extent for the iag.\n\t */\n\tif (iagp->nfreeexts == 0) {\n\t\tif (fwd >= 0)\n\t\t\taiagp->extfreeback = cpu_to_le32(iagno);\n\n\t\tiagp->extfreefwd =\n\t\t    cpu_to_le32(imap->im_agctl[agno].extfree);\n\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\timap->im_agctl[agno].extfree = iagno;\n\t} else {\n\t\t/* remove the iag from the ag extent list if all extents\n\t\t * are now free and place it on the inode map iag free list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {\n\t\t\tif (fwd >= 0)\n\t\t\t\taiagp->extfreeback = iagp->extfreeback;\n\n\t\t\tif (back >= 0)\n\t\t\t\tbiagp->extfreefwd = iagp->extfreefwd;\n\t\t\telse\n\t\t\t\timap->im_agctl[agno].extfree =\n\t\t\t\t    le32_to_cpu(iagp->extfreefwd);\n\n\t\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\n\t\t\tIAGFREE_LOCK(imap);\n\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);\n\t\t\timap->im_freeiag = iagno;\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t}\n\t}\n\n\t/* remove the iag from the ag inode free list if freeing\n\t * this extent causes the iag to have no free inodes.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0)\n\t\t\tciagp->inofreeback = iagp->inofreeback;\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0)\n\t\t\tdiagp->inofreefwd = iagp->inofreefwd;\n\t\telse\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t/* update the inode extent address and working map\n\t * to reflect the free extent.\n\t * the permanent map should have been updated already\n\t * for the inode being freed.\n\t */\n\tif (iagp->pmap[extno] != 0) {\n\t\tjfs_error(ip->i_sb, \"the pmap does not show inode free\\n\");\n\t}\n\tiagp->wmap[extno] = 0;\n\tPXDlength(&iagp->inoext[extno], 0);\n\tPXDaddress(&iagp->inoext[extno], 0);\n\n\t/* update the free extent and free inode summary maps\n\t * to reflect the freed extent.\n\t * the inode summary map is marked to indicate no inodes\n\t * available for the freed extent.\n\t */\n\tsword = extno >> L2EXTSPERSUM;\n\tbitno = extno & (EXTSPERSUM - 1);\n\tmask = HIGHORDER >> bitno;\n\tiagp->inosmap[sword] |= cpu_to_le32(mask);\n\tiagp->extsmap[sword] &= cpu_to_le32(~mask);\n\n\t/* update the number of free inodes and number of free extents\n\t * for the iag.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, -(INOSPEREXT - 1));\n\tle32_add_cpu(&iagp->nfreeexts, 1);\n\n\t/* update the number of free inodes and backed inodes\n\t * at the ag and inode map level.\n\t */\n\timap->im_agctl[agno].numfree -= (INOSPEREXT - 1);\n\timap->im_agctl[agno].numinos -= INOSPEREXT;\n\tatomic_sub(INOSPEREXT - 1, &imap->im_numfree);\n\tatomic_sub(INOSPEREXT, &imap->im_numinos);\n\n\tif (amp)\n\t\twrite_metapage(amp);\n\tif (bmp)\n\t\twrite_metapage(bmp);\n\tif (cmp)\n\t\twrite_metapage(cmp);\n\tif (dmp)\n\t\twrite_metapage(dmp);\n\n\t/*\n\t * start transaction to update block allocation map\n\t * for the inode extent freed;\n\t *\n\t * N.B. AG_LOCK is released and iag will be released below, and\n\t * other thread may allocate inode from/reusing the ixad freed\n\t * BUT with new/different backing inode extent from the extent\n\t * to be freed by the transaction;\n\t */\n\ttid = txBegin(ipimap->i_sb, COMMIT_FORCE);\n\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);\n\n\t/* acquire tlock of the iag page of the freed ixad\n\t * to force the page NOHOMEOK (even though no data is\n\t * logged from the iag page) until NOREDOPAGE|FREEXTENT log\n\t * for the free of the extent is committed;\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor;\n\t */\n\ttlck = txLock(tid, ipimap, mp, tlckINODE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = freepxd;\n\tpxdlock->index = 1;\n\n\twrite_metapage(mp);\n\n\tiplist[0] = ipimap;\n\n\t/*\n\t * logredo needs the IAG number and IAG extent index in order\n\t * to ensure that the IMap is consistent.  The least disruptive\n\t * way to pass these values through  to the transaction manager\n\t * is in the iplist array.\n\t *\n\t * It's not pretty, but it works.\n\t */\n\tiplist[1] = (struct inode *) (size_t)iagno;\n\tiplist[2] = (struct inode *) (size_t)extno;\n\n\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t/* unlock the AG inode map information */\n\tAG_UNLOCK(imap, agno);\n\n\treturn (0);\n\n      error_out:\n\tIREAD_UNLOCK(ipimap);\n\n\tif (amp)\n\t\trelease_metapage(amp);\n\tif (bmp)\n\t\trelease_metapage(bmp);\n\tif (cmp)\n\t\trelease_metapage(cmp);\n\tif (dmp)\n\t\trelease_metapage(dmp);\n\n\tAG_UNLOCK(imap, agno);\n\n\trelease_metapage(mp);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diFindFree(u32, int);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diFree(struct inode *ip)\n{\n\tint rc;\n\tino_t inum = ip->i_ino;\n\tstruct iag *iagp, *aiagp, *biagp, *ciagp, *diagp;\n\tstruct metapage *mp, *amp, *bmp, *cmp, *dmp;\n\tint iagno, ino, extno, bitno, sword, agno;\n\tint back, fwd;\n\tu32 bitmap, mask;\n\tstruct inode *ipimap = JFS_SBI(ip->i_sb)->ipimap;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\tpxd_t freepxd;\n\ttid_t tid;\n\tstruct inode *iplist[3];\n\tstruct tlock *tlck;\n\tstruct pxd_lock *pxdlock;\n\n\t/*\n\t * This is just to suppress compiler warnings.  The same logic that\n\t * references these variables is used to initialize them.\n\t */\n\taiagp = biagp = ciagp = diagp = NULL;\n\n\t/* get the iag number containing the inode.\n\t */\n\tiagno = INOTOIAG(inum);\n\n\t/* make sure that the iag is contained within\n\t * the map.\n\t */\n\tif (iagno >= imap->im_nextiag) {\n\t\tprint_hex_dump(KERN_ERR, \"imap: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       imap, 32, 0);\n\t\tjfs_error(ip->i_sb, \"inum = %d, iagno = %d, nextiag = %d\\n\",\n\t\t\t  (uint) inum, iagno, imap->im_nextiag);\n\t\treturn -EIO;\n\t}\n\n\t/* get the allocation group for this ino.\n\t */\n\tagno = BLKTOAG(JFS_IP(ip)->agstart, JFS_SBI(ip->i_sb));\n\n\t/* Lock the AG specific inode map information\n\t */\n\tAG_LOCK(imap, agno);\n\n\t/* Obtain read lock in imap inode.  Don't release it until we have\n\t * read all of the IAG's that we are going to.\n\t */\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\n\t/* read the iag.\n\t */\n\tif ((rc = diIAGRead(imap, iagno, &mp))) {\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\treturn (rc);\n\t}\n\tiagp = (struct iag *) mp->data;\n\n\t/* get the inode number and extent number of the inode within\n\t * the iag and the inode number within the extent.\n\t */\n\tino = inum & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\tmask = HIGHORDER >> bitno;\n\n\tif (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {\n\t\tjfs_error(ip->i_sb, \"wmap shows inode already free\\n\");\n\t}\n\n\tif (!addressPXD(&iagp->inoext[extno])) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\tjfs_error(ip->i_sb, \"invalid inoext\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* compute the bitmap for the extent reflecting the freed inode.\n\t */\n\tbitmap = le32_to_cpu(iagp->wmap[extno]) & ~mask;\n\n\tif (imap->im_agctl[agno].numfree > imap->im_agctl[agno].numinos) {\n\t\trelease_metapage(mp);\n\t\tIREAD_UNLOCK(ipimap);\n\t\tAG_UNLOCK(imap, agno);\n\t\tjfs_error(ip->i_sb, \"numfree > numinos\\n\");\n\t\treturn -EIO;\n\t}\n\t/*\n\t *\tinode extent still has some inodes or below low water mark:\n\t *\tkeep the inode extent;\n\t */\n\tif (bitmap ||\n\t    imap->im_agctl[agno].numfree < 96 ||\n\t    (imap->im_agctl[agno].numfree < 288 &&\n\t     (((imap->im_agctl[agno].numfree * 100) /\n\t       imap->im_agctl[agno].numinos) <= 25))) {\n\t\t/* if the iag currently has no free inodes (i.e.,\n\t\t * the inode being freed is the first free inode of iag),\n\t\t * insert the iag at head of the inode free list for the ag.\n\t\t */\n\t\tif (iagp->nfreeinos == 0) {\n\t\t\t/* check if there are any iags on the ag inode\n\t\t\t * free list.  if so, read the first one so that\n\t\t\t * we can link the current iag onto the list at\n\t\t\t * the head.\n\t\t\t */\n\t\t\tif ((fwd = imap->im_agctl[agno].inofree) >= 0) {\n\t\t\t\t/* read the iag that currently is the head\n\t\t\t\t * of the list.\n\t\t\t\t */\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp))) {\n\t\t\t\t\tIREAD_UNLOCK(ipimap);\n\t\t\t\t\tAG_UNLOCK(imap, agno);\n\t\t\t\t\trelease_metapage(mp);\n\t\t\t\t\treturn (rc);\n\t\t\t\t}\n\t\t\t\taiagp = (struct iag *) amp->data;\n\n\t\t\t\t/* make current head point back to the iag.\n\t\t\t\t */\n\t\t\t\taiagp->inofreeback = cpu_to_le32(iagno);\n\n\t\t\t\twrite_metapage(amp);\n\t\t\t}\n\n\t\t\t/* iag points forward to current head and iag\n\t\t\t * becomes the new head of the list.\n\t\t\t */\n\t\t\tiagp->inofreefwd =\n\t\t\t    cpu_to_le32(imap->im_agctl[agno].inofree);\n\t\t\tiagp->inofreeback = cpu_to_le32(-1);\n\t\t\timap->im_agctl[agno].inofree = iagno;\n\t\t}\n\t\tIREAD_UNLOCK(ipimap);\n\n\t\t/* update the free inode summary map for the extent if\n\t\t * freeing the inode means the extent will now have free\n\t\t * inodes (i.e., the inode being freed is the first free\n\t\t * inode of extent),\n\t\t */\n\t\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\t\tsword = extno >> L2EXTSPERSUM;\n\t\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\t\tiagp->inosmap[sword] &=\n\t\t\t    cpu_to_le32(~(HIGHORDER >> bitno));\n\t\t}\n\n\t\t/* update the bitmap.\n\t\t */\n\t\tiagp->wmap[extno] = cpu_to_le32(bitmap);\n\n\t\t/* update the free inode counts at the iag, ag and\n\t\t * map level.\n\t\t */\n\t\tle32_add_cpu(&iagp->nfreeinos, 1);\n\t\timap->im_agctl[agno].numfree += 1;\n\t\tatomic_inc(&imap->im_numfree);\n\n\t\t/* release the AG inode map lock\n\t\t */\n\t\tAG_UNLOCK(imap, agno);\n\n\t\t/* write the iag */\n\t\twrite_metapage(mp);\n\n\t\treturn (0);\n\t}\n\n\n\t/*\n\t *\tinode extent has become free and above low water mark:\n\t *\tfree the inode extent;\n\t */\n\n\t/*\n\t *\tprepare to update iag list(s) (careful update step 1)\n\t */\n\tamp = bmp = cmp = dmp = NULL;\n\tfwd = back = -1;\n\n\t/* check if the iag currently has no free extents.  if so,\n\t * it will be placed on the head of the ag extent free list.\n\t */\n\tif (iagp->nfreeexts == 0) {\n\t\t/* check if the ag extent free list has any iags.\n\t\t * if so, read the iag at the head of the list now.\n\t\t * this (head) iag will be updated later to reflect\n\t\t * the addition of the current iag at the head of\n\t\t * the list.\n\t\t */\n\t\tif ((fwd = imap->im_agctl[agno].extfree) >= 0) {\n\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\tgoto error_out;\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\t} else {\n\t\t/* iag has free extents. check if the addition of a free\n\t\t * extent will cause all extents to be free within this\n\t\t * iag.  if so, the iag will be removed from the ag extent\n\t\t * free list and placed on the inode map's free iag list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {\n\t\t\t/* in preparation for removing the iag from the\n\t\t\t * ag extent free list, read the iags preceding\n\t\t\t * and following the iag on the ag extent free\n\t\t\t * list.\n\t\t\t */\n\t\t\tif ((fwd = le32_to_cpu(iagp->extfreefwd)) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, fwd, &amp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\taiagp = (struct iag *) amp->data;\n\t\t\t}\n\n\t\t\tif ((back = le32_to_cpu(iagp->extfreeback)) >= 0) {\n\t\t\t\tif ((rc = diIAGRead(imap, back, &bmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* remove the iag from the ag inode free list if freeing\n\t * this extent cause the iag to have no free inodes.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {\n\t\tint inofreeback = le32_to_cpu(iagp->inofreeback);\n\t\tint inofreefwd = le32_to_cpu(iagp->inofreefwd);\n\n\t\t/* in preparation for removing the iag from the\n\t\t * ag inode free list, read the iags preceding\n\t\t * and following the iag on the ag inode free\n\t\t * list.  before reading these iags, we must make\n\t\t * sure that we already don't have them in hand\n\t\t * from up above, since re-reading an iag (buffer)\n\t\t * we are currently holding would cause a deadlock.\n\t\t */\n\t\tif (inofreefwd >= 0) {\n\n\t\t\tif (inofreefwd == fwd)\n\t\t\t\tciagp = (struct iag *) amp->data;\n\t\t\telse if (inofreefwd == back)\n\t\t\t\tciagp = (struct iag *) bmp->data;\n\t\t\telse {\n\t\t\t\tif ((rc =\n\t\t\t\t     diIAGRead(imap, inofreefwd, &cmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tciagp = (struct iag *) cmp->data;\n\t\t\t}\n\t\t\tassert(ciagp != NULL);\n\t\t}\n\n\t\tif (inofreeback >= 0) {\n\t\t\tif (inofreeback == fwd)\n\t\t\t\tdiagp = (struct iag *) amp->data;\n\t\t\telse if (inofreeback == back)\n\t\t\t\tdiagp = (struct iag *) bmp->data;\n\t\t\telse {\n\t\t\t\tif ((rc =\n\t\t\t\t     diIAGRead(imap, inofreeback, &dmp)))\n\t\t\t\t\tgoto error_out;\n\t\t\t\tdiagp = (struct iag *) dmp->data;\n\t\t\t}\n\t\t\tassert(diagp != NULL);\n\t\t}\n\t}\n\n\tIREAD_UNLOCK(ipimap);\n\n\t/*\n\t * invalidate any page of the inode extent freed from buffer cache;\n\t */\n\tfreepxd = iagp->inoext[extno];\n\tinvalidate_pxd_metapages(ip, freepxd);\n\n\t/*\n\t *\tupdate iag list(s) (careful update step 2)\n\t */\n\t/* add the iag to the ag extent free list if this is the\n\t * first free extent for the iag.\n\t */\n\tif (iagp->nfreeexts == 0) {\n\t\tif (fwd >= 0)\n\t\t\taiagp->extfreeback = cpu_to_le32(iagno);\n\n\t\tiagp->extfreefwd =\n\t\t    cpu_to_le32(imap->im_agctl[agno].extfree);\n\t\tiagp->extfreeback = cpu_to_le32(-1);\n\t\timap->im_agctl[agno].extfree = iagno;\n\t} else {\n\t\t/* remove the iag from the ag extent list if all extents\n\t\t * are now free and place it on the inode map iag free list.\n\t\t */\n\t\tif (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {\n\t\t\tif (fwd >= 0)\n\t\t\t\taiagp->extfreeback = iagp->extfreeback;\n\n\t\t\tif (back >= 0)\n\t\t\t\tbiagp->extfreefwd = iagp->extfreefwd;\n\t\t\telse\n\t\t\t\timap->im_agctl[agno].extfree =\n\t\t\t\t    le32_to_cpu(iagp->extfreefwd);\n\n\t\t\tiagp->extfreefwd = iagp->extfreeback = cpu_to_le32(-1);\n\n\t\t\tIAGFREE_LOCK(imap);\n\t\t\tiagp->iagfree = cpu_to_le32(imap->im_freeiag);\n\t\t\timap->im_freeiag = iagno;\n\t\t\tIAGFREE_UNLOCK(imap);\n\t\t}\n\t}\n\n\t/* remove the iag from the ag inode free list if freeing\n\t * this extent causes the iag to have no free inodes.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(INOSPEREXT - 1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0)\n\t\t\tciagp->inofreeback = iagp->inofreeback;\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0)\n\t\t\tdiagp->inofreefwd = iagp->inofreefwd;\n\t\telse\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t/* update the inode extent address and working map\n\t * to reflect the free extent.\n\t * the permanent map should have been updated already\n\t * for the inode being freed.\n\t */\n\tif (iagp->pmap[extno] != 0) {\n\t\tjfs_error(ip->i_sb, \"the pmap does not show inode free\\n\");\n\t}\n\tiagp->wmap[extno] = 0;\n\tPXDlength(&iagp->inoext[extno], 0);\n\tPXDaddress(&iagp->inoext[extno], 0);\n\n\t/* update the free extent and free inode summary maps\n\t * to reflect the freed extent.\n\t * the inode summary map is marked to indicate no inodes\n\t * available for the freed extent.\n\t */\n\tsword = extno >> L2EXTSPERSUM;\n\tbitno = extno & (EXTSPERSUM - 1);\n\tmask = HIGHORDER >> bitno;\n\tiagp->inosmap[sword] |= cpu_to_le32(mask);\n\tiagp->extsmap[sword] &= cpu_to_le32(~mask);\n\n\t/* update the number of free inodes and number of free extents\n\t * for the iag.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, -(INOSPEREXT - 1));\n\tle32_add_cpu(&iagp->nfreeexts, 1);\n\n\t/* update the number of free inodes and backed inodes\n\t * at the ag and inode map level.\n\t */\n\timap->im_agctl[agno].numfree -= (INOSPEREXT - 1);\n\timap->im_agctl[agno].numinos -= INOSPEREXT;\n\tatomic_sub(INOSPEREXT - 1, &imap->im_numfree);\n\tatomic_sub(INOSPEREXT, &imap->im_numinos);\n\n\tif (amp)\n\t\twrite_metapage(amp);\n\tif (bmp)\n\t\twrite_metapage(bmp);\n\tif (cmp)\n\t\twrite_metapage(cmp);\n\tif (dmp)\n\t\twrite_metapage(dmp);\n\n\t/*\n\t * start transaction to update block allocation map\n\t * for the inode extent freed;\n\t *\n\t * N.B. AG_LOCK is released and iag will be released below, and\n\t * other thread may allocate inode from/reusing the ixad freed\n\t * BUT with new/different backing inode extent from the extent\n\t * to be freed by the transaction;\n\t */\n\ttid = txBegin(ipimap->i_sb, COMMIT_FORCE);\n\tmutex_lock(&JFS_IP(ipimap)->commit_mutex);\n\n\t/* acquire tlock of the iag page of the freed ixad\n\t * to force the page NOHOMEOK (even though no data is\n\t * logged from the iag page) until NOREDOPAGE|FREEXTENT log\n\t * for the free of the extent is committed;\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor;\n\t */\n\ttlck = txLock(tid, ipimap, mp, tlckINODE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = freepxd;\n\tpxdlock->index = 1;\n\n\twrite_metapage(mp);\n\n\tiplist[0] = ipimap;\n\n\t/*\n\t * logredo needs the IAG number and IAG extent index in order\n\t * to ensure that the IMap is consistent.  The least disruptive\n\t * way to pass these values through  to the transaction manager\n\t * is in the iplist array.\n\t *\n\t * It's not pretty, but it works.\n\t */\n\tiplist[1] = (struct inode *) (size_t)iagno;\n\tiplist[2] = (struct inode *) (size_t)extno;\n\n\trc = txCommit(tid, 1, &iplist[0], COMMIT_FORCE);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ipimap)->commit_mutex);\n\n\t/* unlock the AG inode map information */\n\tAG_UNLOCK(imap, agno);\n\n\treturn (0);\n\n      error_out:\n\tIREAD_UNLOCK(ipimap);\n\n\tif (amp)\n\t\trelease_metapage(amp);\n\tif (bmp)\n\t\trelease_metapage(bmp);\n\tif (cmp)\n\t\trelease_metapage(cmp);\n\tif (dmp)\n\t\trelease_metapage(dmp);\n\n\tAG_UNLOCK(imap, agno);\n\n\trelease_metapage(mp);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_free_zero_link",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_free_zero_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
          "lines": "692-763",
          "snippet": "void jfs_free_zero_link(struct inode *ip)\n{\n\tint type;\n\n\tjfs_info(\"jfs_free_zero_link: ip = 0x%p\", ip);\n\n\t/* return if not reg or symbolic link or if size is\n\t * already ok.\n\t */\n\ttype = ip->i_mode & S_IFMT;\n\n\tswitch (type) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t/* if its contained in inode nothing to do */\n\t\tif (ip->i_size < IDATASIZE)\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/*\n\t * free EA\n\t */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT) {\n\t\ts64 xaddr = addressDXD(&JFS_IP(ip)->ea);\n\t\tint xlen = lengthDXD(&JFS_IP(ip)->ea);\n\t\tstruct maplock maplock;\t/* maplock for COMMIT_WMAP */\n\t\tstruct pxd_lock *pxdlock;\t/* maplock for COMMIT_WMAP */\n\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(ip, JFS_IP(ip)->ea);\n\n\t\t/* free EA extent from working block map */\n\t\tmaplock.index = 1;\n\t\tpxdlock = (struct pxd_lock *) & maplock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\tPXDlength(&pxdlock->pxd, xlen);\n\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\t}\n\n\t/*\n\t * free ACL\n\t */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT) {\n\t\ts64 xaddr = addressDXD(&JFS_IP(ip)->acl);\n\t\tint xlen = lengthDXD(&JFS_IP(ip)->acl);\n\t\tstruct maplock maplock;\t/* maplock for COMMIT_WMAP */\n\t\tstruct pxd_lock *pxdlock;\t/* maplock for COMMIT_WMAP */\n\n\t\tinvalidate_dxd_metapages(ip, JFS_IP(ip)->acl);\n\n\t\t/* free ACL extent from working block map */\n\t\tmaplock.index = 1;\n\t\tpxdlock = (struct pxd_lock *) & maplock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\tPXDlength(&pxdlock->pxd, xlen);\n\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\t}\n\n\t/*\n\t * free xtree/data (truncate to zero length):\n\t * free xtree/data pages from cache, and\n\t * free xtree/data blocks from working block map;\n\t */\n\tif (ip->i_size)\n\t\txtTruncate(0, ip, 0, COMMIT_WMAP);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static s64 commitZeroLink(tid_t, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nvoid jfs_free_zero_link(struct inode *ip)\n{\n\tint type;\n\n\tjfs_info(\"jfs_free_zero_link: ip = 0x%p\", ip);\n\n\t/* return if not reg or symbolic link or if size is\n\t * already ok.\n\t */\n\ttype = ip->i_mode & S_IFMT;\n\n\tswitch (type) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t/* if its contained in inode nothing to do */\n\t\tif (ip->i_size < IDATASIZE)\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/*\n\t * free EA\n\t */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT) {\n\t\ts64 xaddr = addressDXD(&JFS_IP(ip)->ea);\n\t\tint xlen = lengthDXD(&JFS_IP(ip)->ea);\n\t\tstruct maplock maplock;\t/* maplock for COMMIT_WMAP */\n\t\tstruct pxd_lock *pxdlock;\t/* maplock for COMMIT_WMAP */\n\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(ip, JFS_IP(ip)->ea);\n\n\t\t/* free EA extent from working block map */\n\t\tmaplock.index = 1;\n\t\tpxdlock = (struct pxd_lock *) & maplock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\tPXDlength(&pxdlock->pxd, xlen);\n\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\t}\n\n\t/*\n\t * free ACL\n\t */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT) {\n\t\ts64 xaddr = addressDXD(&JFS_IP(ip)->acl);\n\t\tint xlen = lengthDXD(&JFS_IP(ip)->acl);\n\t\tstruct maplock maplock;\t/* maplock for COMMIT_WMAP */\n\t\tstruct pxd_lock *pxdlock;\t/* maplock for COMMIT_WMAP */\n\n\t\tinvalidate_dxd_metapages(ip, JFS_IP(ip)->acl);\n\n\t\t/* free ACL extent from working block map */\n\t\tmaplock.index = 1;\n\t\tpxdlock = (struct pxd_lock *) & maplock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\tPXDlength(&pxdlock->pxd, xlen);\n\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\t}\n\n\t/*\n\t * free xtree/data (truncate to zero length):\n\t * free xtree/data pages from cache, and\n\t * free xtree/data blocks from working block map;\n\t */\n\tif (ip->i_size)\n\t\txtTruncate(0, ip, 0, COMMIT_WMAP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Freewmap",
            "inode"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"In jfs_evict_inode, inode = 0x%p\"",
            "inode"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nvoid jfs_evict_inode(struct inode *inode)\n{\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\n\t\t\tdiFree(inode);\n\n\t\t\t/*\n\t\t\t * Free the inode from the quota allocation.\n\t\t\t */\n\t\t\tdquot_initialize(inode);\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n}"
  },
  {
    "function_name": "jfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "125-147",
    "snippet": "int jfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint wait = wbc->sync_mode == WB_SYNC_ALL;\n\n\tif (inode->i_nlink == 0)\n\t\treturn 0;\n\t/*\n\t * If COMMIT_DIRTY is not set, the inode isn't really dirty.\n\t * It has been committed since the last change, but was still\n\t * on the dirty inode list.\n\t */\n\t if (!test_cflag(COMMIT_Dirty, inode)) {\n\t\t/* Make sure committed changes hit the disk */\n\t\tjfs_flush_journal(JFS_SBI(inode->i_sb)->log, wait);\n\t\treturn 0;\n\t }\n\n\tif (jfs_commit_inode(inode, wait)) {\n\t\tjfs_err(\"jfs_write_inode: jfs_commit_inode failed!\");\n\t\treturn -EIO;\n\t} else\n\t\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_write_inode: jfs_commit_inode failed!\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_commit_inode",
          "args": [
            "inode",
            "wait"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_commit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "83-123",
          "snippet": "int jfs_commit_inode(struct inode *inode, int wait)\n{\n\tint rc = 0;\n\ttid_t tid;\n\tstatic int noisy = 5;\n\n\tjfs_info(\"In jfs_commit_inode, inode = 0x%p\", inode);\n\n\t/*\n\t * Don't commit if inode has been committed since last being\n\t * marked dirty, or if it has been deleted.\n\t */\n\tif (inode->i_nlink == 0 || !test_cflag(COMMIT_Dirty, inode))\n\t\treturn 0;\n\n\tif (isReadOnly(inode)) {\n\t\t/* kernel allows writes to devices on read-only\n\t\t * partitions and may think inode is dirty\n\t\t */\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\tjfs_err(\"jfs_commit_inode(0x%p) called on \"\n\t\t\t\t   \"read-only volume\", inode);\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn 0;\n\t}\n\n\ttid = txBegin(inode->i_sb, COMMIT_INODE);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\n\t/*\n\t * Retest inode state after taking commit_mutex\n\t */\n\tif (inode->i_nlink && test_cflag(COMMIT_Dirty, inode))\n\t\trc = txCommit(tid, 1, &inode, wait ? COMMIT_SYNC : 0);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nint jfs_commit_inode(struct inode *inode, int wait)\n{\n\tint rc = 0;\n\ttid_t tid;\n\tstatic int noisy = 5;\n\n\tjfs_info(\"In jfs_commit_inode, inode = 0x%p\", inode);\n\n\t/*\n\t * Don't commit if inode has been committed since last being\n\t * marked dirty, or if it has been deleted.\n\t */\n\tif (inode->i_nlink == 0 || !test_cflag(COMMIT_Dirty, inode))\n\t\treturn 0;\n\n\tif (isReadOnly(inode)) {\n\t\t/* kernel allows writes to devices on read-only\n\t\t * partitions and may think inode is dirty\n\t\t */\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\tjfs_err(\"jfs_commit_inode(0x%p) called on \"\n\t\t\t\t   \"read-only volume\", inode);\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn 0;\n\t}\n\n\ttid = txBegin(inode->i_sb, COMMIT_INODE);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\n\t/*\n\t * Retest inode state after taking commit_mutex\n\t */\n\tif (inode->i_nlink && test_cflag(COMMIT_Dirty, inode))\n\t\trc = txCommit(tid, 1, &inode, wait ? COMMIT_SYNC : 0);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_flush_journal",
          "args": [
            "JFS_SBI(inode->i_sb)->log",
            "wait"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_flush_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1532-1638",
          "snippet": "void jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nvoid jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "inode->i_sb"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Dirty",
            "inode"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nint jfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint wait = wbc->sync_mode == WB_SYNC_ALL;\n\n\tif (inode->i_nlink == 0)\n\t\treturn 0;\n\t/*\n\t * If COMMIT_DIRTY is not set, the inode isn't really dirty.\n\t * It has been committed since the last change, but was still\n\t * on the dirty inode list.\n\t */\n\t if (!test_cflag(COMMIT_Dirty, inode)) {\n\t\t/* Make sure committed changes hit the disk */\n\t\tjfs_flush_journal(JFS_SBI(inode->i_sb)->log, wait);\n\t\treturn 0;\n\t }\n\n\tif (jfs_commit_inode(inode, wait)) {\n\t\tjfs_err(\"jfs_write_inode: jfs_commit_inode failed!\");\n\t\treturn -EIO;\n\t} else\n\t\treturn 0;\n}"
  },
  {
    "function_name": "jfs_commit_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "83-123",
    "snippet": "int jfs_commit_inode(struct inode *inode, int wait)\n{\n\tint rc = 0;\n\ttid_t tid;\n\tstatic int noisy = 5;\n\n\tjfs_info(\"In jfs_commit_inode, inode = 0x%p\", inode);\n\n\t/*\n\t * Don't commit if inode has been committed since last being\n\t * marked dirty, or if it has been deleted.\n\t */\n\tif (inode->i_nlink == 0 || !test_cflag(COMMIT_Dirty, inode))\n\t\treturn 0;\n\n\tif (isReadOnly(inode)) {\n\t\t/* kernel allows writes to devices on read-only\n\t\t * partitions and may think inode is dirty\n\t\t */\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\tjfs_err(\"jfs_commit_inode(0x%p) called on \"\n\t\t\t\t   \"read-only volume\", inode);\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn 0;\n\t}\n\n\ttid = txBegin(inode->i_sb, COMMIT_INODE);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\n\t/*\n\t * Retest inode state after taking commit_mutex\n\t */\n\tif (inode->i_nlink && test_cflag(COMMIT_Dirty, inode))\n\t\trc = txCommit(tid, 1, &inode, wait ? COMMIT_SYNC : 0);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(inode)->commit_mutex"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&inode",
            "wait ? COMMIT_SYNC : 0"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Dirty",
            "inode"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&JFS_IP(inode)->commit_mutex"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "inode->i_sb",
            "COMMIT_INODE"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"Is remount racy?\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_commit_inode(0x%p) called on \"\n\t\t\t\t   \"read-only volume\"",
            "inode"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "special_file",
          "args": [
            "inode->i_mode"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isReadOnly",
          "args": [
            "inode"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "isReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "222-227",
          "snippet": "static inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Dirty",
            "inode"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"In jfs_commit_inode, inode = 0x%p\"",
            "inode"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nint jfs_commit_inode(struct inode *inode, int wait)\n{\n\tint rc = 0;\n\ttid_t tid;\n\tstatic int noisy = 5;\n\n\tjfs_info(\"In jfs_commit_inode, inode = 0x%p\", inode);\n\n\t/*\n\t * Don't commit if inode has been committed since last being\n\t * marked dirty, or if it has been deleted.\n\t */\n\tif (inode->i_nlink == 0 || !test_cflag(COMMIT_Dirty, inode))\n\t\treturn 0;\n\n\tif (isReadOnly(inode)) {\n\t\t/* kernel allows writes to devices on read-only\n\t\t * partitions and may think inode is dirty\n\t\t */\n\t\tif (!special_file(inode->i_mode) && noisy) {\n\t\t\tjfs_err(\"jfs_commit_inode(0x%p) called on \"\n\t\t\t\t   \"read-only volume\", inode);\n\t\t\tjfs_err(\"Is remount racy?\");\n\t\t\tnoisy--;\n\t\t}\n\t\treturn 0;\n\t}\n\n\ttid = txBegin(inode->i_sb, COMMIT_INODE);\n\tmutex_lock(&JFS_IP(inode)->commit_mutex);\n\n\t/*\n\t * Retest inode state after taking commit_mutex\n\t */\n\tif (inode->i_nlink && test_cflag(COMMIT_Dirty, inode))\n\t\trc = txCommit(tid, 1, &inode, wait ? COMMIT_SYNC : 0);\n\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(inode)->commit_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
    "lines": "36-78",
    "snippet": "struct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\t/*\n\t\t\t * The inline data should be null-terminated, but\n\t\t\t * don't let on-disk corruption crash the kernel\n\t\t\t */\n\t\t\tJFS_IP(inode)->i_inline[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_extent.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/mpage.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct address_space_operations jfs_aops = {\n\t.readpage\t= jfs_readpage,\n\t.readpages\t= jfs_readpages,\n\t.writepage\t= jfs_writepage,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= nobh_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "inode->i_rdev"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diRead",
          "args": [
            "inode"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "diRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "304-404",
          "snippet": "int diRead(struct inode *ip)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tint iagno, ino, extno, rc;\n\tstruct inode *ipimap;\n\tstruct dinode *dp;\n\tstruct iag *iagp;\n\tstruct metapage *mp;\n\ts64 blkno, agstart;\n\tstruct inomap *imap;\n\tint block_offset;\n\tint inodes_left;\n\tunsigned long pageno;\n\tint rel_inode;\n\n\tjfs_info(\"diRead: ino = %ld\", ip->i_ino);\n\n\tipimap = sbi->ipimap;\n\tJFS_IP(ip)->ipimap = ipimap;\n\n\t/* determine the iag number for this inode (number) */\n\tiagno = INOTOIAG(ip->i_ino);\n\n\t/* read the iag */\n\timap = JFS_IP(ipimap)->i_imap;\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\trc = diIAGRead(imap, iagno, &mp);\n\tIREAD_UNLOCK(ipimap);\n\tif (rc) {\n\t\tjfs_err(\"diRead: diIAGRead returned %d\", rc);\n\t\treturn (rc);\n\t}\n\n\tiagp = (struct iag *) mp->data;\n\n\t/* determine inode extent that holds the disk inode */\n\tino = ip->i_ino & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\n\tif ((lengthPXD(&iagp->inoext[extno]) != imap->im_nbperiext) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\trelease_metapage(mp);\n\t\treturn -ESTALE;\n\t}\n\n\t/* get disk block number of the page within the inode extent\n\t * that holds the disk inode.\n\t */\n\tblkno = INOPBLK(&iagp->inoext[extno], ino, sbi->l2nbperpage);\n\n\t/* get the ag for the iag */\n\tagstart = le64_to_cpu(iagp->agstart);\n\n\trelease_metapage(mp);\n\n\trel_inode = (ino & (INOSPERPAGE - 1));\n\tpageno = blkno >> sbi->l2nbperpage;\n\n\tif ((block_offset = ((u32) blkno & (sbi->nbperpage - 1)))) {\n\t\t/*\n\t\t * OS/2 didn't always align inode extents on page boundaries\n\t\t */\n\t\tinodes_left =\n\t\t     (sbi->nbperpage - block_offset) << sbi->l2niperblk;\n\n\t\tif (rel_inode < inodes_left)\n\t\t\trel_inode += block_offset << sbi->l2niperblk;\n\t\telse {\n\t\t\tpageno += 1;\n\t\t\trel_inode -= inodes_left;\n\t\t}\n\t}\n\n\t/* read the page of disk inode */\n\tmp = read_metapage(ipimap, pageno << sbi->l2nbperpage, PSIZE, 1);\n\tif (!mp) {\n\t\tjfs_err(\"diRead: read_metapage failed\");\n\t\treturn -EIO;\n\t}\n\n\t/* locate the disk inode requested */\n\tdp = (struct dinode *) mp->data;\n\tdp += rel_inode;\n\n\tif (ip->i_ino != le32_to_cpu(dp->di_number)) {\n\t\tjfs_error(ip->i_sb, \"i_ino != di_number\\n\");\n\t\trc = -EIO;\n\t} else if (le32_to_cpu(dp->di_nlink) == 0)\n\t\trc = -ESTALE;\n\telse\n\t\t/* copy the disk inode to the in-memory inode */\n\t\trc = copy_from_dinode(dp, ip);\n\n\trelease_metapage(mp);\n\n\t/* set the ag for the inode */\n\tJFS_IP(ip)->agstart = agstart;\n\tJFS_IP(ip)->active_ag = -1;\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diFindFree(u32, int);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static void duplicateIXtree(struct super_block *, s64, int, s64 *);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic void duplicateIXtree(struct super_block *, s64, int, s64 *);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nint diRead(struct inode *ip)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tint iagno, ino, extno, rc;\n\tstruct inode *ipimap;\n\tstruct dinode *dp;\n\tstruct iag *iagp;\n\tstruct metapage *mp;\n\ts64 blkno, agstart;\n\tstruct inomap *imap;\n\tint block_offset;\n\tint inodes_left;\n\tunsigned long pageno;\n\tint rel_inode;\n\n\tjfs_info(\"diRead: ino = %ld\", ip->i_ino);\n\n\tipimap = sbi->ipimap;\n\tJFS_IP(ip)->ipimap = ipimap;\n\n\t/* determine the iag number for this inode (number) */\n\tiagno = INOTOIAG(ip->i_ino);\n\n\t/* read the iag */\n\timap = JFS_IP(ipimap)->i_imap;\n\tIREAD_LOCK(ipimap, RDWRLOCK_IMAP);\n\trc = diIAGRead(imap, iagno, &mp);\n\tIREAD_UNLOCK(ipimap);\n\tif (rc) {\n\t\tjfs_err(\"diRead: diIAGRead returned %d\", rc);\n\t\treturn (rc);\n\t}\n\n\tiagp = (struct iag *) mp->data;\n\n\t/* determine inode extent that holds the disk inode */\n\tino = ip->i_ino & (INOSPERIAG - 1);\n\textno = ino >> L2INOSPEREXT;\n\n\tif ((lengthPXD(&iagp->inoext[extno]) != imap->im_nbperiext) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\trelease_metapage(mp);\n\t\treturn -ESTALE;\n\t}\n\n\t/* get disk block number of the page within the inode extent\n\t * that holds the disk inode.\n\t */\n\tblkno = INOPBLK(&iagp->inoext[extno], ino, sbi->l2nbperpage);\n\n\t/* get the ag for the iag */\n\tagstart = le64_to_cpu(iagp->agstart);\n\n\trelease_metapage(mp);\n\n\trel_inode = (ino & (INOSPERPAGE - 1));\n\tpageno = blkno >> sbi->l2nbperpage;\n\n\tif ((block_offset = ((u32) blkno & (sbi->nbperpage - 1)))) {\n\t\t/*\n\t\t * OS/2 didn't always align inode extents on page boundaries\n\t\t */\n\t\tinodes_left =\n\t\t     (sbi->nbperpage - block_offset) << sbi->l2niperblk;\n\n\t\tif (rel_inode < inodes_left)\n\t\t\trel_inode += block_offset << sbi->l2niperblk;\n\t\telse {\n\t\t\tpageno += 1;\n\t\t\trel_inode -= inodes_left;\n\t\t}\n\t}\n\n\t/* read the page of disk inode */\n\tmp = read_metapage(ipimap, pageno << sbi->l2nbperpage, PSIZE, 1);\n\tif (!mp) {\n\t\tjfs_err(\"diRead: read_metapage failed\");\n\t\treturn -EIO;\n\t}\n\n\t/* locate the disk inode requested */\n\tdp = (struct dinode *) mp->data;\n\tdp += rel_inode;\n\n\tif (ip->i_ino != le32_to_cpu(dp->di_number)) {\n\t\tjfs_error(ip->i_sb, \"i_ino != di_number\\n\");\n\t\trc = -EIO;\n\t} else if (le32_to_cpu(dp->di_nlink) == 0)\n\t\trc = -ESTALE;\n\telse\n\t\t/* copy the disk inode to the in-memory inode */\n\t\trc = copy_from_dinode(dp, ip);\n\n\trelease_metapage(mp);\n\n\t/* set the ag for the inode */\n\tJFS_IP(ip)->agstart = agstart;\n\tJFS_IP(ip)->active_ag = -1;\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nconst struct address_space_operations jfs_aops = {\n\t.readpage\t= jfs_readpage,\n\t.readpages\t= jfs_readpages,\n\t.writepage\t= jfs_writepage,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= nobh_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n};\n\nstruct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\t/*\n\t\t\t * The inline data should be null-terminated, but\n\t\t\t * don't let on-disk corruption crash the kernel\n\t\t\t */\n\t\t\tJFS_IP(inode)->i_inline[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
  }
]