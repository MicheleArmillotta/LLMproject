[
  {
    "function_name": "nfs42_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4file.c",
    "lines": "140-164",
    "snippet": "static long nfs42_fallocate(struct file *filep, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(filep);\n\tlong ret;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((mode != 0) && (mode != (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EOPNOTSUPP;\n\n\tret = inode_newsize_ok(inode, offset + len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\tret = nfs42_proc_deallocate(filep, offset, len);\n\telse\n\t\tret = nfs42_proc_allocate(filep, offset, len);\n\tmutex_unlock(&inode->i_mutex);\n\n\tnfs_zap_caches(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"nfs42.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/falloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_zap_caches",
          "args": [
            "inode"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_zap_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "189-194",
          "snippet": "void nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nvoid nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs42_proc_allocate",
          "args": [
            "filep",
            "offset",
            "len"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "nfs42_proc_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
          "lines": "76-91",
          "snippet": "int nfs42_proc_allocate(struct file *filep, loff_t offset, loff_t len)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ALLOCATE],\n\t};\n\tstruct inode *inode = file_inode(filep);\n\tint err;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_ALLOCATE))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nfs42_proc_fallocate(&msg, filep, offset, len);\n\tif (err == -EOPNOTSUPP)\n\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_ALLOCATE;\n\treturn err;\n}",
          "includes": [
            "#include \"nfs42.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nint nfs42_proc_allocate(struct file *filep, loff_t offset, loff_t len)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ALLOCATE],\n\t};\n\tstruct inode *inode = file_inode(filep);\n\tint err;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_ALLOCATE))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nfs42_proc_fallocate(&msg, filep, offset, len);\n\tif (err == -EOPNOTSUPP)\n\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_ALLOCATE;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs42_proc_deallocate",
          "args": [
            "filep",
            "offset",
            "len"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "nfs42_proc_deallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
          "lines": "93-108",
          "snippet": "int nfs42_proc_deallocate(struct file *filep, loff_t offset, loff_t len)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DEALLOCATE],\n\t};\n\tstruct inode *inode = file_inode(filep);\n\tint err;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_DEALLOCATE))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nfs42_proc_fallocate(&msg, filep, offset, len);\n\tif (err == -EOPNOTSUPP)\n\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_DEALLOCATE;\n\treturn err;\n}",
          "includes": [
            "#include \"nfs42.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nint nfs42_proc_deallocate(struct file *filep, loff_t offset, loff_t len)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DEALLOCATE],\n\t};\n\tstruct inode *inode = file_inode(filep);\n\tint err;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_DEALLOCATE))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nfs42_proc_fallocate(&msg, filep, offset, len);\n\tif (err == -EOPNOTSUPP)\n\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_DEALLOCATE;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "offset + len"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "99-124",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filep"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs42.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/falloc.h>\n#include <linux/fs.h>\n\nstatic long nfs42_fallocate(struct file *filep, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(filep);\n\tlong ret;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((mode != 0) && (mode != (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EOPNOTSUPP;\n\n\tret = inode_newsize_ok(inode, offset + len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\tret = nfs42_proc_deallocate(filep, offset, len);\n\telse\n\t\tret = nfs42_proc_allocate(filep, offset, len);\n\tmutex_unlock(&inode->i_mutex);\n\n\tnfs_zap_caches(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4_file_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4file.c",
    "lines": "125-138",
    "snippet": "static loff_t nfs4_file_llseek(struct file *filep, loff_t offset, int whence)\n{\n\tloff_t ret;\n\n\tswitch (whence) {\n\tcase SEEK_HOLE:\n\tcase SEEK_DATA:\n\t\tret = nfs42_proc_llseek(filep, offset, whence);\n\t\tif (ret != -ENOTSUPP)\n\t\t\treturn ret;\n\tdefault:\n\t\treturn nfs_file_llseek(filep, offset, whence);\n\t}\n}",
    "includes": [
      "#include \"nfs42.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/falloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_file_llseek",
          "args": [
            "filep",
            "offset",
            "whence"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_file_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "121-139",
          "snippet": "loff_t nfs_file_llseek(struct file *filp, loff_t offset, int whence)\n{\n\tdprintk(\"NFS: llseek file(%pD2, %lld, %d)\\n\",\n\t\t\tfilp, offset, whence);\n\n\t/*\n\t * whence == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate\n\t * the cached file length\n\t */\n\tif (whence != SEEK_SET && whence != SEEK_CUR) {\n\t\tstruct inode *inode = filp->f_mapping->host;\n\n\t\tint retval = nfs_revalidate_file_size(inode, filp);\n\t\tif (retval < 0)\n\t\t\treturn (loff_t)retval;\n\t}\n\n\treturn generic_file_llseek(filp, offset, whence);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nloff_t nfs_file_llseek(struct file *filp, loff_t offset, int whence)\n{\n\tdprintk(\"NFS: llseek file(%pD2, %lld, %d)\\n\",\n\t\t\tfilp, offset, whence);\n\n\t/*\n\t * whence == SEEK_END || SEEK_DATA || SEEK_HOLE => we must revalidate\n\t * the cached file length\n\t */\n\tif (whence != SEEK_SET && whence != SEEK_CUR) {\n\t\tstruct inode *inode = filp->f_mapping->host;\n\n\t\tint retval = nfs_revalidate_file_size(inode, filp);\n\t\tif (retval < 0)\n\t\t\treturn (loff_t)retval;\n\t}\n\n\treturn generic_file_llseek(filp, offset, whence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs42_proc_llseek",
          "args": [
            "filep",
            "offset",
            "whence"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "nfs42_proc_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs42proc.c",
          "lines": "110-144",
          "snippet": "loff_t nfs42_proc_llseek(struct file *filep, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct nfs42_seek_args args = {\n\t\t.sa_fh\t\t= NFS_FH(inode),\n\t\t.sa_offset\t= offset,\n\t\t.sa_what\t= (whence == SEEK_HOLE) ?\n\t\t\t\t\tNFS4_CONTENT_HOLE : NFS4_CONTENT_DATA,\n\t};\n\tstruct nfs42_seek_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SEEK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint status;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_SEEK))\n\t\treturn -ENOTSUPP;\n\n\tstatus = nfs42_set_rw_stateid(&args.sa_stateid, filep, FMODE_READ);\n\tif (status)\n\t\treturn status;\n\n\tnfs_wb_all(inode);\n\tstatus = nfs4_call_sync(server->client, server, &msg,\n\t\t\t\t&args.seq_args, &res.seq_res, 0);\n\tif (status == -ENOTSUPP)\n\t\tserver->caps &= ~NFS_CAP_SEEK;\n\tif (status)\n\t\treturn status;\n\n\treturn vfs_setpos(filep, res.sr_offset, inode->i_sb->s_maxbytes);\n}",
          "includes": [
            "#include \"nfs42.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs42.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/nfs_xdr.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/fs.h>\n\nloff_t nfs42_proc_llseek(struct file *filep, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(filep);\n\tstruct nfs42_seek_args args = {\n\t\t.sa_fh\t\t= NFS_FH(inode),\n\t\t.sa_offset\t= offset,\n\t\t.sa_what\t= (whence == SEEK_HOLE) ?\n\t\t\t\t\tNFS4_CONTENT_HOLE : NFS4_CONTENT_DATA,\n\t};\n\tstruct nfs42_seek_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SEEK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint status;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_SEEK))\n\t\treturn -ENOTSUPP;\n\n\tstatus = nfs42_set_rw_stateid(&args.sa_stateid, filep, FMODE_READ);\n\tif (status)\n\t\treturn status;\n\n\tnfs_wb_all(inode);\n\tstatus = nfs4_call_sync(server->client, server, &msg,\n\t\t\t\t&args.seq_args, &res.seq_res, 0);\n\tif (status == -ENOTSUPP)\n\t\tserver->caps &= ~NFS_CAP_SEEK;\n\tif (status)\n\t\treturn status;\n\n\treturn vfs_setpos(filep, res.sr_offset, inode->i_sb->s_maxbytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs42.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/falloc.h>\n#include <linux/fs.h>\n\nstatic loff_t nfs4_file_llseek(struct file *filep, loff_t offset, int whence)\n{\n\tloff_t ret;\n\n\tswitch (whence) {\n\tcase SEEK_HOLE:\n\tcase SEEK_DATA:\n\t\tret = nfs42_proc_llseek(filep, offset, whence);\n\t\tif (ret != -ENOTSUPP)\n\t\t\treturn ret;\n\tdefault:\n\t\treturn nfs_file_llseek(filep, offset, whence);\n\t}\n}"
  },
  {
    "function_name": "nfs4_file_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4file.c",
    "lines": "97-122",
    "snippet": "static int\nnfs4_file_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\n\tdo {\n\t\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tmutex_lock(&inode->i_mutex);\n\t\tret = nfs_file_fsync_commit(file, start, end, datasync);\n\t\tif (!ret)\n\t\t\tret = pnfs_layoutcommit_inode(inode, true);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\t/*\n\t\t * If nfs_file_fsync_commit detected a server reboot, then\n\t\t * resend all dirty pages that might have been covered by\n\t\t * the NFS_CONTEXT_RESEND_WRITES flag\n\t\t */\n\t\tstart = 0;\n\t\tend = LLONG_MAX;\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"nfs42.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/falloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_layoutcommit_inode",
          "args": [
            "inode",
            "true"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layoutcommit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "642-645",
          "snippet": "static inline int pnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline int pnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_fsync_commit",
          "args": [
            "file",
            "start",
            "end",
            "datasync"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_file_fsync_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "244-273",
          "snippet": "int\nnfs_file_fsync_commit(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode *inode = file_inode(file);\n\tint have_error, do_resend, status;\n\tint ret = 0;\n\n\tdprintk(\"NFS: fsync file(%pD2) datasync %d\\n\", file, datasync);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFSYNC);\n\tdo_resend = test_and_clear_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\thave_error = test_and_clear_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n\tstatus = nfs_commit_inode(inode, FLUSH_SYNC);\n\thave_error |= test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n\tif (have_error) {\n\t\tret = xchg(&ctx->error, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (status < 0) {\n\t\tret = status;\n\t\tgoto out;\n\t}\n\tdo_resend |= test_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\tif (do_resend)\n\t\tret = -EAGAIN;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint\nnfs_file_fsync_commit(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode *inode = file_inode(file);\n\tint have_error, do_resend, status;\n\tint ret = 0;\n\n\tdprintk(\"NFS: fsync file(%pD2) datasync %d\\n\", file, datasync);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSFSYNC);\n\tdo_resend = test_and_clear_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\thave_error = test_and_clear_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n\tstatus = nfs_commit_inode(inode, FLUSH_SYNC);\n\thave_error |= test_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n\tif (have_error) {\n\t\tret = xchg(&ctx->error, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (status < 0) {\n\t\tret = status;\n\t\tgoto out;\n\t}\n\tdo_resend |= test_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\tif (do_resend)\n\t\tret = -EAGAIN;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs42.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/falloc.h>\n#include <linux/fs.h>\n\nstatic int\nnfs4_file_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tint ret;\n\tstruct inode *inode = file_inode(file);\n\n\tdo {\n\t\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tmutex_lock(&inode->i_mutex);\n\t\tret = nfs_file_fsync_commit(file, start, end, datasync);\n\t\tif (!ret)\n\t\t\tret = pnfs_layoutcommit_inode(inode, true);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\t/*\n\t\t * If nfs_file_fsync_commit detected a server reboot, then\n\t\t * resend all dirty pages that might have been covered by\n\t\t * the NFS_CONTEXT_RESEND_WRITES flag\n\t\t */\n\t\tstart = 0;\n\t\tend = LLONG_MAX;\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4file.c",
    "lines": "19-95",
    "snippet": "static int\nnfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint opened = 0;\n\tint err;\n\n\t/*\n\t * If no cached dentry exists or if it's negative, NFSv4 handled the\n\t * opens in ->lookup() or ->create().\n\t *\n\t * We only get this far for a cached positive dentry.  We skipped\n\t * revalidation, so handle it here by dropping the dentry and returning\n\t * -EOPENSTALE.  The VFS will retry the lookup/create/open.\n\t */\n\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\topenflags--;\n\n\t/* We can't create new files here */\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);\n\tdir = parent->d_inode;\n\n\tctx = alloc_nfs_open_context(filp->f_path.dentry, filp->f_mode);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tnfs_wb_all(inode);\n\t}\n\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, &opened);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tcase -EPERM:\n\t\tcase -EACCES:\n\t\tcase -EDQUOT:\n\t\tcase -ENOSPC:\n\t\tcase -EROFS:\n\t\t\tgoto out_put_ctx;\n\t\tdefault:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != dentry->d_inode)\n\t\tgoto out_drop;\n\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\n\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\n\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}",
    "includes": [
      "#include \"nfs42.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/falloc.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_nfs_open_context",
          "args": [
            "ctx"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "833-836",
          "snippet": "void put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_fscache_open_file",
          "args": [
            "inode",
            "filp"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fscache_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
          "lines": "233-252",
          "snippet": "void nfs_fscache_open_file(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct fscache_cookie *cookie = nfs_i_fscache(inode);\n\n\tif (!fscache_cookie_valid(cookie))\n\t\treturn;\n\n\tif (inode_is_open_for_write(inode)) {\n\t\tdfprintk(FSCACHE, \"NFS: nfsi 0x%p disabling cache\\n\", nfsi);\n\t\tclear_bit(NFS_INO_FSCACHE, &nfsi->flags);\n\t\tfscache_disable_cookie(cookie, true);\n\t\tfscache_uncache_all_inode_pages(cookie, inode);\n\t} else {\n\t\tdfprintk(FSCACHE, \"NFS: nfsi 0x%p enabling cache\\n\", nfsi);\n\t\tfscache_enable_cookie(cookie, nfs_fscache_can_enable, inode);\n\t\tif (fscache_cookie_enabled(cookie))\n\t\t\tset_bit(NFS_INO_FSCACHE, &NFS_I(inode)->flags);\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/in6.h>",
            "#include <linux/nfs_fs_sb.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid nfs_fscache_open_file(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct fscache_cookie *cookie = nfs_i_fscache(inode);\n\n\tif (!fscache_cookie_valid(cookie))\n\t\treturn;\n\n\tif (inode_is_open_for_write(inode)) {\n\t\tdfprintk(FSCACHE, \"NFS: nfsi 0x%p disabling cache\\n\", nfsi);\n\t\tclear_bit(NFS_INO_FSCACHE, &nfsi->flags);\n\t\tfscache_disable_cookie(cookie, true);\n\t\tfscache_uncache_all_inode_pages(cookie, inode);\n\t} else {\n\t\tdfprintk(FSCACHE, \"NFS: nfsi 0x%p enabling cache\\n\", nfsi);\n\t\tfscache_enable_cookie(cookie, nfs_fscache_can_enable, inode);\n\t\tif (fscache_cookie_enabled(cookie))\n\t\t\tset_bit(NFS_INO_FSCACHE, &NFS_I(inode)->flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_set_open_context",
          "args": [
            "filp",
            "ctx"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_file_set_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "854-859",
          "snippet": "void nfs_file_set_open_context(struct file *filp, struct nfs_open_context *ctx)\n{\n\tfilp->private_data = get_nfs_open_context(ctx);\n\tif (list_empty(&ctx->list))\n\t\tnfs_inode_attach_open_context(ctx);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_file_set_open_context(struct file *filp, struct nfs_open_context *ctx)\n{\n\tfilp->private_data = get_nfs_open_context(ctx);\n\tif (list_empty(&ctx->list))\n\t\tnfs_inode_attach_open_context(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_set_verifier",
          "args": [
            "dentry",
            "nfs_save_change_attribute(dir)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_save_change_attribute",
          "args": [
            "dir"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "ctx",
            "openflags",
            "&attr",
            "&opened"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_wb_all",
          "args": [
            "inode"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wb_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1841-1857",
          "snippet": "int nfs_wb_all(struct inode *inode)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_inode_enter(inode);\n\n\tret = sync_inode(inode, &wbc);\n\n\ttrace_nfs_writeback_inode_exit(inode, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_wb_all(struct inode *inode)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_inode_enter(inode);\n\n\tret = sync_inode(inode, &wbc);\n\n\ttrace_nfs_writeback_inode_exit(inode, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctx"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ctx"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_nfs_open_context",
          "args": [
            "filp->f_path.dentry",
            "filp->f_mode"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "776-800",
          "snippet": "struct nfs_open_context *alloc_nfs_open_context(struct dentry *dentry, fmode_t f_mode)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct rpc_cred *cred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn ERR_CAST(cred);\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tput_rpccred(cred);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnfs_sb_active(dentry->d_sb);\n\tctx->dentry = dget(dentry);\n\tctx->cred = cred;\n\tctx->state = NULL;\n\tctx->mode = f_mode;\n\tctx->flags = 0;\n\tctx->error = 0;\n\tnfs_init_lock_context(&ctx->lock_context);\n\tctx->lock_context.open_context = ctx;\n\tINIT_LIST_HEAD(&ctx->list);\n\tctx->mdsthreshold = NULL;\n\treturn ctx;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs_open_context *alloc_nfs_open_context(struct dentry *dentry, fmode_t f_mode)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct rpc_cred *cred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn ERR_CAST(cred);\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tput_rpccred(cred);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnfs_sb_active(dentry->d_sb);\n\tctx->dentry = dget(dentry);\n\tctx->cred = cred;\n\tctx->state = NULL;\n\tctx->mode = f_mode;\n\tctx->flags = 0;\n\tctx->error = 0;\n\tnfs_init_lock_context(&ctx->lock_context);\n\tctx->lock_context.open_context = ctx;\n\tINIT_LIST_HEAD(&ctx->list);\n\tctx->mdsthreshold = NULL;\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: open file(%pd2)\\n\"",
            "dentry"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs42.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/falloc.h>\n#include <linux/fs.h>\n\nstatic int\nnfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint opened = 0;\n\tint err;\n\n\t/*\n\t * If no cached dentry exists or if it's negative, NFSv4 handled the\n\t * opens in ->lookup() or ->create().\n\t *\n\t * We only get this far for a cached positive dentry.  We skipped\n\t * revalidation, so handle it here by dropping the dentry and returning\n\t * -EOPENSTALE.  The VFS will retry the lookup/create/open.\n\t */\n\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\topenflags--;\n\n\t/* We can't create new files here */\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);\n\tdir = parent->d_inode;\n\n\tctx = alloc_nfs_open_context(filp->f_path.dentry, filp->f_mode);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tnfs_wb_all(inode);\n\t}\n\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, &opened);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tcase -EPERM:\n\t\tcase -EACCES:\n\t\tcase -EDQUOT:\n\t\tcase -ENOSPC:\n\t\tcase -EROFS:\n\t\t\tgoto out_put_ctx;\n\t\tdefault:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != dentry->d_inode)\n\t\tgoto out_drop;\n\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\n\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\n\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}"
  }
]