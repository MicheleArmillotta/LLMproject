[
  {
    "function_name": "v9fs_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
    "lines": "312-346",
    "snippet": "static int v9fs_write_end(struct file *filp, struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\tloff_t last_pos = pos + copied;\n\tstruct inode *inode = page->mapping->host;\n\n\tp9_debug(P9_DEBUG_VFS, \"filp %p, mapping %p\\n\", filp, mapping);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * zero out the rest of the area\n\t\t */\n\t\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\n\t\tzero_user(page, from + copied, len - copied);\n\t\tflush_dcache_page(page);\n\t}\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold the i_mutex.\n\t */\n\tif (last_pos > inode->i_size) {\n\t\tinode_add_bytes(inode, last_pos - inode->i_size);\n\t\ti_size_write(inode, last_pos);\n\t}\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn copied;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "last_pos"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_add_bytes",
          "args": [
            "inode",
            "last_pos - inode->i_size"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "460-465",
          "snippet": "void inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "from + copied",
            "len - copied"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied < len"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"filp %p, mapping %p\\n\"",
            "filp",
            "mapping"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_write_end(struct file *filp, struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\tloff_t last_pos = pos + copied;\n\tstruct inode *inode = page->mapping->host;\n\n\tp9_debug(P9_DEBUG_VFS, \"filp %p, mapping %p\\n\", filp, mapping);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * zero out the rest of the area\n\t\t */\n\t\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\n\t\tzero_user(page, from + copied, len - copied);\n\t\tflush_dcache_page(page);\n\t}\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold the i_mutex.\n\t */\n\tif (last_pos > inode->i_size) {\n\t\tinode_add_bytes(inode, last_pos - inode->i_size);\n\t\ti_size_write(inode, last_pos);\n\t}\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn copied;\n}"
  },
  {
    "function_name": "v9fs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
    "lines": "276-310",
    "snippet": "static int v9fs_write_begin(struct file *filp, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tint retval = 0;\n\tstruct page *page;\n\tstruct v9fs_inode *v9inode;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct inode *inode = mapping->host;\n\n\n\tp9_debug(P9_DEBUG_VFS, \"filp %p, mapping %p\\n\", filp, mapping);\n\n\tv9inode = V9FS_I(inode);\nstart:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\tBUG_ON(!v9inode->writeback_fid);\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (len == PAGE_CACHE_SIZE)\n\t\tgoto out;\n\n\tretval = v9fs_fid_readpage(v9inode->writeback_fid, page);\n\tpage_cache_release(page);\n\tif (!retval)\n\t\tgoto start;\nout:\n\t*pagep = page;\n\treturn retval;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_readpage",
          "args": [
            "v9inode->writeback_fid",
            "page"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
          "lines": "52-88",
          "snippet": "static int v9fs_fid_readpage(struct p9_fid *fid, struct page *page)\n{\n\tint retval;\n\tloff_t offset;\n\tchar *buffer;\n\tstruct inode *inode;\n\n\tinode = page->mapping->host;\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tBUG_ON(!PageLocked(page));\n\n\tretval = v9fs_readpage_from_fscache(inode, page);\n\tif (retval == 0)\n\t\treturn retval;\n\n\tbuffer = kmap(page);\n\toffset = page_offset(page);\n\n\tretval = v9fs_fid_readn(fid, buffer, NULL, PAGE_CACHE_SIZE, offset);\n\tif (retval < 0) {\n\t\tv9fs_uncache_page(inode, page);\n\t\tgoto done;\n\t}\n\n\tmemset(buffer + retval, 0, PAGE_CACHE_SIZE - retval);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\n\tv9fs_readpage_to_fscache(inode, page);\n\tretval = 0;\n\ndone:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn retval;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_fid_readpage(struct p9_fid *fid, struct page *page)\n{\n\tint retval;\n\tloff_t offset;\n\tchar *buffer;\n\tstruct inode *inode;\n\n\tinode = page->mapping->host;\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tBUG_ON(!PageLocked(page));\n\n\tretval = v9fs_readpage_from_fscache(inode, page);\n\tif (retval == 0)\n\t\treturn retval;\n\n\tbuffer = kmap(page);\n\toffset = page_offset(page);\n\n\tretval = v9fs_fid_readn(fid, buffer, NULL, PAGE_CACHE_SIZE, offset);\n\tif (retval < 0) {\n\t\tv9fs_uncache_page(inode, page);\n\t\tgoto done;\n\t}\n\n\tmemset(buffer + retval, 0, PAGE_CACHE_SIZE - retval);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\n\tv9fs_readpage_to_fscache(inode, page);\n\tretval = 0;\n\ndone:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!v9inode->writeback_fid"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"filp %p, mapping %p\\n\"",
            "filp",
            "mapping"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_write_begin(struct file *filp, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tint retval = 0;\n\tstruct page *page;\n\tstruct v9fs_inode *v9inode;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct inode *inode = mapping->host;\n\n\n\tp9_debug(P9_DEBUG_VFS, \"filp %p, mapping %p\\n\", filp, mapping);\n\n\tv9inode = V9FS_I(inode);\nstart:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\tBUG_ON(!v9inode->writeback_fid);\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (len == PAGE_CACHE_SIZE)\n\t\tgoto out;\n\n\tretval = v9fs_fid_readpage(v9inode->writeback_fid, page);\n\tpage_cache_release(page);\n\tif (!retval)\n\t\tgoto start;\nout:\n\t*pagep = page;\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
    "lines": "261-274",
    "snippet": "static ssize_t\nv9fs_direct_IO(int rw, struct kiocb *iocb, struct iov_iter *iter, loff_t pos)\n{\n\t/*\n\t * FIXME\n\t * Now that we do caching with cache mode enabled, We need\n\t * to support direct IO\n\t */\n\tp9_debug(P9_DEBUG_VFS, \"v9fs_direct_IO: v9fs_direct_IO (%pD) off/no(%lld/%lu) EINVAL\\n\",\n\t\t iocb->ki_filp,\n\t\t (long long)pos, iter->nr_segs);\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"v9fs_direct_IO: v9fs_direct_IO (%pD) off/no(%lld/%lu) EINVAL\\n\"",
            "iocb->ki_filp",
            "(long long)pos",
            "iter->nr_segs"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t\nv9fs_direct_IO(int rw, struct kiocb *iocb, struct iov_iter *iter, loff_t pos)\n{\n\t/*\n\t * FIXME\n\t * Now that we do caching with cache mode enabled, We need\n\t * to support direct IO\n\t */\n\tp9_debug(P9_DEBUG_VFS, \"v9fs_direct_IO: v9fs_direct_IO (%pD) off/no(%lld/%lu) EINVAL\\n\",\n\t\t iocb->ki_filp,\n\t\t (long long)pos, iter->nr_segs);\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "v9fs_launder_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
    "lines": "228-240",
    "snippet": "static int v9fs_launder_page(struct page *page)\n{\n\tint retval;\n\tstruct inode *inode = page->mapping->host;\n\n\tv9fs_fscache_wait_on_page_write(inode, page);\n\tif (clear_page_dirty_for_io(page)) {\n\t\tretval = v9fs_vfs_writepage_locked(page);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_vfs_writepage_locked",
          "args": [
            "page"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_vfs_writepage_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
          "lines": "162-199",
          "snippet": "static int v9fs_vfs_writepage_locked(struct page *page)\n{\n\tchar *buffer;\n\tint retval, len;\n\tloff_t offset, size;\n\tmm_segment_t old_fs;\n\tstruct v9fs_inode *v9inode;\n\tstruct inode *inode = page->mapping->host;\n\n\tv9inode = V9FS_I(inode);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\n\tset_page_writeback(page);\n\n\tbuffer = kmap(page);\n\toffset = page_offset(page);\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* We should have writeback_fid always set */\n\tBUG_ON(!v9inode->writeback_fid);\n\n\tretval = v9fs_file_write_internal(inode,\n\t\t\t\t\t  v9inode->writeback_fid,\n\t\t\t\t\t  (__force const char __user *)buffer,\n\t\t\t\t\t  len, &offset, 0);\n\tif (retval > 0)\n\t\tretval = 0;\n\n\tset_fs(old_fs);\n\tkunmap(page);\n\tend_page_writeback(page);\n\treturn retval;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_writepage_locked(struct page *page)\n{\n\tchar *buffer;\n\tint retval, len;\n\tloff_t offset, size;\n\tmm_segment_t old_fs;\n\tstruct v9fs_inode *v9inode;\n\tstruct inode *inode = page->mapping->host;\n\n\tv9inode = V9FS_I(inode);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\n\tset_page_writeback(page);\n\n\tbuffer = kmap(page);\n\toffset = page_offset(page);\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* We should have writeback_fid always set */\n\tBUG_ON(!v9inode->writeback_fid);\n\n\tretval = v9fs_file_write_internal(inode,\n\t\t\t\t\t  v9inode->writeback_fid,\n\t\t\t\t\t  (__force const char __user *)buffer,\n\t\t\t\t\t  len, &offset, 0);\n\tif (retval > 0)\n\t\tretval = 0;\n\n\tset_fs(old_fs);\n\tkunmap(page);\n\tend_page_writeback(page);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fscache_wait_on_page_write",
          "args": [
            "inode",
            "page"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "__v9fs_fscache_wait_on_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "408-414",
          "snippet": "void __v9fs_fscache_wait_on_page_write(struct inode *inode, struct page *page)\n{\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tif (PageFsCache(page))\n\t\tfscache_wait_on_page_write(v9inode->fscache, page);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nvoid __v9fs_fscache_wait_on_page_write(struct inode *inode, struct page *page)\n{\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tif (PageFsCache(page))\n\t\tfscache_wait_on_page_write(v9inode->fscache, page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_launder_page(struct page *page)\n{\n\tint retval;\n\tstruct inode *inode = page->mapping->host;\n\n\tv9fs_fscache_wait_on_page_write(inode, page);\n\tif (clear_page_dirty_for_io(page)) {\n\t\tretval = v9fs_vfs_writepage_locked(page);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_vfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
    "lines": "201-221",
    "snippet": "static int v9fs_vfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint retval;\n\n\tp9_debug(P9_DEBUG_VFS, \"page %p\\n\", page);\n\n\tretval = v9fs_vfs_writepage_locked(page);\n\tif (retval < 0) {\n\t\tif (retval == -EAGAIN) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tSetPageError(page);\n\t\t\tmapping_set_error(page->mapping, retval);\n\t\t}\n\t} else\n\t\tretval = 0;\n\n\tunlock_page(page);\n\treturn retval;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "page->mapping",
            "retval"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_vfs_writepage_locked",
          "args": [
            "page"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_vfs_writepage_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
          "lines": "162-199",
          "snippet": "static int v9fs_vfs_writepage_locked(struct page *page)\n{\n\tchar *buffer;\n\tint retval, len;\n\tloff_t offset, size;\n\tmm_segment_t old_fs;\n\tstruct v9fs_inode *v9inode;\n\tstruct inode *inode = page->mapping->host;\n\n\tv9inode = V9FS_I(inode);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\n\tset_page_writeback(page);\n\n\tbuffer = kmap(page);\n\toffset = page_offset(page);\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* We should have writeback_fid always set */\n\tBUG_ON(!v9inode->writeback_fid);\n\n\tretval = v9fs_file_write_internal(inode,\n\t\t\t\t\t  v9inode->writeback_fid,\n\t\t\t\t\t  (__force const char __user *)buffer,\n\t\t\t\t\t  len, &offset, 0);\n\tif (retval > 0)\n\t\tretval = 0;\n\n\tset_fs(old_fs);\n\tkunmap(page);\n\tend_page_writeback(page);\n\treturn retval;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_writepage_locked(struct page *page)\n{\n\tchar *buffer;\n\tint retval, len;\n\tloff_t offset, size;\n\tmm_segment_t old_fs;\n\tstruct v9fs_inode *v9inode;\n\tstruct inode *inode = page->mapping->host;\n\n\tv9inode = V9FS_I(inode);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\n\tset_page_writeback(page);\n\n\tbuffer = kmap(page);\n\toffset = page_offset(page);\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* We should have writeback_fid always set */\n\tBUG_ON(!v9inode->writeback_fid);\n\n\tretval = v9fs_file_write_internal(inode,\n\t\t\t\t\t  v9inode->writeback_fid,\n\t\t\t\t\t  (__force const char __user *)buffer,\n\t\t\t\t\t  len, &offset, 0);\n\tif (retval > 0)\n\t\tretval = 0;\n\n\tset_fs(old_fs);\n\tkunmap(page);\n\tend_page_writeback(page);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"page %p\\n\"",
            "page"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint retval;\n\n\tp9_debug(P9_DEBUG_VFS, \"page %p\\n\", page);\n\n\tretval = v9fs_vfs_writepage_locked(page);\n\tif (retval < 0) {\n\t\tif (retval == -EAGAIN) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tSetPageError(page);\n\t\t\tmapping_set_error(page->mapping, retval);\n\t\t}\n\t} else\n\t\tretval = 0;\n\n\tunlock_page(page);\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_vfs_writepage_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
    "lines": "162-199",
    "snippet": "static int v9fs_vfs_writepage_locked(struct page *page)\n{\n\tchar *buffer;\n\tint retval, len;\n\tloff_t offset, size;\n\tmm_segment_t old_fs;\n\tstruct v9fs_inode *v9inode;\n\tstruct inode *inode = page->mapping->host;\n\n\tv9inode = V9FS_I(inode);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\n\tset_page_writeback(page);\n\n\tbuffer = kmap(page);\n\toffset = page_offset(page);\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* We should have writeback_fid always set */\n\tBUG_ON(!v9inode->writeback_fid);\n\n\tretval = v9fs_file_write_internal(inode,\n\t\t\t\t\t  v9inode->writeback_fid,\n\t\t\t\t\t  (__force const char __user *)buffer,\n\t\t\t\t\t  len, &offset, 0);\n\tif (retval > 0)\n\t\tretval = 0;\n\n\tset_fs(old_fs);\n\tkunmap(page);\n\tend_page_writeback(page);\n\treturn retval;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_file_write_internal",
          "args": [
            "inode",
            "v9inode->writeback_fid",
            "(__force const char __user *)buffer",
            "len",
            "&offset",
            "0"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_file_write_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "455-494",
          "snippet": "ssize_t\nv9fs_file_write_internal(struct inode *inode, struct p9_fid *fid,\n\t\t\t const char __user *data, size_t count,\n\t\t\t loff_t *offset, int invalidate)\n{\n\tint n;\n\tloff_t i_size;\n\tsize_t total = 0;\n\tloff_t origin = *offset;\n\tunsigned long pg_start, pg_end;\n\n\tp9_debug(P9_DEBUG_VFS, \"data %p count %d offset %x\\n\",\n\t\t data, (int)count, (int)*offset);\n\n\tdo {\n\t\tn = p9_client_write(fid, NULL, data+total, origin+total, count);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tcount -= n;\n\t\ttotal += n;\n\t} while (count > 0);\n\n\tif (invalidate && (total > 0)) {\n\t\tpg_start = origin >> PAGE_CACHE_SHIFT;\n\t\tpg_end = (origin + total - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (inode->i_mapping && inode->i_mapping->nrpages)\n\t\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t\t      pg_start, pg_end);\n\t\t*offset += total;\n\t\ti_size = i_size_read(inode);\n\t\tif (*offset > i_size) {\n\t\t\tinode_add_bytes(inode, *offset - i_size);\n\t\t\ti_size_write(inode, *offset);\n\t\t}\n\t}\n\tif (n < 0)\n\t\treturn n;\n\n\treturn total;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nssize_t\nv9fs_file_write_internal(struct inode *inode, struct p9_fid *fid,\n\t\t\t const char __user *data, size_t count,\n\t\t\t loff_t *offset, int invalidate)\n{\n\tint n;\n\tloff_t i_size;\n\tsize_t total = 0;\n\tloff_t origin = *offset;\n\tunsigned long pg_start, pg_end;\n\n\tp9_debug(P9_DEBUG_VFS, \"data %p count %d offset %x\\n\",\n\t\t data, (int)count, (int)*offset);\n\n\tdo {\n\t\tn = p9_client_write(fid, NULL, data+total, origin+total, count);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tcount -= n;\n\t\ttotal += n;\n\t} while (count > 0);\n\n\tif (invalidate && (total > 0)) {\n\t\tpg_start = origin >> PAGE_CACHE_SHIFT;\n\t\tpg_end = (origin + total - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (inode->i_mapping && inode->i_mapping->nrpages)\n\t\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t\t      pg_start, pg_end);\n\t\t*offset += total;\n\t\ti_size = i_size_read(inode);\n\t\tif (*offset > i_size) {\n\t\t\tinode_add_bytes(inode, *offset - i_size);\n\t\t\ti_size_write(inode, *offset);\n\t\t}\n\t}\n\tif (n < 0)\n\t\treturn n;\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!v9inode->writeback_fid"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "get_ds()"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ds",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_writepage_locked(struct page *page)\n{\n\tchar *buffer;\n\tint retval, len;\n\tloff_t offset, size;\n\tmm_segment_t old_fs;\n\tstruct v9fs_inode *v9inode;\n\tstruct inode *inode = page->mapping->host;\n\n\tv9inode = V9FS_I(inode);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\n\tset_page_writeback(page);\n\n\tbuffer = kmap(page);\n\toffset = page_offset(page);\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* We should have writeback_fid always set */\n\tBUG_ON(!v9inode->writeback_fid);\n\n\tretval = v9fs_file_write_internal(inode,\n\t\t\t\t\t  v9inode->writeback_fid,\n\t\t\t\t\t  (__force const char __user *)buffer,\n\t\t\t\t\t  len, &offset, 0);\n\tif (retval > 0)\n\t\tretval = 0;\n\n\tset_fs(old_fs);\n\tkunmap(page);\n\tend_page_writeback(page);\n\treturn retval;\n}"
  },
  {
    "function_name": "v9fs_invalidate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
    "lines": "151-160",
    "snippet": "static void v9fs_invalidate_page(struct page *page, unsigned int offset,\n\t\t\t\t unsigned int length)\n{\n\t/*\n\t * If called with zero offset, we should release\n\t * the private state assocated with the page\n\t */\n\tif (offset == 0 && length == PAGE_CACHE_SIZE)\n\t\tv9fs_fscache_invalidate_page(page);\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_fscache_invalidate_page",
          "args": [
            "page"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "__v9fs_fscache_invalidate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "290-302",
          "snippet": "void __v9fs_fscache_invalidate_page(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tBUG_ON(!v9inode->fscache);\n\n\tif (PageFsCache(page)) {\n\t\tfscache_wait_on_page_write(v9inode->fscache, page);\n\t\tBUG_ON(!PageLocked(page));\n\t\tfscache_uncache_page(v9inode->fscache, page);\n\t}\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nvoid __v9fs_fscache_invalidate_page(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tBUG_ON(!v9inode->fscache);\n\n\tif (PageFsCache(page)) {\n\t\tfscache_wait_on_page_write(v9inode->fscache, page);\n\t\tBUG_ON(!PageLocked(page));\n\t\tfscache_uncache_page(v9inode->fscache, page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic void v9fs_invalidate_page(struct page *page, unsigned int offset,\n\t\t\t\t unsigned int length)\n{\n\t/*\n\t * If called with zero offset, we should release\n\t * the private state assocated with the page\n\t */\n\tif (offset == 0 && length == PAGE_CACHE_SIZE)\n\t\tv9fs_fscache_invalidate_page(page);\n}"
  },
  {
    "function_name": "v9fs_release_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
    "lines": "137-142",
    "snippet": "static int v9fs_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PagePrivate(page))\n\t\treturn 0;\n\treturn v9fs_fscache_release_page(page, gfp);\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_fscache_release_page",
          "args": [
            "page",
            "gfp"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "__v9fs_fscache_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "280-288",
          "snippet": "int __v9fs_fscache_release_page(struct page *page, gfp_t gfp)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tBUG_ON(!v9inode->fscache);\n\n\treturn fscache_maybe_release_page(v9inode->fscache, page, gfp);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nint __v9fs_fscache_release_page(struct page *page, gfp_t gfp)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tBUG_ON(!v9inode->fscache);\n\n\treturn fscache_maybe_release_page(v9inode->fscache, page, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PagePrivate(page))\n\t\treturn 0;\n\treturn v9fs_fscache_release_page(page, gfp);\n}"
  },
  {
    "function_name": "v9fs_vfs_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
    "lines": "113-129",
    "snippet": "static int v9fs_vfs_readpages(struct file *filp, struct address_space *mapping,\n\t\t\t     struct list_head *pages, unsigned nr_pages)\n{\n\tint ret = 0;\n\tstruct inode *inode;\n\n\tinode = mapping->host;\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p file: %p\\n\", inode, filp);\n\n\tret = v9fs_readpages_from_fscache(inode, mapping, pages, &nr_pages);\n\tif (ret == 0)\n\t\treturn ret;\n\n\tret = read_cache_pages(mapping, pages, (void *)v9fs_vfs_readpage, filp);\n\tp9_debug(P9_DEBUG_VFS, \"  = %d\\n\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"  = %d\\n\"",
            "ret"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cache_pages",
          "args": [
            "mapping",
            "pages",
            "(void *)v9fs_vfs_readpage",
            "filp"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_readpages_from_fscache",
          "args": [
            "inode",
            "mapping",
            "pages",
            "&nr_pages"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__v9fs_readpages_from_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "355-386",
          "snippet": "int __v9fs_readpages_from_fscache(struct inode *inode,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages)\n{\n\tint ret;\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tp9_debug(P9_DEBUG_FSC, \"inode %p pages %u\\n\", inode, *nr_pages);\n\tif (!v9inode->fscache)\n\t\treturn -ENOBUFS;\n\n\tret = fscache_read_or_alloc_pages(v9inode->fscache,\n\t\t\t\t\t  mapping, pages, nr_pages,\n\t\t\t\t\t  v9fs_vfs_readpage_complete,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  mapping_gfp_mask(mapping));\n\tswitch (ret) {\n\tcase -ENOBUFS:\n\tcase -ENODATA:\n\t\tp9_debug(P9_DEBUG_FSC, \"pages/inodes not in cache %d\\n\", ret);\n\t\treturn 1;\n\tcase 0:\n\t\tBUG_ON(!list_empty(pages));\n\t\tBUG_ON(*nr_pages != 0);\n\t\tp9_debug(P9_DEBUG_FSC, \"BIO submitted\\n\");\n\t\treturn ret;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_FSC, \"ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nint __v9fs_readpages_from_fscache(struct inode *inode,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages)\n{\n\tint ret;\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tp9_debug(P9_DEBUG_FSC, \"inode %p pages %u\\n\", inode, *nr_pages);\n\tif (!v9inode->fscache)\n\t\treturn -ENOBUFS;\n\n\tret = fscache_read_or_alloc_pages(v9inode->fscache,\n\t\t\t\t\t  mapping, pages, nr_pages,\n\t\t\t\t\t  v9fs_vfs_readpage_complete,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  mapping_gfp_mask(mapping));\n\tswitch (ret) {\n\tcase -ENOBUFS:\n\tcase -ENODATA:\n\t\tp9_debug(P9_DEBUG_FSC, \"pages/inodes not in cache %d\\n\", ret);\n\t\treturn 1;\n\tcase 0:\n\t\tBUG_ON(!list_empty(pages));\n\t\tBUG_ON(*nr_pages != 0);\n\t\tp9_debug(P9_DEBUG_FSC, \"BIO submitted\\n\");\n\t\treturn ret;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_FSC, \"ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"inode: %p file: %p\\n\"",
            "inode",
            "filp"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_readpages(struct file *filp, struct address_space *mapping,\n\t\t\t     struct list_head *pages, unsigned nr_pages)\n{\n\tint ret = 0;\n\tstruct inode *inode;\n\n\tinode = mapping->host;\n\tp9_debug(P9_DEBUG_VFS, \"inode: %p file: %p\\n\", inode, filp);\n\n\tret = v9fs_readpages_from_fscache(inode, mapping, pages, &nr_pages);\n\tif (ret == 0)\n\t\treturn ret;\n\n\tret = read_cache_pages(mapping, pages, (void *)v9fs_vfs_readpage, filp);\n\tp9_debug(P9_DEBUG_VFS, \"  = %d\\n\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "v9fs_vfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
    "lines": "98-101",
    "snippet": "static int v9fs_vfs_readpage(struct file *filp, struct page *page)\n{\n\treturn v9fs_fid_readpage(filp->private_data, page);\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_fid_readpage",
          "args": [
            "filp->private_data",
            "page"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
          "lines": "52-88",
          "snippet": "static int v9fs_fid_readpage(struct p9_fid *fid, struct page *page)\n{\n\tint retval;\n\tloff_t offset;\n\tchar *buffer;\n\tstruct inode *inode;\n\n\tinode = page->mapping->host;\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tBUG_ON(!PageLocked(page));\n\n\tretval = v9fs_readpage_from_fscache(inode, page);\n\tif (retval == 0)\n\t\treturn retval;\n\n\tbuffer = kmap(page);\n\toffset = page_offset(page);\n\n\tretval = v9fs_fid_readn(fid, buffer, NULL, PAGE_CACHE_SIZE, offset);\n\tif (retval < 0) {\n\t\tv9fs_uncache_page(inode, page);\n\t\tgoto done;\n\t}\n\n\tmemset(buffer + retval, 0, PAGE_CACHE_SIZE - retval);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\n\tv9fs_readpage_to_fscache(inode, page);\n\tretval = 0;\n\ndone:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn retval;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_fid_readpage(struct p9_fid *fid, struct page *page)\n{\n\tint retval;\n\tloff_t offset;\n\tchar *buffer;\n\tstruct inode *inode;\n\n\tinode = page->mapping->host;\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tBUG_ON(!PageLocked(page));\n\n\tretval = v9fs_readpage_from_fscache(inode, page);\n\tif (retval == 0)\n\t\treturn retval;\n\n\tbuffer = kmap(page);\n\toffset = page_offset(page);\n\n\tretval = v9fs_fid_readn(fid, buffer, NULL, PAGE_CACHE_SIZE, offset);\n\tif (retval < 0) {\n\t\tv9fs_uncache_page(inode, page);\n\t\tgoto done;\n\t}\n\n\tmemset(buffer + retval, 0, PAGE_CACHE_SIZE - retval);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\n\tv9fs_readpage_to_fscache(inode, page);\n\tretval = 0;\n\ndone:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_readpage(struct file *filp, struct page *page)\n{\n\treturn v9fs_fid_readpage(filp->private_data, page);\n}"
  },
  {
    "function_name": "v9fs_fid_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_addr.c",
    "lines": "52-88",
    "snippet": "static int v9fs_fid_readpage(struct p9_fid *fid, struct page *page)\n{\n\tint retval;\n\tloff_t offset;\n\tchar *buffer;\n\tstruct inode *inode;\n\n\tinode = page->mapping->host;\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tBUG_ON(!PageLocked(page));\n\n\tretval = v9fs_readpage_from_fscache(inode, page);\n\tif (retval == 0)\n\t\treturn retval;\n\n\tbuffer = kmap(page);\n\toffset = page_offset(page);\n\n\tretval = v9fs_fid_readn(fid, buffer, NULL, PAGE_CACHE_SIZE, offset);\n\tif (retval < 0) {\n\t\tv9fs_uncache_page(inode, page);\n\t\tgoto done;\n\t}\n\n\tmemset(buffer + retval, 0, PAGE_CACHE_SIZE - retval);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\n\tv9fs_readpage_to_fscache(inode, page);\n\tretval = 0;\n\ndone:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn retval;\n}",
    "includes": [
      "#include \"fid.h\"",
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/aio.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_readpage_to_fscache",
          "args": [
            "inode",
            "page"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "__v9fs_readpage_to_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "393-403",
          "snippet": "void __v9fs_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tret = fscache_write_page(v9inode->fscache, page, GFP_KERNEL);\n\tp9_debug(P9_DEBUG_FSC, \"ret =  %d\\n\", ret);\n\tif (ret != 0)\n\t\tv9fs_uncache_page(inode, page);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nvoid __v9fs_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tret = fscache_write_page(v9inode->fscache, page, GFP_KERNEL);\n\tp9_debug(P9_DEBUG_FSC, \"ret =  %d\\n\", ret);\n\tif (ret != 0)\n\t\tv9fs_uncache_page(inode, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer + retval",
            "0",
            "PAGE_CACHE_SIZE - retval"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_uncache_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.h",
          "lines": "141-142",
          "snippet": "static inline void v9fs_uncache_page(struct inode *inode, struct page *page)\n{}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/fscache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/fscache.h>\n\nstatic inline void v9fs_uncache_page(struct inode *inode, struct page *page)\n{}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_fid_readn",
          "args": [
            "fid",
            "buffer",
            "NULL",
            "PAGE_CACHE_SIZE",
            "offset"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_readn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_file.c",
          "lines": "375-405",
          "snippet": "ssize_t\nv9fs_fid_readn(struct p9_fid *fid, char *data, char __user *udata, u32 count,\n\t       u64 offset)\n{\n\tint n, total, size;\n\n\tp9_debug(P9_DEBUG_VFS, \"fid %d offset %llu count %d\\n\",\n\t\t fid->fid, (long long unsigned)offset, count);\n\tn = 0;\n\ttotal = 0;\n\tsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\n\tdo {\n\t\tn = p9_client_read(fid, data, udata, offset, count);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\n\t\tif (data)\n\t\t\tdata += n;\n\t\tif (udata)\n\t\t\tudata += n;\n\n\t\toffset += n;\n\t\tcount -= n;\n\t\ttotal += n;\n\t} while (count > 0 && n == size);\n\n\tif (n < 0)\n\t\ttotal = n;\n\n\treturn total;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/utsname.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/list.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <asm/uaccess.h>\n#include <linux/utsname.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nssize_t\nv9fs_fid_readn(struct p9_fid *fid, char *data, char __user *udata, u32 count,\n\t       u64 offset)\n{\n\tint n, total, size;\n\n\tp9_debug(P9_DEBUG_VFS, \"fid %d offset %llu count %d\\n\",\n\t\t fid->fid, (long long unsigned)offset, count);\n\tn = 0;\n\ttotal = 0;\n\tsize = fid->iounit ? fid->iounit : fid->clnt->msize - P9_IOHDRSZ;\n\tdo {\n\t\tn = p9_client_read(fid, data, udata, offset, count);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\n\t\tif (data)\n\t\t\tdata += n;\n\t\tif (udata)\n\t\t\tudata += n;\n\n\t\toffset += n;\n\t\tcount -= n;\n\t\ttotal += n;\n\t} while (count > 0 && n == size);\n\n\tif (n < 0)\n\t\ttotal = n;\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_readpage_from_fscache",
          "args": [
            "inode",
            "page"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "__v9fs_readpage_from_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "320-346",
          "snippet": "int __v9fs_readpage_from_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tif (!v9inode->fscache)\n\t\treturn -ENOBUFS;\n\n\tret = fscache_read_or_alloc_page(v9inode->fscache,\n\t\t\t\t\t page,\n\t\t\t\t\t v9fs_vfs_readpage_complete,\n\t\t\t\t\t NULL,\n\t\t\t\t\t GFP_KERNEL);\n\tswitch (ret) {\n\tcase -ENOBUFS:\n\tcase -ENODATA:\n\t\tp9_debug(P9_DEBUG_FSC, \"page/inode not in cache %d\\n\", ret);\n\t\treturn 1;\n\tcase 0:\n\t\tp9_debug(P9_DEBUG_FSC, \"BIO submitted\\n\");\n\t\treturn ret;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_FSC, \"ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nint __v9fs_readpage_from_fscache(struct inode *inode, struct page *page)\n{\n\tint ret;\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tif (!v9inode->fscache)\n\t\treturn -ENOBUFS;\n\n\tret = fscache_read_or_alloc_page(v9inode->fscache,\n\t\t\t\t\t page,\n\t\t\t\t\t v9fs_vfs_readpage_complete,\n\t\t\t\t\t NULL,\n\t\t\t\t\t GFP_KERNEL);\n\tswitch (ret) {\n\tcase -ENOBUFS:\n\tcase -ENODATA:\n\t\tp9_debug(P9_DEBUG_FSC, \"page/inode not in cache %d\\n\", ret);\n\t\treturn 1;\n\tcase 0:\n\t\tp9_debug(P9_DEBUG_FSC, \"BIO submitted\\n\");\n\t\treturn ret;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_FSC, \"ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"\\n\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fid.h\"\n#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_fid_readpage(struct p9_fid *fid, struct page *page)\n{\n\tint retval;\n\tloff_t offset;\n\tchar *buffer;\n\tstruct inode *inode;\n\n\tinode = page->mapping->host;\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tBUG_ON(!PageLocked(page));\n\n\tretval = v9fs_readpage_from_fscache(inode, page);\n\tif (retval == 0)\n\t\treturn retval;\n\n\tbuffer = kmap(page);\n\toffset = page_offset(page);\n\n\tretval = v9fs_fid_readn(fid, buffer, NULL, PAGE_CACHE_SIZE, offset);\n\tif (retval < 0) {\n\t\tv9fs_uncache_page(inode, page);\n\t\tgoto done;\n\t}\n\n\tmemset(buffer + retval, 0, PAGE_CACHE_SIZE - retval);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\n\tv9fs_readpage_to_fscache(inode, page);\n\tretval = 0;\n\ndone:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn retval;\n}"
  }
]