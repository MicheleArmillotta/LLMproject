[
  {
    "function_name": "exit_cramfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "603-607",
    "snippet": "static void __exit exit_cramfs_fs(void)\n{\n\tcramfs_uncompress_exit();\n\tunregister_filesystem(&cramfs_fs_type);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type cramfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"cramfs\",\n\t.mount\t\t= cramfs_mount,\n\t.kill_sb\t= cramfs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&cramfs_fs_type"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cramfs_uncompress_exit",
          "args": [],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "cramfs_uncompress_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/uncompress.c",
          "lines": "73-79",
          "snippet": "void cramfs_uncompress_exit(void)\n{\n\tif (!--initialized) {\n\t\tzlib_inflateEnd(&stream);\n\t\tvfree(stream.workspace);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static z_stream stream;",
            "static int initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic z_stream stream;\nstatic int initialized;\n\nvoid cramfs_uncompress_exit(void)\n{\n\tif (!--initialized) {\n\t\tzlib_inflateEnd(&stream);\n\t\tvfree(stream.workspace);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct file_system_type cramfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"cramfs\",\n\t.mount\t\t= cramfs_mount,\n\t.kill_sb\t= cramfs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_cramfs_fs(void)\n{\n\tcramfs_uncompress_exit();\n\tunregister_filesystem(&cramfs_fs_type);\n}"
  },
  {
    "function_name": "init_cramfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "590-601",
    "snippet": "static int __init init_cramfs_fs(void)\n{\n\tint rv;\n\n\trv = cramfs_uncompress_init();\n\tif (rv < 0)\n\t\treturn rv;\n\trv = register_filesystem(&cramfs_fs_type);\n\tif (rv < 0)\n\t\tcramfs_uncompress_exit();\n\treturn rv;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type cramfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"cramfs\",\n\t.mount\t\t= cramfs_mount,\n\t.kill_sb\t= cramfs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cramfs_uncompress_exit",
          "args": [],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "cramfs_uncompress_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/uncompress.c",
          "lines": "73-79",
          "snippet": "void cramfs_uncompress_exit(void)\n{\n\tif (!--initialized) {\n\t\tzlib_inflateEnd(&stream);\n\t\tvfree(stream.workspace);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static z_stream stream;",
            "static int initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic z_stream stream;\nstatic int initialized;\n\nvoid cramfs_uncompress_exit(void)\n{\n\tif (!--initialized) {\n\t\tzlib_inflateEnd(&stream);\n\t\tvfree(stream.workspace);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&cramfs_fs_type"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cramfs_uncompress_init",
          "args": [],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "cramfs_uncompress_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/uncompress.c",
          "lines": "58-71",
          "snippet": "int cramfs_uncompress_init(void)\n{\n\tif (!initialized++) {\n\t\tstream.workspace = vmalloc(zlib_inflate_workspacesize());\n\t\tif (!stream.workspace) {\n\t\t\tinitialized = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tstream.next_in = NULL;\n\t\tstream.avail_in = 0;\n\t\tzlib_inflateInit(&stream);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static z_stream stream;",
            "static int initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic z_stream stream;\nstatic int initialized;\n\nint cramfs_uncompress_init(void)\n{\n\tif (!initialized++) {\n\t\tstream.workspace = vmalloc(zlib_inflate_workspacesize());\n\t\tif (!stream.workspace) {\n\t\t\tinitialized = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tstream.next_in = NULL;\n\t\tstream.avail_in = 0;\n\t\tzlib_inflateInit(&stream);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct file_system_type cramfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"cramfs\",\n\t.mount\t\t= cramfs_mount,\n\t.kill_sb\t= cramfs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_cramfs_fs(void)\n{\n\tint rv;\n\n\trv = cramfs_uncompress_init();\n\tif (rv < 0)\n\t\treturn rv;\n\trv = register_filesystem(&cramfs_fs_type);\n\tif (rv < 0)\n\t\tcramfs_uncompress_exit();\n\treturn rv;\n}"
  },
  {
    "function_name": "cramfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "575-579",
    "snippet": "static struct dentry *cramfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, cramfs_fill_super);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "cramfs_fill_super"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *cramfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, cramfs_fill_super);\n}"
  },
  {
    "function_name": "cramfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "491-547",
    "snippet": "static int cramfs_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tu32 maxblock;\n\tint bytes_filled;\n\tvoid *pgdata;\n\n\tmaxblock = (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tbytes_filled = 0;\n\tpgdata = kmap(page);\n\n\tif (page->index < maxblock) {\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tu32 blkptr_offset = OFFSET(inode) + page->index*4;\n\t\tu32 start_offset, compr_len;\n\n\t\tstart_offset = OFFSET(inode) + maxblock*4;\n\t\tmutex_lock(&read_mutex);\n\t\tif (page->index)\n\t\t\tstart_offset = *(u32 *) cramfs_read(sb, blkptr_offset-4,\n\t\t\t\t4);\n\t\tcompr_len = (*(u32 *) cramfs_read(sb, blkptr_offset, 4) -\n\t\t\tstart_offset);\n\t\tmutex_unlock(&read_mutex);\n\n\t\tif (compr_len == 0)\n\t\t\t; /* hole */\n\t\telse if (unlikely(compr_len > (PAGE_CACHE_SIZE << 1))) {\n\t\t\tpr_err(\"bad compressed blocksize %u\\n\",\n\t\t\t\tcompr_len);\n\t\t\tgoto err;\n\t\t} else {\n\t\t\tmutex_lock(&read_mutex);\n\t\t\tbytes_filled = cramfs_uncompress_block(pgdata,\n\t\t\t\t PAGE_CACHE_SIZE,\n\t\t\t\t cramfs_read(sb, start_offset, compr_len),\n\t\t\t\t compr_len);\n\t\t\tmutex_unlock(&read_mutex);\n\t\t\tif (unlikely(bytes_filled < 0))\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tmemset(pgdata + bytes_filled, 0, PAGE_CACHE_SIZE - bytes_filled);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n\nerr:\n\tkunmap(page);\n\tClearPageUptodate(page);\n\tSetPageError(page);\n\tunlock_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(read_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pgdata + bytes_filled",
            "0",
            "PAGE_CACHE_SIZE - bytes_filled"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bytes_filled < 0"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&read_mutex"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cramfs_uncompress_block",
          "args": [
            "pgdata",
            "PAGE_CACHE_SIZE",
            "cramfs_read(sb, start_offset, compr_len)",
            "compr_len"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "cramfs_uncompress_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/uncompress.c",
          "lines": "30-56",
          "snippet": "int cramfs_uncompress_block(void *dst, int dstlen, void *src, int srclen)\n{\n\tint err;\n\n\tstream.next_in = src;\n\tstream.avail_in = srclen;\n\n\tstream.next_out = dst;\n\tstream.avail_out = dstlen;\n\n\terr = zlib_inflateReset(&stream);\n\tif (err != Z_OK) {\n\t\tpr_err(\"zlib_inflateReset error %d\\n\", err);\n\t\tzlib_inflateEnd(&stream);\n\t\tzlib_inflateInit(&stream);\n\t}\n\n\terr = zlib_inflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto err;\n\treturn stream.total_out;\n\nerr:\n\tpr_err(\"Error %d while decompressing!\\n\", err);\n\tpr_err(\"%p(%d)->%p(%d)\\n\", src, srclen, dst, dstlen);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static z_stream stream;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic z_stream stream;\n\nint cramfs_uncompress_block(void *dst, int dstlen, void *src, int srclen)\n{\n\tint err;\n\n\tstream.next_in = src;\n\tstream.avail_in = srclen;\n\n\tstream.next_out = dst;\n\tstream.avail_out = dstlen;\n\n\terr = zlib_inflateReset(&stream);\n\tif (err != Z_OK) {\n\t\tpr_err(\"zlib_inflateReset error %d\\n\", err);\n\t\tzlib_inflateEnd(&stream);\n\t\tzlib_inflateInit(&stream);\n\t}\n\n\terr = zlib_inflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto err;\n\treturn stream.total_out;\n\nerr:\n\tpr_err(\"Error %d while decompressing!\\n\", err);\n\tpr_err(\"%p(%d)->%p(%d)\\n\", src, srclen, dst, dstlen);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cramfs_read",
          "args": [
            "sb",
            "start_offset",
            "compr_len"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "cramfs_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
          "lines": "165-239",
          "snippet": "static void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned int len)\n{\n\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct page *pages[BLKS_PER_BUF];\n\tunsigned i, blocknr, buffer;\n\tunsigned long devsize;\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\tblocknr = offset >> PAGE_CACHE_SHIFT;\n\toffset &= PAGE_CACHE_SIZE - 1;\n\n\t/* Check if an existing buffer already has the data.. */\n\tfor (i = 0; i < READ_BUFFERS; i++) {\n\t\tunsigned int blk_offset;\n\n\t\tif (buffer_dev[i] != sb)\n\t\t\tcontinue;\n\t\tif (blocknr < buffer_blocknr[i])\n\t\t\tcontinue;\n\t\tblk_offset = (blocknr - buffer_blocknr[i]) << PAGE_CACHE_SHIFT;\n\t\tblk_offset += offset;\n\t\tif (blk_offset + len > BUFFER_SIZE)\n\t\t\tcontinue;\n\t\treturn read_buffers[i] + blk_offset;\n\t}\n\n\tdevsize = mapping->host->i_size >> PAGE_CACHE_SHIFT;\n\n\t/* Ok, read in BLKS_PER_BUF pages completely first. */\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = NULL;\n\n\t\tif (blocknr + i < devsize) {\n\t\t\tpage = read_mapping_page(mapping, blocknr + i, NULL);\n\t\t\t/* synchronous error? */\n\t\t\tif (IS_ERR(page))\n\t\t\t\tpage = NULL;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\twait_on_page_locked(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t/* asynchronous error */\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer = next_buffer;\n\tnext_buffer = NEXT_BUFFER(buffer);\n\tbuffer_blocknr[buffer] = blocknr;\n\tbuffer_dev[buffer] = sb;\n\n\tdata = read_buffers[buffer];\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\tmemcpy(data, kmap(page), PAGE_CACHE_SIZE);\n\t\t\tkunmap(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\tmemset(data, 0, PAGE_CACHE_SIZE);\n\t\tdata += PAGE_CACHE_SIZE;\n\t}\n\treturn read_buffers[buffer] + offset;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <uapi/linux/cramfs_fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define BUFFER_SIZE\t\t(BLKS_PER_BUF*PAGE_CACHE_SIZE)",
            "#define BLKS_PER_BUF\t\t(1 << BLKS_PER_BUF_SHIFT)",
            "#define READ_BUFFERS (2)"
          ],
          "globals_used": [
            "static unsigned char read_buffers[READ_BUFFERS][BUFFER_SIZE];",
            "static unsigned buffer_blocknr[READ_BUFFERS];",
            "static struct super_block *buffer_dev[READ_BUFFERS];",
            "static int next_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define BUFFER_SIZE\t\t(BLKS_PER_BUF*PAGE_CACHE_SIZE)\n#define BLKS_PER_BUF\t\t(1 << BLKS_PER_BUF_SHIFT)\n#define READ_BUFFERS (2)\n\nstatic unsigned char read_buffers[READ_BUFFERS][BUFFER_SIZE];\nstatic unsigned buffer_blocknr[READ_BUFFERS];\nstatic struct super_block *buffer_dev[READ_BUFFERS];\nstatic int next_buffer;\n\nstatic void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned int len)\n{\n\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct page *pages[BLKS_PER_BUF];\n\tunsigned i, blocknr, buffer;\n\tunsigned long devsize;\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\tblocknr = offset >> PAGE_CACHE_SHIFT;\n\toffset &= PAGE_CACHE_SIZE - 1;\n\n\t/* Check if an existing buffer already has the data.. */\n\tfor (i = 0; i < READ_BUFFERS; i++) {\n\t\tunsigned int blk_offset;\n\n\t\tif (buffer_dev[i] != sb)\n\t\t\tcontinue;\n\t\tif (blocknr < buffer_blocknr[i])\n\t\t\tcontinue;\n\t\tblk_offset = (blocknr - buffer_blocknr[i]) << PAGE_CACHE_SHIFT;\n\t\tblk_offset += offset;\n\t\tif (blk_offset + len > BUFFER_SIZE)\n\t\t\tcontinue;\n\t\treturn read_buffers[i] + blk_offset;\n\t}\n\n\tdevsize = mapping->host->i_size >> PAGE_CACHE_SHIFT;\n\n\t/* Ok, read in BLKS_PER_BUF pages completely first. */\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = NULL;\n\n\t\tif (blocknr + i < devsize) {\n\t\t\tpage = read_mapping_page(mapping, blocknr + i, NULL);\n\t\t\t/* synchronous error? */\n\t\t\tif (IS_ERR(page))\n\t\t\t\tpage = NULL;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\twait_on_page_locked(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t/* asynchronous error */\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer = next_buffer;\n\tnext_buffer = NEXT_BUFFER(buffer);\n\tbuffer_blocknr[buffer] = blocknr;\n\tbuffer_dev[buffer] = sb;\n\n\tdata = read_buffers[buffer];\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\tmemcpy(data, kmap(page), PAGE_CACHE_SIZE);\n\t\t\tkunmap(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\tmemset(data, 0, PAGE_CACHE_SIZE);\n\t\tdata += PAGE_CACHE_SIZE;\n\t}\n\treturn read_buffers[buffer] + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&read_mutex"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad compressed blocksize %u\\n\"",
            "compr_len"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "compr_len > (PAGE_CACHE_SIZE << 1)"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&read_mutex"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&read_mutex"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OFFSET",
          "args": [
            "inode"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OFFSET",
          "args": [
            "inode"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(read_mutex);\n\nstatic int cramfs_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tu32 maxblock;\n\tint bytes_filled;\n\tvoid *pgdata;\n\n\tmaxblock = (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tbytes_filled = 0;\n\tpgdata = kmap(page);\n\n\tif (page->index < maxblock) {\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tu32 blkptr_offset = OFFSET(inode) + page->index*4;\n\t\tu32 start_offset, compr_len;\n\n\t\tstart_offset = OFFSET(inode) + maxblock*4;\n\t\tmutex_lock(&read_mutex);\n\t\tif (page->index)\n\t\t\tstart_offset = *(u32 *) cramfs_read(sb, blkptr_offset-4,\n\t\t\t\t4);\n\t\tcompr_len = (*(u32 *) cramfs_read(sb, blkptr_offset, 4) -\n\t\t\tstart_offset);\n\t\tmutex_unlock(&read_mutex);\n\n\t\tif (compr_len == 0)\n\t\t\t; /* hole */\n\t\telse if (unlikely(compr_len > (PAGE_CACHE_SIZE << 1))) {\n\t\t\tpr_err(\"bad compressed blocksize %u\\n\",\n\t\t\t\tcompr_len);\n\t\t\tgoto err;\n\t\t} else {\n\t\t\tmutex_lock(&read_mutex);\n\t\t\tbytes_filled = cramfs_uncompress_block(pgdata,\n\t\t\t\t PAGE_CACHE_SIZE,\n\t\t\t\t cramfs_read(sb, start_offset, compr_len),\n\t\t\t\t compr_len);\n\t\t\tmutex_unlock(&read_mutex);\n\t\t\tif (unlikely(bytes_filled < 0))\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tmemset(pgdata + bytes_filled, 0, PAGE_CACHE_SIZE - bytes_filled);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n\nerr:\n\tkunmap(page);\n\tClearPageUptodate(page);\n\tSetPageError(page);\n\tunlock_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "cramfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "433-489",
    "snippet": "static struct dentry *cramfs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tunsigned int offset = 0;\n\tstruct inode *inode = NULL;\n\tint sorted;\n\n\tmutex_lock(&read_mutex);\n\tsorted = CRAMFS_SB(dir->i_sb)->flags & CRAMFS_FLAG_SORTED_DIRS;\n\twhile (offset < dir->i_size) {\n\t\tstruct cramfs_inode *de;\n\t\tchar *name;\n\t\tint namelen, retval;\n\t\tint dir_off = OFFSET(dir) + offset;\n\n\t\tde = cramfs_read(dir->i_sb, dir_off, sizeof(*de)+CRAMFS_MAXPATHLEN);\n\t\tname = (char *)(de+1);\n\n\t\t/* Try to take advantage of sorted directories */\n\t\tif (sorted && (dentry->d_name.name[0] < name[0]))\n\t\t\tbreak;\n\n\t\tnamelen = de->namelen << 2;\n\t\toffset += sizeof(*de) + namelen;\n\n\t\t/* Quick check that the name is roughly the right length */\n\t\tif (((dentry->d_name.len + 3) & ~3) != namelen)\n\t\t\tcontinue;\n\n\t\tfor (;;) {\n\t\t\tif (!namelen) {\n\t\t\t\tinode = ERR_PTR(-EIO);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name[namelen-1])\n\t\t\t\tbreak;\n\t\t\tnamelen--;\n\t\t}\n\t\tif (namelen != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tretval = memcmp(dentry->d_name.name, name, namelen);\n\t\tif (retval > 0)\n\t\t\tcontinue;\n\t\tif (!retval) {\n\t\t\tinode = get_cramfs_inode(dir->i_sb, de, dir_off);\n\t\t\tbreak;\n\t\t}\n\t\t/* else (retval < 0) */\n\t\tif (sorted)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&read_mutex);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\td_add(dentry, inode);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(read_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&read_mutex"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cramfs_inode",
          "args": [
            "dir->i_sb",
            "de",
            "dir_off"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "get_cramfs_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
          "lines": "80-130",
          "snippet": "static struct inode *get_cramfs_inode(struct super_block *sb,\n\tconst struct cramfs_inode *cramfs_inode, unsigned int offset)\n{\n\tstruct inode *inode;\n\tstatic struct timespec zerotime;\n\n\tinode = iget_locked(sb, cramino(cramfs_inode, offset));\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tswitch (cramfs_inode->mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &cramfs_dir_inode_operations;\n\t\tinode->i_fop = &cramfs_directory_operations;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tdefault:\n\t\tinit_special_inode(inode, cramfs_inode->mode,\n\t\t\t\told_decode_dev(cramfs_inode->size));\n\t}\n\n\tinode->i_mode = cramfs_inode->mode;\n\ti_uid_write(inode, cramfs_inode->uid);\n\ti_gid_write(inode, cramfs_inode->gid);\n\n\t/* if the lower 2 bits are zero, the inode contains data */\n\tif (!(inode->i_ino & 3)) {\n\t\tinode->i_size = cramfs_inode->size;\n\t\tinode->i_blocks = (cramfs_inode->size - 1) / 512 + 1;\n\t}\n\n\t/* Struct copy intentional */\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = zerotime;\n\t/* inode->i_nlink is left 1 - arguably wrong for directories,\n\t   but it's the best we can do without reading the directory\n\t   contents.  1 yields the right result in GNU find, even\n\t   without -noleaf option. */\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <uapi/linux/cramfs_fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations cramfs_dir_inode_operations;",
            "static const struct file_operations cramfs_directory_operations;",
            "static const struct address_space_operations cramfs_aops;",
            "static const struct address_space_operations cramfs_aops = {\n\t.readpage = cramfs_readpage\n};",
            "static const struct file_operations cramfs_directory_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= cramfs_readdir,\n};",
            "static const struct inode_operations cramfs_dir_inode_operations = {\n\t.lookup\t\t= cramfs_lookup,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct inode_operations cramfs_dir_inode_operations;\nstatic const struct file_operations cramfs_directory_operations;\nstatic const struct address_space_operations cramfs_aops;\nstatic const struct address_space_operations cramfs_aops = {\n\t.readpage = cramfs_readpage\n};\nstatic const struct file_operations cramfs_directory_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= cramfs_readdir,\n};\nstatic const struct inode_operations cramfs_dir_inode_operations = {\n\t.lookup\t\t= cramfs_lookup,\n};\n\nstatic struct inode *get_cramfs_inode(struct super_block *sb,\n\tconst struct cramfs_inode *cramfs_inode, unsigned int offset)\n{\n\tstruct inode *inode;\n\tstatic struct timespec zerotime;\n\n\tinode = iget_locked(sb, cramino(cramfs_inode, offset));\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tswitch (cramfs_inode->mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &cramfs_dir_inode_operations;\n\t\tinode->i_fop = &cramfs_directory_operations;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tdefault:\n\t\tinit_special_inode(inode, cramfs_inode->mode,\n\t\t\t\told_decode_dev(cramfs_inode->size));\n\t}\n\n\tinode->i_mode = cramfs_inode->mode;\n\ti_uid_write(inode, cramfs_inode->uid);\n\ti_gid_write(inode, cramfs_inode->gid);\n\n\t/* if the lower 2 bits are zero, the inode contains data */\n\tif (!(inode->i_ino & 3)) {\n\t\tinode->i_size = cramfs_inode->size;\n\t\tinode->i_blocks = (cramfs_inode->size - 1) / 512 + 1;\n\t}\n\n\t/* Struct copy intentional */\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = zerotime;\n\t/* inode->i_nlink is left 1 - arguably wrong for directories,\n\t   but it's the best we can do without reading the directory\n\t   contents.  1 yields the right result in GNU find, even\n\t   without -noleaf option. */\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dentry->d_name.name",
            "name",
            "namelen"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cramfs_read",
          "args": [
            "dir->i_sb",
            "dir_off",
            "sizeof(*de)+CRAMFS_MAXPATHLEN"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "cramfs_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
          "lines": "165-239",
          "snippet": "static void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned int len)\n{\n\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct page *pages[BLKS_PER_BUF];\n\tunsigned i, blocknr, buffer;\n\tunsigned long devsize;\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\tblocknr = offset >> PAGE_CACHE_SHIFT;\n\toffset &= PAGE_CACHE_SIZE - 1;\n\n\t/* Check if an existing buffer already has the data.. */\n\tfor (i = 0; i < READ_BUFFERS; i++) {\n\t\tunsigned int blk_offset;\n\n\t\tif (buffer_dev[i] != sb)\n\t\t\tcontinue;\n\t\tif (blocknr < buffer_blocknr[i])\n\t\t\tcontinue;\n\t\tblk_offset = (blocknr - buffer_blocknr[i]) << PAGE_CACHE_SHIFT;\n\t\tblk_offset += offset;\n\t\tif (blk_offset + len > BUFFER_SIZE)\n\t\t\tcontinue;\n\t\treturn read_buffers[i] + blk_offset;\n\t}\n\n\tdevsize = mapping->host->i_size >> PAGE_CACHE_SHIFT;\n\n\t/* Ok, read in BLKS_PER_BUF pages completely first. */\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = NULL;\n\n\t\tif (blocknr + i < devsize) {\n\t\t\tpage = read_mapping_page(mapping, blocknr + i, NULL);\n\t\t\t/* synchronous error? */\n\t\t\tif (IS_ERR(page))\n\t\t\t\tpage = NULL;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\twait_on_page_locked(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t/* asynchronous error */\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer = next_buffer;\n\tnext_buffer = NEXT_BUFFER(buffer);\n\tbuffer_blocknr[buffer] = blocknr;\n\tbuffer_dev[buffer] = sb;\n\n\tdata = read_buffers[buffer];\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\tmemcpy(data, kmap(page), PAGE_CACHE_SIZE);\n\t\t\tkunmap(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\tmemset(data, 0, PAGE_CACHE_SIZE);\n\t\tdata += PAGE_CACHE_SIZE;\n\t}\n\treturn read_buffers[buffer] + offset;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <uapi/linux/cramfs_fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define BUFFER_SIZE\t\t(BLKS_PER_BUF*PAGE_CACHE_SIZE)",
            "#define BLKS_PER_BUF\t\t(1 << BLKS_PER_BUF_SHIFT)",
            "#define READ_BUFFERS (2)"
          ],
          "globals_used": [
            "static unsigned char read_buffers[READ_BUFFERS][BUFFER_SIZE];",
            "static unsigned buffer_blocknr[READ_BUFFERS];",
            "static struct super_block *buffer_dev[READ_BUFFERS];",
            "static int next_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define BUFFER_SIZE\t\t(BLKS_PER_BUF*PAGE_CACHE_SIZE)\n#define BLKS_PER_BUF\t\t(1 << BLKS_PER_BUF_SHIFT)\n#define READ_BUFFERS (2)\n\nstatic unsigned char read_buffers[READ_BUFFERS][BUFFER_SIZE];\nstatic unsigned buffer_blocknr[READ_BUFFERS];\nstatic struct super_block *buffer_dev[READ_BUFFERS];\nstatic int next_buffer;\n\nstatic void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned int len)\n{\n\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct page *pages[BLKS_PER_BUF];\n\tunsigned i, blocknr, buffer;\n\tunsigned long devsize;\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\tblocknr = offset >> PAGE_CACHE_SHIFT;\n\toffset &= PAGE_CACHE_SIZE - 1;\n\n\t/* Check if an existing buffer already has the data.. */\n\tfor (i = 0; i < READ_BUFFERS; i++) {\n\t\tunsigned int blk_offset;\n\n\t\tif (buffer_dev[i] != sb)\n\t\t\tcontinue;\n\t\tif (blocknr < buffer_blocknr[i])\n\t\t\tcontinue;\n\t\tblk_offset = (blocknr - buffer_blocknr[i]) << PAGE_CACHE_SHIFT;\n\t\tblk_offset += offset;\n\t\tif (blk_offset + len > BUFFER_SIZE)\n\t\t\tcontinue;\n\t\treturn read_buffers[i] + blk_offset;\n\t}\n\n\tdevsize = mapping->host->i_size >> PAGE_CACHE_SHIFT;\n\n\t/* Ok, read in BLKS_PER_BUF pages completely first. */\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = NULL;\n\n\t\tif (blocknr + i < devsize) {\n\t\t\tpage = read_mapping_page(mapping, blocknr + i, NULL);\n\t\t\t/* synchronous error? */\n\t\t\tif (IS_ERR(page))\n\t\t\t\tpage = NULL;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\twait_on_page_locked(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t/* asynchronous error */\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer = next_buffer;\n\tnext_buffer = NEXT_BUFFER(buffer);\n\tbuffer_blocknr[buffer] = blocknr;\n\tbuffer_dev[buffer] = sb;\n\n\tdata = read_buffers[buffer];\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\tmemcpy(data, kmap(page), PAGE_CACHE_SIZE);\n\t\t\tkunmap(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\tmemset(data, 0, PAGE_CACHE_SIZE);\n\t\tdata += PAGE_CACHE_SIZE;\n\t}\n\treturn read_buffers[buffer] + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OFFSET",
          "args": [
            "dir"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRAMFS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "CRAMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
          "lines": "41-44",
          "snippet": "static inline struct cramfs_sb_info *CRAMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <uapi/linux/cramfs_fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct cramfs_sb_info *CRAMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&read_mutex"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(read_mutex);\n\nstatic struct dentry *cramfs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tunsigned int offset = 0;\n\tstruct inode *inode = NULL;\n\tint sorted;\n\n\tmutex_lock(&read_mutex);\n\tsorted = CRAMFS_SB(dir->i_sb)->flags & CRAMFS_FLAG_SORTED_DIRS;\n\twhile (offset < dir->i_size) {\n\t\tstruct cramfs_inode *de;\n\t\tchar *name;\n\t\tint namelen, retval;\n\t\tint dir_off = OFFSET(dir) + offset;\n\n\t\tde = cramfs_read(dir->i_sb, dir_off, sizeof(*de)+CRAMFS_MAXPATHLEN);\n\t\tname = (char *)(de+1);\n\n\t\t/* Try to take advantage of sorted directories */\n\t\tif (sorted && (dentry->d_name.name[0] < name[0]))\n\t\t\tbreak;\n\n\t\tnamelen = de->namelen << 2;\n\t\toffset += sizeof(*de) + namelen;\n\n\t\t/* Quick check that the name is roughly the right length */\n\t\tif (((dentry->d_name.len + 3) & ~3) != namelen)\n\t\t\tcontinue;\n\n\t\tfor (;;) {\n\t\t\tif (!namelen) {\n\t\t\t\tinode = ERR_PTR(-EIO);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name[namelen-1])\n\t\t\t\tbreak;\n\t\t\tnamelen--;\n\t\t}\n\t\tif (namelen != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tretval = memcmp(dentry->d_name.name, name, namelen);\n\t\tif (retval > 0)\n\t\t\tcontinue;\n\t\tif (!retval) {\n\t\t\tinode = get_cramfs_inode(dir->i_sb, de, dir_off);\n\t\t\tbreak;\n\t\t}\n\t\t/* else (retval < 0) */\n\t\tif (sorted)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&read_mutex);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\td_add(dentry, inode);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cramfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "370-428",
    "snippet": "static int cramfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tchar *buf;\n\tunsigned int offset;\n\n\t/* Offset within the thing. */\n\tif (ctx->pos >= inode->i_size)\n\t\treturn 0;\n\toffset = ctx->pos;\n\t/* Directory entries are always 4-byte aligned */\n\tif (offset & 3)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(CRAMFS_MAXPATHLEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (offset < inode->i_size) {\n\t\tstruct cramfs_inode *de;\n\t\tunsigned long nextoffset;\n\t\tchar *name;\n\t\tino_t ino;\n\t\tumode_t mode;\n\t\tint namelen;\n\n\t\tmutex_lock(&read_mutex);\n\t\tde = cramfs_read(sb, OFFSET(inode) + offset, sizeof(*de)+CRAMFS_MAXPATHLEN);\n\t\tname = (char *)(de+1);\n\n\t\t/*\n\t\t * Namelengths on disk are shifted by two\n\t\t * and the name padded out to 4-byte boundaries\n\t\t * with zeroes.\n\t\t */\n\t\tnamelen = de->namelen << 2;\n\t\tmemcpy(buf, name, namelen);\n\t\tino = cramino(de, OFFSET(inode) + offset);\n\t\tmode = de->mode;\n\t\tmutex_unlock(&read_mutex);\n\t\tnextoffset = offset + sizeof(*de) + namelen;\n\t\tfor (;;) {\n\t\t\tif (!namelen) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (buf[namelen-1])\n\t\t\t\tbreak;\n\t\t\tnamelen--;\n\t\t}\n\t\tif (!dir_emit(ctx, buf, namelen, ino, mode >> 12))\n\t\t\tbreak;\n\n\t\tctx->pos = offset = nextoffset;\n\t}\n\tkfree(buf);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(read_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "buf",
            "namelen",
            "ino",
            "mode >> 12"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&read_mutex"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cramino",
          "args": [
            "de",
            "OFFSET(inode) + offset"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "cramino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
          "lines": "57-78",
          "snippet": "static unsigned long cramino(const struct cramfs_inode *cino, unsigned int offset)\n{\n\tif (!cino->offset)\n\t\treturn offset + 1;\n\tif (!cino->size)\n\t\treturn offset + 1;\n\n\t/*\n\t * The file mode test fixes buggy mkcramfs implementations where\n\t * cramfs_inode->offset is set to a non zero value for entries\n\t * which did not contain data, like devices node and fifos.\n\t */\n\tswitch (cino->mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\treturn cino->offset << 2;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset + 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <uapi/linux/cramfs_fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic unsigned long cramino(const struct cramfs_inode *cino, unsigned int offset)\n{\n\tif (!cino->offset)\n\t\treturn offset + 1;\n\tif (!cino->size)\n\t\treturn offset + 1;\n\n\t/*\n\t * The file mode test fixes buggy mkcramfs implementations where\n\t * cramfs_inode->offset is set to a non zero value for entries\n\t * which did not contain data, like devices node and fifos.\n\t */\n\tswitch (cino->mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\treturn cino->offset << 2;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OFFSET",
          "args": [
            "inode"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "name",
            "namelen"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cramfs_read",
          "args": [
            "sb",
            "OFFSET(inode) + offset",
            "sizeof(*de)+CRAMFS_MAXPATHLEN"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "cramfs_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
          "lines": "165-239",
          "snippet": "static void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned int len)\n{\n\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct page *pages[BLKS_PER_BUF];\n\tunsigned i, blocknr, buffer;\n\tunsigned long devsize;\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\tblocknr = offset >> PAGE_CACHE_SHIFT;\n\toffset &= PAGE_CACHE_SIZE - 1;\n\n\t/* Check if an existing buffer already has the data.. */\n\tfor (i = 0; i < READ_BUFFERS; i++) {\n\t\tunsigned int blk_offset;\n\n\t\tif (buffer_dev[i] != sb)\n\t\t\tcontinue;\n\t\tif (blocknr < buffer_blocknr[i])\n\t\t\tcontinue;\n\t\tblk_offset = (blocknr - buffer_blocknr[i]) << PAGE_CACHE_SHIFT;\n\t\tblk_offset += offset;\n\t\tif (blk_offset + len > BUFFER_SIZE)\n\t\t\tcontinue;\n\t\treturn read_buffers[i] + blk_offset;\n\t}\n\n\tdevsize = mapping->host->i_size >> PAGE_CACHE_SHIFT;\n\n\t/* Ok, read in BLKS_PER_BUF pages completely first. */\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = NULL;\n\n\t\tif (blocknr + i < devsize) {\n\t\t\tpage = read_mapping_page(mapping, blocknr + i, NULL);\n\t\t\t/* synchronous error? */\n\t\t\tif (IS_ERR(page))\n\t\t\t\tpage = NULL;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\twait_on_page_locked(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t/* asynchronous error */\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer = next_buffer;\n\tnext_buffer = NEXT_BUFFER(buffer);\n\tbuffer_blocknr[buffer] = blocknr;\n\tbuffer_dev[buffer] = sb;\n\n\tdata = read_buffers[buffer];\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\tmemcpy(data, kmap(page), PAGE_CACHE_SIZE);\n\t\t\tkunmap(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\tmemset(data, 0, PAGE_CACHE_SIZE);\n\t\tdata += PAGE_CACHE_SIZE;\n\t}\n\treturn read_buffers[buffer] + offset;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <uapi/linux/cramfs_fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define BUFFER_SIZE\t\t(BLKS_PER_BUF*PAGE_CACHE_SIZE)",
            "#define BLKS_PER_BUF\t\t(1 << BLKS_PER_BUF_SHIFT)",
            "#define READ_BUFFERS (2)"
          ],
          "globals_used": [
            "static unsigned char read_buffers[READ_BUFFERS][BUFFER_SIZE];",
            "static unsigned buffer_blocknr[READ_BUFFERS];",
            "static struct super_block *buffer_dev[READ_BUFFERS];",
            "static int next_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define BUFFER_SIZE\t\t(BLKS_PER_BUF*PAGE_CACHE_SIZE)\n#define BLKS_PER_BUF\t\t(1 << BLKS_PER_BUF_SHIFT)\n#define READ_BUFFERS (2)\n\nstatic unsigned char read_buffers[READ_BUFFERS][BUFFER_SIZE];\nstatic unsigned buffer_blocknr[READ_BUFFERS];\nstatic struct super_block *buffer_dev[READ_BUFFERS];\nstatic int next_buffer;\n\nstatic void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned int len)\n{\n\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct page *pages[BLKS_PER_BUF];\n\tunsigned i, blocknr, buffer;\n\tunsigned long devsize;\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\tblocknr = offset >> PAGE_CACHE_SHIFT;\n\toffset &= PAGE_CACHE_SIZE - 1;\n\n\t/* Check if an existing buffer already has the data.. */\n\tfor (i = 0; i < READ_BUFFERS; i++) {\n\t\tunsigned int blk_offset;\n\n\t\tif (buffer_dev[i] != sb)\n\t\t\tcontinue;\n\t\tif (blocknr < buffer_blocknr[i])\n\t\t\tcontinue;\n\t\tblk_offset = (blocknr - buffer_blocknr[i]) << PAGE_CACHE_SHIFT;\n\t\tblk_offset += offset;\n\t\tif (blk_offset + len > BUFFER_SIZE)\n\t\t\tcontinue;\n\t\treturn read_buffers[i] + blk_offset;\n\t}\n\n\tdevsize = mapping->host->i_size >> PAGE_CACHE_SHIFT;\n\n\t/* Ok, read in BLKS_PER_BUF pages completely first. */\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = NULL;\n\n\t\tif (blocknr + i < devsize) {\n\t\t\tpage = read_mapping_page(mapping, blocknr + i, NULL);\n\t\t\t/* synchronous error? */\n\t\t\tif (IS_ERR(page))\n\t\t\t\tpage = NULL;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\twait_on_page_locked(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t/* asynchronous error */\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer = next_buffer;\n\tnext_buffer = NEXT_BUFFER(buffer);\n\tbuffer_blocknr[buffer] = blocknr;\n\tbuffer_dev[buffer] = sb;\n\n\tdata = read_buffers[buffer];\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\tmemcpy(data, kmap(page), PAGE_CACHE_SIZE);\n\t\t\tkunmap(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\tmemset(data, 0, PAGE_CACHE_SIZE);\n\t\tdata += PAGE_CACHE_SIZE;\n\t}\n\treturn read_buffers[buffer] + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OFFSET",
          "args": [
            "inode"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&read_mutex"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "CRAMFS_MAXPATHLEN",
            "GFP_KERNEL"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(read_mutex);\n\nstatic int cramfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tchar *buf;\n\tunsigned int offset;\n\n\t/* Offset within the thing. */\n\tif (ctx->pos >= inode->i_size)\n\t\treturn 0;\n\toffset = ctx->pos;\n\t/* Directory entries are always 4-byte aligned */\n\tif (offset & 3)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(CRAMFS_MAXPATHLEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (offset < inode->i_size) {\n\t\tstruct cramfs_inode *de;\n\t\tunsigned long nextoffset;\n\t\tchar *name;\n\t\tino_t ino;\n\t\tumode_t mode;\n\t\tint namelen;\n\n\t\tmutex_lock(&read_mutex);\n\t\tde = cramfs_read(sb, OFFSET(inode) + offset, sizeof(*de)+CRAMFS_MAXPATHLEN);\n\t\tname = (char *)(de+1);\n\n\t\t/*\n\t\t * Namelengths on disk are shifted by two\n\t\t * and the name padded out to 4-byte boundaries\n\t\t * with zeroes.\n\t\t */\n\t\tnamelen = de->namelen << 2;\n\t\tmemcpy(buf, name, namelen);\n\t\tino = cramino(de, OFFSET(inode) + offset);\n\t\tmode = de->mode;\n\t\tmutex_unlock(&read_mutex);\n\t\tnextoffset = offset + sizeof(*de) + namelen;\n\t\tfor (;;) {\n\t\t\tif (!namelen) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (buf[namelen-1])\n\t\t\t\tbreak;\n\t\t\tnamelen--;\n\t\t}\n\t\tif (!dir_emit(ctx, buf, namelen, ino, mode >> 12))\n\t\t\tbreak;\n\n\t\tctx->pos = offset = nextoffset;\n\t}\n\tkfree(buf);\n\treturn 0;\n}"
  },
  {
    "function_name": "cramfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "349-365",
    "snippet": "static int cramfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = CRAMFS_MAGIC;\n\tbuf->f_bsize = PAGE_CACHE_SIZE;\n\tbuf->f_blocks = CRAMFS_SB(sb)->blocks;\n\tbuf->f_bfree = 0;\n\tbuf->f_bavail = 0;\n\tbuf->f_files = CRAMFS_SB(sb)->files;\n\tbuf->f_ffree = 0;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = CRAMFS_MAXPATHLEN;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRAMFS_SB",
          "args": [
            "sb"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "CRAMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
          "lines": "41-44",
          "snippet": "static inline struct cramfs_sb_info *CRAMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <uapi/linux/cramfs_fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct cramfs_sb_info *CRAMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int cramfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = CRAMFS_MAGIC;\n\tbuf->f_bsize = PAGE_CACHE_SIZE;\n\tbuf->f_blocks = CRAMFS_SB(sb)->blocks;\n\tbuf->f_bfree = 0;\n\tbuf->f_bavail = 0;\n\tbuf->f_files = CRAMFS_SB(sb)->files;\n\tbuf->f_ffree = 0;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = CRAMFS_MAXPATHLEN;\n\treturn 0;\n}"
  },
  {
    "function_name": "cramfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "256-347",
    "snippet": "static int cramfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tint i;\n\tstruct cramfs_super super;\n\tunsigned long root_offset;\n\tstruct cramfs_sb_info *sbi;\n\tstruct inode *root;\n\n\tsb->s_flags |= MS_RDONLY;\n\n\tsbi = kzalloc(sizeof(struct cramfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\n\t/* Invalidate the read buffers on mount: think disk change.. */\n\tmutex_lock(&read_mutex);\n\tfor (i = 0; i < READ_BUFFERS; i++)\n\t\tbuffer_blocknr[i] = -1;\n\n\t/* Read the first block and get the superblock from it */\n\tmemcpy(&super, cramfs_read(sb, 0, sizeof(super)), sizeof(super));\n\tmutex_unlock(&read_mutex);\n\n\t/* Do sanity checks on the superblock */\n\tif (super.magic != CRAMFS_MAGIC) {\n\t\t/* check for wrong endianness */\n\t\tif (super.magic == CRAMFS_MAGIC_WEND) {\n\t\t\tif (!silent)\n\t\t\t\tpr_err(\"wrong endianness\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check at 512 byte offset */\n\t\tmutex_lock(&read_mutex);\n\t\tmemcpy(&super, cramfs_read(sb, 512, sizeof(super)), sizeof(super));\n\t\tmutex_unlock(&read_mutex);\n\t\tif (super.magic != CRAMFS_MAGIC) {\n\t\t\tif (super.magic == CRAMFS_MAGIC_WEND && !silent)\n\t\t\t\tpr_err(\"wrong endianness\\n\");\n\t\t\telse if (!silent)\n\t\t\t\tpr_err(\"wrong magic\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* get feature flags first */\n\tif (super.flags & ~CRAMFS_SUPPORTED_FLAGS) {\n\t\tpr_err(\"unsupported filesystem features\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check that the root inode is in a sane state */\n\tif (!S_ISDIR(super.root.mode)) {\n\t\tpr_err(\"root is not a directory\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* correct strange, hard-coded permissions of mkcramfs */\n\tsuper.root.mode |= (S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\n\troot_offset = super.root.offset << 2;\n\tif (super.flags & CRAMFS_FLAG_FSID_VERSION_2) {\n\t\tsbi->size = super.size;\n\t\tsbi->blocks = super.fsid.blocks;\n\t\tsbi->files = super.fsid.files;\n\t} else {\n\t\tsbi->size = 1<<28;\n\t\tsbi->blocks = 0;\n\t\tsbi->files = 0;\n\t}\n\tsbi->magic = super.magic;\n\tsbi->flags = super.flags;\n\tif (root_offset == 0)\n\t\tpr_info(\"empty filesystem\");\n\telse if (!(super.flags & CRAMFS_FLAG_SHIFTED_ROOT_OFFSET) &&\n\t\t ((root_offset != sizeof(struct cramfs_super)) &&\n\t\t  (root_offset != 512 + sizeof(struct cramfs_super))))\n\t{\n\t\tpr_err(\"bad root offset %lu\\n\", root_offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Set it all up.. */\n\tsb->s_op = &cramfs_ops;\n\troot = get_cramfs_inode(sb, &super.root, 0);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define READ_BUFFERS (2)"
    ],
    "globals_used": [
      "static const struct super_operations cramfs_ops;",
      "static DEFINE_MUTEX(read_mutex);",
      "static unsigned buffer_blocknr[READ_BUFFERS];",
      "static const struct super_operations cramfs_ops = {\n\t.remount_fs\t= cramfs_remount,\n\t.statfs\t\t= cramfs_statfs,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cramfs_inode",
          "args": [
            "sb",
            "&super.root",
            "0"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "get_cramfs_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
          "lines": "80-130",
          "snippet": "static struct inode *get_cramfs_inode(struct super_block *sb,\n\tconst struct cramfs_inode *cramfs_inode, unsigned int offset)\n{\n\tstruct inode *inode;\n\tstatic struct timespec zerotime;\n\n\tinode = iget_locked(sb, cramino(cramfs_inode, offset));\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tswitch (cramfs_inode->mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &cramfs_dir_inode_operations;\n\t\tinode->i_fop = &cramfs_directory_operations;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tdefault:\n\t\tinit_special_inode(inode, cramfs_inode->mode,\n\t\t\t\told_decode_dev(cramfs_inode->size));\n\t}\n\n\tinode->i_mode = cramfs_inode->mode;\n\ti_uid_write(inode, cramfs_inode->uid);\n\ti_gid_write(inode, cramfs_inode->gid);\n\n\t/* if the lower 2 bits are zero, the inode contains data */\n\tif (!(inode->i_ino & 3)) {\n\t\tinode->i_size = cramfs_inode->size;\n\t\tinode->i_blocks = (cramfs_inode->size - 1) / 512 + 1;\n\t}\n\n\t/* Struct copy intentional */\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = zerotime;\n\t/* inode->i_nlink is left 1 - arguably wrong for directories,\n\t   but it's the best we can do without reading the directory\n\t   contents.  1 yields the right result in GNU find, even\n\t   without -noleaf option. */\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <uapi/linux/cramfs_fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations cramfs_dir_inode_operations;",
            "static const struct file_operations cramfs_directory_operations;",
            "static const struct address_space_operations cramfs_aops;",
            "static const struct address_space_operations cramfs_aops = {\n\t.readpage = cramfs_readpage\n};",
            "static const struct file_operations cramfs_directory_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= cramfs_readdir,\n};",
            "static const struct inode_operations cramfs_dir_inode_operations = {\n\t.lookup\t\t= cramfs_lookup,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct inode_operations cramfs_dir_inode_operations;\nstatic const struct file_operations cramfs_directory_operations;\nstatic const struct address_space_operations cramfs_aops;\nstatic const struct address_space_operations cramfs_aops = {\n\t.readpage = cramfs_readpage\n};\nstatic const struct file_operations cramfs_directory_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= cramfs_readdir,\n};\nstatic const struct inode_operations cramfs_dir_inode_operations = {\n\t.lookup\t\t= cramfs_lookup,\n};\n\nstatic struct inode *get_cramfs_inode(struct super_block *sb,\n\tconst struct cramfs_inode *cramfs_inode, unsigned int offset)\n{\n\tstruct inode *inode;\n\tstatic struct timespec zerotime;\n\n\tinode = iget_locked(sb, cramino(cramfs_inode, offset));\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tswitch (cramfs_inode->mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &cramfs_dir_inode_operations;\n\t\tinode->i_fop = &cramfs_directory_operations;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tdefault:\n\t\tinit_special_inode(inode, cramfs_inode->mode,\n\t\t\t\told_decode_dev(cramfs_inode->size));\n\t}\n\n\tinode->i_mode = cramfs_inode->mode;\n\ti_uid_write(inode, cramfs_inode->uid);\n\ti_gid_write(inode, cramfs_inode->gid);\n\n\t/* if the lower 2 bits are zero, the inode contains data */\n\tif (!(inode->i_ino & 3)) {\n\t\tinode->i_size = cramfs_inode->size;\n\t\tinode->i_blocks = (cramfs_inode->size - 1) / 512 + 1;\n\t}\n\n\t/* Struct copy intentional */\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = zerotime;\n\t/* inode->i_nlink is left 1 - arguably wrong for directories,\n\t   but it's the best we can do without reading the directory\n\t   contents.  1 yields the right result in GNU find, even\n\t   without -noleaf option. */\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad root offset %lu\\n\"",
            "root_offset"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"empty filesystem\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"root is not a directory\\n\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "super.root.mode"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unsupported filesystem features\\n\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"wrong magic\\n\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"wrong endianness\\n\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&read_mutex"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&super",
            "cramfs_read(sb, 512, sizeof(super))",
            "sizeof(super)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cramfs_read",
          "args": [
            "sb",
            "512",
            "sizeof(super)"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "cramfs_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
          "lines": "165-239",
          "snippet": "static void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned int len)\n{\n\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct page *pages[BLKS_PER_BUF];\n\tunsigned i, blocknr, buffer;\n\tunsigned long devsize;\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\tblocknr = offset >> PAGE_CACHE_SHIFT;\n\toffset &= PAGE_CACHE_SIZE - 1;\n\n\t/* Check if an existing buffer already has the data.. */\n\tfor (i = 0; i < READ_BUFFERS; i++) {\n\t\tunsigned int blk_offset;\n\n\t\tif (buffer_dev[i] != sb)\n\t\t\tcontinue;\n\t\tif (blocknr < buffer_blocknr[i])\n\t\t\tcontinue;\n\t\tblk_offset = (blocknr - buffer_blocknr[i]) << PAGE_CACHE_SHIFT;\n\t\tblk_offset += offset;\n\t\tif (blk_offset + len > BUFFER_SIZE)\n\t\t\tcontinue;\n\t\treturn read_buffers[i] + blk_offset;\n\t}\n\n\tdevsize = mapping->host->i_size >> PAGE_CACHE_SHIFT;\n\n\t/* Ok, read in BLKS_PER_BUF pages completely first. */\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = NULL;\n\n\t\tif (blocknr + i < devsize) {\n\t\t\tpage = read_mapping_page(mapping, blocknr + i, NULL);\n\t\t\t/* synchronous error? */\n\t\t\tif (IS_ERR(page))\n\t\t\t\tpage = NULL;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\twait_on_page_locked(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t/* asynchronous error */\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer = next_buffer;\n\tnext_buffer = NEXT_BUFFER(buffer);\n\tbuffer_blocknr[buffer] = blocknr;\n\tbuffer_dev[buffer] = sb;\n\n\tdata = read_buffers[buffer];\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\tmemcpy(data, kmap(page), PAGE_CACHE_SIZE);\n\t\t\tkunmap(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\tmemset(data, 0, PAGE_CACHE_SIZE);\n\t\tdata += PAGE_CACHE_SIZE;\n\t}\n\treturn read_buffers[buffer] + offset;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <uapi/linux/cramfs_fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define BUFFER_SIZE\t\t(BLKS_PER_BUF*PAGE_CACHE_SIZE)",
            "#define BLKS_PER_BUF\t\t(1 << BLKS_PER_BUF_SHIFT)",
            "#define READ_BUFFERS (2)"
          ],
          "globals_used": [
            "static unsigned char read_buffers[READ_BUFFERS][BUFFER_SIZE];",
            "static unsigned buffer_blocknr[READ_BUFFERS];",
            "static struct super_block *buffer_dev[READ_BUFFERS];",
            "static int next_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define BUFFER_SIZE\t\t(BLKS_PER_BUF*PAGE_CACHE_SIZE)\n#define BLKS_PER_BUF\t\t(1 << BLKS_PER_BUF_SHIFT)\n#define READ_BUFFERS (2)\n\nstatic unsigned char read_buffers[READ_BUFFERS][BUFFER_SIZE];\nstatic unsigned buffer_blocknr[READ_BUFFERS];\nstatic struct super_block *buffer_dev[READ_BUFFERS];\nstatic int next_buffer;\n\nstatic void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned int len)\n{\n\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct page *pages[BLKS_PER_BUF];\n\tunsigned i, blocknr, buffer;\n\tunsigned long devsize;\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\tblocknr = offset >> PAGE_CACHE_SHIFT;\n\toffset &= PAGE_CACHE_SIZE - 1;\n\n\t/* Check if an existing buffer already has the data.. */\n\tfor (i = 0; i < READ_BUFFERS; i++) {\n\t\tunsigned int blk_offset;\n\n\t\tif (buffer_dev[i] != sb)\n\t\t\tcontinue;\n\t\tif (blocknr < buffer_blocknr[i])\n\t\t\tcontinue;\n\t\tblk_offset = (blocknr - buffer_blocknr[i]) << PAGE_CACHE_SHIFT;\n\t\tblk_offset += offset;\n\t\tif (blk_offset + len > BUFFER_SIZE)\n\t\t\tcontinue;\n\t\treturn read_buffers[i] + blk_offset;\n\t}\n\n\tdevsize = mapping->host->i_size >> PAGE_CACHE_SHIFT;\n\n\t/* Ok, read in BLKS_PER_BUF pages completely first. */\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = NULL;\n\n\t\tif (blocknr + i < devsize) {\n\t\t\tpage = read_mapping_page(mapping, blocknr + i, NULL);\n\t\t\t/* synchronous error? */\n\t\t\tif (IS_ERR(page))\n\t\t\t\tpage = NULL;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\twait_on_page_locked(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t/* asynchronous error */\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer = next_buffer;\n\tnext_buffer = NEXT_BUFFER(buffer);\n\tbuffer_blocknr[buffer] = blocknr;\n\tbuffer_dev[buffer] = sb;\n\n\tdata = read_buffers[buffer];\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\tmemcpy(data, kmap(page), PAGE_CACHE_SIZE);\n\t\t\tkunmap(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\tmemset(data, 0, PAGE_CACHE_SIZE);\n\t\tdata += PAGE_CACHE_SIZE;\n\t}\n\treturn read_buffers[buffer] + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&read_mutex"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"wrong endianness\\n\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&read_mutex"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&super",
            "cramfs_read(sb, 0, sizeof(super))",
            "sizeof(super)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&read_mutex"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cramfs_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define READ_BUFFERS (2)\n\nstatic const struct super_operations cramfs_ops;\nstatic DEFINE_MUTEX(read_mutex);\nstatic unsigned buffer_blocknr[READ_BUFFERS];\nstatic const struct super_operations cramfs_ops = {\n\t.remount_fs\t= cramfs_remount,\n\t.statfs\t\t= cramfs_statfs,\n};\n\nstatic int cramfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tint i;\n\tstruct cramfs_super super;\n\tunsigned long root_offset;\n\tstruct cramfs_sb_info *sbi;\n\tstruct inode *root;\n\n\tsb->s_flags |= MS_RDONLY;\n\n\tsbi = kzalloc(sizeof(struct cramfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\n\t/* Invalidate the read buffers on mount: think disk change.. */\n\tmutex_lock(&read_mutex);\n\tfor (i = 0; i < READ_BUFFERS; i++)\n\t\tbuffer_blocknr[i] = -1;\n\n\t/* Read the first block and get the superblock from it */\n\tmemcpy(&super, cramfs_read(sb, 0, sizeof(super)), sizeof(super));\n\tmutex_unlock(&read_mutex);\n\n\t/* Do sanity checks on the superblock */\n\tif (super.magic != CRAMFS_MAGIC) {\n\t\t/* check for wrong endianness */\n\t\tif (super.magic == CRAMFS_MAGIC_WEND) {\n\t\t\tif (!silent)\n\t\t\t\tpr_err(\"wrong endianness\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check at 512 byte offset */\n\t\tmutex_lock(&read_mutex);\n\t\tmemcpy(&super, cramfs_read(sb, 512, sizeof(super)), sizeof(super));\n\t\tmutex_unlock(&read_mutex);\n\t\tif (super.magic != CRAMFS_MAGIC) {\n\t\t\tif (super.magic == CRAMFS_MAGIC_WEND && !silent)\n\t\t\t\tpr_err(\"wrong endianness\\n\");\n\t\t\telse if (!silent)\n\t\t\t\tpr_err(\"wrong magic\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* get feature flags first */\n\tif (super.flags & ~CRAMFS_SUPPORTED_FLAGS) {\n\t\tpr_err(\"unsupported filesystem features\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check that the root inode is in a sane state */\n\tif (!S_ISDIR(super.root.mode)) {\n\t\tpr_err(\"root is not a directory\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* correct strange, hard-coded permissions of mkcramfs */\n\tsuper.root.mode |= (S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\n\troot_offset = super.root.offset << 2;\n\tif (super.flags & CRAMFS_FLAG_FSID_VERSION_2) {\n\t\tsbi->size = super.size;\n\t\tsbi->blocks = super.fsid.blocks;\n\t\tsbi->files = super.fsid.files;\n\t} else {\n\t\tsbi->size = 1<<28;\n\t\tsbi->blocks = 0;\n\t\tsbi->files = 0;\n\t}\n\tsbi->magic = super.magic;\n\tsbi->flags = super.flags;\n\tif (root_offset == 0)\n\t\tpr_info(\"empty filesystem\");\n\telse if (!(super.flags & CRAMFS_FLAG_SHIFTED_ROOT_OFFSET) &&\n\t\t ((root_offset != sizeof(struct cramfs_super)) &&\n\t\t  (root_offset != 512 + sizeof(struct cramfs_super))))\n\t{\n\t\tpr_err(\"bad root offset %lu\\n\", root_offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Set it all up.. */\n\tsb->s_op = &cramfs_ops;\n\troot = get_cramfs_inode(sb, &super.root, 0);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "cramfs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "249-254",
    "snippet": "static int cramfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_RDONLY;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int cramfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_RDONLY;\n\treturn 0;\n}"
  },
  {
    "function_name": "cramfs_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "241-247",
    "snippet": "static void cramfs_kill_sb(struct super_block *sb)\n{\n\tstruct cramfs_sb_info *sbi = CRAMFS_SB(sb);\n\n\tkill_block_super(sb);\n\tkfree(sbi);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_block_super",
          "args": [
            "sb"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_kill_block_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "629-638",
          "snippet": "static void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_sb_info_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\n\nstatic void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CRAMFS_SB",
          "args": [
            "sb"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "CRAMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
          "lines": "41-44",
          "snippet": "static inline struct cramfs_sb_info *CRAMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <uapi/linux/cramfs_fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct cramfs_sb_info *CRAMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void cramfs_kill_sb(struct super_block *sb)\n{\n\tstruct cramfs_sb_info *sbi = CRAMFS_SB(sb);\n\n\tkill_block_super(sb);\n\tkfree(sbi);\n}"
  },
  {
    "function_name": "cramfs_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "165-239",
    "snippet": "static void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned int len)\n{\n\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct page *pages[BLKS_PER_BUF];\n\tunsigned i, blocknr, buffer;\n\tunsigned long devsize;\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\tblocknr = offset >> PAGE_CACHE_SHIFT;\n\toffset &= PAGE_CACHE_SIZE - 1;\n\n\t/* Check if an existing buffer already has the data.. */\n\tfor (i = 0; i < READ_BUFFERS; i++) {\n\t\tunsigned int blk_offset;\n\n\t\tif (buffer_dev[i] != sb)\n\t\t\tcontinue;\n\t\tif (blocknr < buffer_blocknr[i])\n\t\t\tcontinue;\n\t\tblk_offset = (blocknr - buffer_blocknr[i]) << PAGE_CACHE_SHIFT;\n\t\tblk_offset += offset;\n\t\tif (blk_offset + len > BUFFER_SIZE)\n\t\t\tcontinue;\n\t\treturn read_buffers[i] + blk_offset;\n\t}\n\n\tdevsize = mapping->host->i_size >> PAGE_CACHE_SHIFT;\n\n\t/* Ok, read in BLKS_PER_BUF pages completely first. */\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = NULL;\n\n\t\tif (blocknr + i < devsize) {\n\t\t\tpage = read_mapping_page(mapping, blocknr + i, NULL);\n\t\t\t/* synchronous error? */\n\t\t\tif (IS_ERR(page))\n\t\t\t\tpage = NULL;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\twait_on_page_locked(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t/* asynchronous error */\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer = next_buffer;\n\tnext_buffer = NEXT_BUFFER(buffer);\n\tbuffer_blocknr[buffer] = blocknr;\n\tbuffer_dev[buffer] = sb;\n\n\tdata = read_buffers[buffer];\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\tmemcpy(data, kmap(page), PAGE_CACHE_SIZE);\n\t\t\tkunmap(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\tmemset(data, 0, PAGE_CACHE_SIZE);\n\t\tdata += PAGE_CACHE_SIZE;\n\t}\n\treturn read_buffers[buffer] + offset;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define BUFFER_SIZE\t\t(BLKS_PER_BUF*PAGE_CACHE_SIZE)",
      "#define BLKS_PER_BUF\t\t(1 << BLKS_PER_BUF_SHIFT)",
      "#define READ_BUFFERS (2)"
    ],
    "globals_used": [
      "static unsigned char read_buffers[READ_BUFFERS][BUFFER_SIZE];",
      "static unsigned buffer_blocknr[READ_BUFFERS];",
      "static struct super_block *buffer_dev[READ_BUFFERS];",
      "static int next_buffer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "kmap(page)",
            "PAGE_CACHE_SIZE"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_BUFFER",
          "args": [
            "buffer"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "blocknr + i",
            "NULL"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define BUFFER_SIZE\t\t(BLKS_PER_BUF*PAGE_CACHE_SIZE)\n#define BLKS_PER_BUF\t\t(1 << BLKS_PER_BUF_SHIFT)\n#define READ_BUFFERS (2)\n\nstatic unsigned char read_buffers[READ_BUFFERS][BUFFER_SIZE];\nstatic unsigned buffer_blocknr[READ_BUFFERS];\nstatic struct super_block *buffer_dev[READ_BUFFERS];\nstatic int next_buffer;\n\nstatic void *cramfs_read(struct super_block *sb, unsigned int offset, unsigned int len)\n{\n\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\tstruct page *pages[BLKS_PER_BUF];\n\tunsigned i, blocknr, buffer;\n\tunsigned long devsize;\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\tblocknr = offset >> PAGE_CACHE_SHIFT;\n\toffset &= PAGE_CACHE_SIZE - 1;\n\n\t/* Check if an existing buffer already has the data.. */\n\tfor (i = 0; i < READ_BUFFERS; i++) {\n\t\tunsigned int blk_offset;\n\n\t\tif (buffer_dev[i] != sb)\n\t\t\tcontinue;\n\t\tif (blocknr < buffer_blocknr[i])\n\t\t\tcontinue;\n\t\tblk_offset = (blocknr - buffer_blocknr[i]) << PAGE_CACHE_SHIFT;\n\t\tblk_offset += offset;\n\t\tif (blk_offset + len > BUFFER_SIZE)\n\t\t\tcontinue;\n\t\treturn read_buffers[i] + blk_offset;\n\t}\n\n\tdevsize = mapping->host->i_size >> PAGE_CACHE_SHIFT;\n\n\t/* Ok, read in BLKS_PER_BUF pages completely first. */\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = NULL;\n\n\t\tif (blocknr + i < devsize) {\n\t\t\tpage = read_mapping_page(mapping, blocknr + i, NULL);\n\t\t\t/* synchronous error? */\n\t\t\tif (IS_ERR(page))\n\t\t\t\tpage = NULL;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\twait_on_page_locked(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t/* asynchronous error */\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpages[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer = next_buffer;\n\tnext_buffer = NEXT_BUFFER(buffer);\n\tbuffer_blocknr[buffer] = blocknr;\n\tbuffer_dev[buffer] = sb;\n\n\tdata = read_buffers[buffer];\n\tfor (i = 0; i < BLKS_PER_BUF; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\tif (page) {\n\t\t\tmemcpy(data, kmap(page), PAGE_CACHE_SIZE);\n\t\t\tkunmap(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\tmemset(data, 0, PAGE_CACHE_SIZE);\n\t\tdata += PAGE_CACHE_SIZE;\n\t}\n\treturn read_buffers[buffer] + offset;\n}"
  },
  {
    "function_name": "get_cramfs_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "80-130",
    "snippet": "static struct inode *get_cramfs_inode(struct super_block *sb,\n\tconst struct cramfs_inode *cramfs_inode, unsigned int offset)\n{\n\tstruct inode *inode;\n\tstatic struct timespec zerotime;\n\n\tinode = iget_locked(sb, cramino(cramfs_inode, offset));\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tswitch (cramfs_inode->mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &cramfs_dir_inode_operations;\n\t\tinode->i_fop = &cramfs_directory_operations;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tdefault:\n\t\tinit_special_inode(inode, cramfs_inode->mode,\n\t\t\t\told_decode_dev(cramfs_inode->size));\n\t}\n\n\tinode->i_mode = cramfs_inode->mode;\n\ti_uid_write(inode, cramfs_inode->uid);\n\ti_gid_write(inode, cramfs_inode->gid);\n\n\t/* if the lower 2 bits are zero, the inode contains data */\n\tif (!(inode->i_ino & 3)) {\n\t\tinode->i_size = cramfs_inode->size;\n\t\tinode->i_blocks = (cramfs_inode->size - 1) / 512 + 1;\n\t}\n\n\t/* Struct copy intentional */\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = zerotime;\n\t/* inode->i_nlink is left 1 - arguably wrong for directories,\n\t   but it's the best we can do without reading the directory\n\t   contents.  1 yields the right result in GNU find, even\n\t   without -noleaf option. */\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations cramfs_dir_inode_operations;",
      "static const struct file_operations cramfs_directory_operations;",
      "static const struct address_space_operations cramfs_aops;",
      "static const struct address_space_operations cramfs_aops = {\n\t.readpage = cramfs_readpage\n};",
      "static const struct file_operations cramfs_directory_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= cramfs_readdir,\n};",
      "static const struct inode_operations cramfs_dir_inode_operations = {\n\t.lookup\t\t= cramfs_lookup,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "cramfs_inode->gid"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "cramfs_inode->uid"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "cramfs_inode->mode",
            "old_decode_dev(cramfs_inode->size)"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "cramfs_inode->size"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "cramino(cramfs_inode, offset)"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cramino",
          "args": [
            "cramfs_inode",
            "offset"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "cramino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
          "lines": "57-78",
          "snippet": "static unsigned long cramino(const struct cramfs_inode *cino, unsigned int offset)\n{\n\tif (!cino->offset)\n\t\treturn offset + 1;\n\tif (!cino->size)\n\t\treturn offset + 1;\n\n\t/*\n\t * The file mode test fixes buggy mkcramfs implementations where\n\t * cramfs_inode->offset is set to a non zero value for entries\n\t * which did not contain data, like devices node and fifos.\n\t */\n\tswitch (cino->mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\treturn cino->offset << 2;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset + 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <uapi/linux/cramfs_fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic unsigned long cramino(const struct cramfs_inode *cino, unsigned int offset)\n{\n\tif (!cino->offset)\n\t\treturn offset + 1;\n\tif (!cino->size)\n\t\treturn offset + 1;\n\n\t/*\n\t * The file mode test fixes buggy mkcramfs implementations where\n\t * cramfs_inode->offset is set to a non zero value for entries\n\t * which did not contain data, like devices node and fifos.\n\t */\n\tswitch (cino->mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\treturn cino->offset << 2;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct inode_operations cramfs_dir_inode_operations;\nstatic const struct file_operations cramfs_directory_operations;\nstatic const struct address_space_operations cramfs_aops;\nstatic const struct address_space_operations cramfs_aops = {\n\t.readpage = cramfs_readpage\n};\nstatic const struct file_operations cramfs_directory_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= cramfs_readdir,\n};\nstatic const struct inode_operations cramfs_dir_inode_operations = {\n\t.lookup\t\t= cramfs_lookup,\n};\n\nstatic struct inode *get_cramfs_inode(struct super_block *sb,\n\tconst struct cramfs_inode *cramfs_inode, unsigned int offset)\n{\n\tstruct inode *inode;\n\tstatic struct timespec zerotime;\n\n\tinode = iget_locked(sb, cramino(cramfs_inode, offset));\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tswitch (cramfs_inode->mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &cramfs_dir_inode_operations;\n\t\tinode->i_fop = &cramfs_directory_operations;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &cramfs_aops;\n\t\tbreak;\n\tdefault:\n\t\tinit_special_inode(inode, cramfs_inode->mode,\n\t\t\t\told_decode_dev(cramfs_inode->size));\n\t}\n\n\tinode->i_mode = cramfs_inode->mode;\n\ti_uid_write(inode, cramfs_inode->uid);\n\ti_gid_write(inode, cramfs_inode->gid);\n\n\t/* if the lower 2 bits are zero, the inode contains data */\n\tif (!(inode->i_ino & 3)) {\n\t\tinode->i_size = cramfs_inode->size;\n\t\tinode->i_blocks = (cramfs_inode->size - 1) / 512 + 1;\n\t}\n\n\t/* Struct copy intentional */\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = zerotime;\n\t/* inode->i_nlink is left 1 - arguably wrong for directories,\n\t   but it's the best we can do without reading the directory\n\t   contents.  1 yields the right result in GNU find, even\n\t   without -noleaf option. */\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "cramino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "57-78",
    "snippet": "static unsigned long cramino(const struct cramfs_inode *cino, unsigned int offset)\n{\n\tif (!cino->offset)\n\t\treturn offset + 1;\n\tif (!cino->size)\n\t\treturn offset + 1;\n\n\t/*\n\t * The file mode test fixes buggy mkcramfs implementations where\n\t * cramfs_inode->offset is set to a non zero value for entries\n\t * which did not contain data, like devices node and fifos.\n\t */\n\tswitch (cino->mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\treturn cino->offset << 2;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset + 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic unsigned long cramino(const struct cramfs_inode *cino, unsigned int offset)\n{\n\tif (!cino->offset)\n\t\treturn offset + 1;\n\tif (!cino->size)\n\t\treturn offset + 1;\n\n\t/*\n\t * The file mode test fixes buggy mkcramfs implementations where\n\t * cramfs_inode->offset is set to a non zero value for entries\n\t * which did not contain data, like devices node and fifos.\n\t */\n\tswitch (cino->mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\treturn cino->offset << 2;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset + 1;\n}"
  },
  {
    "function_name": "CRAMFS_SB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cramfs/inode.c",
    "lines": "41-44",
    "snippet": "static inline struct cramfs_sb_info *CRAMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <uapi/linux/cramfs_fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <uapi/linux/cramfs_fs.h>\n#include <linux/mutex.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct cramfs_sb_info *CRAMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
  }
]