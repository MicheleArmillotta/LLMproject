[
  {
    "function_name": "isofs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/dir.c",
    "lines": "249-266",
    "snippet": "static int isofs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint result;\n\tchar *tmpname;\n\tstruct iso_directory_record *tmpde;\n\tstruct inode *inode = file_inode(file);\n\n\ttmpname = (char *)__get_free_page(GFP_KERNEL);\n\tif (tmpname == NULL)\n\t\treturn -ENOMEM;\n\n\ttmpde = (struct iso_directory_record *) (tmpname+1024);\n\n\tresult = do_isofs_readdir(inode, file, ctx, tmpname, tmpde);\n\n\tfree_page((unsigned long) tmpname);\n\treturn result;\n}",
    "includes": [
      "#include \"isofs.h\"",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) tmpname"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_isofs_readdir",
          "args": [
            "inode",
            "file",
            "ctx",
            "tmpname",
            "tmpde"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "do_isofs_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/dir.c",
          "lines": "81-242",
          "snippet": "static int do_isofs_readdir(struct inode *inode, struct file *file,\n\t\tstruct dir_context *ctx,\n\t\tchar *tmpname, struct iso_directory_record *tmpde)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned char bufbits = ISOFS_BUFFER_BITS(inode);\n\tunsigned long block, offset, block_saved, offset_saved;\n\tunsigned long inode_number = 0;\t/* Quiet GCC */\n\tstruct buffer_head *bh = NULL;\n\tint len;\n\tint map;\n\tint first_de = 1;\n\tchar *p = NULL;\t\t/* Quiet GCC */\n\tstruct iso_directory_record *de;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\n\n\toffset = ctx->pos & (bufsize - 1);\n\tblock = ctx->pos >> bufbits;\n\n\twhile (ctx->pos < inode->i_size) {\n\t\tint de_len;\n\n\t\tif (!bh) {\n\t\t\tbh = isofs_bread(inode, block);\n\t\t\tif (!bh)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\n\t\tde_len = *(unsigned char *)de;\n\n\t\t/*\n\t\t * If the length byte is zero, we should move on to the next\n\t\t * CDROM sector.  If we are at the end of the directory, we\n\t\t * kick out of the while loop.\n\t\t */\n\n\t\tif (de_len == 0) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tctx->pos = (ctx->pos + ISOFS_BLOCK_SIZE) & ~(ISOFS_BLOCK_SIZE - 1);\n\t\t\tblock = ctx->pos >> bufbits;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = block;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = isofs_bread(inode, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy((void *) tmpde + slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\t\t/* Basic sanity check, whether name doesn't exceed dir entry */\n\t\tif (de_len < de->name_len[0] +\n\t\t\t\t\tsizeof(struct iso_directory_record)) {\n\t\t\tprintk(KERN_NOTICE \"iso9660: Corrupted directory entry\"\n\t\t\t       \" in block %lu of inode %lu\\n\", block,\n\t\t\t       inode->i_ino);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (first_de) {\n\t\t\tisofs_normalize_block_and_offset(de,\n\t\t\t\t\t\t\t&block_saved,\n\t\t\t\t\t\t\t&offset_saved);\n\t\t\tinode_number = isofs_get_ino(block_saved,\n\t\t\t\t\t\t\toffset_saved, bufbits);\n\t\t}\n\n\t\tif (de->flags[-sbi->s_high_sierra] & 0x80) {\n\t\t\tfirst_de = 0;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst_de = 1;\n\n\t\t/* Handle the case of the '.' directory */\n\t\tif (de->name_len[0] == 1 && de->name[0] == 0) {\n\t\t\tif (!dir_emit_dot(file, ctx))\n\t\t\t\tbreak;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = 0;\n\n\t\t/* Handle the case of the '..' directory */\n\t\tif (de->name_len[0] == 1 && de->name[0] == 1) {\n\t\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\t\tbreak;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Handle everything else.  Do name translation if there\n\t\t   is no Rock Ridge NM field. */\n\n\t\t/*\n\t\t * Do not report hidden files if so instructed, or associated\n\t\t * files unless instructed to do so\n\t\t */\n\t\tif ((sbi->s_hide && (de->flags[-sbi->s_high_sierra] & 1)) ||\n\t\t    (!sbi->s_showassoc &&\n\t\t\t\t(de->flags[-sbi->s_high_sierra] & 4))) {\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmap = 1;\n\t\tif (sbi->s_rock) {\n\t\t\tlen = get_rock_ridge_filename(de, tmpname, inode);\n\t\t\tif (len != 0) {\t\t/* may be -1 */\n\t\t\t\tp = tmpname;\n\t\t\t\tmap = 0;\n\t\t\t}\n\t\t}\n\t\tif (map) {\n#ifdef CONFIG_JOLIET\n\t\t\tif (sbi->s_joliet_level) {\n\t\t\t\tlen = get_joliet_filename(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else\n#endif\n\t\t\tif (sbi->s_mapping == 'a') {\n\t\t\t\tlen = get_acorn_filename(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else\n\t\t\tif (sbi->s_mapping == 'n') {\n\t\t\t\tlen = isofs_name_translate(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else {\n\t\t\t\tp = de->name;\n\t\t\t\tlen = de->name_len[0];\n\t\t\t}\n\t\t}\n\t\tif (len > 0) {\n\t\t\tif (!dir_emit(ctx, p, len, inode_number, DT_UNKNOWN))\n\t\t\t\tbreak;\n\t\t}\n\t\tctx->pos += de_len;\n\n\t\tcontinue;\n\t}\n\tif (bh)\n\t\tbrelse(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"isofs.h\"",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nstatic int do_isofs_readdir(struct inode *inode, struct file *file,\n\t\tstruct dir_context *ctx,\n\t\tchar *tmpname, struct iso_directory_record *tmpde)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned char bufbits = ISOFS_BUFFER_BITS(inode);\n\tunsigned long block, offset, block_saved, offset_saved;\n\tunsigned long inode_number = 0;\t/* Quiet GCC */\n\tstruct buffer_head *bh = NULL;\n\tint len;\n\tint map;\n\tint first_de = 1;\n\tchar *p = NULL;\t\t/* Quiet GCC */\n\tstruct iso_directory_record *de;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\n\n\toffset = ctx->pos & (bufsize - 1);\n\tblock = ctx->pos >> bufbits;\n\n\twhile (ctx->pos < inode->i_size) {\n\t\tint de_len;\n\n\t\tif (!bh) {\n\t\t\tbh = isofs_bread(inode, block);\n\t\t\tif (!bh)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\n\t\tde_len = *(unsigned char *)de;\n\n\t\t/*\n\t\t * If the length byte is zero, we should move on to the next\n\t\t * CDROM sector.  If we are at the end of the directory, we\n\t\t * kick out of the while loop.\n\t\t */\n\n\t\tif (de_len == 0) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tctx->pos = (ctx->pos + ISOFS_BLOCK_SIZE) & ~(ISOFS_BLOCK_SIZE - 1);\n\t\t\tblock = ctx->pos >> bufbits;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = block;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = isofs_bread(inode, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy((void *) tmpde + slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\t\t/* Basic sanity check, whether name doesn't exceed dir entry */\n\t\tif (de_len < de->name_len[0] +\n\t\t\t\t\tsizeof(struct iso_directory_record)) {\n\t\t\tprintk(KERN_NOTICE \"iso9660: Corrupted directory entry\"\n\t\t\t       \" in block %lu of inode %lu\\n\", block,\n\t\t\t       inode->i_ino);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (first_de) {\n\t\t\tisofs_normalize_block_and_offset(de,\n\t\t\t\t\t\t\t&block_saved,\n\t\t\t\t\t\t\t&offset_saved);\n\t\t\tinode_number = isofs_get_ino(block_saved,\n\t\t\t\t\t\t\toffset_saved, bufbits);\n\t\t}\n\n\t\tif (de->flags[-sbi->s_high_sierra] & 0x80) {\n\t\t\tfirst_de = 0;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst_de = 1;\n\n\t\t/* Handle the case of the '.' directory */\n\t\tif (de->name_len[0] == 1 && de->name[0] == 0) {\n\t\t\tif (!dir_emit_dot(file, ctx))\n\t\t\t\tbreak;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = 0;\n\n\t\t/* Handle the case of the '..' directory */\n\t\tif (de->name_len[0] == 1 && de->name[0] == 1) {\n\t\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\t\tbreak;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Handle everything else.  Do name translation if there\n\t\t   is no Rock Ridge NM field. */\n\n\t\t/*\n\t\t * Do not report hidden files if so instructed, or associated\n\t\t * files unless instructed to do so\n\t\t */\n\t\tif ((sbi->s_hide && (de->flags[-sbi->s_high_sierra] & 1)) ||\n\t\t    (!sbi->s_showassoc &&\n\t\t\t\t(de->flags[-sbi->s_high_sierra] & 4))) {\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmap = 1;\n\t\tif (sbi->s_rock) {\n\t\t\tlen = get_rock_ridge_filename(de, tmpname, inode);\n\t\t\tif (len != 0) {\t\t/* may be -1 */\n\t\t\t\tp = tmpname;\n\t\t\t\tmap = 0;\n\t\t\t}\n\t\t}\n\t\tif (map) {\n#ifdef CONFIG_JOLIET\n\t\t\tif (sbi->s_joliet_level) {\n\t\t\t\tlen = get_joliet_filename(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else\n#endif\n\t\t\tif (sbi->s_mapping == 'a') {\n\t\t\t\tlen = get_acorn_filename(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else\n\t\t\tif (sbi->s_mapping == 'n') {\n\t\t\t\tlen = isofs_name_translate(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else {\n\t\t\t\tp = de->name;\n\t\t\t\tlen = de->name_len[0];\n\t\t\t}\n\t\t}\n\t\tif (len > 0) {\n\t\t\tif (!dir_emit(ctx, p, len, inode_number, DT_UNKNOWN))\n\t\t\t\tbreak;\n\t\t}\n\t\tctx->pos += de_len;\n\n\t\tcontinue;\n\t}\n\tif (bh)\n\t\tbrelse(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nstatic int isofs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint result;\n\tchar *tmpname;\n\tstruct iso_directory_record *tmpde;\n\tstruct inode *inode = file_inode(file);\n\n\ttmpname = (char *)__get_free_page(GFP_KERNEL);\n\tif (tmpname == NULL)\n\t\treturn -ENOMEM;\n\n\ttmpde = (struct iso_directory_record *) (tmpname+1024);\n\n\tresult = do_isofs_readdir(inode, file, ctx, tmpname, tmpde);\n\n\tfree_page((unsigned long) tmpname);\n\treturn result;\n}"
  },
  {
    "function_name": "do_isofs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/dir.c",
    "lines": "81-242",
    "snippet": "static int do_isofs_readdir(struct inode *inode, struct file *file,\n\t\tstruct dir_context *ctx,\n\t\tchar *tmpname, struct iso_directory_record *tmpde)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned char bufbits = ISOFS_BUFFER_BITS(inode);\n\tunsigned long block, offset, block_saved, offset_saved;\n\tunsigned long inode_number = 0;\t/* Quiet GCC */\n\tstruct buffer_head *bh = NULL;\n\tint len;\n\tint map;\n\tint first_de = 1;\n\tchar *p = NULL;\t\t/* Quiet GCC */\n\tstruct iso_directory_record *de;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\n\n\toffset = ctx->pos & (bufsize - 1);\n\tblock = ctx->pos >> bufbits;\n\n\twhile (ctx->pos < inode->i_size) {\n\t\tint de_len;\n\n\t\tif (!bh) {\n\t\t\tbh = isofs_bread(inode, block);\n\t\t\tif (!bh)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\n\t\tde_len = *(unsigned char *)de;\n\n\t\t/*\n\t\t * If the length byte is zero, we should move on to the next\n\t\t * CDROM sector.  If we are at the end of the directory, we\n\t\t * kick out of the while loop.\n\t\t */\n\n\t\tif (de_len == 0) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tctx->pos = (ctx->pos + ISOFS_BLOCK_SIZE) & ~(ISOFS_BLOCK_SIZE - 1);\n\t\t\tblock = ctx->pos >> bufbits;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = block;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = isofs_bread(inode, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy((void *) tmpde + slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\t\t/* Basic sanity check, whether name doesn't exceed dir entry */\n\t\tif (de_len < de->name_len[0] +\n\t\t\t\t\tsizeof(struct iso_directory_record)) {\n\t\t\tprintk(KERN_NOTICE \"iso9660: Corrupted directory entry\"\n\t\t\t       \" in block %lu of inode %lu\\n\", block,\n\t\t\t       inode->i_ino);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (first_de) {\n\t\t\tisofs_normalize_block_and_offset(de,\n\t\t\t\t\t\t\t&block_saved,\n\t\t\t\t\t\t\t&offset_saved);\n\t\t\tinode_number = isofs_get_ino(block_saved,\n\t\t\t\t\t\t\toffset_saved, bufbits);\n\t\t}\n\n\t\tif (de->flags[-sbi->s_high_sierra] & 0x80) {\n\t\t\tfirst_de = 0;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst_de = 1;\n\n\t\t/* Handle the case of the '.' directory */\n\t\tif (de->name_len[0] == 1 && de->name[0] == 0) {\n\t\t\tif (!dir_emit_dot(file, ctx))\n\t\t\t\tbreak;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = 0;\n\n\t\t/* Handle the case of the '..' directory */\n\t\tif (de->name_len[0] == 1 && de->name[0] == 1) {\n\t\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\t\tbreak;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Handle everything else.  Do name translation if there\n\t\t   is no Rock Ridge NM field. */\n\n\t\t/*\n\t\t * Do not report hidden files if so instructed, or associated\n\t\t * files unless instructed to do so\n\t\t */\n\t\tif ((sbi->s_hide && (de->flags[-sbi->s_high_sierra] & 1)) ||\n\t\t    (!sbi->s_showassoc &&\n\t\t\t\t(de->flags[-sbi->s_high_sierra] & 4))) {\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmap = 1;\n\t\tif (sbi->s_rock) {\n\t\t\tlen = get_rock_ridge_filename(de, tmpname, inode);\n\t\t\tif (len != 0) {\t\t/* may be -1 */\n\t\t\t\tp = tmpname;\n\t\t\t\tmap = 0;\n\t\t\t}\n\t\t}\n\t\tif (map) {\n#ifdef CONFIG_JOLIET\n\t\t\tif (sbi->s_joliet_level) {\n\t\t\t\tlen = get_joliet_filename(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else\n#endif\n\t\t\tif (sbi->s_mapping == 'a') {\n\t\t\t\tlen = get_acorn_filename(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else\n\t\t\tif (sbi->s_mapping == 'n') {\n\t\t\t\tlen = isofs_name_translate(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else {\n\t\t\t\tp = de->name;\n\t\t\t\tlen = de->name_len[0];\n\t\t\t}\n\t\t}\n\t\tif (len > 0) {\n\t\t\tif (!dir_emit(ctx, p, len, inode_number, DT_UNKNOWN))\n\t\t\t\tbreak;\n\t\t}\n\t\tctx->pos += de_len;\n\n\t\tcontinue;\n\t}\n\tif (bh)\n\t\tbrelse(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"isofs.h\"",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "p",
            "len",
            "inode_number",
            "DT_UNKNOWN"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isofs_name_translate",
          "args": [
            "de",
            "tmpname",
            "inode"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "isofs_name_translate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/dir.c",
          "lines": "16-46",
          "snippet": "int isofs_name_translate(struct iso_directory_record *de, char *new, struct inode *inode)\n{\n\tchar * old = de->name;\n\tint len = de->name_len[0];\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char c = old[i];\n\t\tif (!c)\n\t\t\tbreak;\n\n\t\tif (c >= 'A' && c <= 'Z')\n\t\t\tc |= 0x20;\t/* lower case */\n\n\t\t/* Drop trailing '.;1' (ISO 9660:1988 7.5.1 requires period) */\n\t\tif (c == '.' && i == len - 3 && old[i + 1] == ';' && old[i + 2] == '1')\n\t\t\tbreak;\n\n\t\t/* Drop trailing ';1' */\n\t\tif (c == ';' && i == len - 2 && old[i + 1] == '1')\n\t\t\tbreak;\n\n\t\t/* Convert remaining ';' to '.' */\n\t\t/* Also '/' to '.' (broken Acorn-generated ISO9660 images) */\n\t\tif (c == ';' || c == '/')\n\t\t\tc = '.';\n\n\t\tnew[i] = c;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"isofs.h\"",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nint isofs_name_translate(struct iso_directory_record *de, char *new, struct inode *inode)\n{\n\tchar * old = de->name;\n\tint len = de->name_len[0];\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char c = old[i];\n\t\tif (!c)\n\t\t\tbreak;\n\n\t\tif (c >= 'A' && c <= 'Z')\n\t\t\tc |= 0x20;\t/* lower case */\n\n\t\t/* Drop trailing '.;1' (ISO 9660:1988 7.5.1 requires period) */\n\t\tif (c == '.' && i == len - 3 && old[i + 1] == ';' && old[i + 2] == '1')\n\t\t\tbreak;\n\n\t\t/* Drop trailing ';1' */\n\t\tif (c == ';' && i == len - 2 && old[i + 1] == '1')\n\t\t\tbreak;\n\n\t\t/* Convert remaining ';' to '.' */\n\t\t/* Also '/' to '.' (broken Acorn-generated ISO9660 images) */\n\t\tif (c == ';' || c == '/')\n\t\t\tc = '.';\n\n\t\tnew[i] = c;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_acorn_filename",
          "args": [
            "de",
            "tmpname",
            "inode"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "get_acorn_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/dir.c",
          "lines": "49-76",
          "snippet": "int get_acorn_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tint std;\n\tunsigned char *chr;\n\tint retnamlen = isofs_name_translate(de, retname, inode);\n\n\tif (retnamlen == 0)\n\t\treturn 0;\n\tstd = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (std & 1)\n\t\tstd++;\n\tif ((*((unsigned char *) de) - std) != 32)\n\t\treturn retnamlen;\n\tchr = ((unsigned char *) de) + std;\n\tif (strncmp(chr, \"ARCHIMEDES\", 10))\n\t\treturn retnamlen;\n\tif ((*retname == '_') && ((chr[19] & 1) == 1))\n\t\t*retname = '!';\n\tif (((de->flags[0] & 2) == 0) && (chr[13] == 0xff)\n\t\t&& ((chr[12] & 0xf0) == 0xf0)) {\n\t\tretname[retnamlen] = ',';\n\t\tsprintf(retname+retnamlen+1, \"%3.3x\",\n\t\t\t((chr[12] & 0xf) << 8) | chr[11]);\n\t\tretnamlen += 4;\n\t}\n\treturn retnamlen;\n}",
          "includes": [
            "#include \"isofs.h\"",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nint get_acorn_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tint std;\n\tunsigned char *chr;\n\tint retnamlen = isofs_name_translate(de, retname, inode);\n\n\tif (retnamlen == 0)\n\t\treturn 0;\n\tstd = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (std & 1)\n\t\tstd++;\n\tif ((*((unsigned char *) de) - std) != 32)\n\t\treturn retnamlen;\n\tchr = ((unsigned char *) de) + std;\n\tif (strncmp(chr, \"ARCHIMEDES\", 10))\n\t\treturn retnamlen;\n\tif ((*retname == '_') && ((chr[19] & 1) == 1))\n\t\t*retname = '!';\n\tif (((de->flags[0] & 2) == 0) && (chr[13] == 0xff)\n\t\t&& ((chr[12] & 0xf0) == 0xf0)) {\n\t\tretname[retnamlen] = ',';\n\t\tsprintf(retname+retnamlen+1, \"%3.3x\",\n\t\t\t((chr[12] & 0xf) << 8) | chr[11]);\n\t\tretnamlen += 4;\n\t}\n\treturn retnamlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_joliet_filename",
          "args": [
            "de",
            "tmpname",
            "inode"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "get_joliet_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/joliet.c",
          "lines": "40-69",
          "snippet": "int\nget_joliet_filename(struct iso_directory_record * de, unsigned char *outname, struct inode * inode)\n{\n\tunsigned char utf8;\n\tstruct nls_table *nls;\n\tunsigned char len = 0;\n\n\tutf8 = ISOFS_SB(inode->i_sb)->s_utf8;\n\tnls = ISOFS_SB(inode->i_sb)->s_nls_iocharset;\n\n\tif (utf8) {\n\t\tlen = utf16s_to_utf8s((const wchar_t *) de->name,\n\t\t\t\tde->name_len[0] >> 1, UTF16_BIG_ENDIAN,\n\t\t\t\toutname, PAGE_SIZE);\n\t} else {\n\t\tlen = uni16_to_x8(outname, (__be16 *) de->name,\n\t\t\t\tde->name_len[0] >> 1, nls);\n\t}\n\tif ((len > 2) && (outname[len-2] == ';') && (outname[len-1] == '1'))\n\t\tlen -= 2;\n\n\t/*\n\t * Windows doesn't like periods at the end of a name,\n\t * so neither do we\n\t */\n\twhile (len >= 2 && (outname[len-1] == '.'))\n\t\tlen--;\n\n\treturn len;\n}",
          "includes": [
            "#include \"isofs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isofs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint\nget_joliet_filename(struct iso_directory_record * de, unsigned char *outname, struct inode * inode)\n{\n\tunsigned char utf8;\n\tstruct nls_table *nls;\n\tunsigned char len = 0;\n\n\tutf8 = ISOFS_SB(inode->i_sb)->s_utf8;\n\tnls = ISOFS_SB(inode->i_sb)->s_nls_iocharset;\n\n\tif (utf8) {\n\t\tlen = utf16s_to_utf8s((const wchar_t *) de->name,\n\t\t\t\tde->name_len[0] >> 1, UTF16_BIG_ENDIAN,\n\t\t\t\toutname, PAGE_SIZE);\n\t} else {\n\t\tlen = uni16_to_x8(outname, (__be16 *) de->name,\n\t\t\t\tde->name_len[0] >> 1, nls);\n\t}\n\tif ((len > 2) && (outname[len-2] == ';') && (outname[len-1] == '1'))\n\t\tlen -= 2;\n\n\t/*\n\t * Windows doesn't like periods at the end of a name,\n\t * so neither do we\n\t */\n\twhile (len >= 2 && (outname[len-1] == '.'))\n\t\tlen--;\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rock_ridge_filename",
          "args": [
            "de",
            "tmpname",
            "inode"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "get_rock_ridge_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "197-295",
          "snippet": "int get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n\tint retnamlen = 0;\n\tint truncate = 0;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n\t\t\t\t\trr->u.NM.flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n\t\t\t\ttruncate = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n\t\t\tretnamlen += rr->len - 5;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nint get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n\tint retnamlen = 0;\n\tint truncate = 0;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n\t\t\t\t\trr->u.NM.flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n\t\t\t\ttruncate = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n\t\t\tretnamlen += rr->len - 5;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dotdot",
          "args": [
            "file",
            "ctx"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dot",
          "args": [
            "file",
            "ctx"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isofs_get_ino",
          "args": [
            "block_saved",
            "offset_saved",
            "bufbits"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "isofs_get_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "144-149",
          "snippet": "static inline unsigned long isofs_get_ino(unsigned long block,\n\t\t\t\t\t  unsigned long offset,\n\t\t\t\t\t  unsigned long bufbits)\n{\n\treturn (block << (bufbits - 5)) | (offset >> 5);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long isofs_get_ino(unsigned long block,\n\t\t\t\t\t  unsigned long offset,\n\t\t\t\t\t  unsigned long bufbits)\n{\n\treturn (block << (bufbits - 5)) | (offset >> 5);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isofs_normalize_block_and_offset",
          "args": [
            "de",
            "&block_saved",
            "&offset_saved"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "isofs_normalize_block_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "182-193",
          "snippet": "static inline void\nisofs_normalize_block_and_offset(struct iso_directory_record* de,\n\t\t\t\t unsigned long *block,\n\t\t\t\t unsigned long *offset)\n{\n\t/* Only directories are normalized. */\n\tif (de->flags[0] & 2) {\n\t\t*offset = 0;\n\t\t*block = (unsigned long)isonum_733(de->extent)\n\t\t\t+ (unsigned long)isonum_711(de->ext_attr_length);\n\t}\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct dentry *isofs_lookup(struct inode *, struct dentry *, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nextern struct dentry *isofs_lookup(struct inode *, struct dentry *, unsigned int flags);\n\nstatic inline void\nisofs_normalize_block_and_offset(struct iso_directory_record* de,\n\t\t\t\t unsigned long *block,\n\t\t\t\t unsigned long *offset)\n{\n\t/* Only directories are normalized. */\n\tif (de->flags[0] & 2) {\n\t\t*offset = 0;\n\t\t*block = (unsigned long)isonum_733(de->extent)\n\t\t\t+ (unsigned long)isonum_711(de->ext_attr_length);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"iso9660: Corrupted directory entry\"\n\t\t\t       \" in block %lu of inode %lu\\n\"",
            "block",
            "inode->i_ino"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *) tmpde + slop",
            "bh->b_data",
            "offset"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isofs_bread",
          "args": [
            "inode",
            "block"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmpde",
            "de",
            "slop"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isofs_bread",
          "args": [
            "inode",
            "block"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "62-65",
          "snippet": "static inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISOFS_BUFFER_BITS",
          "args": [
            "inode"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOFS_BUFFER_SIZE",
          "args": [
            "inode"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nstatic int do_isofs_readdir(struct inode *inode, struct file *file,\n\t\tstruct dir_context *ctx,\n\t\tchar *tmpname, struct iso_directory_record *tmpde)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned char bufbits = ISOFS_BUFFER_BITS(inode);\n\tunsigned long block, offset, block_saved, offset_saved;\n\tunsigned long inode_number = 0;\t/* Quiet GCC */\n\tstruct buffer_head *bh = NULL;\n\tint len;\n\tint map;\n\tint first_de = 1;\n\tchar *p = NULL;\t\t/* Quiet GCC */\n\tstruct iso_directory_record *de;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\n\n\toffset = ctx->pos & (bufsize - 1);\n\tblock = ctx->pos >> bufbits;\n\n\twhile (ctx->pos < inode->i_size) {\n\t\tint de_len;\n\n\t\tif (!bh) {\n\t\t\tbh = isofs_bread(inode, block);\n\t\t\tif (!bh)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\n\t\tde_len = *(unsigned char *)de;\n\n\t\t/*\n\t\t * If the length byte is zero, we should move on to the next\n\t\t * CDROM sector.  If we are at the end of the directory, we\n\t\t * kick out of the while loop.\n\t\t */\n\n\t\tif (de_len == 0) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tctx->pos = (ctx->pos + ISOFS_BLOCK_SIZE) & ~(ISOFS_BLOCK_SIZE - 1);\n\t\t\tblock = ctx->pos >> bufbits;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = block;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = isofs_bread(inode, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy((void *) tmpde + slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\t\t/* Basic sanity check, whether name doesn't exceed dir entry */\n\t\tif (de_len < de->name_len[0] +\n\t\t\t\t\tsizeof(struct iso_directory_record)) {\n\t\t\tprintk(KERN_NOTICE \"iso9660: Corrupted directory entry\"\n\t\t\t       \" in block %lu of inode %lu\\n\", block,\n\t\t\t       inode->i_ino);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (first_de) {\n\t\t\tisofs_normalize_block_and_offset(de,\n\t\t\t\t\t\t\t&block_saved,\n\t\t\t\t\t\t\t&offset_saved);\n\t\t\tinode_number = isofs_get_ino(block_saved,\n\t\t\t\t\t\t\toffset_saved, bufbits);\n\t\t}\n\n\t\tif (de->flags[-sbi->s_high_sierra] & 0x80) {\n\t\t\tfirst_de = 0;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst_de = 1;\n\n\t\t/* Handle the case of the '.' directory */\n\t\tif (de->name_len[0] == 1 && de->name[0] == 0) {\n\t\t\tif (!dir_emit_dot(file, ctx))\n\t\t\t\tbreak;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = 0;\n\n\t\t/* Handle the case of the '..' directory */\n\t\tif (de->name_len[0] == 1 && de->name[0] == 1) {\n\t\t\tif (!dir_emit_dotdot(file, ctx))\n\t\t\t\tbreak;\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Handle everything else.  Do name translation if there\n\t\t   is no Rock Ridge NM field. */\n\n\t\t/*\n\t\t * Do not report hidden files if so instructed, or associated\n\t\t * files unless instructed to do so\n\t\t */\n\t\tif ((sbi->s_hide && (de->flags[-sbi->s_high_sierra] & 1)) ||\n\t\t    (!sbi->s_showassoc &&\n\t\t\t\t(de->flags[-sbi->s_high_sierra] & 4))) {\n\t\t\tctx->pos += de_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmap = 1;\n\t\tif (sbi->s_rock) {\n\t\t\tlen = get_rock_ridge_filename(de, tmpname, inode);\n\t\t\tif (len != 0) {\t\t/* may be -1 */\n\t\t\t\tp = tmpname;\n\t\t\t\tmap = 0;\n\t\t\t}\n\t\t}\n\t\tif (map) {\n#ifdef CONFIG_JOLIET\n\t\t\tif (sbi->s_joliet_level) {\n\t\t\t\tlen = get_joliet_filename(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else\n#endif\n\t\t\tif (sbi->s_mapping == 'a') {\n\t\t\t\tlen = get_acorn_filename(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else\n\t\t\tif (sbi->s_mapping == 'n') {\n\t\t\t\tlen = isofs_name_translate(de, tmpname, inode);\n\t\t\t\tp = tmpname;\n\t\t\t} else {\n\t\t\t\tp = de->name;\n\t\t\t\tlen = de->name_len[0];\n\t\t\t}\n\t\t}\n\t\tif (len > 0) {\n\t\t\tif (!dir_emit(ctx, p, len, inode_number, DT_UNKNOWN))\n\t\t\t\tbreak;\n\t\t}\n\t\tctx->pos += de_len;\n\n\t\tcontinue;\n\t}\n\tif (bh)\n\t\tbrelse(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "get_acorn_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/dir.c",
    "lines": "49-76",
    "snippet": "int get_acorn_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tint std;\n\tunsigned char *chr;\n\tint retnamlen = isofs_name_translate(de, retname, inode);\n\n\tif (retnamlen == 0)\n\t\treturn 0;\n\tstd = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (std & 1)\n\t\tstd++;\n\tif ((*((unsigned char *) de) - std) != 32)\n\t\treturn retnamlen;\n\tchr = ((unsigned char *) de) + std;\n\tif (strncmp(chr, \"ARCHIMEDES\", 10))\n\t\treturn retnamlen;\n\tif ((*retname == '_') && ((chr[19] & 1) == 1))\n\t\t*retname = '!';\n\tif (((de->flags[0] & 2) == 0) && (chr[13] == 0xff)\n\t\t&& ((chr[12] & 0xf0) == 0xf0)) {\n\t\tretname[retnamlen] = ',';\n\t\tsprintf(retname+retnamlen+1, \"%3.3x\",\n\t\t\t((chr[12] & 0xf) << 8) | chr[11]);\n\t\tretnamlen += 4;\n\t}\n\treturn retnamlen;\n}",
    "includes": [
      "#include \"isofs.h\"",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "retname+retnamlen+1",
            "\"%3.3x\"",
            "((chr[12] & 0xf) << 8) | chr[11]"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "chr",
            "\"ARCHIMEDES\"",
            "10"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isofs_name_translate",
          "args": [
            "de",
            "retname",
            "inode"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "isofs_name_translate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/dir.c",
          "lines": "16-46",
          "snippet": "int isofs_name_translate(struct iso_directory_record *de, char *new, struct inode *inode)\n{\n\tchar * old = de->name;\n\tint len = de->name_len[0];\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char c = old[i];\n\t\tif (!c)\n\t\t\tbreak;\n\n\t\tif (c >= 'A' && c <= 'Z')\n\t\t\tc |= 0x20;\t/* lower case */\n\n\t\t/* Drop trailing '.;1' (ISO 9660:1988 7.5.1 requires period) */\n\t\tif (c == '.' && i == len - 3 && old[i + 1] == ';' && old[i + 2] == '1')\n\t\t\tbreak;\n\n\t\t/* Drop trailing ';1' */\n\t\tif (c == ';' && i == len - 2 && old[i + 1] == '1')\n\t\t\tbreak;\n\n\t\t/* Convert remaining ';' to '.' */\n\t\t/* Also '/' to '.' (broken Acorn-generated ISO9660 images) */\n\t\tif (c == ';' || c == '/')\n\t\t\tc = '.';\n\n\t\tnew[i] = c;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"isofs.h\"",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nint isofs_name_translate(struct iso_directory_record *de, char *new, struct inode *inode)\n{\n\tchar * old = de->name;\n\tint len = de->name_len[0];\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char c = old[i];\n\t\tif (!c)\n\t\t\tbreak;\n\n\t\tif (c >= 'A' && c <= 'Z')\n\t\t\tc |= 0x20;\t/* lower case */\n\n\t\t/* Drop trailing '.;1' (ISO 9660:1988 7.5.1 requires period) */\n\t\tif (c == '.' && i == len - 3 && old[i + 1] == ';' && old[i + 2] == '1')\n\t\t\tbreak;\n\n\t\t/* Drop trailing ';1' */\n\t\tif (c == ';' && i == len - 2 && old[i + 1] == '1')\n\t\t\tbreak;\n\n\t\t/* Convert remaining ';' to '.' */\n\t\t/* Also '/' to '.' (broken Acorn-generated ISO9660 images) */\n\t\tif (c == ';' || c == '/')\n\t\t\tc = '.';\n\n\t\tnew[i] = c;\n\t}\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nint get_acorn_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tint std;\n\tunsigned char *chr;\n\tint retnamlen = isofs_name_translate(de, retname, inode);\n\n\tif (retnamlen == 0)\n\t\treturn 0;\n\tstd = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (std & 1)\n\t\tstd++;\n\tif ((*((unsigned char *) de) - std) != 32)\n\t\treturn retnamlen;\n\tchr = ((unsigned char *) de) + std;\n\tif (strncmp(chr, \"ARCHIMEDES\", 10))\n\t\treturn retnamlen;\n\tif ((*retname == '_') && ((chr[19] & 1) == 1))\n\t\t*retname = '!';\n\tif (((de->flags[0] & 2) == 0) && (chr[13] == 0xff)\n\t\t&& ((chr[12] & 0xf0) == 0xf0)) {\n\t\tretname[retnamlen] = ',';\n\t\tsprintf(retname+retnamlen+1, \"%3.3x\",\n\t\t\t((chr[12] & 0xf) << 8) | chr[11]);\n\t\tretnamlen += 4;\n\t}\n\treturn retnamlen;\n}"
  },
  {
    "function_name": "isofs_name_translate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/dir.c",
    "lines": "16-46",
    "snippet": "int isofs_name_translate(struct iso_directory_record *de, char *new, struct inode *inode)\n{\n\tchar * old = de->name;\n\tint len = de->name_len[0];\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char c = old[i];\n\t\tif (!c)\n\t\t\tbreak;\n\n\t\tif (c >= 'A' && c <= 'Z')\n\t\t\tc |= 0x20;\t/* lower case */\n\n\t\t/* Drop trailing '.;1' (ISO 9660:1988 7.5.1 requires period) */\n\t\tif (c == '.' && i == len - 3 && old[i + 1] == ';' && old[i + 2] == '1')\n\t\t\tbreak;\n\n\t\t/* Drop trailing ';1' */\n\t\tif (c == ';' && i == len - 2 && old[i + 1] == '1')\n\t\t\tbreak;\n\n\t\t/* Convert remaining ';' to '.' */\n\t\t/* Also '/' to '.' (broken Acorn-generated ISO9660 images) */\n\t\tif (c == ';' || c == '/')\n\t\t\tc = '.';\n\n\t\tnew[i] = c;\n\t}\n\treturn i;\n}",
    "includes": [
      "#include \"isofs.h\"",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nint isofs_name_translate(struct iso_directory_record *de, char *new, struct inode *inode)\n{\n\tchar * old = de->name;\n\tint len = de->name_len[0];\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char c = old[i];\n\t\tif (!c)\n\t\t\tbreak;\n\n\t\tif (c >= 'A' && c <= 'Z')\n\t\t\tc |= 0x20;\t/* lower case */\n\n\t\t/* Drop trailing '.;1' (ISO 9660:1988 7.5.1 requires period) */\n\t\tif (c == '.' && i == len - 3 && old[i + 1] == ';' && old[i + 2] == '1')\n\t\t\tbreak;\n\n\t\t/* Drop trailing ';1' */\n\t\tif (c == ';' && i == len - 2 && old[i + 1] == '1')\n\t\t\tbreak;\n\n\t\t/* Convert remaining ';' to '.' */\n\t\t/* Also '/' to '.' (broken Acorn-generated ISO9660 images) */\n\t\tif (c == ';' || c == '/')\n\t\t\tc = '.';\n\n\t\tnew[i] = c;\n\t}\n\treturn i;\n}"
  }
]