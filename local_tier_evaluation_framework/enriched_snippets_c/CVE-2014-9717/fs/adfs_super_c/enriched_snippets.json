[
  {
    "function_name": "exit_adfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "544-548",
    "snippet": "static void __exit exit_adfs_fs(void)\n{\n\tunregister_filesystem(&adfs_fs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type adfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"adfs\",\n\t.mount\t\t= adfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "281-289",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(adfs_inode_cachep);\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *adfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *adfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(adfs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&adfs_fs_type"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct file_system_type adfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"adfs\",\n\t.mount\t\t= adfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_adfs_fs(void)\n{\n\tunregister_filesystem(&adfs_fs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_adfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "529-542",
    "snippet": "static int __init init_adfs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&adfs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type adfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"adfs\",\n\t.mount\t\t= adfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "281-289",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(adfs_inode_cachep);\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *adfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *adfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(adfs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&adfs_fs_type"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "269-279",
          "snippet": "static int __init init_inodecache(void)\n{\n\tadfs_inode_cachep = kmem_cache_create(\"adfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct adfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (adfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *adfs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *adfs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tadfs_inode_cachep = kmem_cache_create(\"adfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct adfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (adfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct file_system_type adfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"adfs\",\n\t.mount\t\t= adfs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_adfs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&adfs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}"
  },
  {
    "function_name": "adfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "514-518",
    "snippet": "static struct dentry *adfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, adfs_fill_super);\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "adfs_fill_super"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct dentry *adfs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, adfs_fill_super);\n}"
  },
  {
    "function_name": "adfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "365-512",
    "snippet": "static int adfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct adfs_discrecord *dr;\n\tstruct buffer_head *bh;\n\tstruct object_info root_obj;\n\tunsigned char *b_data;\n\tstruct adfs_sb_info *asb;\n\tstruct inode *root;\n\n\tsb->s_flags |= MS_NODIRATIME;\n\n\tasb = kzalloc(sizeof(*asb), GFP_KERNEL);\n\tif (!asb)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = asb;\n\n\t/* set default options */\n\tasb->s_uid = GLOBAL_ROOT_UID;\n\tasb->s_gid = GLOBAL_ROOT_GID;\n\tasb->s_owner_mask = ADFS_DEFAULT_OWNER_MASK;\n\tasb->s_other_mask = ADFS_DEFAULT_OTHER_MASK;\n\tasb->s_ftsuffix = 0;\n\n\tif (parse_options(sb, data))\n\t\tgoto error;\n\n\tsb_set_blocksize(sb, BLOCK_SIZE);\n\tif (!(bh = sb_bread(sb, ADFS_DISCRECORD / BLOCK_SIZE))) {\n\t\tadfs_error(sb, \"unable to read superblock\");\n\t\tgoto error;\n\t}\n\n\tb_data = bh->b_data + (ADFS_DISCRECORD % BLOCK_SIZE);\n\n\tif (adfs_checkbblk(b_data)) {\n\t\tif (!silent)\n\t\t\tprintk(\"VFS: Can't find an adfs filesystem on dev \"\n\t\t\t\t\"%s.\\n\", sb->s_id);\n\t\tgoto error_free_bh;\n\t}\n\n\tdr = (struct adfs_discrecord *)(b_data + ADFS_DR_OFFSET);\n\n\t/*\n\t * Do some sanity checks on the ADFS disc record\n\t */\n\tif (adfs_checkdiscrecord(dr)) {\n\t\tif (!silent)\n\t\t\tprintk(\"VPS: Can't find an adfs filesystem on dev \"\n\t\t\t\t\"%s.\\n\", sb->s_id);\n\t\tgoto error_free_bh;\n\t}\n\n\tbrelse(bh);\n\tif (sb_set_blocksize(sb, 1 << dr->log2secsize)) {\n\t\tbh = sb_bread(sb, ADFS_DISCRECORD / sb->s_blocksize);\n\t\tif (!bh) {\n\t\t\tadfs_error(sb, \"couldn't read superblock on \"\n\t\t\t\t\"2nd try.\");\n\t\t\tgoto error;\n\t\t}\n\t\tb_data = bh->b_data + (ADFS_DISCRECORD % sb->s_blocksize);\n\t\tif (adfs_checkbblk(b_data)) {\n\t\t\tadfs_error(sb, \"disc record mismatch, very weird!\");\n\t\t\tgoto error_free_bh;\n\t\t}\n\t\tdr = (struct adfs_discrecord *)(b_data + ADFS_DR_OFFSET);\n\t} else {\n\t\tif (!silent)\n\t\t\tprintk(KERN_ERR \"VFS: Unsupported blocksize on dev \"\n\t\t\t\t\"%s.\\n\", sb->s_id);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * blocksize on this device should now be set to the ADFS log2secsize\n\t */\n\n\tsb->s_magic\t\t= ADFS_SUPER_MAGIC;\n\tasb->s_idlen\t\t= dr->idlen;\n\tasb->s_map_size\t\t= dr->nzones | (dr->nzones_high << 8);\n\tasb->s_map2blk\t\t= dr->log2bpmb - dr->log2secsize;\n\tasb->s_size    \t\t= adfs_discsize(dr, sb->s_blocksize_bits);\n\tasb->s_version \t\t= dr->format_version;\n\tasb->s_log2sharesize\t= dr->log2sharesize;\n\t\n\tasb->s_map = adfs_read_map(sb, dr);\n\tif (!asb->s_map)\n\t\tgoto error_free_bh;\n\n\tbrelse(bh);\n\n\t/*\n\t * set up enough so that we can read an inode\n\t */\n\tsb->s_op = &adfs_sops;\n\n\tdr = (struct adfs_discrecord *)(asb->s_map[0].dm_bh->b_data + 4);\n\n\troot_obj.parent_id = root_obj.file_id = le32_to_cpu(dr->root);\n\troot_obj.name_len  = 0;\n\t/* Set root object date as 01 Jan 1987 00:00:00 */\n\troot_obj.loadaddr  = 0xfff0003f;\n\troot_obj.execaddr  = 0xec22c000;\n\troot_obj.size\t   = ADFS_NEWDIR_SIZE;\n\troot_obj.attr\t   = ADFS_NDA_DIRECTORY   | ADFS_NDA_OWNER_READ |\n\t\t\t     ADFS_NDA_OWNER_WRITE | ADFS_NDA_PUBLIC_READ;\n\troot_obj.filetype  = -1;\n\n\t/*\n\t * If this is a F+ disk with variable length directories,\n\t * get the root_size from the disc record.\n\t */\n\tif (asb->s_version) {\n\t\troot_obj.size = le32_to_cpu(dr->root_size);\n\t\tasb->s_dir     = &adfs_fplus_dir_ops;\n\t\tasb->s_namelen = ADFS_FPLUS_NAME_LEN;\n\t} else {\n\t\tasb->s_dir     = &adfs_f_dir_ops;\n\t\tasb->s_namelen = ADFS_F_NAME_LEN;\n\t}\n\t/*\n\t * ,xyz hex filetype suffix may be added by driver\n\t * to files that have valid RISC OS filetype\n\t */\n\tif (asb->s_ftsuffix)\n\t\tasb->s_namelen += 4;\n\n\tsb->s_d_op = &adfs_dentry_operations;\n\troot = adfs_iget(sb, &root_obj);\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\tint i;\n\t\tfor (i = 0; i < asb->s_map_size; i++)\n\t\t\tbrelse(asb->s_map[i].dm_bh);\n\t\tkfree(asb->s_map);\n\t\tadfs_error(sb, \"get root inode failed\\n\");\n\t\tgoto error;\n\t}\n\treturn 0;\n\nerror_free_bh:\n\tbrelse(bh);\nerror:\n\tsb->s_fs_info = NULL;\n\tkfree(asb);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ADFS_DEFAULT_OTHER_MASK (S_IRWXG | S_IRWXO)",
      "#define ADFS_DEFAULT_OWNER_MASK S_IRWXU"
    ],
    "globals_used": [
      "static const struct super_operations adfs_sops = {\n\t.alloc_inode\t= adfs_alloc_inode,\n\t.destroy_inode\t= adfs_destroy_inode,\n\t.write_inode\t= adfs_write_inode,\n\t.put_super\t= adfs_put_super,\n\t.statfs\t\t= adfs_statfs,\n\t.remount_fs\t= adfs_remount,\n\t.show_options\t= adfs_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "asb"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "sb",
            "\"get root inode failed\\n\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "asb->s_map"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_iget",
          "args": [
            "sb",
            "&root_obj"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/inode.c",
          "lines": "242-291",
          "snippet": "struct inode *\nadfs_iget(struct super_block *sb, struct object_info *obj)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_uid\t = ADFS_SB(sb)->s_uid;\n\tinode->i_gid\t = ADFS_SB(sb)->s_gid;\n\tinode->i_ino\t = obj->file_id;\n\tinode->i_size\t = obj->size;\n\tset_nlink(inode, 2);\n\tinode->i_blocks\t = (inode->i_size + sb->s_blocksize - 1) >>\n\t\t\t    sb->s_blocksize_bits;\n\n\t/*\n\t * we need to save the parent directory ID so that\n\t * write_inode can update the directory information\n\t * for this file.  This will need special handling\n\t * for cross-directory renames.\n\t */\n\tADFS_I(inode)->parent_id = obj->parent_id;\n\tADFS_I(inode)->loadaddr  = obj->loadaddr;\n\tADFS_I(inode)->execaddr  = obj->execaddr;\n\tADFS_I(inode)->attr      = obj->attr;\n\tADFS_I(inode)->filetype  = obj->filetype;\n\tADFS_I(inode)->stamped   = ((obj->loadaddr & 0xfff00000) == 0xfff00000);\n\n\tinode->i_mode\t = adfs_atts2mode(sb, inode);\n\tadfs_adfs2unix_time(&inode->i_mtime, inode);\n\tinode->i_atime = inode->i_mtime;\n\tinode->i_ctime = inode->i_mtime;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op\t= &adfs_dir_inode_operations;\n\t\tinode->i_fop\t= &adfs_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op\t= &adfs_file_inode_operations;\n\t\tinode->i_fop\t= &adfs_file_operations;\n\t\tinode->i_mapping->a_ops = &adfs_aops;\n\t\tADFS_I(inode)->mmu_private = inode->i_size;\n\t}\n\n\tinsert_inode_hash(inode);\n\nout:\n\treturn inode;\n}",
          "includes": [
            "#include \"adfs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations adfs_aops = {\n\t.readpage\t= adfs_readpage,\n\t.writepage\t= adfs_writepage,\n\t.write_begin\t= adfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= _adfs_bmap\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"adfs.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic const struct address_space_operations adfs_aops = {\n\t.readpage\t= adfs_readpage,\n\t.writepage\t= adfs_writepage,\n\t.write_begin\t= adfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= _adfs_bmap\n};\n\nstruct inode *\nadfs_iget(struct super_block *sb, struct object_info *obj)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_uid\t = ADFS_SB(sb)->s_uid;\n\tinode->i_gid\t = ADFS_SB(sb)->s_gid;\n\tinode->i_ino\t = obj->file_id;\n\tinode->i_size\t = obj->size;\n\tset_nlink(inode, 2);\n\tinode->i_blocks\t = (inode->i_size + sb->s_blocksize - 1) >>\n\t\t\t    sb->s_blocksize_bits;\n\n\t/*\n\t * we need to save the parent directory ID so that\n\t * write_inode can update the directory information\n\t * for this file.  This will need special handling\n\t * for cross-directory renames.\n\t */\n\tADFS_I(inode)->parent_id = obj->parent_id;\n\tADFS_I(inode)->loadaddr  = obj->loadaddr;\n\tADFS_I(inode)->execaddr  = obj->execaddr;\n\tADFS_I(inode)->attr      = obj->attr;\n\tADFS_I(inode)->filetype  = obj->filetype;\n\tADFS_I(inode)->stamped   = ((obj->loadaddr & 0xfff00000) == 0xfff00000);\n\n\tinode->i_mode\t = adfs_atts2mode(sb, inode);\n\tadfs_adfs2unix_time(&inode->i_mtime, inode);\n\tinode->i_atime = inode->i_mtime;\n\tinode->i_ctime = inode->i_mtime;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op\t= &adfs_dir_inode_operations;\n\t\tinode->i_fop\t= &adfs_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op\t= &adfs_file_inode_operations;\n\t\tinode->i_fop\t= &adfs_file_operations;\n\t\tinode->i_mapping->a_ops = &adfs_aops;\n\t\tADFS_I(inode)->mmu_private = inode->i_size;\n\t}\n\n\tinsert_inode_hash(inode);\n\nout:\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dr->root_size"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_read_map",
          "args": [
            "sb",
            "dr"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_read_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "301-353",
          "snippet": "static struct adfs_discmap *adfs_read_map(struct super_block *sb, struct adfs_discrecord *dr)\n{\n\tstruct adfs_discmap *dm;\n\tunsigned int map_addr, zone_size, nzones;\n\tint i, zone;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tnzones    = asb->s_map_size;\n\tzone_size = (8 << dr->log2secsize) - le16_to_cpu(dr->zone_spare);\n\tmap_addr  = (nzones >> 1) * zone_size -\n\t\t     ((nzones > 1) ? ADFS_DR_SIZE_BITS : 0);\n\tmap_addr  = signed_asl(map_addr, asb->s_map2blk);\n\n\tasb->s_ids_per_zone = zone_size / (asb->s_idlen + 1);\n\n\tdm = kmalloc(nzones * sizeof(*dm), GFP_KERNEL);\n\tif (dm == NULL) {\n\t\tadfs_error(sb, \"not enough memory\");\n\t\treturn NULL;\n\t}\n\n\tfor (zone = 0; zone < nzones; zone++, map_addr++) {\n\t\tdm[zone].dm_startbit = 0;\n\t\tdm[zone].dm_endbit   = zone_size;\n\t\tdm[zone].dm_startblk = zone * zone_size - ADFS_DR_SIZE_BITS;\n\t\tdm[zone].dm_bh       = sb_bread(sb, map_addr);\n\n\t\tif (!dm[zone].dm_bh) {\n\t\t\tadfs_error(sb, \"unable to read map\");\n\t\t\tgoto error_free;\n\t\t}\n\t}\n\n\t/* adjust the limits for the first and last map zones */\n\ti = zone - 1;\n\tdm[0].dm_startblk = 0;\n\tdm[0].dm_startbit = ADFS_DR_SIZE_BITS;\n\tdm[i].dm_endbit   = (le32_to_cpu(dr->disc_size_high) << (32 - dr->log2bpmb)) +\n\t\t\t    (le32_to_cpu(dr->disc_size) >> dr->log2bpmb) +\n\t\t\t    (ADFS_DR_SIZE_BITS - i * zone_size);\n\n\tif (adfs_checkmap(sb, dm))\n\t\treturn dm;\n\n\tadfs_error(sb, \"map corrupted\");\n\nerror_free:\n\twhile (--zone >= 0)\n\t\tbrelse(dm[zone].dm_bh);\n\n\tkfree(dm);\n\treturn NULL;\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct adfs_discmap *adfs_read_map(struct super_block *sb, struct adfs_discrecord *dr)\n{\n\tstruct adfs_discmap *dm;\n\tunsigned int map_addr, zone_size, nzones;\n\tint i, zone;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tnzones    = asb->s_map_size;\n\tzone_size = (8 << dr->log2secsize) - le16_to_cpu(dr->zone_spare);\n\tmap_addr  = (nzones >> 1) * zone_size -\n\t\t     ((nzones > 1) ? ADFS_DR_SIZE_BITS : 0);\n\tmap_addr  = signed_asl(map_addr, asb->s_map2blk);\n\n\tasb->s_ids_per_zone = zone_size / (asb->s_idlen + 1);\n\n\tdm = kmalloc(nzones * sizeof(*dm), GFP_KERNEL);\n\tif (dm == NULL) {\n\t\tadfs_error(sb, \"not enough memory\");\n\t\treturn NULL;\n\t}\n\n\tfor (zone = 0; zone < nzones; zone++, map_addr++) {\n\t\tdm[zone].dm_startbit = 0;\n\t\tdm[zone].dm_endbit   = zone_size;\n\t\tdm[zone].dm_startblk = zone * zone_size - ADFS_DR_SIZE_BITS;\n\t\tdm[zone].dm_bh       = sb_bread(sb, map_addr);\n\n\t\tif (!dm[zone].dm_bh) {\n\t\t\tadfs_error(sb, \"unable to read map\");\n\t\t\tgoto error_free;\n\t\t}\n\t}\n\n\t/* adjust the limits for the first and last map zones */\n\ti = zone - 1;\n\tdm[0].dm_startblk = 0;\n\tdm[0].dm_startbit = ADFS_DR_SIZE_BITS;\n\tdm[i].dm_endbit   = (le32_to_cpu(dr->disc_size_high) << (32 - dr->log2bpmb)) +\n\t\t\t    (le32_to_cpu(dr->disc_size) >> dr->log2bpmb) +\n\t\t\t    (ADFS_DR_SIZE_BITS - i * zone_size);\n\n\tif (adfs_checkmap(sb, dm))\n\t\treturn dm;\n\n\tadfs_error(sb, \"map corrupted\");\n\nerror_free:\n\twhile (--zone >= 0)\n\t\tbrelse(dm[zone].dm_bh);\n\n\tkfree(dm);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_discsize",
          "args": [
            "dr",
            "sb->s_blocksize_bits"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_discsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "355-363",
          "snippet": "static inline unsigned long adfs_discsize(struct adfs_discrecord *dr, int block_bits)\n{\n\tunsigned long discsize;\n\n\tdiscsize  = le32_to_cpu(dr->disc_size_high) << (32 - block_bits);\n\tdiscsize |= le32_to_cpu(dr->disc_size) >> block_bits;\n\n\treturn discsize;\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline unsigned long adfs_discsize(struct adfs_discrecord *dr, int block_bits)\n{\n\tunsigned long discsize;\n\n\tdiscsize  = le32_to_cpu(dr->disc_size_high) << (32 - block_bits);\n\tdiscsize |= le32_to_cpu(dr->disc_size) >> block_bits;\n\n\treturn discsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"VFS: Unsupported blocksize on dev \"\n\t\t\t\t\"%s.\\n\"",
            "sb->s_id"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "sb",
            "\"disc record mismatch, very weird!\""
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_checkbblk",
          "args": [
            "b_data"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "sb",
            "\"couldn't read superblock on \"\n\t\t\t\t\"2nd try.\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "ADFS_DISCRECORD / sb->s_blocksize"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "1 << dr->log2secsize"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_checkdiscrecord",
          "args": [
            "dr"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_checkdiscrecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "40-71",
          "snippet": "static int adfs_checkdiscrecord(struct adfs_discrecord *dr)\n{\n\tint i;\n\n\t/* sector size must be 256, 512 or 1024 bytes */\n\tif (dr->log2secsize != 8 &&\n\t    dr->log2secsize != 9 &&\n\t    dr->log2secsize != 10)\n\t\treturn 1;\n\n\t/* idlen must be at least log2secsize + 3 */\n\tif (dr->idlen < dr->log2secsize + 3)\n\t\treturn 1;\n\n\t/* we cannot have such a large disc that we\n\t * are unable to represent sector offsets in\n\t * 32 bits.  This works out at 2.0 TB.\n\t */\n\tif (le32_to_cpu(dr->disc_size_high) >> dr->log2secsize)\n\t\treturn 1;\n\n\t/* idlen must be no greater than 19 v2 [1.0] */\n\tif (dr->idlen > 19)\n\t\treturn 1;\n\n\t/* reserved bytes should be zero */\n\tfor (i = 0; i < sizeof(dr->unused52); i++)\n\t\tif (dr->unused52[i] != 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int adfs_checkdiscrecord(struct adfs_discrecord *dr)\n{\n\tint i;\n\n\t/* sector size must be 256, 512 or 1024 bytes */\n\tif (dr->log2secsize != 8 &&\n\t    dr->log2secsize != 9 &&\n\t    dr->log2secsize != 10)\n\t\treturn 1;\n\n\t/* idlen must be at least log2secsize + 3 */\n\tif (dr->idlen < dr->log2secsize + 3)\n\t\treturn 1;\n\n\t/* we cannot have such a large disc that we\n\t * are unable to represent sector offsets in\n\t * 32 bits.  This works out at 2.0 TB.\n\t */\n\tif (le32_to_cpu(dr->disc_size_high) >> dr->log2secsize)\n\t\treturn 1;\n\n\t/* idlen must be no greater than 19 v2 [1.0] */\n\tif (dr->idlen > 19)\n\t\treturn 1;\n\n\t/* reserved bytes should be zero */\n\tfor (i = 0; i < sizeof(dr->unused52); i++)\n\t\tif (dr->unused52[i] != 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_checkbblk",
          "args": [
            "b_data"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "sb",
            "\"unable to read superblock\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "ADFS_DISCRECORD / BLOCK_SIZE"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "sb",
            "data"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "158-211",
          "snippet": "static int parse_options(struct super_block *sb, char *options)\n{\n\tchar *p;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tint option;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(asb->s_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(asb->s_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_ownmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_owner_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_othmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_other_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_ftsuffix:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_ftsuffix = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"ADFS-fs: unrecognised mount option \\\"%s\\\" \"\n\t\t\t\t\t\"or missing value\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_ownmask, \"ownmask=%o\"},\n\t{Opt_othmask, \"othmask=%o\"},\n\t{Opt_ftsuffix, \"ftsuffix=%u\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_ownmask, \"ownmask=%o\"},\n\t{Opt_othmask, \"othmask=%o\"},\n\t{Opt_ftsuffix, \"ftsuffix=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(struct super_block *sb, char *options)\n{\n\tchar *p;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tint option;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(asb->s_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(asb->s_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_ownmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_owner_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_othmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_other_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_ftsuffix:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_ftsuffix = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"ADFS-fs: unrecognised mount option \\\"%s\\\" \"\n\t\t\t\t\t\"or missing value\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*asb)",
            "GFP_KERNEL"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define ADFS_DEFAULT_OTHER_MASK (S_IRWXG | S_IRWXO)\n#define ADFS_DEFAULT_OWNER_MASK S_IRWXU\n\nstatic const struct super_operations adfs_sops = {\n\t.alloc_inode\t= adfs_alloc_inode,\n\t.destroy_inode\t= adfs_destroy_inode,\n\t.write_inode\t= adfs_write_inode,\n\t.put_super\t= adfs_put_super,\n\t.statfs\t\t= adfs_statfs,\n\t.remount_fs\t= adfs_remount,\n\t.show_options\t= adfs_show_options,\n};\n\nstatic int adfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct adfs_discrecord *dr;\n\tstruct buffer_head *bh;\n\tstruct object_info root_obj;\n\tunsigned char *b_data;\n\tstruct adfs_sb_info *asb;\n\tstruct inode *root;\n\n\tsb->s_flags |= MS_NODIRATIME;\n\n\tasb = kzalloc(sizeof(*asb), GFP_KERNEL);\n\tif (!asb)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = asb;\n\n\t/* set default options */\n\tasb->s_uid = GLOBAL_ROOT_UID;\n\tasb->s_gid = GLOBAL_ROOT_GID;\n\tasb->s_owner_mask = ADFS_DEFAULT_OWNER_MASK;\n\tasb->s_other_mask = ADFS_DEFAULT_OTHER_MASK;\n\tasb->s_ftsuffix = 0;\n\n\tif (parse_options(sb, data))\n\t\tgoto error;\n\n\tsb_set_blocksize(sb, BLOCK_SIZE);\n\tif (!(bh = sb_bread(sb, ADFS_DISCRECORD / BLOCK_SIZE))) {\n\t\tadfs_error(sb, \"unable to read superblock\");\n\t\tgoto error;\n\t}\n\n\tb_data = bh->b_data + (ADFS_DISCRECORD % BLOCK_SIZE);\n\n\tif (adfs_checkbblk(b_data)) {\n\t\tif (!silent)\n\t\t\tprintk(\"VFS: Can't find an adfs filesystem on dev \"\n\t\t\t\t\"%s.\\n\", sb->s_id);\n\t\tgoto error_free_bh;\n\t}\n\n\tdr = (struct adfs_discrecord *)(b_data + ADFS_DR_OFFSET);\n\n\t/*\n\t * Do some sanity checks on the ADFS disc record\n\t */\n\tif (adfs_checkdiscrecord(dr)) {\n\t\tif (!silent)\n\t\t\tprintk(\"VPS: Can't find an adfs filesystem on dev \"\n\t\t\t\t\"%s.\\n\", sb->s_id);\n\t\tgoto error_free_bh;\n\t}\n\n\tbrelse(bh);\n\tif (sb_set_blocksize(sb, 1 << dr->log2secsize)) {\n\t\tbh = sb_bread(sb, ADFS_DISCRECORD / sb->s_blocksize);\n\t\tif (!bh) {\n\t\t\tadfs_error(sb, \"couldn't read superblock on \"\n\t\t\t\t\"2nd try.\");\n\t\t\tgoto error;\n\t\t}\n\t\tb_data = bh->b_data + (ADFS_DISCRECORD % sb->s_blocksize);\n\t\tif (adfs_checkbblk(b_data)) {\n\t\t\tadfs_error(sb, \"disc record mismatch, very weird!\");\n\t\t\tgoto error_free_bh;\n\t\t}\n\t\tdr = (struct adfs_discrecord *)(b_data + ADFS_DR_OFFSET);\n\t} else {\n\t\tif (!silent)\n\t\t\tprintk(KERN_ERR \"VFS: Unsupported blocksize on dev \"\n\t\t\t\t\"%s.\\n\", sb->s_id);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * blocksize on this device should now be set to the ADFS log2secsize\n\t */\n\n\tsb->s_magic\t\t= ADFS_SUPER_MAGIC;\n\tasb->s_idlen\t\t= dr->idlen;\n\tasb->s_map_size\t\t= dr->nzones | (dr->nzones_high << 8);\n\tasb->s_map2blk\t\t= dr->log2bpmb - dr->log2secsize;\n\tasb->s_size    \t\t= adfs_discsize(dr, sb->s_blocksize_bits);\n\tasb->s_version \t\t= dr->format_version;\n\tasb->s_log2sharesize\t= dr->log2sharesize;\n\t\n\tasb->s_map = adfs_read_map(sb, dr);\n\tif (!asb->s_map)\n\t\tgoto error_free_bh;\n\n\tbrelse(bh);\n\n\t/*\n\t * set up enough so that we can read an inode\n\t */\n\tsb->s_op = &adfs_sops;\n\n\tdr = (struct adfs_discrecord *)(asb->s_map[0].dm_bh->b_data + 4);\n\n\troot_obj.parent_id = root_obj.file_id = le32_to_cpu(dr->root);\n\troot_obj.name_len  = 0;\n\t/* Set root object date as 01 Jan 1987 00:00:00 */\n\troot_obj.loadaddr  = 0xfff0003f;\n\troot_obj.execaddr  = 0xec22c000;\n\troot_obj.size\t   = ADFS_NEWDIR_SIZE;\n\troot_obj.attr\t   = ADFS_NDA_DIRECTORY   | ADFS_NDA_OWNER_READ |\n\t\t\t     ADFS_NDA_OWNER_WRITE | ADFS_NDA_PUBLIC_READ;\n\troot_obj.filetype  = -1;\n\n\t/*\n\t * If this is a F+ disk with variable length directories,\n\t * get the root_size from the disc record.\n\t */\n\tif (asb->s_version) {\n\t\troot_obj.size = le32_to_cpu(dr->root_size);\n\t\tasb->s_dir     = &adfs_fplus_dir_ops;\n\t\tasb->s_namelen = ADFS_FPLUS_NAME_LEN;\n\t} else {\n\t\tasb->s_dir     = &adfs_f_dir_ops;\n\t\tasb->s_namelen = ADFS_F_NAME_LEN;\n\t}\n\t/*\n\t * ,xyz hex filetype suffix may be added by driver\n\t * to files that have valid RISC OS filetype\n\t */\n\tif (asb->s_ftsuffix)\n\t\tasb->s_namelen += 4;\n\n\tsb->s_d_op = &adfs_dentry_operations;\n\troot = adfs_iget(sb, &root_obj);\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\tint i;\n\t\tfor (i = 0; i < asb->s_map_size; i++)\n\t\t\tbrelse(asb->s_map[i].dm_bh);\n\t\tkfree(asb->s_map);\n\t\tadfs_error(sb, \"get root inode failed\\n\");\n\t\tgoto error;\n\t}\n\treturn 0;\n\nerror_free_bh:\n\tbrelse(bh);\nerror:\n\tsb->s_fs_info = NULL;\n\tkfree(asb);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "adfs_discsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "355-363",
    "snippet": "static inline unsigned long adfs_discsize(struct adfs_discrecord *dr, int block_bits)\n{\n\tunsigned long discsize;\n\n\tdiscsize  = le32_to_cpu(dr->disc_size_high) << (32 - block_bits);\n\tdiscsize |= le32_to_cpu(dr->disc_size) >> block_bits;\n\n\treturn discsize;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dr->disc_size"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline unsigned long adfs_discsize(struct adfs_discrecord *dr, int block_bits)\n{\n\tunsigned long discsize;\n\n\tdiscsize  = le32_to_cpu(dr->disc_size_high) << (32 - block_bits);\n\tdiscsize |= le32_to_cpu(dr->disc_size) >> block_bits;\n\n\treturn discsize;\n}"
  },
  {
    "function_name": "adfs_read_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "301-353",
    "snippet": "static struct adfs_discmap *adfs_read_map(struct super_block *sb, struct adfs_discrecord *dr)\n{\n\tstruct adfs_discmap *dm;\n\tunsigned int map_addr, zone_size, nzones;\n\tint i, zone;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tnzones    = asb->s_map_size;\n\tzone_size = (8 << dr->log2secsize) - le16_to_cpu(dr->zone_spare);\n\tmap_addr  = (nzones >> 1) * zone_size -\n\t\t     ((nzones > 1) ? ADFS_DR_SIZE_BITS : 0);\n\tmap_addr  = signed_asl(map_addr, asb->s_map2blk);\n\n\tasb->s_ids_per_zone = zone_size / (asb->s_idlen + 1);\n\n\tdm = kmalloc(nzones * sizeof(*dm), GFP_KERNEL);\n\tif (dm == NULL) {\n\t\tadfs_error(sb, \"not enough memory\");\n\t\treturn NULL;\n\t}\n\n\tfor (zone = 0; zone < nzones; zone++, map_addr++) {\n\t\tdm[zone].dm_startbit = 0;\n\t\tdm[zone].dm_endbit   = zone_size;\n\t\tdm[zone].dm_startblk = zone * zone_size - ADFS_DR_SIZE_BITS;\n\t\tdm[zone].dm_bh       = sb_bread(sb, map_addr);\n\n\t\tif (!dm[zone].dm_bh) {\n\t\t\tadfs_error(sb, \"unable to read map\");\n\t\t\tgoto error_free;\n\t\t}\n\t}\n\n\t/* adjust the limits for the first and last map zones */\n\ti = zone - 1;\n\tdm[0].dm_startblk = 0;\n\tdm[0].dm_startbit = ADFS_DR_SIZE_BITS;\n\tdm[i].dm_endbit   = (le32_to_cpu(dr->disc_size_high) << (32 - dr->log2bpmb)) +\n\t\t\t    (le32_to_cpu(dr->disc_size) >> dr->log2bpmb) +\n\t\t\t    (ADFS_DR_SIZE_BITS - i * zone_size);\n\n\tif (adfs_checkmap(sb, dm))\n\t\treturn dm;\n\n\tadfs_error(sb, \"map corrupted\");\n\nerror_free:\n\twhile (--zone >= 0)\n\t\tbrelse(dm[zone].dm_bh);\n\n\tkfree(dm);\n\treturn NULL;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dm"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dm[zone].dm_bh"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "sb",
            "\"map corrupted\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_checkmap",
          "args": [
            "sb",
            "dm"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_checkmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "97-116",
          "snippet": "static int adfs_checkmap(struct super_block *sb, struct adfs_discmap *dm)\n{\n\tunsigned char crosscheck = 0, zonecheck = 1;\n\tint i;\n\n\tfor (i = 0; i < ADFS_SB(sb)->s_map_size; i++) {\n\t\tunsigned char *map;\n\n\t\tmap = dm[i].dm_bh->b_data;\n\n\t\tif (adfs_calczonecheck(sb, map) != map[0]) {\n\t\t\tadfs_error(sb, \"zone %d fails zonecheck\", i);\n\t\t\tzonecheck = 0;\n\t\t}\n\t\tcrosscheck ^= map[3];\n\t}\n\tif (crosscheck != 0xff)\n\t\tadfs_error(sb, \"crosscheck != 0xff\");\n\treturn crosscheck == 0xff && zonecheck;\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int adfs_checkmap(struct super_block *sb, struct adfs_discmap *dm)\n{\n\tunsigned char crosscheck = 0, zonecheck = 1;\n\tint i;\n\n\tfor (i = 0; i < ADFS_SB(sb)->s_map_size; i++) {\n\t\tunsigned char *map;\n\n\t\tmap = dm[i].dm_bh->b_data;\n\n\t\tif (adfs_calczonecheck(sb, map) != map[0]) {\n\t\t\tadfs_error(sb, \"zone %d fails zonecheck\", i);\n\t\t\tzonecheck = 0;\n\t\t}\n\t\tcrosscheck ^= map[3];\n\t}\n\tif (crosscheck != 0xff)\n\t\tadfs_error(sb, \"crosscheck != 0xff\");\n\treturn crosscheck == 0xff && zonecheck;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dr->disc_size"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "sb",
            "\"unable to read map\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "map_addr"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "sb",
            "\"not enough memory\""
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "nzones * sizeof(*dm)",
            "GFP_KERNEL"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signed_asl",
          "args": [
            "map_addr",
            "asb->s_map2blk"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "signed_asl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "181-188",
          "snippet": "static inline __u32 signed_asl(__u32 val, signed int shift)\n{\n\tif (shift >= 0)\n\t\tval <<= shift;\n\telse\n\t\tval >>= -shift;\n\treturn val;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline __u32 signed_asl(__u32 val, signed int shift)\n{\n\tif (shift >= 0)\n\t\tval <<= shift;\n\telse\n\t\tval >>= -shift;\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dr->zone_spare"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "sb"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct adfs_discmap *adfs_read_map(struct super_block *sb, struct adfs_discrecord *dr)\n{\n\tstruct adfs_discmap *dm;\n\tunsigned int map_addr, zone_size, nzones;\n\tint i, zone;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tnzones    = asb->s_map_size;\n\tzone_size = (8 << dr->log2secsize) - le16_to_cpu(dr->zone_spare);\n\tmap_addr  = (nzones >> 1) * zone_size -\n\t\t     ((nzones > 1) ? ADFS_DR_SIZE_BITS : 0);\n\tmap_addr  = signed_asl(map_addr, asb->s_map2blk);\n\n\tasb->s_ids_per_zone = zone_size / (asb->s_idlen + 1);\n\n\tdm = kmalloc(nzones * sizeof(*dm), GFP_KERNEL);\n\tif (dm == NULL) {\n\t\tadfs_error(sb, \"not enough memory\");\n\t\treturn NULL;\n\t}\n\n\tfor (zone = 0; zone < nzones; zone++, map_addr++) {\n\t\tdm[zone].dm_startbit = 0;\n\t\tdm[zone].dm_endbit   = zone_size;\n\t\tdm[zone].dm_startblk = zone * zone_size - ADFS_DR_SIZE_BITS;\n\t\tdm[zone].dm_bh       = sb_bread(sb, map_addr);\n\n\t\tif (!dm[zone].dm_bh) {\n\t\t\tadfs_error(sb, \"unable to read map\");\n\t\t\tgoto error_free;\n\t\t}\n\t}\n\n\t/* adjust the limits for the first and last map zones */\n\ti = zone - 1;\n\tdm[0].dm_startblk = 0;\n\tdm[0].dm_startbit = ADFS_DR_SIZE_BITS;\n\tdm[i].dm_endbit   = (le32_to_cpu(dr->disc_size_high) << (32 - dr->log2bpmb)) +\n\t\t\t    (le32_to_cpu(dr->disc_size) >> dr->log2bpmb) +\n\t\t\t    (ADFS_DR_SIZE_BITS - i * zone_size);\n\n\tif (adfs_checkmap(sb, dm))\n\t\treturn dm;\n\n\tadfs_error(sb, \"map corrupted\");\n\nerror_free:\n\twhile (--zone >= 0)\n\t\tbrelse(dm[zone].dm_bh);\n\n\tkfree(dm);\n\treturn NULL;\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "281-289",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(adfs_inode_cachep);\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *adfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "adfs_inode_cachep"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *adfs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(adfs_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "269-279",
    "snippet": "static int __init init_inodecache(void)\n{\n\tadfs_inode_cachep = kmem_cache_create(\"adfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct adfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (adfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *adfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"adfs_inode_cache\"",
            "sizeof(struct adfs_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *adfs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tadfs_inode_cachep = kmem_cache_create(\"adfs_inode_cache\",\n\t\t\t\t\t     sizeof(struct adfs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (adfs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "262-267",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct adfs_inode_info *ei = (struct adfs_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct adfs_inode_info *ei = (struct adfs_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "adfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "257-260",
    "snippet": "static void adfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, adfs_i_callback);\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "adfs_i_callback"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void adfs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, adfs_i_callback);\n}"
  },
  {
    "function_name": "adfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "251-255",
    "snippet": "static void adfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(adfs_inode_cachep, ADFS_I(inode));\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *adfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "adfs_inode_cachep",
            "ADFS_I(inode)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADFS_I",
          "args": [
            "inode"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "73-76",
          "snippet": "static inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nstatic inline struct adfs_inode_info *ADFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct adfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *adfs_inode_cachep;\n\nstatic void adfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(adfs_inode_cachep, ADFS_I(inode));\n}"
  },
  {
    "function_name": "adfs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "242-249",
    "snippet": "static struct inode *adfs_alloc_inode(struct super_block *sb)\n{\n\tstruct adfs_inode_info *ei;\n\tei = (struct adfs_inode_info *)kmem_cache_alloc(adfs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *adfs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "adfs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *adfs_inode_cachep;\n\nstatic struct inode *adfs_alloc_inode(struct super_block *sb)\n{\n\tstruct adfs_inode_info *ei;\n\tei = (struct adfs_inode_info *)kmem_cache_alloc(adfs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "adfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "220-238",
    "snippet": "static int adfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct adfs_sb_info *sbi = ADFS_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type    = ADFS_SUPER_MAGIC;\n\tbuf->f_namelen = sbi->s_namelen;\n\tbuf->f_bsize   = sb->s_blocksize;\n\tbuf->f_blocks  = sbi->s_size;\n\tbuf->f_files   = sbi->s_ids_per_zone * sbi->s_map_size;\n\tbuf->f_bavail  =\n\tbuf->f_bfree   = adfs_map_free(sb);\n\tbuf->f_ffree   = (long)(buf->f_bfree * buf->f_files) / (long)buf->f_blocks;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_map_free",
          "args": [
            "sb"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_map_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/map.c",
          "lines": "229-245",
          "snippet": "unsigned int\nadfs_map_free(struct super_block *sb)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tstruct adfs_discmap *dm;\n\tunsigned int total = 0;\n\tunsigned int zone;\n\n\tdm   = asb->s_map;\n\tzone = asb->s_map_size;\n\n\tdo {\n\t\ttotal += scan_free_map(asb, dm++);\n\t} while (--zone > 0);\n\n\treturn signed_asl(total, asb->s_map2blk);\n}",
          "includes": [
            "#include \"adfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adfs.h\"\n#include <asm/unaligned.h>\n#include <linux/buffer_head.h>\n\nunsigned int\nadfs_map_free(struct super_block *sb)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tstruct adfs_discmap *dm;\n\tunsigned int total = 0;\n\tunsigned int zone;\n\n\tdm   = asb->s_map;\n\tzone = asb->s_map_size;\n\n\tdo {\n\t\ttotal += scan_free_map(asb, dm++);\n\t} while (--zone > 0);\n\n\treturn signed_asl(total, asb->s_map2blk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "sb"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int adfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct adfs_sb_info *sbi = ADFS_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type    = ADFS_SUPER_MAGIC;\n\tbuf->f_namelen = sbi->s_namelen;\n\tbuf->f_bsize   = sb->s_blocksize;\n\tbuf->f_blocks  = sbi->s_size;\n\tbuf->f_files   = sbi->s_ids_per_zone * sbi->s_map_size;\n\tbuf->f_bavail  =\n\tbuf->f_bfree   = adfs_map_free(sb);\n\tbuf->f_ffree   = (long)(buf->f_bfree * buf->f_files) / (long)buf->f_blocks;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "adfs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "213-218",
    "snippet": "static int adfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_NODIRATIME;\n\treturn parse_options(sb, data);\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "sb",
            "data"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "158-211",
          "snippet": "static int parse_options(struct super_block *sb, char *options)\n{\n\tchar *p;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tint option;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(asb->s_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(asb->s_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_ownmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_owner_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_othmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_other_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_ftsuffix:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_ftsuffix = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"ADFS-fs: unrecognised mount option \\\"%s\\\" \"\n\t\t\t\t\t\"or missing value\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_ownmask, \"ownmask=%o\"},\n\t{Opt_othmask, \"othmask=%o\"},\n\t{Opt_ftsuffix, \"ftsuffix=%u\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_ownmask, \"ownmask=%o\"},\n\t{Opt_othmask, \"othmask=%o\"},\n\t{Opt_ftsuffix, \"ftsuffix=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(struct super_block *sb, char *options)\n{\n\tchar *p;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tint option;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(asb->s_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(asb->s_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_ownmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_owner_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_othmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_other_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_ftsuffix:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_ftsuffix = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"ADFS-fs: unrecognised mount option \\\"%s\\\" \"\n\t\t\t\t\t\"or missing value\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int adfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\t*flags |= MS_NODIRATIME;\n\treturn parse_options(sb, data);\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "158-211",
    "snippet": "static int parse_options(struct super_block *sb, char *options)\n{\n\tchar *p;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tint option;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(asb->s_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(asb->s_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_ownmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_owner_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_othmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_other_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_ftsuffix:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_ftsuffix = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"ADFS-fs: unrecognised mount option \\\"%s\\\" \"\n\t\t\t\t\t\"or missing value\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_ownmask, \"ownmask=%o\"},\n\t{Opt_othmask, \"othmask=%o\"},\n\t{Opt_ftsuffix, \"ftsuffix=%u\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ADFS-fs: unrecognised mount option \\\"%s\\\" \"\n\t\t\t\t\t\"or missing value\\n\"",
            "p"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "args",
            "&option"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "args",
            "&option"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "asb->s_gid"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "asb->s_uid"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "args",
            "&option"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "sb"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_ownmask, \"ownmask=%o\"},\n\t{Opt_othmask, \"othmask=%o\"},\n\t{Opt_ftsuffix, \"ftsuffix=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(struct super_block *sb, char *options)\n{\n\tchar *p;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\tint option;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(asb->s_uid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(asb->s_gid))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_ownmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_owner_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_othmask:\n\t\t\tif (match_octal(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_other_mask = option;\n\t\t\tbreak;\n\t\tcase Opt_ftsuffix:\n\t\t\tif (match_int(args, &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tasb->s_ftsuffix = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"ADFS-fs: unrecognised mount option \\\"%s\\\" \"\n\t\t\t\t\t\"or missing value\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "adfs_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "129-145",
    "snippet": "static int adfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(root->d_sb);\n\n\tif (!uid_eq(asb->s_uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(seq, \",uid=%u\", from_kuid_munged(&init_user_ns, asb->s_uid));\n\tif (!gid_eq(asb->s_gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(seq, \",gid=%u\", from_kgid_munged(&init_user_ns, asb->s_gid));\n\tif (asb->s_owner_mask != ADFS_DEFAULT_OWNER_MASK)\n\t\tseq_printf(seq, \",ownmask=%o\", asb->s_owner_mask);\n\tif (asb->s_other_mask != ADFS_DEFAULT_OTHER_MASK)\n\t\tseq_printf(seq, \",othmask=%o\", asb->s_other_mask);\n\tif (asb->s_ftsuffix != 0)\n\t\tseq_printf(seq, \",ftsuffix=%u\", asb->s_ftsuffix);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ADFS_DEFAULT_OTHER_MASK (S_IRWXG | S_IRWXO)",
      "#define ADFS_DEFAULT_OWNER_MASK S_IRWXU"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",ftsuffix=%u\"",
            "asb->s_ftsuffix"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "asb->s_gid"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "asb->s_gid",
            "GLOBAL_ROOT_GID"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "asb->s_uid"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "asb->s_uid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "root->d_sb"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define ADFS_DEFAULT_OTHER_MASK (S_IRWXG | S_IRWXO)\n#define ADFS_DEFAULT_OWNER_MASK S_IRWXU\n\nstatic int adfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct adfs_sb_info *asb = ADFS_SB(root->d_sb);\n\n\tif (!uid_eq(asb->s_uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(seq, \",uid=%u\", from_kuid_munged(&init_user_ns, asb->s_uid));\n\tif (!gid_eq(asb->s_gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(seq, \",gid=%u\", from_kgid_munged(&init_user_ns, asb->s_gid));\n\tif (asb->s_owner_mask != ADFS_DEFAULT_OWNER_MASK)\n\t\tseq_printf(seq, \",ownmask=%o\", asb->s_owner_mask);\n\tif (asb->s_other_mask != ADFS_DEFAULT_OTHER_MASK)\n\t\tseq_printf(seq, \",othmask=%o\", asb->s_other_mask);\n\tif (asb->s_ftsuffix != 0)\n\t\tseq_printf(seq, \",ftsuffix=%u\", asb->s_ftsuffix);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "adfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "118-127",
    "snippet": "static void adfs_put_super(struct super_block *sb)\n{\n\tint i;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tfor (i = 0; i < asb->s_map_size; i++)\n\t\tbrelse(asb->s_map[i].dm_bh);\n\tkfree(asb->s_map);\n\tkfree_rcu(asb, rcu);\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "asb",
            "rcu"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "asb->s_map"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "asb->s_map[i].dm_bh"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "sb"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void adfs_put_super(struct super_block *sb)\n{\n\tint i;\n\tstruct adfs_sb_info *asb = ADFS_SB(sb);\n\n\tfor (i = 0; i < asb->s_map_size; i++)\n\t\tbrelse(asb->s_map[i].dm_bh);\n\tkfree(asb->s_map);\n\tkfree_rcu(asb, rcu);\n}"
  },
  {
    "function_name": "adfs_checkmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "97-116",
    "snippet": "static int adfs_checkmap(struct super_block *sb, struct adfs_discmap *dm)\n{\n\tunsigned char crosscheck = 0, zonecheck = 1;\n\tint i;\n\n\tfor (i = 0; i < ADFS_SB(sb)->s_map_size; i++) {\n\t\tunsigned char *map;\n\n\t\tmap = dm[i].dm_bh->b_data;\n\n\t\tif (adfs_calczonecheck(sb, map) != map[0]) {\n\t\t\tadfs_error(sb, \"zone %d fails zonecheck\", i);\n\t\t\tzonecheck = 0;\n\t\t}\n\t\tcrosscheck ^= map[3];\n\t}\n\tif (crosscheck != 0xff)\n\t\tadfs_error(sb, \"crosscheck != 0xff\");\n\treturn crosscheck == 0xff && zonecheck;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "sb",
            "\"crosscheck != 0xff\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adfs_error",
          "args": [
            "sb",
            "\"zone %d fails zonecheck\"",
            "i"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "__adfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "26-38",
          "snippet": "void __adfs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tchar error_buf[128];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\tprintk(KERN_CRIT \"ADFS-fs error (device %s)%s%s: %s\\n\",\n\t\tsb->s_id, function ? \": \" : \"\",\n\t\tfunction ? function : \"\", error_buf);\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid __adfs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tchar error_buf[128];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\tprintk(KERN_CRIT \"ADFS-fs error (device %s)%s%s: %s\\n\",\n\t\tsb->s_id, function ? \": \" : \"\",\n\t\tfunction ? function : \"\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adfs_calczonecheck",
          "args": [
            "sb",
            "map"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "adfs_calczonecheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
          "lines": "73-95",
          "snippet": "static unsigned char adfs_calczonecheck(struct super_block *sb, unsigned char *map)\n{\n\tunsigned int v0, v1, v2, v3;\n\tint i;\n\n\tv0 = v1 = v2 = v3 = 0;\n\tfor (i = sb->s_blocksize - 4; i; i -= 4) {\n\t\tv0 += map[i]     + (v3 >> 8);\n\t\tv3 &= 0xff;\n\t\tv1 += map[i + 1] + (v0 >> 8);\n\t\tv0 &= 0xff;\n\t\tv2 += map[i + 2] + (v1 >> 8);\n\t\tv1 &= 0xff;\n\t\tv3 += map[i + 3] + (v2 >> 8);\n\t\tv2 &= 0xff;\n\t}\n\tv0 +=           v3 >> 8;\n\tv1 += map[1] + (v0 >> 8);\n\tv2 += map[2] + (v1 >> 8);\n\tv3 += map[3] + (v2 >> 8);\n\n\treturn v0 ^ v1 ^ v2 ^ v3;\n}",
          "includes": [
            "#include \"dir_fplus.h\"",
            "#include \"dir_f.h\"",
            "#include \"adfs.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic unsigned char adfs_calczonecheck(struct super_block *sb, unsigned char *map)\n{\n\tunsigned int v0, v1, v2, v3;\n\tint i;\n\n\tv0 = v1 = v2 = v3 = 0;\n\tfor (i = sb->s_blocksize - 4; i; i -= 4) {\n\t\tv0 += map[i]     + (v3 >> 8);\n\t\tv3 &= 0xff;\n\t\tv1 += map[i + 1] + (v0 >> 8);\n\t\tv0 &= 0xff;\n\t\tv2 += map[i + 2] + (v1 >> 8);\n\t\tv1 &= 0xff;\n\t\tv3 += map[i + 3] + (v2 >> 8);\n\t\tv2 &= 0xff;\n\t}\n\tv0 +=           v3 >> 8;\n\tv1 += map[1] + (v0 >> 8);\n\tv2 += map[2] + (v1 >> 8);\n\tv3 += map[3] + (v2 >> 8);\n\n\treturn v0 ^ v1 ^ v2 ^ v3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADFS_SB",
          "args": [
            "sb"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ADFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/adfs.h",
          "lines": "68-71",
          "snippet": "static inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"dir_f.h\"",
            "#include <linux/adfs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int adfs_map_free(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dir_f.h\"\n#include <linux/adfs_fs.h>\n#include <linux/fs.h>\n\nextern unsigned int adfs_map_free(struct super_block *sb);\n\nstatic inline struct adfs_sb_info *ADFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int adfs_checkmap(struct super_block *sb, struct adfs_discmap *dm)\n{\n\tunsigned char crosscheck = 0, zonecheck = 1;\n\tint i;\n\n\tfor (i = 0; i < ADFS_SB(sb)->s_map_size; i++) {\n\t\tunsigned char *map;\n\n\t\tmap = dm[i].dm_bh->b_data;\n\n\t\tif (adfs_calczonecheck(sb, map) != map[0]) {\n\t\t\tadfs_error(sb, \"zone %d fails zonecheck\", i);\n\t\t\tzonecheck = 0;\n\t\t}\n\t\tcrosscheck ^= map[3];\n\t}\n\tif (crosscheck != 0xff)\n\t\tadfs_error(sb, \"crosscheck != 0xff\");\n\treturn crosscheck == 0xff && zonecheck;\n}"
  },
  {
    "function_name": "adfs_calczonecheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "73-95",
    "snippet": "static unsigned char adfs_calczonecheck(struct super_block *sb, unsigned char *map)\n{\n\tunsigned int v0, v1, v2, v3;\n\tint i;\n\n\tv0 = v1 = v2 = v3 = 0;\n\tfor (i = sb->s_blocksize - 4; i; i -= 4) {\n\t\tv0 += map[i]     + (v3 >> 8);\n\t\tv3 &= 0xff;\n\t\tv1 += map[i + 1] + (v0 >> 8);\n\t\tv0 &= 0xff;\n\t\tv2 += map[i + 2] + (v1 >> 8);\n\t\tv1 &= 0xff;\n\t\tv3 += map[i + 3] + (v2 >> 8);\n\t\tv2 &= 0xff;\n\t}\n\tv0 +=           v3 >> 8;\n\tv1 += map[1] + (v0 >> 8);\n\tv2 += map[2] + (v1 >> 8);\n\tv3 += map[3] + (v2 >> 8);\n\n\treturn v0 ^ v1 ^ v2 ^ v3;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic unsigned char adfs_calczonecheck(struct super_block *sb, unsigned char *map)\n{\n\tunsigned int v0, v1, v2, v3;\n\tint i;\n\n\tv0 = v1 = v2 = v3 = 0;\n\tfor (i = sb->s_blocksize - 4; i; i -= 4) {\n\t\tv0 += map[i]     + (v3 >> 8);\n\t\tv3 &= 0xff;\n\t\tv1 += map[i + 1] + (v0 >> 8);\n\t\tv0 &= 0xff;\n\t\tv2 += map[i + 2] + (v1 >> 8);\n\t\tv1 &= 0xff;\n\t\tv3 += map[i + 3] + (v2 >> 8);\n\t\tv2 &= 0xff;\n\t}\n\tv0 +=           v3 >> 8;\n\tv1 += map[1] + (v0 >> 8);\n\tv2 += map[2] + (v1 >> 8);\n\tv3 += map[3] + (v2 >> 8);\n\n\treturn v0 ^ v1 ^ v2 ^ v3;\n}"
  },
  {
    "function_name": "adfs_checkdiscrecord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "40-71",
    "snippet": "static int adfs_checkdiscrecord(struct adfs_discrecord *dr)\n{\n\tint i;\n\n\t/* sector size must be 256, 512 or 1024 bytes */\n\tif (dr->log2secsize != 8 &&\n\t    dr->log2secsize != 9 &&\n\t    dr->log2secsize != 10)\n\t\treturn 1;\n\n\t/* idlen must be at least log2secsize + 3 */\n\tif (dr->idlen < dr->log2secsize + 3)\n\t\treturn 1;\n\n\t/* we cannot have such a large disc that we\n\t * are unable to represent sector offsets in\n\t * 32 bits.  This works out at 2.0 TB.\n\t */\n\tif (le32_to_cpu(dr->disc_size_high) >> dr->log2secsize)\n\t\treturn 1;\n\n\t/* idlen must be no greater than 19 v2 [1.0] */\n\tif (dr->idlen > 19)\n\t\treturn 1;\n\n\t/* reserved bytes should be zero */\n\tfor (i = 0; i < sizeof(dr->unused52); i++)\n\t\tif (dr->unused52[i] != 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dr->disc_size_high"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int adfs_checkdiscrecord(struct adfs_discrecord *dr)\n{\n\tint i;\n\n\t/* sector size must be 256, 512 or 1024 bytes */\n\tif (dr->log2secsize != 8 &&\n\t    dr->log2secsize != 9 &&\n\t    dr->log2secsize != 10)\n\t\treturn 1;\n\n\t/* idlen must be at least log2secsize + 3 */\n\tif (dr->idlen < dr->log2secsize + 3)\n\t\treturn 1;\n\n\t/* we cannot have such a large disc that we\n\t * are unable to represent sector offsets in\n\t * 32 bits.  This works out at 2.0 TB.\n\t */\n\tif (le32_to_cpu(dr->disc_size_high) >> dr->log2secsize)\n\t\treturn 1;\n\n\t/* idlen must be no greater than 19 v2 [1.0] */\n\tif (dr->idlen > 19)\n\t\treturn 1;\n\n\t/* reserved bytes should be zero */\n\tfor (i = 0; i < sizeof(dr->unused52); i++)\n\t\tif (dr->unused52[i] != 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__adfs_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/adfs/super.c",
    "lines": "26-38",
    "snippet": "void __adfs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tchar error_buf[128];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\tprintk(KERN_CRIT \"ADFS-fs error (device %s)%s%s: %s\\n\",\n\t\tsb->s_id, function ? \": \" : \"\",\n\t\tfunction ? function : \"\", error_buf);\n}",
    "includes": [
      "#include \"dir_fplus.h\"",
      "#include \"dir_f.h\"",
      "#include \"adfs.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/mount.h>",
      "#include <linux/parser.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"ADFS-fs error (device %s)%s%s: %s\\n\"",
            "sb->s_id",
            "function ? \": \" : \"\"",
            "function ? function : \"\"",
            "error_buf"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "error_buf",
            "sizeof(error_buf)",
            "fmt",
            "args"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir_fplus.h\"\n#include \"dir_f.h\"\n#include \"adfs.h\"\n#include <linux/user_namespace.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid __adfs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tchar error_buf[128];\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\tprintk(KERN_CRIT \"ADFS-fs error (device %s)%s%s: %s\\n\",\n\t\tsb->s_id, function ? \": \" : \"\",\n\t\tfunction ? function : \"\", error_buf);\n}"
  }
]