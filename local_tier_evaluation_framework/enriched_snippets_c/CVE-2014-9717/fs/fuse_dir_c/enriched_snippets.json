[
  {
    "function_name": "fuse_init_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1949-1952",
    "snippet": "void fuse_init_symlink(struct inode *inode)\n{\n\tinode->i_op = &fuse_symlink_inode_operations;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations fuse_symlink_inode_operations = {\n\t.setattr\t= fuse_setattr,\n\t.follow_link\t= fuse_follow_link,\n\t.put_link\t= fuse_put_link,\n\t.readlink\t= generic_readlink,\n\t.getattr\t= fuse_getattr,\n\t.setxattr\t= fuse_setxattr,\n\t.getxattr\t= fuse_getxattr,\n\t.listxattr\t= fuse_listxattr,\n\t.removexattr\t= fuse_removexattr,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct inode_operations fuse_symlink_inode_operations = {\n\t.setattr\t= fuse_setattr,\n\t.follow_link\t= fuse_follow_link,\n\t.put_link\t= fuse_put_link,\n\t.readlink\t= generic_readlink,\n\t.getattr\t= fuse_getattr,\n\t.setxattr\t= fuse_setxattr,\n\t.getxattr\t= fuse_getxattr,\n\t.listxattr\t= fuse_listxattr,\n\t.removexattr\t= fuse_removexattr,\n};\n\nvoid fuse_init_symlink(struct inode *inode)\n{\n\tinode->i_op = &fuse_symlink_inode_operations;\n}"
  },
  {
    "function_name": "fuse_init_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1943-1947",
    "snippet": "void fuse_init_dir(struct inode *inode)\n{\n\tinode->i_op = &fuse_dir_inode_operations;\n\tinode->i_fop = &fuse_dir_operations;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations fuse_dir_inode_operations = {\n\t.lookup\t\t= fuse_lookup,\n\t.mkdir\t\t= fuse_mkdir,\n\t.symlink\t= fuse_symlink,\n\t.unlink\t\t= fuse_unlink,\n\t.rmdir\t\t= fuse_rmdir,\n\t.rename2\t= fuse_rename2,\n\t.link\t\t= fuse_link,\n\t.setattr\t= fuse_setattr,\n\t.create\t\t= fuse_create,\n\t.atomic_open\t= fuse_atomic_open,\n\t.mknod\t\t= fuse_mknod,\n\t.permission\t= fuse_permission,\n\t.getattr\t= fuse_getattr,\n\t.setxattr\t= fuse_setxattr,\n\t.getxattr\t= fuse_getxattr,\n\t.listxattr\t= fuse_listxattr,\n\t.removexattr\t= fuse_removexattr,\n};",
      "static const struct file_operations fuse_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= fuse_readdir,\n\t.open\t\t= fuse_dir_open,\n\t.release\t= fuse_dir_release,\n\t.fsync\t\t= fuse_dir_fsync,\n\t.unlocked_ioctl\t= fuse_dir_ioctl,\n\t.compat_ioctl\t= fuse_dir_compat_ioctl,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct inode_operations fuse_dir_inode_operations = {\n\t.lookup\t\t= fuse_lookup,\n\t.mkdir\t\t= fuse_mkdir,\n\t.symlink\t= fuse_symlink,\n\t.unlink\t\t= fuse_unlink,\n\t.rmdir\t\t= fuse_rmdir,\n\t.rename2\t= fuse_rename2,\n\t.link\t\t= fuse_link,\n\t.setattr\t= fuse_setattr,\n\t.create\t\t= fuse_create,\n\t.atomic_open\t= fuse_atomic_open,\n\t.mknod\t\t= fuse_mknod,\n\t.permission\t= fuse_permission,\n\t.getattr\t= fuse_getattr,\n\t.setxattr\t= fuse_setxattr,\n\t.getxattr\t= fuse_getxattr,\n\t.listxattr\t= fuse_listxattr,\n\t.removexattr\t= fuse_removexattr,\n};\nstatic const struct file_operations fuse_dir_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= fuse_readdir,\n\t.open\t\t= fuse_dir_open,\n\t.release\t= fuse_dir_release,\n\t.fsync\t\t= fuse_dir_fsync,\n\t.unlocked_ioctl\t= fuse_dir_ioctl,\n\t.compat_ioctl\t= fuse_dir_compat_ioctl,\n};\n\nvoid fuse_init_dir(struct inode *inode)\n{\n\tinode->i_op = &fuse_dir_inode_operations;\n\tinode->i_fop = &fuse_dir_operations;\n}"
  },
  {
    "function_name": "fuse_init_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1938-1941",
    "snippet": "void fuse_init_common(struct inode *inode)\n{\n\tinode->i_op = &fuse_common_inode_operations;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations fuse_common_inode_operations = {\n\t.setattr\t= fuse_setattr,\n\t.permission\t= fuse_permission,\n\t.getattr\t= fuse_getattr,\n\t.setxattr\t= fuse_setxattr,\n\t.getxattr\t= fuse_getxattr,\n\t.listxattr\t= fuse_listxattr,\n\t.removexattr\t= fuse_removexattr,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct inode_operations fuse_common_inode_operations = {\n\t.setattr\t= fuse_setattr,\n\t.permission\t= fuse_permission,\n\t.getattr\t= fuse_getattr,\n\t.setxattr\t= fuse_setxattr,\n\t.getxattr\t= fuse_getxattr,\n\t.listxattr\t= fuse_listxattr,\n\t.removexattr\t= fuse_removexattr,\n};\n\nvoid fuse_init_common(struct inode *inode)\n{\n\tinode->i_op = &fuse_common_inode_operations;\n}"
  },
  {
    "function_name": "fuse_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1858-1883",
    "snippet": "static int fuse_removexattr(struct dentry *entry, const char *name)\n{\n\tstruct inode *inode = entry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tint err;\n\n\tif (fc->no_removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\targs.in.h.opcode = FUSE_REMOVEXATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = strlen(name) + 1;\n\targs.in.args[0].value = name;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_removexattr = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\tif (!err) {\n\t\tfuse_invalidate_attr(inode);\n\t\tfuse_update_ctime(inode);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_update_ctime",
          "args": [
            "inode"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_update_ctime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "635-641",
          "snippet": "static inline void fuse_update_ctime(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode->i_ctime = current_fs_time(inode->i_sb);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void fuse_update_ctime(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode->i_ctime = current_fs_time(inode->i_sb);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "inode"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_removexattr(struct dentry *entry, const char *name)\n{\n\tstruct inode *inode = entry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tint err;\n\n\tif (fc->no_removexattr)\n\t\treturn -EOPNOTSUPP;\n\n\targs.in.h.opcode = FUSE_REMOVEXATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = strlen(name) + 1;\n\targs.in.args[0].value = name;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_removexattr = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\tif (!err) {\n\t\tfuse_invalidate_attr(inode);\n\t\tfuse_update_ctime(inode);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1816-1856",
    "snippet": "static ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)\n{\n\tstruct inode *inode = entry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_getxattr_in inarg;\n\tstruct fuse_getxattr_out outarg;\n\tssize_t ret;\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (fc->no_listxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.size = size;\n\targs.in.h.opcode = FUSE_LISTXATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\t/* This is really two different operations rolled into one */\n\targs.out.numargs = 1;\n\tif (size) {\n\t\targs.out.argvar = 1;\n\t\targs.out.args[0].size = size;\n\t\targs.out.args[0].value = list;\n\t} else {\n\t\targs.out.args[0].size = sizeof(outarg);\n\t\targs.out.args[0].value = &outarg;\n\t}\n\tret = fuse_simple_request(fc, &args);\n\tif (!ret && !size)\n\t\tret = outarg.size;\n\tif (ret == -ENOSYS) {\n\t\tfc->no_listxattr = 1;\n\t\tret = -EOPNOTSUPP;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_allow_current_process",
          "args": [
            "fc"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_allow_current_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1013-1030",
          "snippet": "int fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)\n{\n\tstruct inode *inode = entry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_getxattr_in inarg;\n\tstruct fuse_getxattr_out outarg;\n\tssize_t ret;\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (fc->no_listxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.size = size;\n\targs.in.h.opcode = FUSE_LISTXATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\t/* This is really two different operations rolled into one */\n\targs.out.numargs = 1;\n\tif (size) {\n\t\targs.out.argvar = 1;\n\t\targs.out.args[0].size = size;\n\t\targs.out.args[0].value = list;\n\t} else {\n\t\targs.out.args[0].size = sizeof(outarg);\n\t\targs.out.args[0].value = &outarg;\n\t}\n\tret = fuse_simple_request(fc, &args);\n\tif (!ret && !size)\n\t\tret = outarg.size;\n\tif (ret == -ENOSYS) {\n\t\tfc->no_listxattr = 1;\n\t\tret = -EOPNOTSUPP;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "fuse_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1774-1814",
    "snippet": "static ssize_t fuse_getxattr(struct dentry *entry, const char *name,\n\t\t\t     void *value, size_t size)\n{\n\tstruct inode *inode = entry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_getxattr_in inarg;\n\tstruct fuse_getxattr_out outarg;\n\tssize_t ret;\n\n\tif (fc->no_getxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.size = size;\n\targs.in.h.opcode = FUSE_GETXATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = strlen(name) + 1;\n\targs.in.args[1].value = name;\n\t/* This is really two different operations rolled into one */\n\targs.out.numargs = 1;\n\tif (size) {\n\t\targs.out.argvar = 1;\n\t\targs.out.args[0].size = size;\n\t\targs.out.args[0].value = value;\n\t} else {\n\t\targs.out.args[0].size = sizeof(outarg);\n\t\targs.out.args[0].value = &outarg;\n\t}\n\tret = fuse_simple_request(fc, &args);\n\tif (!ret && !size)\n\t\tret = outarg.size;\n\tif (ret == -ENOSYS) {\n\t\tfc->no_getxattr = 1;\n\t\tret = -EOPNOTSUPP;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_getxattr(struct dentry *entry, const char *name,\n\t\t\t     void *value, size_t size)\n{\n\tstruct inode *inode = entry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_getxattr_in inarg;\n\tstruct fuse_getxattr_out outarg;\n\tssize_t ret;\n\n\tif (fc->no_getxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.size = size;\n\targs.in.h.opcode = FUSE_GETXATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = strlen(name) + 1;\n\targs.in.args[1].value = name;\n\t/* This is really two different operations rolled into one */\n\targs.out.numargs = 1;\n\tif (size) {\n\t\targs.out.argvar = 1;\n\t\targs.out.args[0].size = size;\n\t\targs.out.args[0].value = value;\n\t} else {\n\t\targs.out.args[0].size = sizeof(outarg);\n\t\targs.out.args[0].value = &outarg;\n\t}\n\tret = fuse_simple_request(fc, &args);\n\tif (!ret && !size)\n\t\tret = outarg.size;\n\tif (ret == -ENOSYS) {\n\t\tfc->no_getxattr = 1;\n\t\tret = -EOPNOTSUPP;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "fuse_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1738-1772",
    "snippet": "static int fuse_setxattr(struct dentry *entry, const char *name,\n\t\t\t const void *value, size_t size, int flags)\n{\n\tstruct inode *inode = entry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setxattr_in inarg;\n\tint err;\n\n\tif (fc->no_setxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.size = size;\n\tinarg.flags = flags;\n\targs.in.h.opcode = FUSE_SETXATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 3;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = strlen(name) + 1;\n\targs.in.args[1].value = name;\n\targs.in.args[2].size = size;\n\targs.in.args[2].value = value;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_setxattr = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\tif (!err) {\n\t\tfuse_invalidate_attr(inode);\n\t\tfuse_update_ctime(inode);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_update_ctime",
          "args": [
            "inode"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_update_ctime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "635-641",
          "snippet": "static inline void fuse_update_ctime(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode->i_ctime = current_fs_time(inode->i_sb);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void fuse_update_ctime(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode->i_ctime = current_fs_time(inode->i_sb);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "inode"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_setxattr(struct dentry *entry, const char *name,\n\t\t\t const void *value, size_t size, int flags)\n{\n\tstruct inode *inode = entry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setxattr_in inarg;\n\tint err;\n\n\tif (fc->no_setxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.size = size;\n\tinarg.flags = flags;\n\targs.in.h.opcode = FUSE_SETXATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 3;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = strlen(name) + 1;\n\targs.in.args[1].value = name;\n\targs.in.args[2].size = size;\n\targs.in.args[2].value = value;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_setxattr = 1;\n\t\terr = -EOPNOTSUPP;\n\t}\n\tif (!err) {\n\t\tfuse_invalidate_attr(inode);\n\t\tfuse_update_ctime(inode);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1726-1736",
    "snippet": "static int fuse_getattr(struct vfsmount *mnt, struct dentry *entry,\n\t\t\tstruct kstat *stat)\n{\n\tstruct inode *inode = entry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\treturn fuse_update_attributes(inode, stat, NULL, NULL);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_update_attributes",
          "args": [
            "inode",
            "stat",
            "NULL",
            "NULL"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_update_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "909-933",
          "snippet": "int fuse_update_attributes(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file, bool *refreshed)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err;\n\tbool r;\n\n\tif (time_before64(fi->i_time, get_jiffies_64())) {\n\t\tr = true;\n\t\terr = fuse_do_getattr(inode, stat, file);\n\t} else {\n\t\tr = false;\n\t\terr = 0;\n\t\tif (stat) {\n\t\t\tgeneric_fillattr(inode, stat);\n\t\t\tstat->mode = fi->orig_i_mode;\n\t\t\tstat->ino = fi->orig_ino;\n\t\t}\n\t}\n\n\tif (refreshed != NULL)\n\t\t*refreshed = r;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_update_attributes(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file, bool *refreshed)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err;\n\tbool r;\n\n\tif (time_before64(fi->i_time, get_jiffies_64())) {\n\t\tr = true;\n\t\terr = fuse_do_getattr(inode, stat, file);\n\t} else {\n\t\tr = false;\n\t\terr = 0;\n\t\tif (stat) {\n\t\t\tgeneric_fillattr(inode, stat);\n\t\t\tstat->mode = fi->orig_i_mode;\n\t\t\tstat->ino = fi->orig_ino;\n\t\t}\n\t}\n\n\tif (refreshed != NULL)\n\t\t*refreshed = r;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_allow_current_process",
          "args": [
            "fc"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_allow_current_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1013-1030",
          "snippet": "int fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_getattr(struct vfsmount *mnt, struct dentry *entry,\n\t\t\tstruct kstat *stat)\n{\n\tstruct inode *inode = entry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\treturn fuse_update_attributes(inode, stat, NULL, NULL);\n}"
  },
  {
    "function_name": "fuse_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1713-1724",
    "snippet": "static int fuse_setattr(struct dentry *entry, struct iattr *attr)\n{\n\tstruct inode *inode = entry->d_inode;\n\n\tif (!fuse_allow_current_process(get_fuse_conn(inode)))\n\t\treturn -EACCES;\n\n\tif (attr->ia_valid & ATTR_FILE)\n\t\treturn fuse_do_setattr(inode, attr, attr->ia_file);\n\telse\n\t\treturn fuse_do_setattr(inode, attr, NULL);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_do_setattr",
          "args": [
            "inode",
            "attr",
            "NULL"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_do_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1605-1711",
          "snippet": "int fuse_do_setattr(struct inode *inode, struct iattr *attr,\n\t\t    struct file *file)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tbool is_truncate = false;\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tint err;\n\tbool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);\n\n\tif (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))\n\t\tattr->ia_valid |= ATTR_FORCE;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_OPEN) {\n\t\tif (fc->atomic_o_trunc)\n\t\t\treturn 0;\n\t\tfile = NULL;\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\tis_truncate = true;\n\n\tif (is_truncate) {\n\t\tfuse_set_nowrite(inode);\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\t\tif (trust_local_cmtime && attr->ia_size != inode->i_size)\n\t\t\tattr->ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t}\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tiattr_to_fattr(attr, &inarg, trust_local_cmtime);\n\tif (file) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/* For mandatory locking in truncate */\n\t\tinarg.valid |= FATTR_LOCKOWNER;\n\t\tinarg.lock_owner = fuse_lock_owner_id(fc, current->files);\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\terr = fuse_simple_request(fc, &args);\n\tif (err) {\n\t\tif (err == -EINTR)\n\t\t\tfuse_invalidate_attr(inode);\n\t\tgoto error;\n\t}\n\n\tif ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\tmake_bad_inode(inode);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&fc->lock);\n\t/* the kernel maintains i_mtime locally */\n\tif (trust_local_cmtime) {\n\t\tif (attr->ia_valid & ATTR_MTIME)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\tif (attr->ia_valid & ATTR_CTIME)\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t/* FIXME: clear I_DIRTY_SYNC? */\n\t}\n\n\tfuse_change_attributes_common(inode, &outarg.attr,\n\t\t\t\t      attr_timeout(&outarg));\n\toldsize = inode->i_size;\n\t/* see the comment in fuse_change_attributes() */\n\tif (!is_wb || is_truncate || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, outarg.attr.size);\n\n\tif (is_truncate) {\n\t\t/* NOTE: this may release/reacquire fc->lock */\n\t\t__fuse_release_nowrite(inode);\n\t}\n\tspin_unlock(&fc->lock);\n\n\t/*\n\t * Only call invalidate_inode_pages2() after removing\n\t * FUSE_NOWRITE, otherwise fuse_launder_page() would deadlock.\n\t */\n\tif ((is_truncate || !is_wb) &&\n\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {\n\t\ttruncate_pagecache(inode, outarg.attr.size);\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\treturn 0;\n\nerror:\n\tif (is_truncate)\n\t\tfuse_release_nowrite(inode);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_do_setattr(struct inode *inode, struct iattr *attr,\n\t\t    struct file *file)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tbool is_truncate = false;\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tint err;\n\tbool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);\n\n\tif (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))\n\t\tattr->ia_valid |= ATTR_FORCE;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_OPEN) {\n\t\tif (fc->atomic_o_trunc)\n\t\t\treturn 0;\n\t\tfile = NULL;\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\tis_truncate = true;\n\n\tif (is_truncate) {\n\t\tfuse_set_nowrite(inode);\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\t\tif (trust_local_cmtime && attr->ia_size != inode->i_size)\n\t\t\tattr->ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t}\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tiattr_to_fattr(attr, &inarg, trust_local_cmtime);\n\tif (file) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/* For mandatory locking in truncate */\n\t\tinarg.valid |= FATTR_LOCKOWNER;\n\t\tinarg.lock_owner = fuse_lock_owner_id(fc, current->files);\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\terr = fuse_simple_request(fc, &args);\n\tif (err) {\n\t\tif (err == -EINTR)\n\t\t\tfuse_invalidate_attr(inode);\n\t\tgoto error;\n\t}\n\n\tif ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\tmake_bad_inode(inode);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&fc->lock);\n\t/* the kernel maintains i_mtime locally */\n\tif (trust_local_cmtime) {\n\t\tif (attr->ia_valid & ATTR_MTIME)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\tif (attr->ia_valid & ATTR_CTIME)\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t/* FIXME: clear I_DIRTY_SYNC? */\n\t}\n\n\tfuse_change_attributes_common(inode, &outarg.attr,\n\t\t\t\t      attr_timeout(&outarg));\n\toldsize = inode->i_size;\n\t/* see the comment in fuse_change_attributes() */\n\tif (!is_wb || is_truncate || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, outarg.attr.size);\n\n\tif (is_truncate) {\n\t\t/* NOTE: this may release/reacquire fc->lock */\n\t\t__fuse_release_nowrite(inode);\n\t}\n\tspin_unlock(&fc->lock);\n\n\t/*\n\t * Only call invalidate_inode_pages2() after removing\n\t * FUSE_NOWRITE, otherwise fuse_launder_page() would deadlock.\n\t */\n\tif ((is_truncate || !is_wb) &&\n\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {\n\t\ttruncate_pagecache(inode, outarg.attr.size);\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\treturn 0;\n\nerror:\n\tif (is_truncate)\n\t\tfuse_release_nowrite(inode);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_allow_current_process",
          "args": [
            "get_fuse_conn(inode)"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_allow_current_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1013-1030",
          "snippet": "int fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_setattr(struct dentry *entry, struct iattr *attr)\n{\n\tstruct inode *inode = entry->d_inode;\n\n\tif (!fuse_allow_current_process(get_fuse_conn(inode)))\n\t\treturn -EACCES;\n\n\tif (attr->ia_valid & ATTR_FILE)\n\t\treturn fuse_do_setattr(inode, attr, attr->ia_file);\n\telse\n\t\treturn fuse_do_setattr(inode, attr, NULL);\n}"
  },
  {
    "function_name": "fuse_do_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1605-1711",
    "snippet": "int fuse_do_setattr(struct inode *inode, struct iattr *attr,\n\t\t    struct file *file)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tbool is_truncate = false;\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tint err;\n\tbool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);\n\n\tif (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))\n\t\tattr->ia_valid |= ATTR_FORCE;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_OPEN) {\n\t\tif (fc->atomic_o_trunc)\n\t\t\treturn 0;\n\t\tfile = NULL;\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\tis_truncate = true;\n\n\tif (is_truncate) {\n\t\tfuse_set_nowrite(inode);\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\t\tif (trust_local_cmtime && attr->ia_size != inode->i_size)\n\t\t\tattr->ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t}\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tiattr_to_fattr(attr, &inarg, trust_local_cmtime);\n\tif (file) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/* For mandatory locking in truncate */\n\t\tinarg.valid |= FATTR_LOCKOWNER;\n\t\tinarg.lock_owner = fuse_lock_owner_id(fc, current->files);\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\terr = fuse_simple_request(fc, &args);\n\tif (err) {\n\t\tif (err == -EINTR)\n\t\t\tfuse_invalidate_attr(inode);\n\t\tgoto error;\n\t}\n\n\tif ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\tmake_bad_inode(inode);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&fc->lock);\n\t/* the kernel maintains i_mtime locally */\n\tif (trust_local_cmtime) {\n\t\tif (attr->ia_valid & ATTR_MTIME)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\tif (attr->ia_valid & ATTR_CTIME)\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t/* FIXME: clear I_DIRTY_SYNC? */\n\t}\n\n\tfuse_change_attributes_common(inode, &outarg.attr,\n\t\t\t\t      attr_timeout(&outarg));\n\toldsize = inode->i_size;\n\t/* see the comment in fuse_change_attributes() */\n\tif (!is_wb || is_truncate || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, outarg.attr.size);\n\n\tif (is_truncate) {\n\t\t/* NOTE: this may release/reacquire fc->lock */\n\t\t__fuse_release_nowrite(inode);\n\t}\n\tspin_unlock(&fc->lock);\n\n\t/*\n\t * Only call invalidate_inode_pages2() after removing\n\t * FUSE_NOWRITE, otherwise fuse_launder_page() would deadlock.\n\t */\n\tif ((is_truncate || !is_wb) &&\n\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {\n\t\ttruncate_pagecache(inode, outarg.attr.size);\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\treturn 0;\n\nerror:\n\tif (is_truncate)\n\t\tfuse_release_nowrite(inode);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "FUSE_I_SIZE_UNSTABLE",
            "&fi->state"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_release_nowrite",
          "args": [
            "inode"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_release_nowrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1543-1550",
          "snippet": "void fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tspin_lock(&fc->lock);\n\t__fuse_release_nowrite(inode);\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tspin_lock(&fc->lock);\n\t__fuse_release_nowrite(inode);\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "outarg.attr.size"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fuse_release_nowrite",
          "args": [
            "inode"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_release_nowrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1534-1541",
          "snippet": "static void __fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(fi->writectr != FUSE_NOWRITE);\n\tfi->writectr = 0;\n\tfuse_flush_writepages(inode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void __fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(fi->writectr != FUSE_NOWRITE);\n\tfi->writectr = 0;\n\tfuse_flush_writepages(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "outarg.attr.size"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_change_attributes_common",
          "args": [
            "inode",
            "&outarg.attr",
            "attr_timeout(&outarg)"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_change_attributes_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "157-197",
          "snippet": "void fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,\n\t\t\t\t   u64 attr_valid)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tfi->attr_version = ++fc->attr_version;\n\tfi->i_time = attr_valid;\n\n\tinode->i_ino     = fuse_squash_ino(attr->ino);\n\tinode->i_mode    = (inode->i_mode & S_IFMT) | (attr->mode & 07777);\n\tset_nlink(inode, attr->nlink);\n\tinode->i_uid     = make_kuid(&init_user_ns, attr->uid);\n\tinode->i_gid     = make_kgid(&init_user_ns, attr->gid);\n\tinode->i_blocks  = attr->blocks;\n\tinode->i_atime.tv_sec   = attr->atime;\n\tinode->i_atime.tv_nsec  = attr->atimensec;\n\t/* mtime from server may be stale due to local buffered write */\n\tif (!fc->writeback_cache || !S_ISREG(inode->i_mode)) {\n\t\tinode->i_mtime.tv_sec   = attr->mtime;\n\t\tinode->i_mtime.tv_nsec  = attr->mtimensec;\n\t\tinode->i_ctime.tv_sec   = attr->ctime;\n\t\tinode->i_ctime.tv_nsec  = attr->ctimensec;\n\t}\n\n\tif (attr->blksize != 0)\n\t\tinode->i_blkbits = ilog2(attr->blksize);\n\telse\n\t\tinode->i_blkbits = inode->i_sb->s_blocksize_bits;\n\n\t/*\n\t * Don't set the sticky bit in i_mode, unless we want the VFS\n\t * to check permissions.  This prevents failures due to the\n\t * check in may_delete().\n\t */\n\tfi->orig_i_mode = inode->i_mode;\n\tif (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))\n\t\tinode->i_mode &= ~S_ISVTX;\n\n\tfi->orig_ino = attr->ino;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_change_attributes_common(struct inode *inode, struct fuse_attr *attr,\n\t\t\t\t   u64 attr_valid)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tfi->attr_version = ++fc->attr_version;\n\tfi->i_time = attr_valid;\n\n\tinode->i_ino     = fuse_squash_ino(attr->ino);\n\tinode->i_mode    = (inode->i_mode & S_IFMT) | (attr->mode & 07777);\n\tset_nlink(inode, attr->nlink);\n\tinode->i_uid     = make_kuid(&init_user_ns, attr->uid);\n\tinode->i_gid     = make_kgid(&init_user_ns, attr->gid);\n\tinode->i_blocks  = attr->blocks;\n\tinode->i_atime.tv_sec   = attr->atime;\n\tinode->i_atime.tv_nsec  = attr->atimensec;\n\t/* mtime from server may be stale due to local buffered write */\n\tif (!fc->writeback_cache || !S_ISREG(inode->i_mode)) {\n\t\tinode->i_mtime.tv_sec   = attr->mtime;\n\t\tinode->i_mtime.tv_nsec  = attr->mtimensec;\n\t\tinode->i_ctime.tv_sec   = attr->ctime;\n\t\tinode->i_ctime.tv_nsec  = attr->ctimensec;\n\t}\n\n\tif (attr->blksize != 0)\n\t\tinode->i_blkbits = ilog2(attr->blksize);\n\telse\n\t\tinode->i_blkbits = inode->i_sb->s_blocksize_bits;\n\n\t/*\n\t * Don't set the sticky bit in i_mode, unless we want the VFS\n\t * to check permissions.  This prevents failures due to the\n\t * check in may_delete().\n\t */\n\tfi->orig_i_mode = inode->i_mode;\n\tif (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))\n\t\tinode->i_mode &= ~S_ISVTX;\n\n\tfi->orig_ino = attr->ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attr_timeout",
          "args": [
            "&outarg"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "entry_attr_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "101-104",
          "snippet": "static u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "170-179",
          "snippet": "void make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};",
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nvoid make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "inode"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_setattr_fill",
          "args": [
            "fc",
            "&args",
            "inode",
            "&inarg",
            "&outarg"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_setattr_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1552-1565",
          "snippet": "static void fuse_setattr_fill(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t      struct inode *inode,\n\t\t\t      struct fuse_setattr_in *inarg_p,\n\t\t\t      struct fuse_attr_out *outarg_p)\n{\n\targs->in.h.opcode = FUSE_SETATTR;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg_p);\n\targs->in.args[0].value = inarg_p;\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(*outarg_p);\n\targs->out.args[0].value = outarg_p;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_setattr_fill(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t      struct inode *inode,\n\t\t\t      struct fuse_setattr_in *inarg_p,\n\t\t\t      struct fuse_attr_out *outarg_p)\n{\n\targs->in.h.opcode = FUSE_SETATTR;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg_p);\n\targs->in.args[0].value = inarg_p;\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(*outarg_p);\n\targs->out.args[0].value = outarg_p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lock_owner_id",
          "args": [
            "fc",
            "current->files"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lock_owner_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "314-330",
          "snippet": "u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iattr_to_fattr",
          "args": [
            "attr",
            "&inarg",
            "trust_local_cmtime"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "iattr_to_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1474-1506",
          "snippet": "static void iattr_to_fattr(struct iattr *iattr, struct fuse_setattr_in *arg,\n\t\t\t   bool trust_local_cmtime)\n{\n\tunsigned ivalid = iattr->ia_valid;\n\n\tif (ivalid & ATTR_MODE)\n\t\targ->valid |= FATTR_MODE,   arg->mode = iattr->ia_mode;\n\tif (ivalid & ATTR_UID)\n\t\targ->valid |= FATTR_UID,    arg->uid = from_kuid(&init_user_ns, iattr->ia_uid);\n\tif (ivalid & ATTR_GID)\n\t\targ->valid |= FATTR_GID,    arg->gid = from_kgid(&init_user_ns, iattr->ia_gid);\n\tif (ivalid & ATTR_SIZE)\n\t\targ->valid |= FATTR_SIZE,   arg->size = iattr->ia_size;\n\tif (ivalid & ATTR_ATIME) {\n\t\targ->valid |= FATTR_ATIME;\n\t\targ->atime = iattr->ia_atime.tv_sec;\n\t\targ->atimensec = iattr->ia_atime.tv_nsec;\n\t\tif (!(ivalid & ATTR_ATIME_SET))\n\t\t\targ->valid |= FATTR_ATIME_NOW;\n\t}\n\tif ((ivalid & ATTR_MTIME) && update_mtime(ivalid, trust_local_cmtime)) {\n\t\targ->valid |= FATTR_MTIME;\n\t\targ->mtime = iattr->ia_mtime.tv_sec;\n\t\targ->mtimensec = iattr->ia_mtime.tv_nsec;\n\t\tif (!(ivalid & ATTR_MTIME_SET) && !trust_local_cmtime)\n\t\t\targ->valid |= FATTR_MTIME_NOW;\n\t}\n\tif ((ivalid & ATTR_CTIME) && trust_local_cmtime) {\n\t\targ->valid |= FATTR_CTIME;\n\t\targ->ctime = iattr->ia_ctime.tv_sec;\n\t\targ->ctimensec = iattr->ia_ctime.tv_nsec;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void iattr_to_fattr(struct iattr *iattr, struct fuse_setattr_in *arg,\n\t\t\t   bool trust_local_cmtime)\n{\n\tunsigned ivalid = iattr->ia_valid;\n\n\tif (ivalid & ATTR_MODE)\n\t\targ->valid |= FATTR_MODE,   arg->mode = iattr->ia_mode;\n\tif (ivalid & ATTR_UID)\n\t\targ->valid |= FATTR_UID,    arg->uid = from_kuid(&init_user_ns, iattr->ia_uid);\n\tif (ivalid & ATTR_GID)\n\t\targ->valid |= FATTR_GID,    arg->gid = from_kgid(&init_user_ns, iattr->ia_gid);\n\tif (ivalid & ATTR_SIZE)\n\t\targ->valid |= FATTR_SIZE,   arg->size = iattr->ia_size;\n\tif (ivalid & ATTR_ATIME) {\n\t\targ->valid |= FATTR_ATIME;\n\t\targ->atime = iattr->ia_atime.tv_sec;\n\t\targ->atimensec = iattr->ia_atime.tv_nsec;\n\t\tif (!(ivalid & ATTR_ATIME_SET))\n\t\t\targ->valid |= FATTR_ATIME_NOW;\n\t}\n\tif ((ivalid & ATTR_MTIME) && update_mtime(ivalid, trust_local_cmtime)) {\n\t\targ->valid |= FATTR_MTIME;\n\t\targ->mtime = iattr->ia_mtime.tv_sec;\n\t\targ->mtimensec = iattr->ia_mtime.tv_nsec;\n\t\tif (!(ivalid & ATTR_MTIME_SET) && !trust_local_cmtime)\n\t\t\targ->valid |= FATTR_MTIME_NOW;\n\t}\n\tif ((ivalid & ATTR_CTIME) && trust_local_cmtime) {\n\t\targ->valid |= FATTR_CTIME;\n\t\targ->ctime = iattr->ia_ctime.tv_sec;\n\t\targ->ctimensec = iattr->ia_ctime.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&outarg",
            "0",
            "sizeof(outarg)"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FUSE_I_SIZE_UNSTABLE",
            "&fi->state"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_set_nowrite",
          "args": [
            "inode"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_set_nowrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1514-1526",
          "snippet": "void fuse_set_nowrite(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(!mutex_is_locked(&inode->i_mutex));\n\n\tspin_lock(&fc->lock);\n\tBUG_ON(fi->writectr < 0);\n\tfi->writectr += FUSE_NOWRITE;\n\tspin_unlock(&fc->lock);\n\twait_event(fi->page_waitq, fi->writectr == FUSE_NOWRITE);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_set_nowrite(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(!mutex_is_locked(&inode->i_mutex));\n\n\tspin_lock(&fc->lock);\n\tBUG_ON(fi->writectr < 0);\n\tfi->writectr += FUSE_NOWRITE;\n\tspin_unlock(&fc->lock);\n\twait_event(fi->page_waitq, fi->writectr == FUSE_NOWRITE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_do_setattr(struct inode *inode, struct iattr *attr,\n\t\t    struct file *file)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tbool is_truncate = false;\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tint err;\n\tbool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);\n\n\tif (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))\n\t\tattr->ia_valid |= ATTR_FORCE;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_OPEN) {\n\t\tif (fc->atomic_o_trunc)\n\t\t\treturn 0;\n\t\tfile = NULL;\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\tis_truncate = true;\n\n\tif (is_truncate) {\n\t\tfuse_set_nowrite(inode);\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\t\tif (trust_local_cmtime && attr->ia_size != inode->i_size)\n\t\t\tattr->ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t}\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tiattr_to_fattr(attr, &inarg, trust_local_cmtime);\n\tif (file) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/* For mandatory locking in truncate */\n\t\tinarg.valid |= FATTR_LOCKOWNER;\n\t\tinarg.lock_owner = fuse_lock_owner_id(fc, current->files);\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\terr = fuse_simple_request(fc, &args);\n\tif (err) {\n\t\tif (err == -EINTR)\n\t\t\tfuse_invalidate_attr(inode);\n\t\tgoto error;\n\t}\n\n\tif ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\tmake_bad_inode(inode);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&fc->lock);\n\t/* the kernel maintains i_mtime locally */\n\tif (trust_local_cmtime) {\n\t\tif (attr->ia_valid & ATTR_MTIME)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\tif (attr->ia_valid & ATTR_CTIME)\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t/* FIXME: clear I_DIRTY_SYNC? */\n\t}\n\n\tfuse_change_attributes_common(inode, &outarg.attr,\n\t\t\t\t      attr_timeout(&outarg));\n\toldsize = inode->i_size;\n\t/* see the comment in fuse_change_attributes() */\n\tif (!is_wb || is_truncate || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, outarg.attr.size);\n\n\tif (is_truncate) {\n\t\t/* NOTE: this may release/reacquire fc->lock */\n\t\t__fuse_release_nowrite(inode);\n\t}\n\tspin_unlock(&fc->lock);\n\n\t/*\n\t * Only call invalidate_inode_pages2() after removing\n\t * FUSE_NOWRITE, otherwise fuse_launder_page() would deadlock.\n\t */\n\tif ((is_truncate || !is_wb) &&\n\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {\n\t\ttruncate_pagecache(inode, outarg.attr.size);\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\treturn 0;\n\nerror:\n\tif (is_truncate)\n\t\tfuse_release_nowrite(inode);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_flush_times",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1570-1595",
    "snippet": "int fuse_flush_times(struct inode *inode, struct fuse_file *ff)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\n\tinarg.valid = FATTR_MTIME;\n\tinarg.mtime = inode->i_mtime.tv_sec;\n\tinarg.mtimensec = inode->i_mtime.tv_nsec;\n\tif (fc->minor >= 23) {\n\t\tinarg.valid |= FATTR_CTIME;\n\t\tinarg.ctime = inode->i_ctime.tv_sec;\n\t\tinarg.ctimensec = inode->i_ctime.tv_nsec;\n\t}\n\tif (ff) {\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\n\treturn fuse_simple_request(fc, &args);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_setattr_fill",
          "args": [
            "fc",
            "&args",
            "inode",
            "&inarg",
            "&outarg"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_setattr_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1552-1565",
          "snippet": "static void fuse_setattr_fill(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t      struct inode *inode,\n\t\t\t      struct fuse_setattr_in *inarg_p,\n\t\t\t      struct fuse_attr_out *outarg_p)\n{\n\targs->in.h.opcode = FUSE_SETATTR;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg_p);\n\targs->in.args[0].value = inarg_p;\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(*outarg_p);\n\targs->out.args[0].value = outarg_p;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_setattr_fill(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t      struct inode *inode,\n\t\t\t      struct fuse_setattr_in *inarg_p,\n\t\t\t      struct fuse_attr_out *outarg_p)\n{\n\targs->in.h.opcode = FUSE_SETATTR;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg_p);\n\targs->in.args[0].value = inarg_p;\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(*outarg_p);\n\targs->out.args[0].value = outarg_p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&outarg",
            "0",
            "sizeof(outarg)"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_flush_times(struct inode *inode, struct fuse_file *ff)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\n\tinarg.valid = FATTR_MTIME;\n\tinarg.mtime = inode->i_mtime.tv_sec;\n\tinarg.mtimensec = inode->i_mtime.tv_nsec;\n\tif (fc->minor >= 23) {\n\t\tinarg.valid |= FATTR_CTIME;\n\t\tinarg.ctime = inode->i_ctime.tv_sec;\n\t\tinarg.ctimensec = inode->i_ctime.tv_nsec;\n\t}\n\tif (ff) {\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\n\treturn fuse_simple_request(fc, &args);\n}"
  },
  {
    "function_name": "fuse_setattr_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1552-1565",
    "snippet": "static void fuse_setattr_fill(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t      struct inode *inode,\n\t\t\t      struct fuse_setattr_in *inarg_p,\n\t\t\t      struct fuse_attr_out *outarg_p)\n{\n\targs->in.h.opcode = FUSE_SETATTR;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg_p);\n\targs->in.args[0].value = inarg_p;\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(*outarg_p);\n\targs->out.args[0].value = outarg_p;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_setattr_fill(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t      struct inode *inode,\n\t\t\t      struct fuse_setattr_in *inarg_p,\n\t\t\t      struct fuse_attr_out *outarg_p)\n{\n\targs->in.h.opcode = FUSE_SETATTR;\n\targs->in.h.nodeid = get_node_id(inode);\n\targs->in.numargs = 1;\n\targs->in.args[0].size = sizeof(*inarg_p);\n\targs->in.args[0].value = inarg_p;\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(*outarg_p);\n\targs->out.args[0].value = outarg_p;\n}"
  },
  {
    "function_name": "fuse_release_nowrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1543-1550",
    "snippet": "void fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tspin_lock(&fc->lock);\n\t__fuse_release_nowrite(inode);\n\tspin_unlock(&fc->lock);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fuse_release_nowrite",
          "args": [
            "inode"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "__fuse_release_nowrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1534-1541",
          "snippet": "static void __fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(fi->writectr != FUSE_NOWRITE);\n\tfi->writectr = 0;\n\tfuse_flush_writepages(inode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void __fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(fi->writectr != FUSE_NOWRITE);\n\tfi->writectr = 0;\n\tfuse_flush_writepages(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tspin_lock(&fc->lock);\n\t__fuse_release_nowrite(inode);\n\tspin_unlock(&fc->lock);\n}"
  },
  {
    "function_name": "__fuse_release_nowrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1534-1541",
    "snippet": "static void __fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(fi->writectr != FUSE_NOWRITE);\n\tfi->writectr = 0;\n\tfuse_flush_writepages(inode);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_flush_writepages",
          "args": [
            "inode"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_flush_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1520-1534",
          "snippet": "void fuse_flush_writepages(struct inode *inode)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tsize_t crop = i_size_read(inode);\n\tstruct fuse_req *req;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\treq = list_entry(fi->queued_writes.next, struct fuse_req, list);\n\t\tlist_del_init(&req->list);\n\t\tfuse_send_writepage(fc, req, crop);\n\t}\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_flush_writepages(struct inode *inode)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tsize_t crop = i_size_read(inode);\n\tstruct fuse_req *req;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\treq = list_entry(fi->queued_writes.next, struct fuse_req, list);\n\t\tlist_del_init(&req->list);\n\t\tfuse_send_writepage(fc, req, crop);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fi->writectr != FUSE_NOWRITE"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void __fuse_release_nowrite(struct inode *inode)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(fi->writectr != FUSE_NOWRITE);\n\tfi->writectr = 0;\n\tfuse_flush_writepages(inode);\n}"
  },
  {
    "function_name": "fuse_set_nowrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1514-1526",
    "snippet": "void fuse_set_nowrite(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(!mutex_is_locked(&inode->i_mutex));\n\n\tspin_lock(&fc->lock);\n\tBUG_ON(fi->writectr < 0);\n\tfi->writectr += FUSE_NOWRITE;\n\tspin_unlock(&fc->lock);\n\twait_event(fi->page_waitq, fi->writectr == FUSE_NOWRITE);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fi->page_waitq",
            "fi->writectr == FUSE_NOWRITE"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fi->writectr < 0"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&inode->i_mutex)"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_set_nowrite(struct inode *inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tBUG_ON(!mutex_is_locked(&inode->i_mutex));\n\n\tspin_lock(&fc->lock);\n\tBUG_ON(fi->writectr < 0);\n\tfi->writectr += FUSE_NOWRITE;\n\tspin_unlock(&fc->lock);\n\twait_event(fi->page_waitq, fi->writectr == FUSE_NOWRITE);\n}"
  },
  {
    "function_name": "iattr_to_fattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1474-1506",
    "snippet": "static void iattr_to_fattr(struct iattr *iattr, struct fuse_setattr_in *arg,\n\t\t\t   bool trust_local_cmtime)\n{\n\tunsigned ivalid = iattr->ia_valid;\n\n\tif (ivalid & ATTR_MODE)\n\t\targ->valid |= FATTR_MODE,   arg->mode = iattr->ia_mode;\n\tif (ivalid & ATTR_UID)\n\t\targ->valid |= FATTR_UID,    arg->uid = from_kuid(&init_user_ns, iattr->ia_uid);\n\tif (ivalid & ATTR_GID)\n\t\targ->valid |= FATTR_GID,    arg->gid = from_kgid(&init_user_ns, iattr->ia_gid);\n\tif (ivalid & ATTR_SIZE)\n\t\targ->valid |= FATTR_SIZE,   arg->size = iattr->ia_size;\n\tif (ivalid & ATTR_ATIME) {\n\t\targ->valid |= FATTR_ATIME;\n\t\targ->atime = iattr->ia_atime.tv_sec;\n\t\targ->atimensec = iattr->ia_atime.tv_nsec;\n\t\tif (!(ivalid & ATTR_ATIME_SET))\n\t\t\targ->valid |= FATTR_ATIME_NOW;\n\t}\n\tif ((ivalid & ATTR_MTIME) && update_mtime(ivalid, trust_local_cmtime)) {\n\t\targ->valid |= FATTR_MTIME;\n\t\targ->mtime = iattr->ia_mtime.tv_sec;\n\t\targ->mtimensec = iattr->ia_mtime.tv_nsec;\n\t\tif (!(ivalid & ATTR_MTIME_SET) && !trust_local_cmtime)\n\t\t\targ->valid |= FATTR_MTIME_NOW;\n\t}\n\tif ((ivalid & ATTR_CTIME) && trust_local_cmtime) {\n\t\targ->valid |= FATTR_CTIME;\n\t\targ->ctime = iattr->ia_ctime.tv_sec;\n\t\targ->ctimensec = iattr->ia_ctime.tv_nsec;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_mtime",
          "args": [
            "ivalid",
            "trust_local_cmtime"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "update_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1456-1472",
          "snippet": "static bool update_mtime(unsigned ivalid, bool trust_local_mtime)\n{\n\t/* Always update if mtime is explicitly set  */\n\tif (ivalid & ATTR_MTIME_SET)\n\t\treturn true;\n\n\t/* Or if kernel i_mtime is the official one */\n\tif (trust_local_mtime)\n\t\treturn true;\n\n\t/* If it's an open(O_TRUNC) or an ftruncate(), don't update */\n\tif ((ivalid & ATTR_SIZE) && (ivalid & (ATTR_OPEN | ATTR_FILE)))\n\t\treturn false;\n\n\t/* In all other cases update */\n\treturn true;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic bool update_mtime(unsigned ivalid, bool trust_local_mtime)\n{\n\t/* Always update if mtime is explicitly set  */\n\tif (ivalid & ATTR_MTIME_SET)\n\t\treturn true;\n\n\t/* Or if kernel i_mtime is the official one */\n\tif (trust_local_mtime)\n\t\treturn true;\n\n\t/* If it's an open(O_TRUNC) or an ftruncate(), don't update */\n\tif ((ivalid & ATTR_SIZE) && (ivalid & (ATTR_OPEN | ATTR_FILE)))\n\t\treturn false;\n\n\t/* In all other cases update */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "iattr->ia_gid"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "iattr->ia_uid"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void iattr_to_fattr(struct iattr *iattr, struct fuse_setattr_in *arg,\n\t\t\t   bool trust_local_cmtime)\n{\n\tunsigned ivalid = iattr->ia_valid;\n\n\tif (ivalid & ATTR_MODE)\n\t\targ->valid |= FATTR_MODE,   arg->mode = iattr->ia_mode;\n\tif (ivalid & ATTR_UID)\n\t\targ->valid |= FATTR_UID,    arg->uid = from_kuid(&init_user_ns, iattr->ia_uid);\n\tif (ivalid & ATTR_GID)\n\t\targ->valid |= FATTR_GID,    arg->gid = from_kgid(&init_user_ns, iattr->ia_gid);\n\tif (ivalid & ATTR_SIZE)\n\t\targ->valid |= FATTR_SIZE,   arg->size = iattr->ia_size;\n\tif (ivalid & ATTR_ATIME) {\n\t\targ->valid |= FATTR_ATIME;\n\t\targ->atime = iattr->ia_atime.tv_sec;\n\t\targ->atimensec = iattr->ia_atime.tv_nsec;\n\t\tif (!(ivalid & ATTR_ATIME_SET))\n\t\t\targ->valid |= FATTR_ATIME_NOW;\n\t}\n\tif ((ivalid & ATTR_MTIME) && update_mtime(ivalid, trust_local_cmtime)) {\n\t\targ->valid |= FATTR_MTIME;\n\t\targ->mtime = iattr->ia_mtime.tv_sec;\n\t\targ->mtimensec = iattr->ia_mtime.tv_nsec;\n\t\tif (!(ivalid & ATTR_MTIME_SET) && !trust_local_cmtime)\n\t\t\targ->valid |= FATTR_MTIME_NOW;\n\t}\n\tif ((ivalid & ATTR_CTIME) && trust_local_cmtime) {\n\t\targ->valid |= FATTR_CTIME;\n\t\targ->ctime = iattr->ia_ctime.tv_sec;\n\t\targ->ctimensec = iattr->ia_ctime.tv_nsec;\n\t}\n}"
  },
  {
    "function_name": "update_mtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1456-1472",
    "snippet": "static bool update_mtime(unsigned ivalid, bool trust_local_mtime)\n{\n\t/* Always update if mtime is explicitly set  */\n\tif (ivalid & ATTR_MTIME_SET)\n\t\treturn true;\n\n\t/* Or if kernel i_mtime is the official one */\n\tif (trust_local_mtime)\n\t\treturn true;\n\n\t/* If it's an open(O_TRUNC) or an ftruncate(), don't update */\n\tif ((ivalid & ATTR_SIZE) && (ivalid & (ATTR_OPEN | ATTR_FILE)))\n\t\treturn false;\n\n\t/* In all other cases update */\n\treturn true;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic bool update_mtime(unsigned ivalid, bool trust_local_mtime)\n{\n\t/* Always update if mtime is explicitly set  */\n\tif (ivalid & ATTR_MTIME_SET)\n\t\treturn true;\n\n\t/* Or if kernel i_mtime is the official one */\n\tif (trust_local_mtime)\n\t\treturn true;\n\n\t/* If it's an open(O_TRUNC) or an ftruncate(), don't update */\n\tif ((ivalid & ATTR_SIZE) && (ivalid & (ATTR_OPEN | ATTR_FILE)))\n\t\treturn false;\n\n\t/* In all other cases update */\n\treturn true;\n}"
  },
  {
    "function_name": "fuse_dir_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1444-1454",
    "snippet": "static long fuse_dir_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(file->f_mapping->host);\n\n\tif (fc->minor < 18)\n\t\treturn -ENOTTY;\n\n\treturn fuse_ioctl_common(file, cmd, arg,\n\t\t\t\t FUSE_IOCTL_COMPAT | FUSE_IOCTL_DIR);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_ioctl_common",
          "args": [
            "file",
            "cmd",
            "arg",
            "FUSE_IOCTL_COMPAT | FUSE_IOCTL_DIR"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ioctl_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2635-2648",
          "snippet": "long fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nlong fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic long fuse_dir_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(file->f_mapping->host);\n\n\tif (fc->minor < 18)\n\t\treturn -ENOTTY;\n\n\treturn fuse_ioctl_common(file, cmd, arg,\n\t\t\t\t FUSE_IOCTL_COMPAT | FUSE_IOCTL_DIR);\n}"
  },
  {
    "function_name": "fuse_dir_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1432-1442",
    "snippet": "static long fuse_dir_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(file->f_mapping->host);\n\n\t/* FUSE_IOCTL_DIR only supported for API version >= 7.18 */\n\tif (fc->minor < 18)\n\t\treturn -ENOTTY;\n\n\treturn fuse_ioctl_common(file, cmd, arg, FUSE_IOCTL_DIR);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_ioctl_common",
          "args": [
            "file",
            "cmd",
            "arg",
            "FUSE_IOCTL_DIR"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ioctl_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "2635-2648",
          "snippet": "long fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nlong fuse_ioctl_common(struct file *file, unsigned int cmd,\n\t\t       unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic long fuse_dir_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(file->f_mapping->host);\n\n\t/* FUSE_IOCTL_DIR only supported for API version >= 7.18 */\n\tif (fc->minor < 18)\n\t\treturn -ENOTTY;\n\n\treturn fuse_ioctl_common(file, cmd, arg, FUSE_IOCTL_DIR);\n}"
  },
  {
    "function_name": "fuse_dir_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1426-1430",
    "snippet": "static int fuse_dir_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t  int datasync)\n{\n\treturn fuse_fsync_common(file, start, end, datasync, 1);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_fsync_common",
          "args": [
            "file",
            "start",
            "end",
            "datasync",
            "1"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_fsync_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "440-491",
          "snippet": "int fuse_fsync_common(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync, int isdir)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tFUSE_ARGS(args);\n\tstruct fuse_fsync_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Start writeback against all dirty pages of the inode, then\n\t * wait for all outstanding writes, before sending the FSYNC\n\t * request.\n\t */\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\tgoto out;\n\n\tfuse_sync_writes(inode);\n\terr = sync_inode_metadata(inode, 1);\n\tif (err)\n\t\tgoto out;\n\n\tif ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))\n\t\tgoto out;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.fsync_flags = datasync ? 1 : 0;\n\targs.in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tif (isdir)\n\t\t\tfc->no_fsyncdir = 1;\n\t\telse\n\t\t\tfc->no_fsync = 1;\n\t\terr = 0;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_fsync_common(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync, int isdir)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tFUSE_ARGS(args);\n\tstruct fuse_fsync_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Start writeback against all dirty pages of the inode, then\n\t * wait for all outstanding writes, before sending the FSYNC\n\t * request.\n\t */\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\tgoto out;\n\n\tfuse_sync_writes(inode);\n\terr = sync_inode_metadata(inode, 1);\n\tif (err)\n\t\tgoto out;\n\n\tif ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))\n\t\tgoto out;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.fsync_flags = datasync ? 1 : 0;\n\targs.in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tif (isdir)\n\t\t\tfc->no_fsyncdir = 1;\n\t\telse\n\t\t\tfc->no_fsync = 1;\n\t\terr = 0;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_dir_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t  int datasync)\n{\n\treturn fuse_fsync_common(file, start, end, datasync, 1);\n}"
  },
  {
    "function_name": "fuse_dir_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1419-1424",
    "snippet": "static int fuse_dir_release(struct inode *inode, struct file *file)\n{\n\tfuse_release_common(file, FUSE_RELEASEDIR);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_release_common",
          "args": [
            "file",
            "FUSE_RELEASEDIR"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_release_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "246-277",
          "snippet": "void fuse_release_common(struct file *file, int opcode)\n{\n\tstruct fuse_file *ff;\n\tstruct fuse_req *req;\n\n\tff = file->private_data;\n\tif (unlikely(!ff))\n\t\treturn;\n\n\treq = ff->reserved_req;\n\tfuse_prepare_release(ff, file->f_flags, opcode);\n\n\tif (ff->flock) {\n\t\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\t\tinarg->release_flags |= FUSE_RELEASE_FLOCK_UNLOCK;\n\t\tinarg->lock_owner = fuse_lock_owner_id(ff->fc,\n\t\t\t\t\t\t       (fl_owner_t) file);\n\t}\n\t/* Hold inode until release is finished */\n\treq->misc.release.inode = igrab(file_inode(file));\n\n\t/*\n\t * Normally this will send the RELEASE request, however if\n\t * some asynchronous READ or WRITE requests are outstanding,\n\t * the sending will be delayed.\n\t *\n\t * Make the release synchronous if this is a fuseblk mount,\n\t * synchronous RELEASE is allowed (and desirable) in this case\n\t * because the server can be trusted not to screw up.\n\t */\n\tfuse_file_put(ff, ff->fc->destroy_req != NULL);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_release_common(struct file *file, int opcode)\n{\n\tstruct fuse_file *ff;\n\tstruct fuse_req *req;\n\n\tff = file->private_data;\n\tif (unlikely(!ff))\n\t\treturn;\n\n\treq = ff->reserved_req;\n\tfuse_prepare_release(ff, file->f_flags, opcode);\n\n\tif (ff->flock) {\n\t\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\t\tinarg->release_flags |= FUSE_RELEASE_FLOCK_UNLOCK;\n\t\tinarg->lock_owner = fuse_lock_owner_id(ff->fc,\n\t\t\t\t\t\t       (fl_owner_t) file);\n\t}\n\t/* Hold inode until release is finished */\n\treq->misc.release.inode = igrab(file_inode(file));\n\n\t/*\n\t * Normally this will send the RELEASE request, however if\n\t * some asynchronous READ or WRITE requests are outstanding,\n\t * the sending will be delayed.\n\t *\n\t * Make the release synchronous if this is a fuseblk mount,\n\t * synchronous RELEASE is allowed (and desirable) in this case\n\t * because the server can be trusted not to screw up.\n\t */\n\tfuse_file_put(ff, ff->fc->destroy_req != NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_dir_release(struct inode *inode, struct file *file)\n{\n\tfuse_release_common(file, FUSE_RELEASEDIR);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_dir_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1414-1417",
    "snippet": "static int fuse_dir_open(struct inode *inode, struct file *file)\n{\n\treturn fuse_open_common(inode, file, true);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_open_common",
          "args": [
            "inode",
            "file",
            "true"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_open_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "197-221",
          "snippet": "int fuse_open_common(struct inode *inode, struct file *file, bool isdir)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\tbool lock_inode = (file->f_flags & O_TRUNC) &&\n\t\t\t  fc->atomic_o_trunc &&\n\t\t\t  fc->writeback_cache;\n\n\terr = generic_file_open(inode, file);\n\tif (err)\n\t\treturn err;\n\n\tif (lock_inode)\n\t\tmutex_lock(&inode->i_mutex);\n\n\terr = fuse_do_open(fc, get_node_id(inode), file, isdir);\n\n\tif (!err)\n\t\tfuse_finish_open(inode, file);\n\n\tif (lock_inode)\n\t\tmutex_unlock(&inode->i_mutex);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_open_common(struct inode *inode, struct file *file, bool isdir)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\tbool lock_inode = (file->f_flags & O_TRUNC) &&\n\t\t\t  fc->atomic_o_trunc &&\n\t\t\t  fc->writeback_cache;\n\n\terr = generic_file_open(inode, file);\n\tif (err)\n\t\treturn err;\n\n\tif (lock_inode)\n\t\tmutex_lock(&inode->i_mutex);\n\n\terr = fuse_do_open(fc, get_node_id(inode), file, isdir);\n\n\tif (!err)\n\t\tfuse_finish_open(inode, file);\n\n\tif (lock_inode)\n\t\tmutex_unlock(&inode->i_mutex);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_dir_open(struct inode *inode, struct file *file)\n{\n\treturn fuse_open_common(inode, file, true);\n}"
  },
  {
    "function_name": "fuse_put_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1409-1412",
    "snippet": "static void fuse_put_link(struct dentry *dentry, struct nameidata *nd, void *c)\n{\n\tfree_link(nd_get_link(nd));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_link",
          "args": [
            "nd_get_link(nd)"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "free_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1397-1401",
          "snippet": "static void free_link(char *link)\n{\n\tif (!IS_ERR(link))\n\t\tfree_page((unsigned long) link);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void free_link(char *link)\n{\n\tif (!IS_ERR(link))\n\t\tfree_page((unsigned long) link);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nd_get_link",
          "args": [
            "nd"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "nd_get_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "723-726",
          "snippet": "char *nd_get_link(struct nameidata *nd)\n{\n\treturn nd->saved_names[nd->depth];\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nchar *nd_get_link(struct nameidata *nd)\n{\n\treturn nd->saved_names[nd->depth];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_put_link(struct dentry *dentry, struct nameidata *nd, void *c)\n{\n\tfree_link(nd_get_link(nd));\n}"
  },
  {
    "function_name": "fuse_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1403-1407",
    "snippet": "static void *fuse_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tnd_set_link(nd, read_link(dentry));\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "read_link(dentry)"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_link",
          "args": [
            "dentry"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "read_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1368-1395",
          "snippet": "static char *read_link(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tchar *link;\n\tssize_t ret;\n\n\tlink = (char *) __get_free_page(GFP_KERNEL);\n\tif (!link)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\targs.in.h.opcode = FUSE_READLINK;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.out.argvar = 1;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = PAGE_SIZE - 1;\n\targs.out.args[0].value = link;\n\tret = fuse_simple_request(fc, &args);\n\tif (ret < 0) {\n\t\tfree_page((unsigned long) link);\n\t\tlink = ERR_PTR(ret);\n\t} else {\n\t\tlink[ret] = '\\0';\n\t}\n\tfuse_invalidate_atime(inode);\n\treturn link;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic char *read_link(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tchar *link;\n\tssize_t ret;\n\n\tlink = (char *) __get_free_page(GFP_KERNEL);\n\tif (!link)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\targs.in.h.opcode = FUSE_READLINK;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.out.argvar = 1;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = PAGE_SIZE - 1;\n\targs.out.args[0].value = link;\n\tret = fuse_simple_request(fc, &args);\n\tif (ret < 0) {\n\t\tfree_page((unsigned long) link);\n\t\tlink = ERR_PTR(ret);\n\t} else {\n\t\tlink[ret] = '\\0';\n\t}\n\tfuse_invalidate_atime(inode);\n\treturn link;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void *fuse_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tnd_set_link(nd, read_link(dentry));\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1397-1401",
    "snippet": "static void free_link(char *link)\n{\n\tif (!IS_ERR(link))\n\t\tfree_page((unsigned long) link);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) link"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "link"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void free_link(char *link)\n{\n\tif (!IS_ERR(link))\n\t\tfree_page((unsigned long) link);\n}"
  },
  {
    "function_name": "read_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1368-1395",
    "snippet": "static char *read_link(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tchar *link;\n\tssize_t ret;\n\n\tlink = (char *) __get_free_page(GFP_KERNEL);\n\tif (!link)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\targs.in.h.opcode = FUSE_READLINK;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.out.argvar = 1;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = PAGE_SIZE - 1;\n\targs.out.args[0].value = link;\n\tret = fuse_simple_request(fc, &args);\n\tif (ret < 0) {\n\t\tfree_page((unsigned long) link);\n\t\tlink = ERR_PTR(ret);\n\t} else {\n\t\tlink[ret] = '\\0';\n\t}\n\tfuse_invalidate_atime(inode);\n\treturn link;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_invalidate_atime",
          "args": [
            "inode"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "119-123",
          "snippet": "void fuse_invalidate_atime(struct inode *inode)\n{\n\tif (!IS_RDONLY(inode))\n\t\tfuse_invalidate_attr(inode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_atime(struct inode *inode)\n{\n\tif (!IS_RDONLY(inode))\n\t\tfuse_invalidate_attr(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) link"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic char *read_link(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tchar *link;\n\tssize_t ret;\n\n\tlink = (char *) __get_free_page(GFP_KERNEL);\n\tif (!link)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\targs.in.h.opcode = FUSE_READLINK;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.out.argvar = 1;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = PAGE_SIZE - 1;\n\targs.out.args[0].value = link;\n\tret = fuse_simple_request(fc, &args);\n\tif (ret < 0) {\n\t\tfree_page((unsigned long) link);\n\t\tlink = ERR_PTR(ret);\n\t} else {\n\t\tlink[ret] = '\\0';\n\t}\n\tfuse_invalidate_atime(inode);\n\treturn link;\n}"
  },
  {
    "function_name": "fuse_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1312-1366",
    "snippet": "static int fuse_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint plus, err;\n\tsize_t nbytes;\n\tstruct page *page;\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tu64 attr_version = 0;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treq = fuse_get_req(fc, 1);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page) {\n\t\tfuse_put_request(fc, req);\n\t\treturn -ENOMEM;\n\t}\n\n\tplus = fuse_use_readdirplus(inode, ctx);\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = PAGE_SIZE;\n\tif (plus) {\n\t\tattr_version = fuse_get_attr_version(fc);\n\t\tfuse_read_fill(req, file, ctx->pos, PAGE_SIZE,\n\t\t\t       FUSE_READDIRPLUS);\n\t} else {\n\t\tfuse_read_fill(req, file, ctx->pos, PAGE_SIZE,\n\t\t\t       FUSE_READDIR);\n\t}\n\tfuse_request_send(fc, req);\n\tnbytes = req->out.args[0].size;\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (!err) {\n\t\tif (plus) {\n\t\t\terr = parse_dirplusfile(page_address(page), nbytes,\n\t\t\t\t\t\tfile, ctx,\n\t\t\t\t\t\tattr_version);\n\t\t} else {\n\t\t\terr = parse_dirfile(page_address(page), nbytes, file,\n\t\t\t\t\t    ctx);\n\t\t}\n\t}\n\n\t__free_page(page);\n\tfuse_invalidate_atime(inode);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_invalidate_atime",
          "args": [
            "inode"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "119-123",
          "snippet": "void fuse_invalidate_atime(struct inode *inode)\n{\n\tif (!IS_RDONLY(inode))\n\t\tfuse_invalidate_attr(inode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_atime(struct inode *inode)\n{\n\tif (!IS_RDONLY(inode))\n\t\tfuse_invalidate_attr(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_dirfile",
          "args": [
            "page_address(page)",
            "nbytes",
            "file",
            "ctx"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "parse_dirfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1136-1159",
          "snippet": "static int parse_dirfile(char *buf, size_t nbytes, struct file *file,\n\t\t\t struct dir_context *ctx)\n{\n\twhile (nbytes >= FUSE_NAME_OFFSET) {\n\t\tstruct fuse_dirent *dirent = (struct fuse_dirent *) buf;\n\t\tsize_t reclen = FUSE_DIRENT_SIZE(dirent);\n\t\tif (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX)\n\t\t\treturn -EIO;\n\t\tif (reclen > nbytes)\n\t\t\tbreak;\n\t\tif (memchr(dirent->name, '/', dirent->namelen) != NULL)\n\t\t\treturn -EIO;\n\n\t\tif (!dir_emit(ctx, dirent->name, dirent->namelen,\n\t\t\t       dirent->ino, dirent->type))\n\t\t\tbreak;\n\n\t\tbuf += reclen;\n\t\tnbytes -= reclen;\n\t\tctx->pos = dirent->off;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int parse_dirfile(char *buf, size_t nbytes, struct file *file,\n\t\t\t struct dir_context *ctx)\n{\n\twhile (nbytes >= FUSE_NAME_OFFSET) {\n\t\tstruct fuse_dirent *dirent = (struct fuse_dirent *) buf;\n\t\tsize_t reclen = FUSE_DIRENT_SIZE(dirent);\n\t\tif (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX)\n\t\t\treturn -EIO;\n\t\tif (reclen > nbytes)\n\t\t\tbreak;\n\t\tif (memchr(dirent->name, '/', dirent->namelen) != NULL)\n\t\t\treturn -EIO;\n\n\t\tif (!dir_emit(ctx, dirent->name, dirent->namelen,\n\t\t\t       dirent->ino, dirent->type))\n\t\t\tbreak;\n\n\t\tbuf += reclen;\n\t\tnbytes -= reclen;\n\t\tctx->pos = dirent->off;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_dirplusfile",
          "args": [
            "page_address(page)",
            "nbytes",
            "file",
            "ctx",
            "attr_version"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "parse_dirplusfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1268-1310",
          "snippet": "static int parse_dirplusfile(char *buf, size_t nbytes, struct file *file,\n\t\t\t     struct dir_context *ctx, u64 attr_version)\n{\n\tstruct fuse_direntplus *direntplus;\n\tstruct fuse_dirent *dirent;\n\tsize_t reclen;\n\tint over = 0;\n\tint ret;\n\n\twhile (nbytes >= FUSE_NAME_OFFSET_DIRENTPLUS) {\n\t\tdirentplus = (struct fuse_direntplus *) buf;\n\t\tdirent = &direntplus->dirent;\n\t\treclen = FUSE_DIRENTPLUS_SIZE(direntplus);\n\n\t\tif (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX)\n\t\t\treturn -EIO;\n\t\tif (reclen > nbytes)\n\t\t\tbreak;\n\t\tif (memchr(dirent->name, '/', dirent->namelen) != NULL)\n\t\t\treturn -EIO;\n\n\t\tif (!over) {\n\t\t\t/* We fill entries into dstbuf only as much as\n\t\t\t   it can hold. But we still continue iterating\n\t\t\t   over remaining entries to link them. If not,\n\t\t\t   we need to send a FORGET for each of those\n\t\t\t   which we did not link.\n\t\t\t*/\n\t\t\tover = !dir_emit(ctx, dirent->name, dirent->namelen,\n\t\t\t\t       dirent->ino, dirent->type);\n\t\t\tctx->pos = dirent->off;\n\t\t}\n\n\t\tbuf += reclen;\n\t\tnbytes -= reclen;\n\n\t\tret = fuse_direntplus_link(file, direntplus, attr_version);\n\t\tif (ret)\n\t\t\tfuse_force_forget(file, direntplus->entry_out.nodeid);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int parse_dirplusfile(char *buf, size_t nbytes, struct file *file,\n\t\t\t     struct dir_context *ctx, u64 attr_version)\n{\n\tstruct fuse_direntplus *direntplus;\n\tstruct fuse_dirent *dirent;\n\tsize_t reclen;\n\tint over = 0;\n\tint ret;\n\n\twhile (nbytes >= FUSE_NAME_OFFSET_DIRENTPLUS) {\n\t\tdirentplus = (struct fuse_direntplus *) buf;\n\t\tdirent = &direntplus->dirent;\n\t\treclen = FUSE_DIRENTPLUS_SIZE(direntplus);\n\n\t\tif (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX)\n\t\t\treturn -EIO;\n\t\tif (reclen > nbytes)\n\t\t\tbreak;\n\t\tif (memchr(dirent->name, '/', dirent->namelen) != NULL)\n\t\t\treturn -EIO;\n\n\t\tif (!over) {\n\t\t\t/* We fill entries into dstbuf only as much as\n\t\t\t   it can hold. But we still continue iterating\n\t\t\t   over remaining entries to link them. If not,\n\t\t\t   we need to send a FORGET for each of those\n\t\t\t   which we did not link.\n\t\t\t*/\n\t\t\tover = !dir_emit(ctx, dirent->name, dirent->namelen,\n\t\t\t\t       dirent->ino, dirent->type);\n\t\t\tctx->pos = dirent->off;\n\t\t}\n\n\t\tbuf += reclen;\n\t\tnbytes -= reclen;\n\n\t\tret = fuse_direntplus_link(file, direntplus, attr_version);\n\t\tif (ret)\n\t\t\tfuse_force_forget(file, direntplus->entry_out.nodeid);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_put_request",
          "args": [
            "fc",
            "req"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "277-299",
          "snippet": "void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_put_request(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (unlikely(req->background)) {\n\t\t\t/*\n\t\t\t * We get here in the unlikely case that a background\n\t\t\t * request was allocated but not sent\n\t\t\t */\n\t\t\tspin_lock(&fc->lock);\n\t\t\tif (!fc->blocked)\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_request_send",
          "args": [
            "fc",
            "req"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_request_send_background_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "647-652",
          "snippet": "void fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_request_send_background_locked(struct fuse_conn *fc,\n\t\t\t\t\t struct fuse_req *req)\n{\n\treq->isreply = 1;\n\tfuse_request_send_nowait_locked(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_read_fill",
          "args": [
            "req",
            "file",
            "ctx->pos",
            "PAGE_SIZE",
            "FUSE_READDIR"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_read_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "499-517",
          "snippet": "void fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,\n\t\t    size_t count, int opcode)\n{\n\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\tstruct fuse_file *ff = file->private_data;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\tinarg->flags = file->f_flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_read_in);\n\treq->in.args[0].value = inarg;\n\treq->out.argvar = 1;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = count;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,\n\t\t    size_t count, int opcode)\n{\n\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\tstruct fuse_file *ff = file->private_data;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\tinarg->flags = file->f_flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_read_in);\n\treq->in.args[0].value = inarg;\n\treq->out.argvar = 1;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_attr_version",
          "args": [
            "fc"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_attr_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "163-176",
          "snippet": "u64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_use_readdirplus",
          "args": [
            "inode",
            "ctx"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_use_readdirplus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "17-31",
          "snippet": "static bool fuse_use_readdirplus(struct inode *dir, struct dir_context *ctx)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tstruct fuse_inode *fi = get_fuse_inode(dir);\n\n\tif (!fc->do_readdirplus)\n\t\treturn false;\n\tif (!fc->readdirplus_auto)\n\t\treturn true;\n\tif (test_and_clear_bit(FUSE_I_ADVISE_RDPLUS, &fi->state))\n\t\treturn true;\n\tif (ctx->pos == 0)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic bool fuse_use_readdirplus(struct inode *dir, struct dir_context *ctx)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tstruct fuse_inode *fi = get_fuse_inode(dir);\n\n\tif (!fc->do_readdirplus)\n\t\treturn false;\n\tif (!fc->readdirplus_auto)\n\t\treturn true;\n\tif (test_and_clear_bit(FUSE_I_ADVISE_RDPLUS, &fi->state))\n\t\treturn true;\n\tif (ctx->pos == 0)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_req",
          "args": [
            "fc",
            "1"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_req_nofail_nopages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "258-275",
          "snippet": "struct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstruct fuse_req *fuse_get_req_nofail_nopages(struct fuse_conn *fc,\n\t\t\t\t\t     struct file *file)\n{\n\tstruct fuse_req *req;\n\n\tatomic_inc(&fc->num_waiting);\n\twait_event(fc->blocked_waitq, fc->initialized);\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\treq = fuse_request_alloc(0);\n\tif (!req)\n\t\treq = get_reserved_req(fc, file);\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treq->background = 0;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_readdir(struct file *file, struct dir_context *ctx)\n{\n\tint plus, err;\n\tsize_t nbytes;\n\tstruct page *page;\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tu64 attr_version = 0;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treq = fuse_get_req(fc, 1);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page) {\n\t\tfuse_put_request(fc, req);\n\t\treturn -ENOMEM;\n\t}\n\n\tplus = fuse_use_readdirplus(inode, ctx);\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\treq->page_descs[0].length = PAGE_SIZE;\n\tif (plus) {\n\t\tattr_version = fuse_get_attr_version(fc);\n\t\tfuse_read_fill(req, file, ctx->pos, PAGE_SIZE,\n\t\t\t       FUSE_READDIRPLUS);\n\t} else {\n\t\tfuse_read_fill(req, file, ctx->pos, PAGE_SIZE,\n\t\t\t       FUSE_READDIR);\n\t}\n\tfuse_request_send(fc, req);\n\tnbytes = req->out.args[0].size;\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (!err) {\n\t\tif (plus) {\n\t\t\terr = parse_dirplusfile(page_address(page), nbytes,\n\t\t\t\t\t\tfile, ctx,\n\t\t\t\t\t\tattr_version);\n\t\t} else {\n\t\t\terr = parse_dirfile(page_address(page), nbytes, file,\n\t\t\t\t\t    ctx);\n\t\t}\n\t}\n\n\t__free_page(page);\n\tfuse_invalidate_atime(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "parse_dirplusfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1268-1310",
    "snippet": "static int parse_dirplusfile(char *buf, size_t nbytes, struct file *file,\n\t\t\t     struct dir_context *ctx, u64 attr_version)\n{\n\tstruct fuse_direntplus *direntplus;\n\tstruct fuse_dirent *dirent;\n\tsize_t reclen;\n\tint over = 0;\n\tint ret;\n\n\twhile (nbytes >= FUSE_NAME_OFFSET_DIRENTPLUS) {\n\t\tdirentplus = (struct fuse_direntplus *) buf;\n\t\tdirent = &direntplus->dirent;\n\t\treclen = FUSE_DIRENTPLUS_SIZE(direntplus);\n\n\t\tif (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX)\n\t\t\treturn -EIO;\n\t\tif (reclen > nbytes)\n\t\t\tbreak;\n\t\tif (memchr(dirent->name, '/', dirent->namelen) != NULL)\n\t\t\treturn -EIO;\n\n\t\tif (!over) {\n\t\t\t/* We fill entries into dstbuf only as much as\n\t\t\t   it can hold. But we still continue iterating\n\t\t\t   over remaining entries to link them. If not,\n\t\t\t   we need to send a FORGET for each of those\n\t\t\t   which we did not link.\n\t\t\t*/\n\t\t\tover = !dir_emit(ctx, dirent->name, dirent->namelen,\n\t\t\t\t       dirent->ino, dirent->type);\n\t\t\tctx->pos = dirent->off;\n\t\t}\n\n\t\tbuf += reclen;\n\t\tnbytes -= reclen;\n\n\t\tret = fuse_direntplus_link(file, direntplus, attr_version);\n\t\tif (ret)\n\t\t\tfuse_force_forget(file, direntplus->entry_out.nodeid);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_force_forget",
          "args": [
            "file",
            "direntplus->entry_out.nodeid"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_force_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "654-673",
          "snippet": "void fuse_force_forget(struct file *file, u64 nodeid)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tstruct fuse_forget_in inarg;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.nlookup = 1;\n\treq = fuse_get_req_nofail_nopages(fc, file);\n\treq->in.h.opcode = FUSE_FORGET;\n\treq->in.h.nodeid = nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->isreply = 0;\n\t__fuse_request_send(fc, req);\n\t/* ignore errors */\n\tfuse_put_request(fc, req);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_force_forget(struct file *file, u64 nodeid)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tstruct fuse_forget_in inarg;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.nlookup = 1;\n\treq = fuse_get_req_nofail_nopages(fc, file);\n\treq->in.h.opcode = FUSE_FORGET;\n\treq->in.h.nodeid = nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->isreply = 0;\n\t__fuse_request_send(fc, req);\n\t/* ignore errors */\n\tfuse_put_request(fc, req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_direntplus_link",
          "args": [
            "file",
            "direntplus",
            "attr_version"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_direntplus_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1161-1266",
          "snippet": "static int fuse_direntplus_link(struct file *file,\n\t\t\t\tstruct fuse_direntplus *direntplus,\n\t\t\t\tu64 attr_version)\n{\n\tint err;\n\tstruct fuse_entry_out *o = &direntplus->entry_out;\n\tstruct fuse_dirent *dirent = &direntplus->dirent;\n\tstruct dentry *parent = file->f_path.dentry;\n\tstruct qstr name = QSTR_INIT(dirent->name, dirent->namelen);\n\tstruct dentry *dentry;\n\tstruct dentry *alias;\n\tstruct inode *dir = parent->d_inode;\n\tstruct fuse_conn *fc;\n\tstruct inode *inode;\n\n\tif (!o->nodeid) {\n\t\t/*\n\t\t * Unlike in the case of fuse_lookup, zero nodeid does not mean\n\t\t * ENOENT. Instead, it only means the userspace filesystem did\n\t\t * not want to return attributes/handle for this entry.\n\t\t *\n\t\t * So do nothing.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (name.name[0] == '.') {\n\t\t/*\n\t\t * We could potentially refresh the attributes of the directory\n\t\t * and its parent?\n\t\t */\n\t\tif (name.len == 1)\n\t\t\treturn 0;\n\t\tif (name.name[1] == '.' && name.len == 2)\n\t\t\treturn 0;\n\t}\n\n\tif (invalid_nodeid(o->nodeid))\n\t\treturn -EIO;\n\tif (!fuse_valid_type(o->attr.mode))\n\t\treturn -EIO;\n\n\tfc = get_fuse_conn(dir);\n\n\tname.hash = full_name_hash(name.name, name.len);\n\tdentry = d_lookup(parent, &name);\n\tif (dentry) {\n\t\tinode = dentry->d_inode;\n\t\tif (!inode) {\n\t\t\td_drop(dentry);\n\t\t} else if (get_node_id(inode) != o->nodeid ||\n\t\t\t   ((o->attr.mode ^ inode->i_mode) & S_IFMT)) {\n\t\t\td_invalidate(dentry);\n\t\t} else if (is_bad_inode(inode)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tstruct fuse_inode *fi;\n\t\t\tfi = get_fuse_inode(inode);\n\t\t\tspin_lock(&fc->lock);\n\t\t\tfi->nlookup++;\n\t\t\tspin_unlock(&fc->lock);\n\n\t\t\tfuse_change_attributes(inode, &o->attr,\n\t\t\t\t\t       entry_attr_timeout(o),\n\t\t\t\t\t       attr_version);\n\n\t\t\t/*\n\t\t\t * The other branch to 'found' comes via fuse_iget()\n\t\t\t * which bumps nlookup inside\n\t\t\t */\n\t\t\tgoto found;\n\t\t}\n\t\tdput(dentry);\n\t}\n\n\tdentry = d_alloc(parent, &name);\n\terr = -ENOMEM;\n\tif (!dentry)\n\t\tgoto out;\n\n\tinode = fuse_iget(dir->i_sb, o->nodeid, o->generation,\n\t\t\t  &o->attr, entry_attr_timeout(o), attr_version);\n\tif (!inode)\n\t\tgoto out;\n\n\talias = d_splice_alias(inode, dentry);\n\terr = PTR_ERR(alias);\n\tif (IS_ERR(alias))\n\t\tgoto out;\n\n\tif (alias) {\n\t\tdput(dentry);\n\t\tdentry = alias;\n\t}\n\nfound:\n\tif (fc->readdirplus_auto)\n\t\tset_bit(FUSE_I_INIT_RDPLUS, &get_fuse_inode(inode)->state);\n\tfuse_change_entry_timeout(dentry, o);\n\n\terr = 0;\nout:\n\tdput(dentry);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_direntplus_link(struct file *file,\n\t\t\t\tstruct fuse_direntplus *direntplus,\n\t\t\t\tu64 attr_version)\n{\n\tint err;\n\tstruct fuse_entry_out *o = &direntplus->entry_out;\n\tstruct fuse_dirent *dirent = &direntplus->dirent;\n\tstruct dentry *parent = file->f_path.dentry;\n\tstruct qstr name = QSTR_INIT(dirent->name, dirent->namelen);\n\tstruct dentry *dentry;\n\tstruct dentry *alias;\n\tstruct inode *dir = parent->d_inode;\n\tstruct fuse_conn *fc;\n\tstruct inode *inode;\n\n\tif (!o->nodeid) {\n\t\t/*\n\t\t * Unlike in the case of fuse_lookup, zero nodeid does not mean\n\t\t * ENOENT. Instead, it only means the userspace filesystem did\n\t\t * not want to return attributes/handle for this entry.\n\t\t *\n\t\t * So do nothing.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (name.name[0] == '.') {\n\t\t/*\n\t\t * We could potentially refresh the attributes of the directory\n\t\t * and its parent?\n\t\t */\n\t\tif (name.len == 1)\n\t\t\treturn 0;\n\t\tif (name.name[1] == '.' && name.len == 2)\n\t\t\treturn 0;\n\t}\n\n\tif (invalid_nodeid(o->nodeid))\n\t\treturn -EIO;\n\tif (!fuse_valid_type(o->attr.mode))\n\t\treturn -EIO;\n\n\tfc = get_fuse_conn(dir);\n\n\tname.hash = full_name_hash(name.name, name.len);\n\tdentry = d_lookup(parent, &name);\n\tif (dentry) {\n\t\tinode = dentry->d_inode;\n\t\tif (!inode) {\n\t\t\td_drop(dentry);\n\t\t} else if (get_node_id(inode) != o->nodeid ||\n\t\t\t   ((o->attr.mode ^ inode->i_mode) & S_IFMT)) {\n\t\t\td_invalidate(dentry);\n\t\t} else if (is_bad_inode(inode)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tstruct fuse_inode *fi;\n\t\t\tfi = get_fuse_inode(inode);\n\t\t\tspin_lock(&fc->lock);\n\t\t\tfi->nlookup++;\n\t\t\tspin_unlock(&fc->lock);\n\n\t\t\tfuse_change_attributes(inode, &o->attr,\n\t\t\t\t\t       entry_attr_timeout(o),\n\t\t\t\t\t       attr_version);\n\n\t\t\t/*\n\t\t\t * The other branch to 'found' comes via fuse_iget()\n\t\t\t * which bumps nlookup inside\n\t\t\t */\n\t\t\tgoto found;\n\t\t}\n\t\tdput(dentry);\n\t}\n\n\tdentry = d_alloc(parent, &name);\n\terr = -ENOMEM;\n\tif (!dentry)\n\t\tgoto out;\n\n\tinode = fuse_iget(dir->i_sb, o->nodeid, o->generation,\n\t\t\t  &o->attr, entry_attr_timeout(o), attr_version);\n\tif (!inode)\n\t\tgoto out;\n\n\talias = d_splice_alias(inode, dentry);\n\terr = PTR_ERR(alias);\n\tif (IS_ERR(alias))\n\t\tgoto out;\n\n\tif (alias) {\n\t\tdput(dentry);\n\t\tdentry = alias;\n\t}\n\nfound:\n\tif (fc->readdirplus_auto)\n\t\tset_bit(FUSE_I_INIT_RDPLUS, &get_fuse_inode(inode)->state);\n\tfuse_change_entry_timeout(dentry, o);\n\n\terr = 0;\nout:\n\tdput(dentry);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "dirent->name",
            "dirent->namelen",
            "dirent->ino",
            "dirent->type"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "dirent->name",
            "'/'",
            "dirent->namelen"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_DIRENTPLUS_SIZE",
          "args": [
            "direntplus"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int parse_dirplusfile(char *buf, size_t nbytes, struct file *file,\n\t\t\t     struct dir_context *ctx, u64 attr_version)\n{\n\tstruct fuse_direntplus *direntplus;\n\tstruct fuse_dirent *dirent;\n\tsize_t reclen;\n\tint over = 0;\n\tint ret;\n\n\twhile (nbytes >= FUSE_NAME_OFFSET_DIRENTPLUS) {\n\t\tdirentplus = (struct fuse_direntplus *) buf;\n\t\tdirent = &direntplus->dirent;\n\t\treclen = FUSE_DIRENTPLUS_SIZE(direntplus);\n\n\t\tif (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX)\n\t\t\treturn -EIO;\n\t\tif (reclen > nbytes)\n\t\t\tbreak;\n\t\tif (memchr(dirent->name, '/', dirent->namelen) != NULL)\n\t\t\treturn -EIO;\n\n\t\tif (!over) {\n\t\t\t/* We fill entries into dstbuf only as much as\n\t\t\t   it can hold. But we still continue iterating\n\t\t\t   over remaining entries to link them. If not,\n\t\t\t   we need to send a FORGET for each of those\n\t\t\t   which we did not link.\n\t\t\t*/\n\t\t\tover = !dir_emit(ctx, dirent->name, dirent->namelen,\n\t\t\t\t       dirent->ino, dirent->type);\n\t\t\tctx->pos = dirent->off;\n\t\t}\n\n\t\tbuf += reclen;\n\t\tnbytes -= reclen;\n\n\t\tret = fuse_direntplus_link(file, direntplus, attr_version);\n\t\tif (ret)\n\t\t\tfuse_force_forget(file, direntplus->entry_out.nodeid);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_direntplus_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1161-1266",
    "snippet": "static int fuse_direntplus_link(struct file *file,\n\t\t\t\tstruct fuse_direntplus *direntplus,\n\t\t\t\tu64 attr_version)\n{\n\tint err;\n\tstruct fuse_entry_out *o = &direntplus->entry_out;\n\tstruct fuse_dirent *dirent = &direntplus->dirent;\n\tstruct dentry *parent = file->f_path.dentry;\n\tstruct qstr name = QSTR_INIT(dirent->name, dirent->namelen);\n\tstruct dentry *dentry;\n\tstruct dentry *alias;\n\tstruct inode *dir = parent->d_inode;\n\tstruct fuse_conn *fc;\n\tstruct inode *inode;\n\n\tif (!o->nodeid) {\n\t\t/*\n\t\t * Unlike in the case of fuse_lookup, zero nodeid does not mean\n\t\t * ENOENT. Instead, it only means the userspace filesystem did\n\t\t * not want to return attributes/handle for this entry.\n\t\t *\n\t\t * So do nothing.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (name.name[0] == '.') {\n\t\t/*\n\t\t * We could potentially refresh the attributes of the directory\n\t\t * and its parent?\n\t\t */\n\t\tif (name.len == 1)\n\t\t\treturn 0;\n\t\tif (name.name[1] == '.' && name.len == 2)\n\t\t\treturn 0;\n\t}\n\n\tif (invalid_nodeid(o->nodeid))\n\t\treturn -EIO;\n\tif (!fuse_valid_type(o->attr.mode))\n\t\treturn -EIO;\n\n\tfc = get_fuse_conn(dir);\n\n\tname.hash = full_name_hash(name.name, name.len);\n\tdentry = d_lookup(parent, &name);\n\tif (dentry) {\n\t\tinode = dentry->d_inode;\n\t\tif (!inode) {\n\t\t\td_drop(dentry);\n\t\t} else if (get_node_id(inode) != o->nodeid ||\n\t\t\t   ((o->attr.mode ^ inode->i_mode) & S_IFMT)) {\n\t\t\td_invalidate(dentry);\n\t\t} else if (is_bad_inode(inode)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tstruct fuse_inode *fi;\n\t\t\tfi = get_fuse_inode(inode);\n\t\t\tspin_lock(&fc->lock);\n\t\t\tfi->nlookup++;\n\t\t\tspin_unlock(&fc->lock);\n\n\t\t\tfuse_change_attributes(inode, &o->attr,\n\t\t\t\t\t       entry_attr_timeout(o),\n\t\t\t\t\t       attr_version);\n\n\t\t\t/*\n\t\t\t * The other branch to 'found' comes via fuse_iget()\n\t\t\t * which bumps nlookup inside\n\t\t\t */\n\t\t\tgoto found;\n\t\t}\n\t\tdput(dentry);\n\t}\n\n\tdentry = d_alloc(parent, &name);\n\terr = -ENOMEM;\n\tif (!dentry)\n\t\tgoto out;\n\n\tinode = fuse_iget(dir->i_sb, o->nodeid, o->generation,\n\t\t\t  &o->attr, entry_attr_timeout(o), attr_version);\n\tif (!inode)\n\t\tgoto out;\n\n\talias = d_splice_alias(inode, dentry);\n\terr = PTR_ERR(alias);\n\tif (IS_ERR(alias))\n\t\tgoto out;\n\n\tif (alias) {\n\t\tdput(dentry);\n\t\tdentry = alias;\n\t}\n\nfound:\n\tif (fc->readdirplus_auto)\n\t\tset_bit(FUSE_I_INIT_RDPLUS, &get_fuse_inode(inode)->state);\n\tfuse_change_entry_timeout(dentry, o);\n\n\terr = 0;\nout:\n\tdput(dentry);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_change_entry_timeout",
          "args": [
            "dentry",
            "o"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_change_entry_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "89-94",
          "snippet": "static void fuse_change_entry_timeout(struct dentry *entry,\n\t\t\t\t      struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\ttime_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_change_entry_timeout(struct dentry *entry,\n\t\t\t\t      struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\ttime_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FUSE_I_INIT_RDPLUS",
            "&get_fuse_inode(inode)->state"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "alias"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "alias"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_iget",
          "args": [
            "dir->i_sb",
            "o->nodeid",
            "o->generation",
            "&o->attr",
            "entry_attr_timeout(o)",
            "attr_version"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "293-327",
          "snippet": "struct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n retry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t/* Inode has changed type, any I/O on the old should fail */\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fc->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fc->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n retry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t/* Inode has changed type, any I/O on the old should fail */\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fc->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fc->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_attr_timeout",
          "args": [
            "o"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "entry_attr_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "101-104",
          "snippet": "static u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "parent",
            "&name"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_change_attributes",
          "args": [
            "inode",
            "&o->attr",
            "entry_attr_timeout(o)",
            "attr_version"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_change_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "199-251",
          "snippet": "void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    u64 attr_valid, u64 attr_version)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tstruct timespec old_mtime;\n\n\tspin_lock(&fc->lock);\n\tif ((attr_version != 0 && fi->attr_version > attr_version) ||\n\t    test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn;\n\t}\n\n\told_mtime = inode->i_mtime;\n\tfuse_change_attributes_common(inode, attr, attr_valid);\n\n\toldsize = inode->i_size;\n\t/*\n\t * In case of writeback_cache enabled, the cached writes beyond EOF\n\t * extend local i_size without keeping userspace server in sync. So,\n\t * attr->size coming from server can be stale. We cannot trust it.\n\t */\n\tif (!is_wb || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, attr->size);\n\tspin_unlock(&fc->lock);\n\n\tif (!is_wb && S_ISREG(inode->i_mode)) {\n\t\tbool inval = false;\n\n\t\tif (oldsize != attr->size) {\n\t\t\ttruncate_pagecache(inode, attr->size);\n\t\t\tinval = true;\n\t\t} else if (fc->auto_inval_data) {\n\t\t\tstruct timespec new_mtime = {\n\t\t\t\t.tv_sec = attr->mtime,\n\t\t\t\t.tv_nsec = attr->mtimensec,\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Auto inval mode also checks and invalidates if mtime\n\t\t\t * has changed.\n\t\t\t */\n\t\t\tif (!timespec_equal(&old_mtime, &new_mtime))\n\t\t\t\tinval = true;\n\t\t}\n\n\t\tif (inval)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    u64 attr_valid, u64 attr_version)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tstruct timespec old_mtime;\n\n\tspin_lock(&fc->lock);\n\tif ((attr_version != 0 && fi->attr_version > attr_version) ||\n\t    test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn;\n\t}\n\n\told_mtime = inode->i_mtime;\n\tfuse_change_attributes_common(inode, attr, attr_valid);\n\n\toldsize = inode->i_size;\n\t/*\n\t * In case of writeback_cache enabled, the cached writes beyond EOF\n\t * extend local i_size without keeping userspace server in sync. So,\n\t * attr->size coming from server can be stale. We cannot trust it.\n\t */\n\tif (!is_wb || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, attr->size);\n\tspin_unlock(&fc->lock);\n\n\tif (!is_wb && S_ISREG(inode->i_mode)) {\n\t\tbool inval = false;\n\n\t\tif (oldsize != attr->size) {\n\t\t\ttruncate_pagecache(inode, attr->size);\n\t\t\tinval = true;\n\t\t} else if (fc->auto_inval_data) {\n\t\t\tstruct timespec new_mtime = {\n\t\t\t\t.tv_sec = attr->mtime,\n\t\t\t\t.tv_nsec = attr->mtimensec,\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Auto inval mode also checks and invalidates if mtime\n\t\t\t * has changed.\n\t\t\t */\n\t\t\tif (!timespec_equal(&old_mtime, &new_mtime))\n\t\t\t\tinval = true;\n\t\t}\n\n\t\tif (inval)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_invalidate",
          "args": [
            "dentry"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "d_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1465-1506",
          "snippet": "void d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lookup",
          "args": [
            "parent",
            "&name"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "name.name",
            "name.len"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "dir"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_valid_type",
          "args": [
            "o->attr.mode"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_valid_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "279-283",
          "snippet": "int fuse_valid_type(int m)\n{\n\treturn S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||\n\t\tS_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_valid_type(int m)\n{\n\treturn S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||\n\t\tS_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalid_nodeid",
          "args": [
            "o->nodeid"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "invalid_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "270-273",
          "snippet": "static int invalid_nodeid(u64 nodeid)\n{\n\treturn !nodeid || nodeid == FUSE_ROOT_ID;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int invalid_nodeid(u64 nodeid)\n{\n\treturn !nodeid || nodeid == FUSE_ROOT_ID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSTR_INIT",
          "args": [
            "dirent->name",
            "dirent->namelen"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_direntplus_link(struct file *file,\n\t\t\t\tstruct fuse_direntplus *direntplus,\n\t\t\t\tu64 attr_version)\n{\n\tint err;\n\tstruct fuse_entry_out *o = &direntplus->entry_out;\n\tstruct fuse_dirent *dirent = &direntplus->dirent;\n\tstruct dentry *parent = file->f_path.dentry;\n\tstruct qstr name = QSTR_INIT(dirent->name, dirent->namelen);\n\tstruct dentry *dentry;\n\tstruct dentry *alias;\n\tstruct inode *dir = parent->d_inode;\n\tstruct fuse_conn *fc;\n\tstruct inode *inode;\n\n\tif (!o->nodeid) {\n\t\t/*\n\t\t * Unlike in the case of fuse_lookup, zero nodeid does not mean\n\t\t * ENOENT. Instead, it only means the userspace filesystem did\n\t\t * not want to return attributes/handle for this entry.\n\t\t *\n\t\t * So do nothing.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (name.name[0] == '.') {\n\t\t/*\n\t\t * We could potentially refresh the attributes of the directory\n\t\t * and its parent?\n\t\t */\n\t\tif (name.len == 1)\n\t\t\treturn 0;\n\t\tif (name.name[1] == '.' && name.len == 2)\n\t\t\treturn 0;\n\t}\n\n\tif (invalid_nodeid(o->nodeid))\n\t\treturn -EIO;\n\tif (!fuse_valid_type(o->attr.mode))\n\t\treturn -EIO;\n\n\tfc = get_fuse_conn(dir);\n\n\tname.hash = full_name_hash(name.name, name.len);\n\tdentry = d_lookup(parent, &name);\n\tif (dentry) {\n\t\tinode = dentry->d_inode;\n\t\tif (!inode) {\n\t\t\td_drop(dentry);\n\t\t} else if (get_node_id(inode) != o->nodeid ||\n\t\t\t   ((o->attr.mode ^ inode->i_mode) & S_IFMT)) {\n\t\t\td_invalidate(dentry);\n\t\t} else if (is_bad_inode(inode)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tstruct fuse_inode *fi;\n\t\t\tfi = get_fuse_inode(inode);\n\t\t\tspin_lock(&fc->lock);\n\t\t\tfi->nlookup++;\n\t\t\tspin_unlock(&fc->lock);\n\n\t\t\tfuse_change_attributes(inode, &o->attr,\n\t\t\t\t\t       entry_attr_timeout(o),\n\t\t\t\t\t       attr_version);\n\n\t\t\t/*\n\t\t\t * The other branch to 'found' comes via fuse_iget()\n\t\t\t * which bumps nlookup inside\n\t\t\t */\n\t\t\tgoto found;\n\t\t}\n\t\tdput(dentry);\n\t}\n\n\tdentry = d_alloc(parent, &name);\n\terr = -ENOMEM;\n\tif (!dentry)\n\t\tgoto out;\n\n\tinode = fuse_iget(dir->i_sb, o->nodeid, o->generation,\n\t\t\t  &o->attr, entry_attr_timeout(o), attr_version);\n\tif (!inode)\n\t\tgoto out;\n\n\talias = d_splice_alias(inode, dentry);\n\terr = PTR_ERR(alias);\n\tif (IS_ERR(alias))\n\t\tgoto out;\n\n\tif (alias) {\n\t\tdput(dentry);\n\t\tdentry = alias;\n\t}\n\nfound:\n\tif (fc->readdirplus_auto)\n\t\tset_bit(FUSE_I_INIT_RDPLUS, &get_fuse_inode(inode)->state);\n\tfuse_change_entry_timeout(dentry, o);\n\n\terr = 0;\nout:\n\tdput(dentry);\n\treturn err;\n}"
  },
  {
    "function_name": "parse_dirfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1136-1159",
    "snippet": "static int parse_dirfile(char *buf, size_t nbytes, struct file *file,\n\t\t\t struct dir_context *ctx)\n{\n\twhile (nbytes >= FUSE_NAME_OFFSET) {\n\t\tstruct fuse_dirent *dirent = (struct fuse_dirent *) buf;\n\t\tsize_t reclen = FUSE_DIRENT_SIZE(dirent);\n\t\tif (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX)\n\t\t\treturn -EIO;\n\t\tif (reclen > nbytes)\n\t\t\tbreak;\n\t\tif (memchr(dirent->name, '/', dirent->namelen) != NULL)\n\t\t\treturn -EIO;\n\n\t\tif (!dir_emit(ctx, dirent->name, dirent->namelen,\n\t\t\t       dirent->ino, dirent->type))\n\t\t\tbreak;\n\n\t\tbuf += reclen;\n\t\tnbytes -= reclen;\n\t\tctx->pos = dirent->off;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "dirent->name",
            "dirent->namelen",
            "dirent->ino",
            "dirent->type"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "dirent->name",
            "'/'",
            "dirent->namelen"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_DIRENT_SIZE",
          "args": [
            "dirent"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int parse_dirfile(char *buf, size_t nbytes, struct file *file,\n\t\t\t struct dir_context *ctx)\n{\n\twhile (nbytes >= FUSE_NAME_OFFSET) {\n\t\tstruct fuse_dirent *dirent = (struct fuse_dirent *) buf;\n\t\tsize_t reclen = FUSE_DIRENT_SIZE(dirent);\n\t\tif (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX)\n\t\t\treturn -EIO;\n\t\tif (reclen > nbytes)\n\t\t\tbreak;\n\t\tif (memchr(dirent->name, '/', dirent->namelen) != NULL)\n\t\t\treturn -EIO;\n\n\t\tif (!dir_emit(ctx, dirent->name, dirent->namelen,\n\t\t\t       dirent->ino, dirent->type))\n\t\t\tbreak;\n\n\t\tbuf += reclen;\n\t\tnbytes -= reclen;\n\t\tctx->pos = dirent->off;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1080-1134",
    "snippet": "static int fuse_permission(struct inode *inode, int mask)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tbool refreshed = false;\n\tint err = 0;\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\t/*\n\t * If attributes are needed, refresh them before proceeding\n\t */\n\tif ((fc->flags & FUSE_DEFAULT_PERMISSIONS) ||\n\t    ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tif (time_before64(fi->i_time, get_jiffies_64())) {\n\t\t\trefreshed = true;\n\n\t\t\terr = fuse_perm_getattr(inode, mask);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (fc->flags & FUSE_DEFAULT_PERMISSIONS) {\n\t\terr = generic_permission(inode, mask);\n\n\t\t/* If permission is denied, try to refresh file\n\t\t   attributes.  This is also needed, because the root\n\t\t   node will at first have no permissions */\n\t\tif (err == -EACCES && !refreshed) {\n\t\t\terr = fuse_perm_getattr(inode, mask);\n\t\t\tif (!err)\n\t\t\t\terr = generic_permission(inode, mask);\n\t\t}\n\n\t\t/* Note: the opposite of the above test does not\n\t\t   exist.  So if permissions are revoked this won't be\n\t\t   noticed immediately, only after the attribute\n\t\t   timeout has expired */\n\t} else if (mask & (MAY_ACCESS | MAY_CHDIR)) {\n\t\terr = fuse_access(inode, mask);\n\t} else if ((mask & MAY_EXEC) && S_ISREG(inode->i_mode)) {\n\t\tif (!(inode->i_mode & S_IXUGO)) {\n\t\t\tif (refreshed)\n\t\t\t\treturn -EACCES;\n\n\t\t\terr = fuse_perm_getattr(inode, mask);\n\t\t\tif (!err && !(inode->i_mode & S_IXUGO))\n\t\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_perm_getattr",
          "args": [
            "inode",
            "mask"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_perm_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1059-1065",
          "snippet": "static int fuse_perm_getattr(struct inode *inode, int mask)\n{\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\treturn fuse_do_getattr(inode, NULL, NULL);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_perm_getattr(struct inode *inode, int mask)\n{\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\treturn fuse_do_getattr(inode, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_access",
          "args": [
            "inode",
            "mask"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1032-1057",
          "snippet": "static int fuse_access(struct inode *inode, int mask)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_access_in inarg;\n\tint err;\n\n\tBUG_ON(mask & MAY_NOT_BLOCK);\n\n\tif (fc->no_access)\n\t\treturn 0;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mask = mask & (MAY_READ | MAY_WRITE | MAY_EXEC);\n\targs.in.h.opcode = FUSE_ACCESS;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_access = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_access(struct inode *inode, int mask)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_access_in inarg;\n\tint err;\n\n\tBUG_ON(mask & MAY_NOT_BLOCK);\n\n\tif (fc->no_access)\n\t\treturn 0;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mask = mask & (MAY_READ | MAY_WRITE | MAY_EXEC);\n\targs.in.h.opcode = FUSE_ACCESS;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_access = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before64",
          "args": [
            "fi->i_time",
            "get_jiffies_64()"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_jiffies_64",
          "args": [],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_allow_current_process",
          "args": [
            "fc"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_allow_current_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "1013-1030",
          "snippet": "int fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_permission(struct inode *inode, int mask)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tbool refreshed = false;\n\tint err = 0;\n\n\tif (!fuse_allow_current_process(fc))\n\t\treturn -EACCES;\n\n\t/*\n\t * If attributes are needed, refresh them before proceeding\n\t */\n\tif ((fc->flags & FUSE_DEFAULT_PERMISSIONS) ||\n\t    ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tif (time_before64(fi->i_time, get_jiffies_64())) {\n\t\t\trefreshed = true;\n\n\t\t\terr = fuse_perm_getattr(inode, mask);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (fc->flags & FUSE_DEFAULT_PERMISSIONS) {\n\t\terr = generic_permission(inode, mask);\n\n\t\t/* If permission is denied, try to refresh file\n\t\t   attributes.  This is also needed, because the root\n\t\t   node will at first have no permissions */\n\t\tif (err == -EACCES && !refreshed) {\n\t\t\terr = fuse_perm_getattr(inode, mask);\n\t\t\tif (!err)\n\t\t\t\terr = generic_permission(inode, mask);\n\t\t}\n\n\t\t/* Note: the opposite of the above test does not\n\t\t   exist.  So if permissions are revoked this won't be\n\t\t   noticed immediately, only after the attribute\n\t\t   timeout has expired */\n\t} else if (mask & (MAY_ACCESS | MAY_CHDIR)) {\n\t\terr = fuse_access(inode, mask);\n\t} else if ((mask & MAY_EXEC) && S_ISREG(inode->i_mode)) {\n\t\tif (!(inode->i_mode & S_IXUGO)) {\n\t\t\tif (refreshed)\n\t\t\t\treturn -EACCES;\n\n\t\t\terr = fuse_perm_getattr(inode, mask);\n\t\t\tif (!err && !(inode->i_mode & S_IXUGO))\n\t\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_perm_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1059-1065",
    "snippet": "static int fuse_perm_getattr(struct inode *inode, int mask)\n{\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\treturn fuse_do_getattr(inode, NULL, NULL);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_do_getattr",
          "args": [
            "inode",
            "NULL",
            "NULL"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "864-907",
          "snippet": "static int fuse_do_getattr(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file)\n{\n\tint err;\n\tstruct fuse_getattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tu64 attr_version;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\t/* Directories have separate file-handle space */\n\tif (file && S_ISREG(inode->i_mode)) {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\targs.in.h.opcode = FUSE_GETATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\tif ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\t\tmake_bad_inode(inode);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tfuse_change_attributes(inode, &outarg.attr,\n\t\t\t\t\t       attr_timeout(&outarg),\n\t\t\t\t\t       attr_version);\n\t\t\tif (stat)\n\t\t\t\tfuse_fillattr(inode, &outarg.attr, stat);\n\t\t}\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_do_getattr(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file)\n{\n\tint err;\n\tstruct fuse_getattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tu64 attr_version;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\t/* Directories have separate file-handle space */\n\tif (file && S_ISREG(inode->i_mode)) {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\targs.in.h.opcode = FUSE_GETATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\tif ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\t\tmake_bad_inode(inode);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tfuse_change_attributes(inode, &outarg.attr,\n\t\t\t\t\t       attr_timeout(&outarg),\n\t\t\t\t\t       attr_version);\n\t\t\tif (stat)\n\t\t\t\tfuse_fillattr(inode, &outarg.attr, stat);\n\t\t}\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_perm_getattr(struct inode *inode, int mask)\n{\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\treturn fuse_do_getattr(inode, NULL, NULL);\n}"
  },
  {
    "function_name": "fuse_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1032-1057",
    "snippet": "static int fuse_access(struct inode *inode, int mask)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_access_in inarg;\n\tint err;\n\n\tBUG_ON(mask & MAY_NOT_BLOCK);\n\n\tif (fc->no_access)\n\t\treturn 0;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mask = mask & (MAY_READ | MAY_WRITE | MAY_EXEC);\n\targs.in.h.opcode = FUSE_ACCESS;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_access = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mask & MAY_NOT_BLOCK"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_access(struct inode *inode, int mask)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_access_in inarg;\n\tint err;\n\n\tBUG_ON(mask & MAY_NOT_BLOCK);\n\n\tif (fc->no_access)\n\t\treturn 0;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mask = mask & (MAY_READ | MAY_WRITE | MAY_EXEC);\n\targs.in.h.opcode = FUSE_ACCESS;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (err == -ENOSYS) {\n\t\tfc->no_access = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_allow_current_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "1013-1030",
    "snippet": "int fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "cred->gid",
            "fc->group_id"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "cred->sgid",
            "fc->group_id"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "cred->egid",
            "fc->group_id"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->uid",
            "fc->user_id"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_allow_current_process(struct fuse_conn *fc)\n{\n\tconst struct cred *cred;\n\n\tif (fc->flags & FUSE_ALLOW_OTHER)\n\t\treturn 1;\n\n\tcred = current_cred();\n\tif (uid_eq(cred->euid, fc->user_id) &&\n\t    uid_eq(cred->suid, fc->user_id) &&\n\t    uid_eq(cred->uid,  fc->user_id) &&\n\t    gid_eq(cred->egid, fc->group_id) &&\n\t    gid_eq(cred->sgid, fc->group_id) &&\n\t    gid_eq(cred->gid,  fc->group_id))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_reverse_inval_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "935-998",
    "snippet": "int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,\n\t\t\t     u64 child_nodeid, struct qstr *name)\n{\n\tint err = -ENOTDIR;\n\tstruct inode *parent;\n\tstruct dentry *dir;\n\tstruct dentry *entry;\n\n\tparent = ilookup5(sb, parent_nodeid, fuse_inode_eq, &parent_nodeid);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&parent->i_mutex);\n\tif (!S_ISDIR(parent->i_mode))\n\t\tgoto unlock;\n\n\terr = -ENOENT;\n\tdir = d_find_alias(parent);\n\tif (!dir)\n\t\tgoto unlock;\n\n\tentry = d_lookup(dir, name);\n\tdput(dir);\n\tif (!entry)\n\t\tgoto unlock;\n\n\tfuse_invalidate_attr(parent);\n\tfuse_invalidate_entry(entry);\n\n\tif (child_nodeid != 0 && entry->d_inode) {\n\t\tmutex_lock(&entry->d_inode->i_mutex);\n\t\tif (get_node_id(entry->d_inode) != child_nodeid) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_mountpoint(entry)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_is_dir(entry)) {\n\t\t\tshrink_dcache_parent(entry);\n\t\t\tif (!simple_empty(entry)) {\n\t\t\t\terr = -ENOTEMPTY;\n\t\t\t\tgoto badentry;\n\t\t\t}\n\t\t\tentry->d_inode->i_flags |= S_DEAD;\n\t\t}\n\t\tdont_mount(entry);\n\t\tclear_nlink(entry->d_inode);\n\t\terr = 0;\n badentry:\n\t\tmutex_unlock(&entry->d_inode->i_mutex);\n\t\tif (!err)\n\t\t\td_delete(entry);\n\t} else {\n\t\terr = 0;\n\t}\n\tdput(entry);\n\n unlock:\n\tmutex_unlock(&parent->i_mutex);\n\tiput(parent);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "parent"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&parent->i_mutex"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "entry"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "entry"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "afs_d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "699-717",
          "snippet": "static int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
            "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
            "static int afs_d_delete(const struct dentry *dentry);",
            "static void afs_d_release(struct dentry *dentry);",
            "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
            "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
            "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&entry->d_inode->i_mutex"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "entry->d_inode"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dont_mount",
          "args": [
            "entry"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_empty",
          "args": [
            "entry"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "simple_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "284-302",
          "snippet": "int simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_parent",
          "args": [
            "entry"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1361-1377",
          "snippet": "void shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "entry"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "entry"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "entry->d_inode"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&entry->d_inode->i_mutex"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_entry",
          "args": [
            "entry"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "142-146",
          "snippet": "static void fuse_invalidate_entry(struct dentry *entry)\n{\n\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_invalidate_entry(struct dentry *entry)\n{\n\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "parent"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lookup",
          "args": [
            "dir",
            "name"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "parent"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "parent->i_mode"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&parent->i_mutex"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilookup5",
          "args": [
            "sb",
            "parent_nodeid",
            "fuse_inode_eq",
            "&parent_nodeid"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1239-1247",
          "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,\n\t\t\t     u64 child_nodeid, struct qstr *name)\n{\n\tint err = -ENOTDIR;\n\tstruct inode *parent;\n\tstruct dentry *dir;\n\tstruct dentry *entry;\n\n\tparent = ilookup5(sb, parent_nodeid, fuse_inode_eq, &parent_nodeid);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&parent->i_mutex);\n\tif (!S_ISDIR(parent->i_mode))\n\t\tgoto unlock;\n\n\terr = -ENOENT;\n\tdir = d_find_alias(parent);\n\tif (!dir)\n\t\tgoto unlock;\n\n\tentry = d_lookup(dir, name);\n\tdput(dir);\n\tif (!entry)\n\t\tgoto unlock;\n\n\tfuse_invalidate_attr(parent);\n\tfuse_invalidate_entry(entry);\n\n\tif (child_nodeid != 0 && entry->d_inode) {\n\t\tmutex_lock(&entry->d_inode->i_mutex);\n\t\tif (get_node_id(entry->d_inode) != child_nodeid) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_mountpoint(entry)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto badentry;\n\t\t}\n\t\tif (d_is_dir(entry)) {\n\t\t\tshrink_dcache_parent(entry);\n\t\t\tif (!simple_empty(entry)) {\n\t\t\t\terr = -ENOTEMPTY;\n\t\t\t\tgoto badentry;\n\t\t\t}\n\t\t\tentry->d_inode->i_flags |= S_DEAD;\n\t\t}\n\t\tdont_mount(entry);\n\t\tclear_nlink(entry->d_inode);\n\t\terr = 0;\n badentry:\n\t\tmutex_unlock(&entry->d_inode->i_mutex);\n\t\tif (!err)\n\t\t\td_delete(entry);\n\t} else {\n\t\terr = 0;\n\t}\n\tdput(entry);\n\n unlock:\n\tmutex_unlock(&parent->i_mutex);\n\tiput(parent);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_update_attributes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "909-933",
    "snippet": "int fuse_update_attributes(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file, bool *refreshed)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err;\n\tbool r;\n\n\tif (time_before64(fi->i_time, get_jiffies_64())) {\n\t\tr = true;\n\t\terr = fuse_do_getattr(inode, stat, file);\n\t} else {\n\t\tr = false;\n\t\terr = 0;\n\t\tif (stat) {\n\t\t\tgeneric_fillattr(inode, stat);\n\t\t\tstat->mode = fi->orig_i_mode;\n\t\t\tstat->ino = fi->orig_ino;\n\t\t}\n\t}\n\n\tif (refreshed != NULL)\n\t\t*refreshed = r;\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_do_getattr",
          "args": [
            "inode",
            "stat",
            "file"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "864-907",
          "snippet": "static int fuse_do_getattr(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file)\n{\n\tint err;\n\tstruct fuse_getattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tu64 attr_version;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\t/* Directories have separate file-handle space */\n\tif (file && S_ISREG(inode->i_mode)) {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\targs.in.h.opcode = FUSE_GETATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\tif ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\t\tmake_bad_inode(inode);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tfuse_change_attributes(inode, &outarg.attr,\n\t\t\t\t\t       attr_timeout(&outarg),\n\t\t\t\t\t       attr_version);\n\t\t\tif (stat)\n\t\t\t\tfuse_fillattr(inode, &outarg.attr, stat);\n\t\t}\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_do_getattr(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file)\n{\n\tint err;\n\tstruct fuse_getattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tu64 attr_version;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\t/* Directories have separate file-handle space */\n\tif (file && S_ISREG(inode->i_mode)) {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\targs.in.h.opcode = FUSE_GETATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\tif ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\t\tmake_bad_inode(inode);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tfuse_change_attributes(inode, &outarg.attr,\n\t\t\t\t\t       attr_timeout(&outarg),\n\t\t\t\t\t       attr_version);\n\t\t\tif (stat)\n\t\t\t\tfuse_fillattr(inode, &outarg.attr, stat);\n\t\t}\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before64",
          "args": [
            "fi->i_time",
            "get_jiffies_64()"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_jiffies_64",
          "args": [],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_update_attributes(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file, bool *refreshed)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint err;\n\tbool r;\n\n\tif (time_before64(fi->i_time, get_jiffies_64())) {\n\t\tr = true;\n\t\terr = fuse_do_getattr(inode, stat, file);\n\t} else {\n\t\tr = false;\n\t\terr = 0;\n\t\tif (stat) {\n\t\t\tgeneric_fillattr(inode, stat);\n\t\t\tstat->mode = fi->orig_i_mode;\n\t\t\tstat->ino = fi->orig_ino;\n\t\t}\n\t}\n\n\tif (refreshed != NULL)\n\t\t*refreshed = r;\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_do_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "864-907",
    "snippet": "static int fuse_do_getattr(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file)\n{\n\tint err;\n\tstruct fuse_getattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tu64 attr_version;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\t/* Directories have separate file-handle space */\n\tif (file && S_ISREG(inode->i_mode)) {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\targs.in.h.opcode = FUSE_GETATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\tif ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\t\tmake_bad_inode(inode);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tfuse_change_attributes(inode, &outarg.attr,\n\t\t\t\t\t       attr_timeout(&outarg),\n\t\t\t\t\t       attr_version);\n\t\t\tif (stat)\n\t\t\t\tfuse_fillattr(inode, &outarg.attr, stat);\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_fillattr",
          "args": [
            "inode",
            "&outarg.attr",
            "stat"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "825-862",
          "snippet": "static void fuse_fillattr(struct inode *inode, struct fuse_attr *attr,\n\t\t\t  struct kstat *stat)\n{\n\tunsigned int blkbits;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t/* see the comment in fuse_change_attributes() */\n\tif (fc->writeback_cache && S_ISREG(inode->i_mode)) {\n\t\tattr->size = i_size_read(inode);\n\t\tattr->mtime = inode->i_mtime.tv_sec;\n\t\tattr->mtimensec = inode->i_mtime.tv_nsec;\n\t\tattr->ctime = inode->i_ctime.tv_sec;\n\t\tattr->ctimensec = inode->i_ctime.tv_nsec;\n\t}\n\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = attr->ino;\n\tstat->mode = (inode->i_mode & S_IFMT) | (attr->mode & 07777);\n\tstat->nlink = attr->nlink;\n\tstat->uid = make_kuid(&init_user_ns, attr->uid);\n\tstat->gid = make_kgid(&init_user_ns, attr->gid);\n\tstat->rdev = inode->i_rdev;\n\tstat->atime.tv_sec = attr->atime;\n\tstat->atime.tv_nsec = attr->atimensec;\n\tstat->mtime.tv_sec = attr->mtime;\n\tstat->mtime.tv_nsec = attr->mtimensec;\n\tstat->ctime.tv_sec = attr->ctime;\n\tstat->ctime.tv_nsec = attr->ctimensec;\n\tstat->size = attr->size;\n\tstat->blocks = attr->blocks;\n\n\tif (attr->blksize != 0)\n\t\tblkbits = ilog2(attr->blksize);\n\telse\n\t\tblkbits = inode->i_sb->s_blocksize_bits;\n\n\tstat->blksize = 1 << blkbits;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_fillattr(struct inode *inode, struct fuse_attr *attr,\n\t\t\t  struct kstat *stat)\n{\n\tunsigned int blkbits;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t/* see the comment in fuse_change_attributes() */\n\tif (fc->writeback_cache && S_ISREG(inode->i_mode)) {\n\t\tattr->size = i_size_read(inode);\n\t\tattr->mtime = inode->i_mtime.tv_sec;\n\t\tattr->mtimensec = inode->i_mtime.tv_nsec;\n\t\tattr->ctime = inode->i_ctime.tv_sec;\n\t\tattr->ctimensec = inode->i_ctime.tv_nsec;\n\t}\n\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = attr->ino;\n\tstat->mode = (inode->i_mode & S_IFMT) | (attr->mode & 07777);\n\tstat->nlink = attr->nlink;\n\tstat->uid = make_kuid(&init_user_ns, attr->uid);\n\tstat->gid = make_kgid(&init_user_ns, attr->gid);\n\tstat->rdev = inode->i_rdev;\n\tstat->atime.tv_sec = attr->atime;\n\tstat->atime.tv_nsec = attr->atimensec;\n\tstat->mtime.tv_sec = attr->mtime;\n\tstat->mtime.tv_nsec = attr->mtimensec;\n\tstat->ctime.tv_sec = attr->ctime;\n\tstat->ctime.tv_nsec = attr->ctimensec;\n\tstat->size = attr->size;\n\tstat->blocks = attr->blocks;\n\n\tif (attr->blksize != 0)\n\t\tblkbits = ilog2(attr->blksize);\n\telse\n\t\tblkbits = inode->i_sb->s_blocksize_bits;\n\n\tstat->blksize = 1 << blkbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_change_attributes",
          "args": [
            "inode",
            "&outarg.attr",
            "attr_timeout(&outarg)",
            "attr_version"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_change_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "199-251",
          "snippet": "void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    u64 attr_valid, u64 attr_version)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tstruct timespec old_mtime;\n\n\tspin_lock(&fc->lock);\n\tif ((attr_version != 0 && fi->attr_version > attr_version) ||\n\t    test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn;\n\t}\n\n\told_mtime = inode->i_mtime;\n\tfuse_change_attributes_common(inode, attr, attr_valid);\n\n\toldsize = inode->i_size;\n\t/*\n\t * In case of writeback_cache enabled, the cached writes beyond EOF\n\t * extend local i_size without keeping userspace server in sync. So,\n\t * attr->size coming from server can be stale. We cannot trust it.\n\t */\n\tif (!is_wb || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, attr->size);\n\tspin_unlock(&fc->lock);\n\n\tif (!is_wb && S_ISREG(inode->i_mode)) {\n\t\tbool inval = false;\n\n\t\tif (oldsize != attr->size) {\n\t\t\ttruncate_pagecache(inode, attr->size);\n\t\t\tinval = true;\n\t\t} else if (fc->auto_inval_data) {\n\t\t\tstruct timespec new_mtime = {\n\t\t\t\t.tv_sec = attr->mtime,\n\t\t\t\t.tv_nsec = attr->mtimensec,\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Auto inval mode also checks and invalidates if mtime\n\t\t\t * has changed.\n\t\t\t */\n\t\t\tif (!timespec_equal(&old_mtime, &new_mtime))\n\t\t\t\tinval = true;\n\t\t}\n\n\t\tif (inval)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    u64 attr_valid, u64 attr_version)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tstruct timespec old_mtime;\n\n\tspin_lock(&fc->lock);\n\tif ((attr_version != 0 && fi->attr_version > attr_version) ||\n\t    test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn;\n\t}\n\n\told_mtime = inode->i_mtime;\n\tfuse_change_attributes_common(inode, attr, attr_valid);\n\n\toldsize = inode->i_size;\n\t/*\n\t * In case of writeback_cache enabled, the cached writes beyond EOF\n\t * extend local i_size without keeping userspace server in sync. So,\n\t * attr->size coming from server can be stale. We cannot trust it.\n\t */\n\tif (!is_wb || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, attr->size);\n\tspin_unlock(&fc->lock);\n\n\tif (!is_wb && S_ISREG(inode->i_mode)) {\n\t\tbool inval = false;\n\n\t\tif (oldsize != attr->size) {\n\t\t\ttruncate_pagecache(inode, attr->size);\n\t\t\tinval = true;\n\t\t} else if (fc->auto_inval_data) {\n\t\t\tstruct timespec new_mtime = {\n\t\t\t\t.tv_sec = attr->mtime,\n\t\t\t\t.tv_nsec = attr->mtimensec,\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Auto inval mode also checks and invalidates if mtime\n\t\t\t * has changed.\n\t\t\t */\n\t\t\tif (!timespec_equal(&old_mtime, &new_mtime))\n\t\t\t\tinval = true;\n\t\t}\n\n\t\tif (inval)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "attr_timeout",
          "args": [
            "&outarg"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "entry_attr_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "101-104",
          "snippet": "static u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "170-179",
          "snippet": "void make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};",
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nvoid make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&outarg",
            "0",
            "sizeof(outarg)"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_get_attr_version",
          "args": [
            "fc"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_attr_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "163-176",
          "snippet": "u64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_do_getattr(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file)\n{\n\tint err;\n\tstruct fuse_getattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\tu64 attr_version;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\t/* Directories have separate file-handle space */\n\tif (file && S_ISREG(inode->i_mode)) {\n\t\tstruct fuse_file *ff = file->private_data;\n\n\t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\targs.in.h.opcode = FUSE_GETATTR;\n\targs.in.h.nodeid = get_node_id(inode);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.out.numargs = 1;\n\targs.out.args[0].size = sizeof(outarg);\n\targs.out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\tif ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\t\tmake_bad_inode(inode);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tfuse_change_attributes(inode, &outarg.attr,\n\t\t\t\t\t       attr_timeout(&outarg),\n\t\t\t\t\t       attr_version);\n\t\t\tif (stat)\n\t\t\t\tfuse_fillattr(inode, &outarg.attr, stat);\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_fillattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "825-862",
    "snippet": "static void fuse_fillattr(struct inode *inode, struct fuse_attr *attr,\n\t\t\t  struct kstat *stat)\n{\n\tunsigned int blkbits;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t/* see the comment in fuse_change_attributes() */\n\tif (fc->writeback_cache && S_ISREG(inode->i_mode)) {\n\t\tattr->size = i_size_read(inode);\n\t\tattr->mtime = inode->i_mtime.tv_sec;\n\t\tattr->mtimensec = inode->i_mtime.tv_nsec;\n\t\tattr->ctime = inode->i_ctime.tv_sec;\n\t\tattr->ctimensec = inode->i_ctime.tv_nsec;\n\t}\n\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = attr->ino;\n\tstat->mode = (inode->i_mode & S_IFMT) | (attr->mode & 07777);\n\tstat->nlink = attr->nlink;\n\tstat->uid = make_kuid(&init_user_ns, attr->uid);\n\tstat->gid = make_kgid(&init_user_ns, attr->gid);\n\tstat->rdev = inode->i_rdev;\n\tstat->atime.tv_sec = attr->atime;\n\tstat->atime.tv_nsec = attr->atimensec;\n\tstat->mtime.tv_sec = attr->mtime;\n\tstat->mtime.tv_nsec = attr->mtimensec;\n\tstat->ctime.tv_sec = attr->ctime;\n\tstat->ctime.tv_nsec = attr->ctimensec;\n\tstat->size = attr->size;\n\tstat->blocks = attr->blocks;\n\n\tif (attr->blksize != 0)\n\t\tblkbits = ilog2(attr->blksize);\n\telse\n\t\tblkbits = inode->i_sb->s_blocksize_bits;\n\n\tstat->blksize = 1 << blkbits;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "attr->blksize"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "attr->gid"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "attr->uid"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_fillattr(struct inode *inode, struct fuse_attr *attr,\n\t\t\t  struct kstat *stat)\n{\n\tunsigned int blkbits;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\t/* see the comment in fuse_change_attributes() */\n\tif (fc->writeback_cache && S_ISREG(inode->i_mode)) {\n\t\tattr->size = i_size_read(inode);\n\t\tattr->mtime = inode->i_mtime.tv_sec;\n\t\tattr->mtimensec = inode->i_mtime.tv_nsec;\n\t\tattr->ctime = inode->i_ctime.tv_sec;\n\t\tattr->ctimensec = inode->i_ctime.tv_nsec;\n\t}\n\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = attr->ino;\n\tstat->mode = (inode->i_mode & S_IFMT) | (attr->mode & 07777);\n\tstat->nlink = attr->nlink;\n\tstat->uid = make_kuid(&init_user_ns, attr->uid);\n\tstat->gid = make_kgid(&init_user_ns, attr->gid);\n\tstat->rdev = inode->i_rdev;\n\tstat->atime.tv_sec = attr->atime;\n\tstat->atime.tv_nsec = attr->atimensec;\n\tstat->mtime.tv_sec = attr->mtime;\n\tstat->mtime.tv_nsec = attr->mtimensec;\n\tstat->ctime.tv_sec = attr->ctime;\n\tstat->ctime.tv_nsec = attr->ctimensec;\n\tstat->size = attr->size;\n\tstat->blocks = attr->blocks;\n\n\tif (attr->blksize != 0)\n\t\tblkbits = ilog2(attr->blksize);\n\telse\n\t\tblkbits = inode->i_sb->s_blocksize_bits;\n\n\tstat->blksize = 1 << blkbits;\n}"
  },
  {
    "function_name": "fuse_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "786-823",
    "snippet": "static int fuse_link(struct dentry *entry, struct inode *newdir,\n\t\t     struct dentry *newent)\n{\n\tint err;\n\tstruct fuse_link_in inarg;\n\tstruct inode *inode = entry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.oldnodeid = get_node_id(inode);\n\targs.in.h.opcode = FUSE_LINK;\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = newent->d_name.len + 1;\n\targs.in.args[1].value = newent->d_name.name;\n\terr = create_new_entry(fc, &args, newdir, newent, inode->i_mode);\n\t/* Contrary to \"normal\" filesystems it can happen that link\n\t   makes two \"logical\" inodes point to the same \"physical\"\n\t   inode.  We invalidate the attributes of the old one, so it\n\t   will reflect changes in the backing inode (link count,\n\t   etc.)\n\t*/\n\tif (!err) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\tinc_nlink(inode);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tfuse_update_ctime(inode);\n\t} else if (err == -EINTR) {\n\t\tfuse_invalidate_attr(inode);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "inode"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_update_ctime",
          "args": [
            "inode"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_update_ctime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "635-641",
          "snippet": "static inline void fuse_update_ctime(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode->i_ctime = current_fs_time(inode->i_sb);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void fuse_update_ctime(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode->i_ctime = current_fs_time(inode->i_sb);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_new_entry",
          "args": [
            "fc",
            "&args",
            "newdir",
            "newent",
            "inode->i_mode"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "519-567",
          "snippet": "static int create_new_entry(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t    struct inode *dir, struct dentry *entry,\n\t\t\t    umode_t mode)\n{\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tint err;\n\tstruct fuse_forget_link *forget;\n\n\tforget = fuse_alloc_forget();\n\tif (!forget)\n\t\treturn -ENOMEM;\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs->in.h.nodeid = get_node_id(dir);\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(outarg);\n\targs->out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, args);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = -EIO;\n\tif (invalid_nodeid(outarg.nodeid))\n\t\tgoto out_put_forget_req;\n\n\tif ((outarg.attr.mode ^ mode) & S_IFMT)\n\t\tgoto out_put_forget_req;\n\n\tinode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,\n\t\t\t  &outarg.attr, entry_attr_timeout(&outarg), 0);\n\tif (!inode) {\n\t\tfuse_queue_forget(fc, forget, outarg.nodeid, 1);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(forget);\n\n\terr = d_instantiate_no_diralias(entry, inode);\n\tif (err)\n\t\treturn err;\n\n\tfuse_change_entry_timeout(entry, &outarg);\n\tfuse_invalidate_attr(dir);\n\treturn 0;\n\n out_put_forget_req:\n\tkfree(forget);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int create_new_entry(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t    struct inode *dir, struct dentry *entry,\n\t\t\t    umode_t mode)\n{\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tint err;\n\tstruct fuse_forget_link *forget;\n\n\tforget = fuse_alloc_forget();\n\tif (!forget)\n\t\treturn -ENOMEM;\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs->in.h.nodeid = get_node_id(dir);\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(outarg);\n\targs->out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, args);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = -EIO;\n\tif (invalid_nodeid(outarg.nodeid))\n\t\tgoto out_put_forget_req;\n\n\tif ((outarg.attr.mode ^ mode) & S_IFMT)\n\t\tgoto out_put_forget_req;\n\n\tinode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,\n\t\t\t  &outarg.attr, entry_attr_timeout(&outarg), 0);\n\tif (!inode) {\n\t\tfuse_queue_forget(fc, forget, outarg.nodeid, 1);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(forget);\n\n\terr = d_instantiate_no_diralias(entry, inode);\n\tif (err)\n\t\treturn err;\n\n\tfuse_change_entry_timeout(entry, &outarg);\n\tfuse_invalidate_attr(dir);\n\treturn 0;\n\n out_put_forget_req:\n\tkfree(forget);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_link(struct dentry *entry, struct inode *newdir,\n\t\t     struct dentry *newent)\n{\n\tint err;\n\tstruct fuse_link_in inarg;\n\tstruct inode *inode = entry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.oldnodeid = get_node_id(inode);\n\targs.in.h.opcode = FUSE_LINK;\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = newent->d_name.len + 1;\n\targs.in.args[1].value = newent->d_name.name;\n\terr = create_new_entry(fc, &args, newdir, newent, inode->i_mode);\n\t/* Contrary to \"normal\" filesystems it can happen that link\n\t   makes two \"logical\" inodes point to the same \"physical\"\n\t   inode.  We invalidate the attributes of the old one, so it\n\t   will reflect changes in the backing inode (link count,\n\t   etc.)\n\t*/\n\tif (!err) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\tinc_nlink(inode);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tfuse_update_ctime(inode);\n\t} else if (err == -EINTR) {\n\t\tfuse_invalidate_attr(inode);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_rename2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "756-784",
    "snippet": "static int fuse_rename2(struct inode *olddir, struct dentry *oldent,\n\t\t\tstruct inode *newdir, struct dentry *newent,\n\t\t\tunsigned int flags)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(olddir);\n\tint err;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tif (flags) {\n\t\tif (fc->no_rename2 || fc->minor < 23)\n\t\t\treturn -EINVAL;\n\n\t\terr = fuse_rename_common(olddir, oldent, newdir, newent, flags,\n\t\t\t\t\t FUSE_RENAME2,\n\t\t\t\t\t sizeof(struct fuse_rename2_in));\n\t\tif (err == -ENOSYS) {\n\t\t\tfc->no_rename2 = 1;\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = fuse_rename_common(olddir, oldent, newdir, newent, 0,\n\t\t\t\t\t FUSE_RENAME,\n\t\t\t\t\t sizeof(struct fuse_rename_in));\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_rename_common",
          "args": [
            "olddir",
            "oldent",
            "newdir",
            "newent",
            "0",
            "FUSE_RENAME",
            "sizeof(struct fuse_rename_in)"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_rename_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "700-754",
          "snippet": "static int fuse_rename_common(struct inode *olddir, struct dentry *oldent,\n\t\t\t      struct inode *newdir, struct dentry *newent,\n\t\t\t      unsigned int flags, int opcode, size_t argsize)\n{\n\tint err;\n\tstruct fuse_rename2_in inarg;\n\tstruct fuse_conn *fc = get_fuse_conn(olddir);\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, argsize);\n\tinarg.newdir = get_node_id(newdir);\n\tinarg.flags = flags;\n\targs.in.h.opcode = opcode;\n\targs.in.h.nodeid = get_node_id(olddir);\n\targs.in.numargs = 3;\n\targs.in.args[0].size = argsize;\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = oldent->d_name.len + 1;\n\targs.in.args[1].value = oldent->d_name.name;\n\targs.in.args[2].size = newent->d_name.len + 1;\n\targs.in.args[2].value = newent->d_name.name;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\t/* ctime changes */\n\t\tfuse_invalidate_attr(oldent->d_inode);\n\t\tfuse_update_ctime(oldent->d_inode);\n\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfuse_invalidate_attr(newent->d_inode);\n\t\t\tfuse_update_ctime(newent->d_inode);\n\t\t}\n\n\t\tfuse_invalidate_attr(olddir);\n\t\tif (olddir != newdir)\n\t\t\tfuse_invalidate_attr(newdir);\n\n\t\t/* newent will end up negative */\n\t\tif (!(flags & RENAME_EXCHANGE) && newent->d_inode) {\n\t\t\tfuse_invalidate_attr(newent->d_inode);\n\t\t\tfuse_invalidate_entry_cache(newent);\n\t\t\tfuse_update_ctime(newent->d_inode);\n\t\t}\n\t} else if (err == -EINTR) {\n\t\t/* If request was interrupted, DEITY only knows if the\n\t\t   rename actually took place.  If the invalidation\n\t\t   fails (e.g. some process has CWD under the renamed\n\t\t   directory), then there can be inconsistency between\n\t\t   the dcache and the real filesystem.  Tough luck. */\n\t\tfuse_invalidate_entry(oldent);\n\t\tif (newent->d_inode)\n\t\t\tfuse_invalidate_entry(newent);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_rename_common(struct inode *olddir, struct dentry *oldent,\n\t\t\t      struct inode *newdir, struct dentry *newent,\n\t\t\t      unsigned int flags, int opcode, size_t argsize)\n{\n\tint err;\n\tstruct fuse_rename2_in inarg;\n\tstruct fuse_conn *fc = get_fuse_conn(olddir);\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, argsize);\n\tinarg.newdir = get_node_id(newdir);\n\tinarg.flags = flags;\n\targs.in.h.opcode = opcode;\n\targs.in.h.nodeid = get_node_id(olddir);\n\targs.in.numargs = 3;\n\targs.in.args[0].size = argsize;\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = oldent->d_name.len + 1;\n\targs.in.args[1].value = oldent->d_name.name;\n\targs.in.args[2].size = newent->d_name.len + 1;\n\targs.in.args[2].value = newent->d_name.name;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\t/* ctime changes */\n\t\tfuse_invalidate_attr(oldent->d_inode);\n\t\tfuse_update_ctime(oldent->d_inode);\n\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfuse_invalidate_attr(newent->d_inode);\n\t\t\tfuse_update_ctime(newent->d_inode);\n\t\t}\n\n\t\tfuse_invalidate_attr(olddir);\n\t\tif (olddir != newdir)\n\t\t\tfuse_invalidate_attr(newdir);\n\n\t\t/* newent will end up negative */\n\t\tif (!(flags & RENAME_EXCHANGE) && newent->d_inode) {\n\t\t\tfuse_invalidate_attr(newent->d_inode);\n\t\t\tfuse_invalidate_entry_cache(newent);\n\t\t\tfuse_update_ctime(newent->d_inode);\n\t\t}\n\t} else if (err == -EINTR) {\n\t\t/* If request was interrupted, DEITY only knows if the\n\t\t   rename actually took place.  If the invalidation\n\t\t   fails (e.g. some process has CWD under the renamed\n\t\t   directory), then there can be inconsistency between\n\t\t   the dcache and the real filesystem.  Tough luck. */\n\t\tfuse_invalidate_entry(oldent);\n\t\tif (newent->d_inode)\n\t\t\tfuse_invalidate_entry(newent);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "olddir"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_rename2(struct inode *olddir, struct dentry *oldent,\n\t\t\tstruct inode *newdir, struct dentry *newent,\n\t\t\tunsigned int flags)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(olddir);\n\tint err;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tif (flags) {\n\t\tif (fc->no_rename2 || fc->minor < 23)\n\t\t\treturn -EINVAL;\n\n\t\terr = fuse_rename_common(olddir, oldent, newdir, newent, flags,\n\t\t\t\t\t FUSE_RENAME2,\n\t\t\t\t\t sizeof(struct fuse_rename2_in));\n\t\tif (err == -ENOSYS) {\n\t\t\tfc->no_rename2 = 1;\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = fuse_rename_common(olddir, oldent, newdir, newent, 0,\n\t\t\t\t\t FUSE_RENAME,\n\t\t\t\t\t sizeof(struct fuse_rename_in));\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_rename_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "700-754",
    "snippet": "static int fuse_rename_common(struct inode *olddir, struct dentry *oldent,\n\t\t\t      struct inode *newdir, struct dentry *newent,\n\t\t\t      unsigned int flags, int opcode, size_t argsize)\n{\n\tint err;\n\tstruct fuse_rename2_in inarg;\n\tstruct fuse_conn *fc = get_fuse_conn(olddir);\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, argsize);\n\tinarg.newdir = get_node_id(newdir);\n\tinarg.flags = flags;\n\targs.in.h.opcode = opcode;\n\targs.in.h.nodeid = get_node_id(olddir);\n\targs.in.numargs = 3;\n\targs.in.args[0].size = argsize;\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = oldent->d_name.len + 1;\n\targs.in.args[1].value = oldent->d_name.name;\n\targs.in.args[2].size = newent->d_name.len + 1;\n\targs.in.args[2].value = newent->d_name.name;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\t/* ctime changes */\n\t\tfuse_invalidate_attr(oldent->d_inode);\n\t\tfuse_update_ctime(oldent->d_inode);\n\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfuse_invalidate_attr(newent->d_inode);\n\t\t\tfuse_update_ctime(newent->d_inode);\n\t\t}\n\n\t\tfuse_invalidate_attr(olddir);\n\t\tif (olddir != newdir)\n\t\t\tfuse_invalidate_attr(newdir);\n\n\t\t/* newent will end up negative */\n\t\tif (!(flags & RENAME_EXCHANGE) && newent->d_inode) {\n\t\t\tfuse_invalidate_attr(newent->d_inode);\n\t\t\tfuse_invalidate_entry_cache(newent);\n\t\t\tfuse_update_ctime(newent->d_inode);\n\t\t}\n\t} else if (err == -EINTR) {\n\t\t/* If request was interrupted, DEITY only knows if the\n\t\t   rename actually took place.  If the invalidation\n\t\t   fails (e.g. some process has CWD under the renamed\n\t\t   directory), then there can be inconsistency between\n\t\t   the dcache and the real filesystem.  Tough luck. */\n\t\tfuse_invalidate_entry(oldent);\n\t\tif (newent->d_inode)\n\t\t\tfuse_invalidate_entry(newent);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_invalidate_entry",
          "args": [
            "newent"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "142-146",
          "snippet": "static void fuse_invalidate_entry(struct dentry *entry)\n{\n\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_invalidate_entry(struct dentry *entry)\n{\n\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_update_ctime",
          "args": [
            "newent->d_inode"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_update_ctime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "635-641",
          "snippet": "static inline void fuse_update_ctime(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode->i_ctime = current_fs_time(inode->i_sb);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void fuse_update_ctime(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode->i_ctime = current_fs_time(inode->i_sb);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_entry_cache",
          "args": [
            "newent"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_entry_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "133-136",
          "snippet": "void fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "newent->d_inode"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "olddir"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "argsize"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "olddir"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_rename_common(struct inode *olddir, struct dentry *oldent,\n\t\t\t      struct inode *newdir, struct dentry *newent,\n\t\t\t      unsigned int flags, int opcode, size_t argsize)\n{\n\tint err;\n\tstruct fuse_rename2_in inarg;\n\tstruct fuse_conn *fc = get_fuse_conn(olddir);\n\tFUSE_ARGS(args);\n\n\tmemset(&inarg, 0, argsize);\n\tinarg.newdir = get_node_id(newdir);\n\tinarg.flags = flags;\n\targs.in.h.opcode = opcode;\n\targs.in.h.nodeid = get_node_id(olddir);\n\targs.in.numargs = 3;\n\targs.in.args[0].size = argsize;\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = oldent->d_name.len + 1;\n\targs.in.args[1].value = oldent->d_name.name;\n\targs.in.args[2].size = newent->d_name.len + 1;\n\targs.in.args[2].value = newent->d_name.name;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\t/* ctime changes */\n\t\tfuse_invalidate_attr(oldent->d_inode);\n\t\tfuse_update_ctime(oldent->d_inode);\n\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfuse_invalidate_attr(newent->d_inode);\n\t\t\tfuse_update_ctime(newent->d_inode);\n\t\t}\n\n\t\tfuse_invalidate_attr(olddir);\n\t\tif (olddir != newdir)\n\t\t\tfuse_invalidate_attr(newdir);\n\n\t\t/* newent will end up negative */\n\t\tif (!(flags & RENAME_EXCHANGE) && newent->d_inode) {\n\t\t\tfuse_invalidate_attr(newent->d_inode);\n\t\t\tfuse_invalidate_entry_cache(newent);\n\t\t\tfuse_update_ctime(newent->d_inode);\n\t\t}\n\t} else if (err == -EINTR) {\n\t\t/* If request was interrupted, DEITY only knows if the\n\t\t   rename actually took place.  If the invalidation\n\t\t   fails (e.g. some process has CWD under the renamed\n\t\t   directory), then there can be inconsistency between\n\t\t   the dcache and the real filesystem.  Tough luck. */\n\t\tfuse_invalidate_entry(oldent);\n\t\tif (newent->d_inode)\n\t\t\tfuse_invalidate_entry(newent);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "679-698",
    "snippet": "static int fuse_rmdir(struct inode *dir, struct dentry *entry)\n{\n\tint err;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\n\targs.in.h.opcode = FUSE_RMDIR;\n\targs.in.h.nodeid = get_node_id(dir);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = entry->d_name.len + 1;\n\targs.in.args[0].value = entry->d_name.name;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\tclear_nlink(entry->d_inode);\n\t\tfuse_invalidate_attr(dir);\n\t\tfuse_invalidate_entry_cache(entry);\n\t} else if (err == -EINTR)\n\t\tfuse_invalidate_entry(entry);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_invalidate_entry",
          "args": [
            "entry"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "142-146",
          "snippet": "static void fuse_invalidate_entry(struct dentry *entry)\n{\n\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_invalidate_entry(struct dentry *entry)\n{\n\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_entry_cache",
          "args": [
            "entry"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_entry_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "133-136",
          "snippet": "void fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "dir"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "entry->d_inode"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "dir"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "dir"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_rmdir(struct inode *dir, struct dentry *entry)\n{\n\tint err;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\n\targs.in.h.opcode = FUSE_RMDIR;\n\targs.in.h.nodeid = get_node_id(dir);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = entry->d_name.len + 1;\n\targs.in.args[0].value = entry->d_name.name;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\tclear_nlink(entry->d_inode);\n\t\tfuse_invalidate_attr(dir);\n\t\tfuse_invalidate_entry_cache(entry);\n\t} else if (err == -EINTR)\n\t\tfuse_invalidate_entry(entry);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "643-677",
    "snippet": "static int fuse_unlink(struct inode *dir, struct dentry *entry)\n{\n\tint err;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\n\targs.in.h.opcode = FUSE_UNLINK;\n\targs.in.h.nodeid = get_node_id(dir);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = entry->d_name.len + 1;\n\targs.in.args[0].value = entry->d_name.name;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\tstruct inode *inode = entry->d_inode;\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\t/*\n\t\t * If i_nlink == 0 then unlink doesn't make sense, yet this can\n\t\t * happen if userspace filesystem is careless.  It would be\n\t\t * difficult to enforce correct nlink usage so just ignore this\n\t\t * condition here\n\t\t */\n\t\tif (inode->i_nlink > 0)\n\t\t\tdrop_nlink(inode);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tfuse_invalidate_attr(dir);\n\t\tfuse_invalidate_entry_cache(entry);\n\t\tfuse_update_ctime(inode);\n\t} else if (err == -EINTR)\n\t\tfuse_invalidate_entry(entry);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_invalidate_entry",
          "args": [
            "entry"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "142-146",
          "snippet": "static void fuse_invalidate_entry(struct dentry *entry)\n{\n\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_invalidate_entry(struct dentry *entry)\n{\n\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_update_ctime",
          "args": [
            "inode"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_update_ctime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "635-641",
          "snippet": "static inline void fuse_update_ctime(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode->i_ctime = current_fs_time(inode->i_sb);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void fuse_update_ctime(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode->i_ctime = current_fs_time(inode->i_sb);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_entry_cache",
          "args": [
            "entry"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_entry_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "133-136",
          "snippet": "void fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "dir"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "127-131",
          "snippet": "static inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "dir"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "dir"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_unlink(struct inode *dir, struct dentry *entry)\n{\n\tint err;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\n\targs.in.h.opcode = FUSE_UNLINK;\n\targs.in.h.nodeid = get_node_id(dir);\n\targs.in.numargs = 1;\n\targs.in.args[0].size = entry->d_name.len + 1;\n\targs.in.args[0].value = entry->d_name.name;\n\terr = fuse_simple_request(fc, &args);\n\tif (!err) {\n\t\tstruct inode *inode = entry->d_inode;\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\t/*\n\t\t * If i_nlink == 0 then unlink doesn't make sense, yet this can\n\t\t * happen if userspace filesystem is careless.  It would be\n\t\t * difficult to enforce correct nlink usage so just ignore this\n\t\t * condition here\n\t\t */\n\t\tif (inode->i_nlink > 0)\n\t\t\tdrop_nlink(inode);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tfuse_invalidate_attr(dir);\n\t\tfuse_invalidate_entry_cache(entry);\n\t\tfuse_update_ctime(inode);\n\t} else if (err == -EINTR)\n\t\tfuse_invalidate_entry(entry);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_update_ctime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "635-641",
    "snippet": "static inline void fuse_update_ctime(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode->i_ctime = current_fs_time(inode->i_sb);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "291-294",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_NOCMTIME",
          "args": [
            "inode"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void fuse_update_ctime(struct inode *inode)\n{\n\tif (!IS_NOCMTIME(inode)) {\n\t\tinode->i_ctime = current_fs_time(inode->i_sb);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n}"
  },
  {
    "function_name": "fuse_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "619-633",
    "snippet": "static int fuse_symlink(struct inode *dir, struct dentry *entry,\n\t\t\tconst char *link)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tunsigned len = strlen(link) + 1;\n\tFUSE_ARGS(args);\n\n\targs.in.h.opcode = FUSE_SYMLINK;\n\targs.in.numargs = 2;\n\targs.in.args[0].size = entry->d_name.len + 1;\n\targs.in.args[0].value = entry->d_name.name;\n\targs.in.args[1].size = len;\n\targs.in.args[1].value = link;\n\treturn create_new_entry(fc, &args, dir, entry, S_IFLNK);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_new_entry",
          "args": [
            "fc",
            "&args",
            "dir",
            "entry",
            "S_IFLNK"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "519-567",
          "snippet": "static int create_new_entry(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t    struct inode *dir, struct dentry *entry,\n\t\t\t    umode_t mode)\n{\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tint err;\n\tstruct fuse_forget_link *forget;\n\n\tforget = fuse_alloc_forget();\n\tif (!forget)\n\t\treturn -ENOMEM;\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs->in.h.nodeid = get_node_id(dir);\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(outarg);\n\targs->out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, args);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = -EIO;\n\tif (invalid_nodeid(outarg.nodeid))\n\t\tgoto out_put_forget_req;\n\n\tif ((outarg.attr.mode ^ mode) & S_IFMT)\n\t\tgoto out_put_forget_req;\n\n\tinode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,\n\t\t\t  &outarg.attr, entry_attr_timeout(&outarg), 0);\n\tif (!inode) {\n\t\tfuse_queue_forget(fc, forget, outarg.nodeid, 1);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(forget);\n\n\terr = d_instantiate_no_diralias(entry, inode);\n\tif (err)\n\t\treturn err;\n\n\tfuse_change_entry_timeout(entry, &outarg);\n\tfuse_invalidate_attr(dir);\n\treturn 0;\n\n out_put_forget_req:\n\tkfree(forget);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int create_new_entry(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t    struct inode *dir, struct dentry *entry,\n\t\t\t    umode_t mode)\n{\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tint err;\n\tstruct fuse_forget_link *forget;\n\n\tforget = fuse_alloc_forget();\n\tif (!forget)\n\t\treturn -ENOMEM;\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs->in.h.nodeid = get_node_id(dir);\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(outarg);\n\targs->out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, args);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = -EIO;\n\tif (invalid_nodeid(outarg.nodeid))\n\t\tgoto out_put_forget_req;\n\n\tif ((outarg.attr.mode ^ mode) & S_IFMT)\n\t\tgoto out_put_forget_req;\n\n\tinode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,\n\t\t\t  &outarg.attr, entry_attr_timeout(&outarg), 0);\n\tif (!inode) {\n\t\tfuse_queue_forget(fc, forget, outarg.nodeid, 1);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(forget);\n\n\terr = d_instantiate_no_diralias(entry, inode);\n\tif (err)\n\t\treturn err;\n\n\tfuse_change_entry_timeout(entry, &outarg);\n\tfuse_invalidate_attr(dir);\n\treturn 0;\n\n out_put_forget_req:\n\tkfree(forget);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "link"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "dir"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_symlink(struct inode *dir, struct dentry *entry,\n\t\t\tconst char *link)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tunsigned len = strlen(link) + 1;\n\tFUSE_ARGS(args);\n\n\targs.in.h.opcode = FUSE_SYMLINK;\n\targs.in.numargs = 2;\n\targs.in.args[0].size = entry->d_name.len + 1;\n\targs.in.args[0].value = entry->d_name.name;\n\targs.in.args[1].size = len;\n\targs.in.args[1].value = link;\n\treturn create_new_entry(fc, &args, dir, entry, S_IFLNK);\n}"
  },
  {
    "function_name": "fuse_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "598-617",
    "snippet": "static int fuse_mkdir(struct inode *dir, struct dentry *entry, umode_t mode)\n{\n\tstruct fuse_mkdir_in inarg;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\n\tif (!fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mode = mode;\n\tinarg.umask = current_umask();\n\targs.in.h.opcode = FUSE_MKDIR;\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = entry->d_name.len + 1;\n\targs.in.args[1].value = entry->d_name.name;\n\treturn create_new_entry(fc, &args, dir, entry, S_IFDIR);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_new_entry",
          "args": [
            "fc",
            "&args",
            "dir",
            "entry",
            "S_IFDIR"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "519-567",
          "snippet": "static int create_new_entry(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t    struct inode *dir, struct dentry *entry,\n\t\t\t    umode_t mode)\n{\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tint err;\n\tstruct fuse_forget_link *forget;\n\n\tforget = fuse_alloc_forget();\n\tif (!forget)\n\t\treturn -ENOMEM;\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs->in.h.nodeid = get_node_id(dir);\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(outarg);\n\targs->out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, args);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = -EIO;\n\tif (invalid_nodeid(outarg.nodeid))\n\t\tgoto out_put_forget_req;\n\n\tif ((outarg.attr.mode ^ mode) & S_IFMT)\n\t\tgoto out_put_forget_req;\n\n\tinode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,\n\t\t\t  &outarg.attr, entry_attr_timeout(&outarg), 0);\n\tif (!inode) {\n\t\tfuse_queue_forget(fc, forget, outarg.nodeid, 1);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(forget);\n\n\terr = d_instantiate_no_diralias(entry, inode);\n\tif (err)\n\t\treturn err;\n\n\tfuse_change_entry_timeout(entry, &outarg);\n\tfuse_invalidate_attr(dir);\n\treturn 0;\n\n out_put_forget_req:\n\tkfree(forget);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int create_new_entry(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t    struct inode *dir, struct dentry *entry,\n\t\t\t    umode_t mode)\n{\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tint err;\n\tstruct fuse_forget_link *forget;\n\n\tforget = fuse_alloc_forget();\n\tif (!forget)\n\t\treturn -ENOMEM;\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs->in.h.nodeid = get_node_id(dir);\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(outarg);\n\targs->out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, args);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = -EIO;\n\tif (invalid_nodeid(outarg.nodeid))\n\t\tgoto out_put_forget_req;\n\n\tif ((outarg.attr.mode ^ mode) & S_IFMT)\n\t\tgoto out_put_forget_req;\n\n\tinode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,\n\t\t\t  &outarg.attr, entry_attr_timeout(&outarg), 0);\n\tif (!inode) {\n\t\tfuse_queue_forget(fc, forget, outarg.nodeid, 1);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(forget);\n\n\terr = d_instantiate_no_diralias(entry, inode);\n\tif (err)\n\t\treturn err;\n\n\tfuse_change_entry_timeout(entry, &outarg);\n\tfuse_invalidate_attr(dir);\n\treturn 0;\n\n out_put_forget_req:\n\tkfree(forget);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "dir"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_mkdir(struct inode *dir, struct dentry *entry, umode_t mode)\n{\n\tstruct fuse_mkdir_in inarg;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\n\tif (!fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mode = mode;\n\tinarg.umask = current_umask();\n\targs.in.h.opcode = FUSE_MKDIR;\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = entry->d_name.len + 1;\n\targs.in.args[1].value = entry->d_name.name;\n\treturn create_new_entry(fc, &args, dir, entry, S_IFDIR);\n}"
  },
  {
    "function_name": "fuse_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "592-596",
    "snippet": "static int fuse_create(struct inode *dir, struct dentry *entry, umode_t mode,\n\t\t       bool excl)\n{\n\treturn fuse_mknod(dir, entry, mode, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_mknod",
          "args": [
            "dir",
            "entry",
            "mode",
            "0"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "569-590",
          "snippet": "static int fuse_mknod(struct inode *dir, struct dentry *entry, umode_t mode,\n\t\t      dev_t rdev)\n{\n\tstruct fuse_mknod_in inarg;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\n\tif (!fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mode = mode;\n\tinarg.rdev = new_encode_dev(rdev);\n\tinarg.umask = current_umask();\n\targs.in.h.opcode = FUSE_MKNOD;\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = entry->d_name.len + 1;\n\targs.in.args[1].value = entry->d_name.name;\n\treturn create_new_entry(fc, &args, dir, entry, mode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fuse_mknod(struct inode *, struct dentry *, umode_t, dev_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_mknod(struct inode *, struct dentry *, umode_t, dev_t);\n\nstatic int fuse_mknod(struct inode *dir, struct dentry *entry, umode_t mode,\n\t\t      dev_t rdev)\n{\n\tstruct fuse_mknod_in inarg;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\n\tif (!fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mode = mode;\n\tinarg.rdev = new_encode_dev(rdev);\n\tinarg.umask = current_umask();\n\targs.in.h.opcode = FUSE_MKNOD;\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = entry->d_name.len + 1;\n\targs.in.args[1].value = entry->d_name.name;\n\treturn create_new_entry(fc, &args, dir, entry, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_create(struct inode *dir, struct dentry *entry, umode_t mode,\n\t\t       bool excl)\n{\n\treturn fuse_mknod(dir, entry, mode, 0);\n}"
  },
  {
    "function_name": "fuse_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "569-590",
    "snippet": "static int fuse_mknod(struct inode *dir, struct dentry *entry, umode_t mode,\n\t\t      dev_t rdev)\n{\n\tstruct fuse_mknod_in inarg;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\n\tif (!fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mode = mode;\n\tinarg.rdev = new_encode_dev(rdev);\n\tinarg.umask = current_umask();\n\targs.in.h.opcode = FUSE_MKNOD;\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = entry->d_name.len + 1;\n\targs.in.args[1].value = entry->d_name.name;\n\treturn create_new_entry(fc, &args, dir, entry, mode);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fuse_mknod(struct inode *, struct dentry *, umode_t, dev_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_new_entry",
          "args": [
            "fc",
            "&args",
            "dir",
            "entry",
            "mode"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "519-567",
          "snippet": "static int create_new_entry(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t    struct inode *dir, struct dentry *entry,\n\t\t\t    umode_t mode)\n{\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tint err;\n\tstruct fuse_forget_link *forget;\n\n\tforget = fuse_alloc_forget();\n\tif (!forget)\n\t\treturn -ENOMEM;\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs->in.h.nodeid = get_node_id(dir);\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(outarg);\n\targs->out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, args);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = -EIO;\n\tif (invalid_nodeid(outarg.nodeid))\n\t\tgoto out_put_forget_req;\n\n\tif ((outarg.attr.mode ^ mode) & S_IFMT)\n\t\tgoto out_put_forget_req;\n\n\tinode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,\n\t\t\t  &outarg.attr, entry_attr_timeout(&outarg), 0);\n\tif (!inode) {\n\t\tfuse_queue_forget(fc, forget, outarg.nodeid, 1);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(forget);\n\n\terr = d_instantiate_no_diralias(entry, inode);\n\tif (err)\n\t\treturn err;\n\n\tfuse_change_entry_timeout(entry, &outarg);\n\tfuse_invalidate_attr(dir);\n\treturn 0;\n\n out_put_forget_req:\n\tkfree(forget);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int create_new_entry(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t    struct inode *dir, struct dentry *entry,\n\t\t\t    umode_t mode)\n{\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tint err;\n\tstruct fuse_forget_link *forget;\n\n\tforget = fuse_alloc_forget();\n\tif (!forget)\n\t\treturn -ENOMEM;\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs->in.h.nodeid = get_node_id(dir);\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(outarg);\n\targs->out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, args);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = -EIO;\n\tif (invalid_nodeid(outarg.nodeid))\n\t\tgoto out_put_forget_req;\n\n\tif ((outarg.attr.mode ^ mode) & S_IFMT)\n\t\tgoto out_put_forget_req;\n\n\tinode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,\n\t\t\t  &outarg.attr, entry_attr_timeout(&outarg), 0);\n\tif (!inode) {\n\t\tfuse_queue_forget(fc, forget, outarg.nodeid, 1);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(forget);\n\n\terr = d_instantiate_no_diralias(entry, inode);\n\tif (err)\n\t\treturn err;\n\n\tfuse_change_entry_timeout(entry, &outarg);\n\tfuse_invalidate_attr(dir);\n\treturn 0;\n\n out_put_forget_req:\n\tkfree(forget);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "rdev"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "dir"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_mknod(struct inode *, struct dentry *, umode_t, dev_t);\n\nstatic int fuse_mknod(struct inode *dir, struct dentry *entry, umode_t mode,\n\t\t      dev_t rdev)\n{\n\tstruct fuse_mknod_in inarg;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\n\tif (!fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mode = mode;\n\tinarg.rdev = new_encode_dev(rdev);\n\tinarg.umask = current_umask();\n\targs.in.h.opcode = FUSE_MKNOD;\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = entry->d_name.len + 1;\n\targs.in.args[1].value = entry->d_name.name;\n\treturn create_new_entry(fc, &args, dir, entry, mode);\n}"
  },
  {
    "function_name": "create_new_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "519-567",
    "snippet": "static int create_new_entry(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t    struct inode *dir, struct dentry *entry,\n\t\t\t    umode_t mode)\n{\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tint err;\n\tstruct fuse_forget_link *forget;\n\n\tforget = fuse_alloc_forget();\n\tif (!forget)\n\t\treturn -ENOMEM;\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs->in.h.nodeid = get_node_id(dir);\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(outarg);\n\targs->out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, args);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = -EIO;\n\tif (invalid_nodeid(outarg.nodeid))\n\t\tgoto out_put_forget_req;\n\n\tif ((outarg.attr.mode ^ mode) & S_IFMT)\n\t\tgoto out_put_forget_req;\n\n\tinode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,\n\t\t\t  &outarg.attr, entry_attr_timeout(&outarg), 0);\n\tif (!inode) {\n\t\tfuse_queue_forget(fc, forget, outarg.nodeid, 1);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(forget);\n\n\terr = d_instantiate_no_diralias(entry, inode);\n\tif (err)\n\t\treturn err;\n\n\tfuse_change_entry_timeout(entry, &outarg);\n\tfuse_invalidate_attr(dir);\n\treturn 0;\n\n out_put_forget_req:\n\tkfree(forget);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "forget"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "dir"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_change_entry_timeout",
          "args": [
            "entry",
            "&outarg"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_change_entry_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "89-94",
          "snippet": "static void fuse_change_entry_timeout(struct dentry *entry,\n\t\t\t\t      struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\ttime_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_change_entry_timeout(struct dentry *entry,\n\t\t\t\t      struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\ttime_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate_no_diralias",
          "args": [
            "entry",
            "inode"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "forget"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_queue_forget",
          "args": [
            "fc",
            "forget",
            "outarg.nodeid",
            "1"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_queue_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "337-353",
          "snippet": "void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->forget_list_tail->next = forget;\n\t\tfc->forget_list_tail = forget;\n\t\twake_up(&fc->waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->forget_list_tail->next = forget;\n\t\tfc->forget_list_tail = forget;\n\t\twake_up(&fc->waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_iget",
          "args": [
            "dir->i_sb",
            "outarg.nodeid",
            "outarg.generation",
            "&outarg.attr",
            "entry_attr_timeout(&outarg)",
            "0"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "293-327",
          "snippet": "struct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n retry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t/* Inode has changed type, any I/O on the old should fail */\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fc->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fc->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n retry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t/* Inode has changed type, any I/O on the old should fail */\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fc->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fc->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_attr_timeout",
          "args": [
            "&outarg"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "entry_attr_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "101-104",
          "snippet": "static u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalid_nodeid",
          "args": [
            "outarg.nodeid"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "invalid_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "270-273",
          "snippet": "static int invalid_nodeid(u64 nodeid)\n{\n\treturn !nodeid || nodeid == FUSE_ROOT_ID;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int invalid_nodeid(u64 nodeid)\n{\n\treturn !nodeid || nodeid == FUSE_ROOT_ID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "args"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "dir"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&outarg",
            "0",
            "sizeof(outarg)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_alloc_forget",
          "args": [],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_alloc_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "74-77",
          "snippet": "struct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int create_new_entry(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t    struct inode *dir, struct dentry *entry,\n\t\t\t    umode_t mode)\n{\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tint err;\n\tstruct fuse_forget_link *forget;\n\n\tforget = fuse_alloc_forget();\n\tif (!forget)\n\t\treturn -ENOMEM;\n\n\tmemset(&outarg, 0, sizeof(outarg));\n\targs->in.h.nodeid = get_node_id(dir);\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(outarg);\n\targs->out.args[0].value = &outarg;\n\terr = fuse_simple_request(fc, args);\n\tif (err)\n\t\tgoto out_put_forget_req;\n\n\terr = -EIO;\n\tif (invalid_nodeid(outarg.nodeid))\n\t\tgoto out_put_forget_req;\n\n\tif ((outarg.attr.mode ^ mode) & S_IFMT)\n\t\tgoto out_put_forget_req;\n\n\tinode = fuse_iget(dir->i_sb, outarg.nodeid, outarg.generation,\n\t\t\t  &outarg.attr, entry_attr_timeout(&outarg), 0);\n\tif (!inode) {\n\t\tfuse_queue_forget(fc, forget, outarg.nodeid, 1);\n\t\treturn -ENOMEM;\n\t}\n\tkfree(forget);\n\n\terr = d_instantiate_no_diralias(entry, inode);\n\tif (err)\n\t\treturn err;\n\n\tfuse_change_entry_timeout(entry, &outarg);\n\tfuse_invalidate_attr(dir);\n\treturn 0;\n\n out_put_forget_req:\n\tkfree(forget);\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_atomic_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "473-514",
    "snippet": "static int fuse_atomic_open(struct inode *dir, struct dentry *entry,\n\t\t\t    struct file *file, unsigned flags,\n\t\t\t    umode_t mode, int *opened)\n{\n\tint err;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tstruct dentry *res = NULL;\n\n\tif (d_unhashed(entry)) {\n\t\tres = fuse_lookup(dir, entry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\tif (res)\n\t\t\tentry = res;\n\t}\n\n\tif (!(flags & O_CREAT) || entry->d_inode)\n\t\tgoto no_open;\n\n\t/* Only creates */\n\t*opened |= FILE_CREATED;\n\n\tif (fc->no_create)\n\t\tgoto mknod;\n\n\terr = fuse_create_open(dir, entry, file, flags, mode, opened);\n\tif (err == -ENOSYS) {\n\t\tfc->no_create = 1;\n\t\tgoto mknod;\n\t}\nout_dput:\n\tdput(res);\n\treturn err;\n\nmknod:\n\terr = fuse_mknod(dir, entry, mode, 0);\n\tif (err)\n\t\tgoto out_dput;\nno_open:\n\treturn finish_no_open(file, res);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_no_open",
          "args": [
            "file",
            "res"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "finish_no_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "814-818",
          "snippet": "int finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_mknod",
          "args": [
            "dir",
            "entry",
            "mode",
            "0"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "569-590",
          "snippet": "static int fuse_mknod(struct inode *dir, struct dentry *entry, umode_t mode,\n\t\t      dev_t rdev)\n{\n\tstruct fuse_mknod_in inarg;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\n\tif (!fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mode = mode;\n\tinarg.rdev = new_encode_dev(rdev);\n\tinarg.umask = current_umask();\n\targs.in.h.opcode = FUSE_MKNOD;\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = entry->d_name.len + 1;\n\targs.in.args[1].value = entry->d_name.name;\n\treturn create_new_entry(fc, &args, dir, entry, mode);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fuse_mknod(struct inode *, struct dentry *, umode_t, dev_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_mknod(struct inode *, struct dentry *, umode_t, dev_t);\n\nstatic int fuse_mknod(struct inode *dir, struct dentry *entry, umode_t mode,\n\t\t      dev_t rdev)\n{\n\tstruct fuse_mknod_in inarg;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\n\tif (!fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.mode = mode;\n\tinarg.rdev = new_encode_dev(rdev);\n\tinarg.umask = current_umask();\n\targs.in.h.opcode = FUSE_MKNOD;\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = entry->d_name.len + 1;\n\targs.in.args[1].value = entry->d_name.name;\n\treturn create_new_entry(fc, &args, dir, entry, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "res"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_create_open",
          "args": [
            "dir",
            "entry",
            "file",
            "flags",
            "mode",
            "opened"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_create_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "383-470",
          "snippet": "static int fuse_create_open(struct inode *dir, struct dentry *entry,\n\t\t\t    struct file *file, unsigned flags,\n\t\t\t    umode_t mode, int *opened)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tstruct fuse_create_in inarg;\n\tstruct fuse_open_out outopen;\n\tstruct fuse_entry_out outentry;\n\tstruct fuse_file *ff;\n\n\t/* Userspace expects S_IFREG in create mode */\n\tBUG_ON((mode & S_IFMT) != S_IFREG);\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out_err;\n\n\terr = -ENOMEM;\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\tgoto out_put_forget_req;\n\n\tif (!fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tflags &= ~O_NOCTTY;\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outentry, 0, sizeof(outentry));\n\tinarg.flags = flags;\n\tinarg.mode = mode;\n\tinarg.umask = current_umask();\n\targs.in.h.opcode = FUSE_CREATE;\n\targs.in.h.nodeid = get_node_id(dir);\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = entry->d_name.len + 1;\n\targs.in.args[1].value = entry->d_name.name;\n\targs.out.numargs = 2;\n\targs.out.args[0].size = sizeof(outentry);\n\targs.out.args[0].value = &outentry;\n\targs.out.args[1].size = sizeof(outopen);\n\targs.out.args[1].value = &outopen;\n\terr = fuse_simple_request(fc, &args);\n\tif (err)\n\t\tgoto out_free_ff;\n\n\terr = -EIO;\n\tif (!S_ISREG(outentry.attr.mode) || invalid_nodeid(outentry.nodeid))\n\t\tgoto out_free_ff;\n\n\tff->fh = outopen.fh;\n\tff->nodeid = outentry.nodeid;\n\tff->open_flags = outopen.open_flags;\n\tinode = fuse_iget(dir->i_sb, outentry.nodeid, outentry.generation,\n\t\t\t  &outentry.attr, entry_attr_timeout(&outentry), 0);\n\tif (!inode) {\n\t\tflags &= ~(O_CREAT | O_EXCL | O_TRUNC);\n\t\tfuse_sync_release(ff, flags);\n\t\tfuse_queue_forget(fc, forget, outentry.nodeid, 1);\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tkfree(forget);\n\td_instantiate(entry, inode);\n\tfuse_change_entry_timeout(entry, &outentry);\n\tfuse_invalidate_attr(dir);\n\terr = finish_open(file, entry, generic_file_open, opened);\n\tif (err) {\n\t\tfuse_sync_release(ff, flags);\n\t} else {\n\t\tfile->private_data = fuse_file_get(ff);\n\t\tfuse_finish_open(inode, file);\n\t}\n\treturn err;\n\nout_free_ff:\n\tfuse_file_free(ff);\nout_put_forget_req:\n\tkfree(forget);\nout_err:\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_create_open(struct inode *dir, struct dentry *entry,\n\t\t\t    struct file *file, unsigned flags,\n\t\t\t    umode_t mode, int *opened)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tstruct fuse_create_in inarg;\n\tstruct fuse_open_out outopen;\n\tstruct fuse_entry_out outentry;\n\tstruct fuse_file *ff;\n\n\t/* Userspace expects S_IFREG in create mode */\n\tBUG_ON((mode & S_IFMT) != S_IFREG);\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out_err;\n\n\terr = -ENOMEM;\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\tgoto out_put_forget_req;\n\n\tif (!fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tflags &= ~O_NOCTTY;\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outentry, 0, sizeof(outentry));\n\tinarg.flags = flags;\n\tinarg.mode = mode;\n\tinarg.umask = current_umask();\n\targs.in.h.opcode = FUSE_CREATE;\n\targs.in.h.nodeid = get_node_id(dir);\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = entry->d_name.len + 1;\n\targs.in.args[1].value = entry->d_name.name;\n\targs.out.numargs = 2;\n\targs.out.args[0].size = sizeof(outentry);\n\targs.out.args[0].value = &outentry;\n\targs.out.args[1].size = sizeof(outopen);\n\targs.out.args[1].value = &outopen;\n\terr = fuse_simple_request(fc, &args);\n\tif (err)\n\t\tgoto out_free_ff;\n\n\terr = -EIO;\n\tif (!S_ISREG(outentry.attr.mode) || invalid_nodeid(outentry.nodeid))\n\t\tgoto out_free_ff;\n\n\tff->fh = outopen.fh;\n\tff->nodeid = outentry.nodeid;\n\tff->open_flags = outopen.open_flags;\n\tinode = fuse_iget(dir->i_sb, outentry.nodeid, outentry.generation,\n\t\t\t  &outentry.attr, entry_attr_timeout(&outentry), 0);\n\tif (!inode) {\n\t\tflags &= ~(O_CREAT | O_EXCL | O_TRUNC);\n\t\tfuse_sync_release(ff, flags);\n\t\tfuse_queue_forget(fc, forget, outentry.nodeid, 1);\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tkfree(forget);\n\td_instantiate(entry, inode);\n\tfuse_change_entry_timeout(entry, &outentry);\n\tfuse_invalidate_attr(dir);\n\terr = finish_open(file, entry, generic_file_open, opened);\n\tif (err) {\n\t\tfuse_sync_release(ff, flags);\n\t} else {\n\t\tfile->private_data = fuse_file_get(ff);\n\t\tfuse_finish_open(inode, file);\n\t}\n\treturn err;\n\nout_free_ff:\n\tfuse_file_free(ff);\nout_put_forget_req:\n\tkfree(forget);\nout_err:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "res"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_lookup",
          "args": [
            "dir",
            "entry",
            "0"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "335-375",
          "snippet": "static struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,\n\t\t\t\t  unsigned int flags)\n{\n\tint err;\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tstruct dentry *newent;\n\tbool outarg_valid = true;\n\n\terr = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,\n\t\t\t       &outarg, &inode);\n\tif (err == -ENOENT) {\n\t\toutarg_valid = false;\n\t\terr = 0;\n\t}\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tif (inode && get_node_id(inode) == FUSE_ROOT_ID)\n\t\tgoto out_iput;\n\n\tnewent = d_splice_alias(inode, entry);\n\terr = PTR_ERR(newent);\n\tif (IS_ERR(newent))\n\t\tgoto out_err;\n\n\tentry = newent ? newent : entry;\n\tif (outarg_valid)\n\t\tfuse_change_entry_timeout(entry, &outarg);\n\telse\n\t\tfuse_invalidate_entry_cache(entry);\n\n\tfuse_advise_use_readdirplus(dir);\n\treturn newent;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,\n\t\t\t\t  unsigned int flags)\n{\n\tint err;\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tstruct dentry *newent;\n\tbool outarg_valid = true;\n\n\terr = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,\n\t\t\t       &outarg, &inode);\n\tif (err == -ENOENT) {\n\t\toutarg_valid = false;\n\t\terr = 0;\n\t}\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tif (inode && get_node_id(inode) == FUSE_ROOT_ID)\n\t\tgoto out_iput;\n\n\tnewent = d_splice_alias(inode, entry);\n\terr = PTR_ERR(newent);\n\tif (IS_ERR(newent))\n\t\tgoto out_err;\n\n\tentry = newent ? newent : entry;\n\tif (outarg_valid)\n\t\tfuse_change_entry_timeout(entry, &outarg);\n\telse\n\t\tfuse_invalidate_entry_cache(entry);\n\n\tfuse_advise_use_readdirplus(dir);\n\treturn newent;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "entry"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "dir"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_atomic_open(struct inode *dir, struct dentry *entry,\n\t\t\t    struct file *file, unsigned flags,\n\t\t\t    umode_t mode, int *opened)\n{\n\tint err;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tstruct dentry *res = NULL;\n\n\tif (d_unhashed(entry)) {\n\t\tres = fuse_lookup(dir, entry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\tif (res)\n\t\t\tentry = res;\n\t}\n\n\tif (!(flags & O_CREAT) || entry->d_inode)\n\t\tgoto no_open;\n\n\t/* Only creates */\n\t*opened |= FILE_CREATED;\n\n\tif (fc->no_create)\n\t\tgoto mknod;\n\n\terr = fuse_create_open(dir, entry, file, flags, mode, opened);\n\tif (err == -ENOSYS) {\n\t\tfc->no_create = 1;\n\t\tgoto mknod;\n\t}\nout_dput:\n\tdput(res);\n\treturn err;\n\nmknod:\n\terr = fuse_mknod(dir, entry, mode, 0);\n\tif (err)\n\t\tgoto out_dput;\nno_open:\n\treturn finish_no_open(file, res);\n}"
  },
  {
    "function_name": "fuse_create_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "383-470",
    "snippet": "static int fuse_create_open(struct inode *dir, struct dentry *entry,\n\t\t\t    struct file *file, unsigned flags,\n\t\t\t    umode_t mode, int *opened)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tstruct fuse_create_in inarg;\n\tstruct fuse_open_out outopen;\n\tstruct fuse_entry_out outentry;\n\tstruct fuse_file *ff;\n\n\t/* Userspace expects S_IFREG in create mode */\n\tBUG_ON((mode & S_IFMT) != S_IFREG);\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out_err;\n\n\terr = -ENOMEM;\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\tgoto out_put_forget_req;\n\n\tif (!fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tflags &= ~O_NOCTTY;\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outentry, 0, sizeof(outentry));\n\tinarg.flags = flags;\n\tinarg.mode = mode;\n\tinarg.umask = current_umask();\n\targs.in.h.opcode = FUSE_CREATE;\n\targs.in.h.nodeid = get_node_id(dir);\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = entry->d_name.len + 1;\n\targs.in.args[1].value = entry->d_name.name;\n\targs.out.numargs = 2;\n\targs.out.args[0].size = sizeof(outentry);\n\targs.out.args[0].value = &outentry;\n\targs.out.args[1].size = sizeof(outopen);\n\targs.out.args[1].value = &outopen;\n\terr = fuse_simple_request(fc, &args);\n\tif (err)\n\t\tgoto out_free_ff;\n\n\terr = -EIO;\n\tif (!S_ISREG(outentry.attr.mode) || invalid_nodeid(outentry.nodeid))\n\t\tgoto out_free_ff;\n\n\tff->fh = outopen.fh;\n\tff->nodeid = outentry.nodeid;\n\tff->open_flags = outopen.open_flags;\n\tinode = fuse_iget(dir->i_sb, outentry.nodeid, outentry.generation,\n\t\t\t  &outentry.attr, entry_attr_timeout(&outentry), 0);\n\tif (!inode) {\n\t\tflags &= ~(O_CREAT | O_EXCL | O_TRUNC);\n\t\tfuse_sync_release(ff, flags);\n\t\tfuse_queue_forget(fc, forget, outentry.nodeid, 1);\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tkfree(forget);\n\td_instantiate(entry, inode);\n\tfuse_change_entry_timeout(entry, &outentry);\n\tfuse_invalidate_attr(dir);\n\terr = finish_open(file, entry, generic_file_open, opened);\n\tif (err) {\n\t\tfuse_sync_release(ff, flags);\n\t} else {\n\t\tfile->private_data = fuse_file_get(ff);\n\t\tfuse_finish_open(inode, file);\n\t}\n\treturn err;\n\nout_free_ff:\n\tfuse_file_free(ff);\nout_put_forget_req:\n\tkfree(forget);\nout_err:\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "forget"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_file_free",
          "args": [
            "ff"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "72-76",
          "snippet": "void fuse_file_free(struct fuse_file *ff)\n{\n\tfuse_request_free(ff->reserved_req);\n\tkfree(ff);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_file_free(struct fuse_file *ff)\n{\n\tfuse_request_free(ff->reserved_req);\n\tkfree(ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_finish_open",
          "args": [
            "inode",
            "file"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_finish_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "171-195",
          "snippet": "void fuse_finish_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (ff->open_flags & FOPEN_DIRECT_IO)\n\t\tfile->f_op = &fuse_direct_io_file_operations;\n\tif (!(ff->open_flags & FOPEN_KEEP_CACHE))\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\tif (ff->open_flags & FOPEN_NONSEEKABLE)\n\t\tnonseekable_open(inode, file);\n\tif (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, 0);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tif (fc->writeback_cache)\n\t\t\tfile_update_time(file);\n\t}\n\tif ((file->f_mode & FMODE_WRITE) && fc->writeback_cache)\n\t\tfuse_link_write_file(file);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_direct_io_file_operations;",
            "static const struct file_operations fuse_direct_io_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= fuse_direct_read,\n\t.write\t\t= fuse_direct_write,\n\t.mmap\t\t= fuse_direct_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n\t/* no splice_read */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_direct_io_file_operations;\nstatic const struct file_operations fuse_direct_io_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= fuse_direct_read,\n\t.write\t\t= fuse_direct_write,\n\t.mmap\t\t= fuse_direct_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n\t/* no splice_read */\n};\n\nvoid fuse_finish_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (ff->open_flags & FOPEN_DIRECT_IO)\n\t\tfile->f_op = &fuse_direct_io_file_operations;\n\tif (!(ff->open_flags & FOPEN_KEEP_CACHE))\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\tif (ff->open_flags & FOPEN_NONSEEKABLE)\n\t\tnonseekable_open(inode, file);\n\tif (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, 0);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t\tif (fc->writeback_cache)\n\t\t\tfile_update_time(file);\n\t}\n\tif ((file->f_mode & FMODE_WRITE) && fc->writeback_cache)\n\t\tfuse_link_write_file(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_file_get",
          "args": [
            "ff"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "78-82",
          "snippet": "struct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_sync_release",
          "args": [
            "ff",
            "flags"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_sync_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "298-307",
          "snippet": "void fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\tff->reserved_req->force = 1;\n\tff->reserved_req->background = 0;\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\tff->reserved_req->force = 1;\n\tff->reserved_req->background = 0;\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_open",
          "args": [
            "file",
            "entry",
            "generic_file_open",
            "opened"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "finish_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "784-797",
          "snippet": "int finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "dir"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_change_entry_timeout",
          "args": [
            "entry",
            "&outentry"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_change_entry_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "89-94",
          "snippet": "static void fuse_change_entry_timeout(struct dentry *entry,\n\t\t\t\t      struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\ttime_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_change_entry_timeout(struct dentry *entry,\n\t\t\t\t      struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\ttime_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "entry",
            "inode"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "forget"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_queue_forget",
          "args": [
            "fc",
            "forget",
            "outentry.nodeid",
            "1"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_queue_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "337-353",
          "snippet": "void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->forget_list_tail->next = forget;\n\t\tfc->forget_list_tail = forget;\n\t\twake_up(&fc->waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->forget_list_tail->next = forget;\n\t\tfc->forget_list_tail = forget;\n\t\twake_up(&fc->waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_iget",
          "args": [
            "dir->i_sb",
            "outentry.nodeid",
            "outentry.generation",
            "&outentry.attr",
            "entry_attr_timeout(&outentry)",
            "0"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "293-327",
          "snippet": "struct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n retry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t/* Inode has changed type, any I/O on the old should fail */\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fc->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fc->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n retry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t/* Inode has changed type, any I/O on the old should fail */\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fc->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fc->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_attr_timeout",
          "args": [
            "&outentry"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "entry_attr_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "101-104",
          "snippet": "static u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalid_nodeid",
          "args": [
            "outentry.nodeid"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "invalid_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "270-273",
          "snippet": "static int invalid_nodeid(u64 nodeid)\n{\n\treturn !nodeid || nodeid == FUSE_ROOT_ID;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int invalid_nodeid(u64 nodeid)\n{\n\treturn !nodeid || nodeid == FUSE_ROOT_ID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "outentry.attr.mode"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "dir"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&outentry",
            "0",
            "sizeof(outentry)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&inarg",
            "0",
            "sizeof(inarg)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_file_alloc",
          "args": [
            "fc"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_file_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "45-70",
          "snippet": "struct fuse_file *fuse_file_alloc(struct fuse_conn *fc)\n{\n\tstruct fuse_file *ff;\n\n\tff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);\n\tif (unlikely(!ff))\n\t\treturn NULL;\n\n\tff->fc = fc;\n\tff->reserved_req = fuse_request_alloc(0);\n\tif (unlikely(!ff->reserved_req)) {\n\t\tkfree(ff);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ff->write_entry);\n\tatomic_set(&ff->count, 0);\n\tRB_CLEAR_NODE(&ff->polled_node);\n\tinit_waitqueue_head(&ff->poll_wait);\n\n\tspin_lock(&fc->lock);\n\tff->kh = ++fc->khctr;\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_file *fuse_file_alloc(struct fuse_conn *fc)\n{\n\tstruct fuse_file *ff;\n\n\tff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);\n\tif (unlikely(!ff))\n\t\treturn NULL;\n\n\tff->fc = fc;\n\tff->reserved_req = fuse_request_alloc(0);\n\tif (unlikely(!ff->reserved_req)) {\n\t\tkfree(ff);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ff->write_entry);\n\tatomic_set(&ff->count, 0);\n\tRB_CLEAR_NODE(&ff->polled_node);\n\tinit_waitqueue_head(&ff->poll_wait);\n\n\tspin_lock(&fc->lock);\n\tff->kh = ++fc->khctr;\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_alloc_forget",
          "args": [],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_alloc_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "74-77",
          "snippet": "struct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(mode & S_IFMT) != S_IFREG"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "dir"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_create_open(struct inode *dir, struct dentry *entry,\n\t\t\t    struct file *file, unsigned flags,\n\t\t\t    umode_t mode, int *opened)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tstruct fuse_create_in inarg;\n\tstruct fuse_open_out outopen;\n\tstruct fuse_entry_out outentry;\n\tstruct fuse_file *ff;\n\n\t/* Userspace expects S_IFREG in create mode */\n\tBUG_ON((mode & S_IFMT) != S_IFREG);\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out_err;\n\n\terr = -ENOMEM;\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\tgoto out_put_forget_req;\n\n\tif (!fc->dont_mask)\n\t\tmode &= ~current_umask();\n\n\tflags &= ~O_NOCTTY;\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outentry, 0, sizeof(outentry));\n\tinarg.flags = flags;\n\tinarg.mode = mode;\n\tinarg.umask = current_umask();\n\targs.in.h.opcode = FUSE_CREATE;\n\targs.in.h.nodeid = get_node_id(dir);\n\targs.in.numargs = 2;\n\targs.in.args[0].size = sizeof(inarg);\n\targs.in.args[0].value = &inarg;\n\targs.in.args[1].size = entry->d_name.len + 1;\n\targs.in.args[1].value = entry->d_name.name;\n\targs.out.numargs = 2;\n\targs.out.args[0].size = sizeof(outentry);\n\targs.out.args[0].value = &outentry;\n\targs.out.args[1].size = sizeof(outopen);\n\targs.out.args[1].value = &outopen;\n\terr = fuse_simple_request(fc, &args);\n\tif (err)\n\t\tgoto out_free_ff;\n\n\terr = -EIO;\n\tif (!S_ISREG(outentry.attr.mode) || invalid_nodeid(outentry.nodeid))\n\t\tgoto out_free_ff;\n\n\tff->fh = outopen.fh;\n\tff->nodeid = outentry.nodeid;\n\tff->open_flags = outopen.open_flags;\n\tinode = fuse_iget(dir->i_sb, outentry.nodeid, outentry.generation,\n\t\t\t  &outentry.attr, entry_attr_timeout(&outentry), 0);\n\tif (!inode) {\n\t\tflags &= ~(O_CREAT | O_EXCL | O_TRUNC);\n\t\tfuse_sync_release(ff, flags);\n\t\tfuse_queue_forget(fc, forget, outentry.nodeid, 1);\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tkfree(forget);\n\td_instantiate(entry, inode);\n\tfuse_change_entry_timeout(entry, &outentry);\n\tfuse_invalidate_attr(dir);\n\terr = finish_open(file, entry, generic_file_open, opened);\n\tif (err) {\n\t\tfuse_sync_release(ff, flags);\n\t} else {\n\t\tfile->private_data = fuse_file_get(ff);\n\t\tfuse_finish_open(inode, file);\n\t}\n\treturn err;\n\nout_free_ff:\n\tfuse_file_free(ff);\nout_put_forget_req:\n\tkfree(forget);\nout_err:\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "335-375",
    "snippet": "static struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,\n\t\t\t\t  unsigned int flags)\n{\n\tint err;\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tstruct dentry *newent;\n\tbool outarg_valid = true;\n\n\terr = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,\n\t\t\t       &outarg, &inode);\n\tif (err == -ENOENT) {\n\t\toutarg_valid = false;\n\t\terr = 0;\n\t}\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tif (inode && get_node_id(inode) == FUSE_ROOT_ID)\n\t\tgoto out_iput;\n\n\tnewent = d_splice_alias(inode, entry);\n\terr = PTR_ERR(newent);\n\tif (IS_ERR(newent))\n\t\tgoto out_err;\n\n\tentry = newent ? newent : entry;\n\tif (outarg_valid)\n\t\tfuse_change_entry_timeout(entry, &outarg);\n\telse\n\t\tfuse_invalidate_entry_cache(entry);\n\n\tfuse_advise_use_readdirplus(dir);\n\treturn newent;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_advise_use_readdirplus",
          "args": [
            "dir"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_advise_use_readdirplus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "33-38",
          "snippet": "static void fuse_advise_use_readdirplus(struct inode *dir)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(dir);\n\n\tset_bit(FUSE_I_ADVISE_RDPLUS, &fi->state);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_advise_use_readdirplus(struct inode *dir)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(dir);\n\n\tset_bit(FUSE_I_ADVISE_RDPLUS, &fi->state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_invalidate_entry_cache",
          "args": [
            "entry"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_entry_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "133-136",
          "snippet": "void fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_change_entry_timeout",
          "args": [
            "entry",
            "&outarg"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_change_entry_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "89-94",
          "snippet": "static void fuse_change_entry_timeout(struct dentry *entry,\n\t\t\t\t      struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\ttime_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_change_entry_timeout(struct dentry *entry,\n\t\t\t\t      struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\ttime_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "newent"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "newent"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "entry"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lookup_name",
          "args": [
            "dir->i_sb",
            "get_node_id(dir)",
            "&entry->d_name",
            "&outarg",
            "&inode"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lookup_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "285-333",
          "snippet": "int fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,\n\t\t     struct fuse_entry_out *outarg, struct inode **inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tu64 attr_version;\n\tint err;\n\n\t*inode = NULL;\n\terr = -ENAMETOOLONG;\n\tif (name->len > FUSE_NAME_MAX)\n\t\tgoto out;\n\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tfuse_lookup_init(fc, &args, nodeid, name, outarg);\n\terr = fuse_simple_request(fc, &args);\n\t/* Zero nodeid is same as -ENOENT, but with valid timeout */\n\tif (err || !outarg->nodeid)\n\t\tgoto out_put_forget;\n\n\terr = -EIO;\n\tif (!outarg->nodeid)\n\t\tgoto out_put_forget;\n\tif (!fuse_valid_type(outarg->attr.mode))\n\t\tgoto out_put_forget;\n\n\t*inode = fuse_iget(sb, outarg->nodeid, outarg->generation,\n\t\t\t   &outarg->attr, entry_attr_timeout(outarg),\n\t\t\t   attr_version);\n\terr = -ENOMEM;\n\tif (!*inode) {\n\t\tfuse_queue_forget(fc, forget, outarg->nodeid, 1);\n\t\tgoto out;\n\t}\n\terr = 0;\n\n out_put_forget:\n\tkfree(forget);\n out:\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,\n\t\t     struct fuse_entry_out *outarg, struct inode **inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tu64 attr_version;\n\tint err;\n\n\t*inode = NULL;\n\terr = -ENAMETOOLONG;\n\tif (name->len > FUSE_NAME_MAX)\n\t\tgoto out;\n\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tfuse_lookup_init(fc, &args, nodeid, name, outarg);\n\terr = fuse_simple_request(fc, &args);\n\t/* Zero nodeid is same as -ENOENT, but with valid timeout */\n\tif (err || !outarg->nodeid)\n\t\tgoto out_put_forget;\n\n\terr = -EIO;\n\tif (!outarg->nodeid)\n\t\tgoto out_put_forget;\n\tif (!fuse_valid_type(outarg->attr.mode))\n\t\tgoto out_put_forget;\n\n\t*inode = fuse_iget(sb, outarg->nodeid, outarg->generation,\n\t\t\t   &outarg->attr, entry_attr_timeout(outarg),\n\t\t\t   attr_version);\n\terr = -ENOMEM;\n\tif (!*inode) {\n\t\tfuse_queue_forget(fc, forget, outarg->nodeid, 1);\n\t\tgoto out;\n\t}\n\terr = 0;\n\n out_put_forget:\n\tkfree(forget);\n out:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,\n\t\t\t\t  unsigned int flags)\n{\n\tint err;\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tstruct dentry *newent;\n\tbool outarg_valid = true;\n\n\terr = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,\n\t\t\t       &outarg, &inode);\n\tif (err == -ENOENT) {\n\t\toutarg_valid = false;\n\t\terr = 0;\n\t}\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tif (inode && get_node_id(inode) == FUSE_ROOT_ID)\n\t\tgoto out_iput;\n\n\tnewent = d_splice_alias(inode, entry);\n\terr = PTR_ERR(newent);\n\tif (IS_ERR(newent))\n\t\tgoto out_err;\n\n\tentry = newent ? newent : entry;\n\tif (outarg_valid)\n\t\tfuse_change_entry_timeout(entry, &outarg);\n\telse\n\t\tfuse_invalidate_entry_cache(entry);\n\n\tfuse_advise_use_readdirplus(dir);\n\treturn newent;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "fuse_lookup_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "285-333",
    "snippet": "int fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,\n\t\t     struct fuse_entry_out *outarg, struct inode **inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tu64 attr_version;\n\tint err;\n\n\t*inode = NULL;\n\terr = -ENAMETOOLONG;\n\tif (name->len > FUSE_NAME_MAX)\n\t\tgoto out;\n\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tfuse_lookup_init(fc, &args, nodeid, name, outarg);\n\terr = fuse_simple_request(fc, &args);\n\t/* Zero nodeid is same as -ENOENT, but with valid timeout */\n\tif (err || !outarg->nodeid)\n\t\tgoto out_put_forget;\n\n\terr = -EIO;\n\tif (!outarg->nodeid)\n\t\tgoto out_put_forget;\n\tif (!fuse_valid_type(outarg->attr.mode))\n\t\tgoto out_put_forget;\n\n\t*inode = fuse_iget(sb, outarg->nodeid, outarg->generation,\n\t\t\t   &outarg->attr, entry_attr_timeout(outarg),\n\t\t\t   attr_version);\n\terr = -ENOMEM;\n\tif (!*inode) {\n\t\tfuse_queue_forget(fc, forget, outarg->nodeid, 1);\n\t\tgoto out;\n\t}\n\terr = 0;\n\n out_put_forget:\n\tkfree(forget);\n out:\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "forget"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_queue_forget",
          "args": [
            "fc",
            "forget",
            "outarg->nodeid",
            "1"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_queue_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "337-353",
          "snippet": "void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->forget_list_tail->next = forget;\n\t\tfc->forget_list_tail = forget;\n\t\twake_up(&fc->waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->forget_list_tail->next = forget;\n\t\tfc->forget_list_tail = forget;\n\t\twake_up(&fc->waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_iget",
          "args": [
            "sb",
            "outarg->nodeid",
            "outarg->generation",
            "&outarg->attr",
            "entry_attr_timeout(outarg)",
            "attr_version"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "293-327",
          "snippet": "struct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n retry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t/* Inode has changed type, any I/O on the old should fail */\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fc->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fc->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n retry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t/* Inode has changed type, any I/O on the old should fail */\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\n\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fc->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fc->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_attr_timeout",
          "args": [
            "outarg"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "entry_attr_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "101-104",
          "snippet": "static u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_valid_type",
          "args": [
            "outarg->attr.mode"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_valid_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "279-283",
          "snippet": "int fuse_valid_type(int m)\n{\n\treturn S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||\n\t\tS_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_valid_type(int m)\n{\n\treturn S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||\n\t\tS_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lookup_init",
          "args": [
            "fc",
            "&args",
            "nodeid",
            "name",
            "outarg"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lookup_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "148-161",
          "snippet": "static void fuse_lookup_init(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t     u64 nodeid, struct qstr *name,\n\t\t\t     struct fuse_entry_out *outarg)\n{\n\tmemset(outarg, 0, sizeof(struct fuse_entry_out));\n\targs->in.h.opcode = FUSE_LOOKUP;\n\targs->in.h.nodeid = nodeid;\n\targs->in.numargs = 1;\n\targs->in.args[0].size = name->len + 1;\n\targs->in.args[0].value = name->name;\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(struct fuse_entry_out);\n\targs->out.args[0].value = outarg;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_lookup_init(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t     u64 nodeid, struct qstr *name,\n\t\t\t     struct fuse_entry_out *outarg)\n{\n\tmemset(outarg, 0, sizeof(struct fuse_entry_out));\n\targs->in.h.opcode = FUSE_LOOKUP;\n\targs->in.h.nodeid = nodeid;\n\targs->in.numargs = 1;\n\targs->in.args[0].size = name->len + 1;\n\targs->in.args[0].value = name->name;\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(struct fuse_entry_out);\n\targs->out.args[0].value = outarg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_attr_version",
          "args": [
            "fc"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_attr_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "163-176",
          "snippet": "u64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_alloc_forget",
          "args": [],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_alloc_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "74-77",
          "snippet": "struct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fuse_conn_super",
          "args": [
            "sb"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "618-621",
          "snippet": "static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_lookup_name(struct super_block *sb, u64 nodeid, struct qstr *name,\n\t\t     struct fuse_entry_out *outarg, struct inode **inode)\n{\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\tFUSE_ARGS(args);\n\tstruct fuse_forget_link *forget;\n\tu64 attr_version;\n\tint err;\n\n\t*inode = NULL;\n\terr = -ENAMETOOLONG;\n\tif (name->len > FUSE_NAME_MAX)\n\t\tgoto out;\n\n\n\tforget = fuse_alloc_forget();\n\terr = -ENOMEM;\n\tif (!forget)\n\t\tgoto out;\n\n\tattr_version = fuse_get_attr_version(fc);\n\n\tfuse_lookup_init(fc, &args, nodeid, name, outarg);\n\terr = fuse_simple_request(fc, &args);\n\t/* Zero nodeid is same as -ENOENT, but with valid timeout */\n\tif (err || !outarg->nodeid)\n\t\tgoto out_put_forget;\n\n\terr = -EIO;\n\tif (!outarg->nodeid)\n\t\tgoto out_put_forget;\n\tif (!fuse_valid_type(outarg->attr.mode))\n\t\tgoto out_put_forget;\n\n\t*inode = fuse_iget(sb, outarg->nodeid, outarg->generation,\n\t\t\t   &outarg->attr, entry_attr_timeout(outarg),\n\t\t\t   attr_version);\n\terr = -ENOMEM;\n\tif (!*inode) {\n\t\tfuse_queue_forget(fc, forget, outarg->nodeid, 1);\n\t\tgoto out;\n\t}\n\terr = 0;\n\n out_put_forget:\n\tkfree(forget);\n out:\n\treturn err;\n}"
  },
  {
    "function_name": "fuse_valid_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "279-283",
    "snippet": "int fuse_valid_type(int m)\n{\n\treturn S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||\n\t\tS_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "m"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "m"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "m"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "m"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "m"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "m"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "m"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nint fuse_valid_type(int m)\n{\n\treturn S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||\n\t\tS_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);\n}"
  },
  {
    "function_name": "invalid_nodeid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "270-273",
    "snippet": "static int invalid_nodeid(u64 nodeid)\n{\n\treturn !nodeid || nodeid == FUSE_ROOT_ID;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int invalid_nodeid(u64 nodeid)\n{\n\treturn !nodeid || nodeid == FUSE_ROOT_ID;\n}"
  },
  {
    "function_name": "fuse_dentry_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "187-268",
    "snippet": "static int fuse_dentry_revalidate(struct dentry *entry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\tstruct fuse_conn *fc;\n\tstruct fuse_inode *fi;\n\tint ret;\n\n\tinode = ACCESS_ONCE(entry->d_inode);\n\tif (inode && is_bad_inode(inode))\n\t\tgoto invalid;\n\telse if (time_before64(fuse_dentry_time(entry), get_jiffies_64()) ||\n\t\t (flags & LOOKUP_REVAL)) {\n\t\tstruct fuse_entry_out outarg;\n\t\tFUSE_ARGS(args);\n\t\tstruct fuse_forget_link *forget;\n\t\tu64 attr_version;\n\n\t\t/* For negative dentries, always do a fresh lookup */\n\t\tif (!inode)\n\t\t\tgoto invalid;\n\n\t\tret = -ECHILD;\n\t\tif (flags & LOOKUP_RCU)\n\t\t\tgoto out;\n\n\t\tfc = get_fuse_conn(inode);\n\n\t\tforget = fuse_alloc_forget();\n\t\tret = -ENOMEM;\n\t\tif (!forget)\n\t\t\tgoto out;\n\n\t\tattr_version = fuse_get_attr_version(fc);\n\n\t\tparent = dget_parent(entry);\n\t\tfuse_lookup_init(fc, &args, get_node_id(parent->d_inode),\n\t\t\t\t &entry->d_name, &outarg);\n\t\tret = fuse_simple_request(fc, &args);\n\t\tdput(parent);\n\t\t/* Zero nodeid is same as -ENOENT */\n\t\tif (!ret && !outarg.nodeid)\n\t\t\tret = -ENOENT;\n\t\tif (!ret) {\n\t\t\tfi = get_fuse_inode(inode);\n\t\t\tif (outarg.nodeid != get_node_id(inode)) {\n\t\t\t\tfuse_queue_forget(fc, forget, outarg.nodeid, 1);\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tspin_lock(&fc->lock);\n\t\t\tfi->nlookup++;\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\t\tkfree(forget);\n\t\tif (ret == -ENOMEM)\n\t\t\tgoto out;\n\t\tif (ret || (outarg.attr.mode ^ inode->i_mode) & S_IFMT)\n\t\t\tgoto invalid;\n\n\t\tfuse_change_attributes(inode, &outarg.attr,\n\t\t\t\t       entry_attr_timeout(&outarg),\n\t\t\t\t       attr_version);\n\t\tfuse_change_entry_timeout(entry, &outarg);\n\t} else if (inode) {\n\t\tfi = get_fuse_inode(inode);\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tif (test_bit(FUSE_I_INIT_RDPLUS, &fi->state))\n\t\t\t\treturn -ECHILD;\n\t\t} else if (test_and_clear_bit(FUSE_I_INIT_RDPLUS, &fi->state)) {\n\t\t\tparent = dget_parent(entry);\n\t\t\tfuse_advise_use_readdirplus(parent->d_inode);\n\t\t\tdput(parent);\n\t\t}\n\t}\n\tret = 1;\nout:\n\treturn ret;\n\ninvalid:\n\tret = 0;\n\tgoto out;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_advise_use_readdirplus",
          "args": [
            "parent->d_inode"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_advise_use_readdirplus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "33-38",
          "snippet": "static void fuse_advise_use_readdirplus(struct inode *dir)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(dir);\n\n\tset_bit(FUSE_I_ADVISE_RDPLUS, &fi->state);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_advise_use_readdirplus(struct inode *dir)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(dir);\n\n\tset_bit(FUSE_I_ADVISE_RDPLUS, &fi->state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "entry"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "FUSE_I_INIT_RDPLUS",
            "&fi->state"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FUSE_I_INIT_RDPLUS",
            "&fi->state"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_change_entry_timeout",
          "args": [
            "entry",
            "&outarg"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_change_entry_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "89-94",
          "snippet": "static void fuse_change_entry_timeout(struct dentry *entry,\n\t\t\t\t      struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\ttime_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_change_entry_timeout(struct dentry *entry,\n\t\t\t\t      struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\ttime_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_change_attributes",
          "args": [
            "inode",
            "&outarg.attr",
            "entry_attr_timeout(&outarg)",
            "attr_version"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_change_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "199-251",
          "snippet": "void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    u64 attr_valid, u64 attr_version)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tstruct timespec old_mtime;\n\n\tspin_lock(&fc->lock);\n\tif ((attr_version != 0 && fi->attr_version > attr_version) ||\n\t    test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn;\n\t}\n\n\told_mtime = inode->i_mtime;\n\tfuse_change_attributes_common(inode, attr, attr_valid);\n\n\toldsize = inode->i_size;\n\t/*\n\t * In case of writeback_cache enabled, the cached writes beyond EOF\n\t * extend local i_size without keeping userspace server in sync. So,\n\t * attr->size coming from server can be stale. We cannot trust it.\n\t */\n\tif (!is_wb || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, attr->size);\n\tspin_unlock(&fc->lock);\n\n\tif (!is_wb && S_ISREG(inode->i_mode)) {\n\t\tbool inval = false;\n\n\t\tif (oldsize != attr->size) {\n\t\t\ttruncate_pagecache(inode, attr->size);\n\t\t\tinval = true;\n\t\t} else if (fc->auto_inval_data) {\n\t\t\tstruct timespec new_mtime = {\n\t\t\t\t.tv_sec = attr->mtime,\n\t\t\t\t.tv_nsec = attr->mtimensec,\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Auto inval mode also checks and invalidates if mtime\n\t\t\t * has changed.\n\t\t\t */\n\t\t\tif (!timespec_equal(&old_mtime, &new_mtime))\n\t\t\t\tinval = true;\n\t\t}\n\n\t\tif (inval)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_change_attributes(struct inode *inode, struct fuse_attr *attr,\n\t\t\t    u64 attr_valid, u64 attr_version)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tstruct timespec old_mtime;\n\n\tspin_lock(&fc->lock);\n\tif ((attr_version != 0 && fi->attr_version > attr_version) ||\n\t    test_bit(FUSE_I_SIZE_UNSTABLE, &fi->state)) {\n\t\tspin_unlock(&fc->lock);\n\t\treturn;\n\t}\n\n\told_mtime = inode->i_mtime;\n\tfuse_change_attributes_common(inode, attr, attr_valid);\n\n\toldsize = inode->i_size;\n\t/*\n\t * In case of writeback_cache enabled, the cached writes beyond EOF\n\t * extend local i_size without keeping userspace server in sync. So,\n\t * attr->size coming from server can be stale. We cannot trust it.\n\t */\n\tif (!is_wb || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, attr->size);\n\tspin_unlock(&fc->lock);\n\n\tif (!is_wb && S_ISREG(inode->i_mode)) {\n\t\tbool inval = false;\n\n\t\tif (oldsize != attr->size) {\n\t\t\ttruncate_pagecache(inode, attr->size);\n\t\t\tinval = true;\n\t\t} else if (fc->auto_inval_data) {\n\t\t\tstruct timespec new_mtime = {\n\t\t\t\t.tv_sec = attr->mtime,\n\t\t\t\t.tv_nsec = attr->mtimensec,\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Auto inval mode also checks and invalidates if mtime\n\t\t\t * has changed.\n\t\t\t */\n\t\t\tif (!timespec_equal(&old_mtime, &new_mtime))\n\t\t\t\tinval = true;\n\t\t}\n\n\t\tif (inval)\n\t\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_attr_timeout",
          "args": [
            "&outarg"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "entry_attr_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "101-104",
          "snippet": "static u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "forget"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_queue_forget",
          "args": [
            "fc",
            "forget",
            "outarg.nodeid",
            "1"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_queue_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "337-353",
          "snippet": "void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->forget_list_tail->next = forget;\n\t\tfc->forget_list_tail = forget;\n\t\twake_up(&fc->waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->forget_list_tail->next = forget;\n\t\tfc->forget_list_tail = forget;\n\t\twake_up(&fc->waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_id",
          "args": [
            "inode"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "633-636",
          "snippet": "static inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline u64 get_node_id(struct inode *inode)\n{\n\treturn get_fuse_inode(inode)->nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_simple_request",
          "args": [
            "fc",
            "&args"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_simple_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "558-588",
          "snippet": "ssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nssize_t fuse_simple_request(struct fuse_conn *fc, struct fuse_args *args)\n{\n\tstruct fuse_req *req;\n\tssize_t ret;\n\n\treq = fuse_get_req(fc, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* Needs to be done after fuse_get_req() so that fc->minor is valid */\n\tfuse_adjust_compat(fc, args);\n\n\treq->in.h.opcode = args->in.h.opcode;\n\treq->in.h.nodeid = args->in.h.nodeid;\n\treq->in.numargs = args->in.numargs;\n\tmemcpy(req->in.args, args->in.args,\n\t       args->in.numargs * sizeof(struct fuse_in_arg));\n\treq->out.argvar = args->out.argvar;\n\treq->out.numargs = args->out.numargs;\n\tmemcpy(req->out.args, args->out.args,\n\t       args->out.numargs * sizeof(struct fuse_arg));\n\tfuse_request_send(fc, req);\n\tret = req->out.h.error;\n\tif (!ret && args->out.argvar) {\n\t\tBUG_ON(args->out.numargs != 1);\n\t\tret = req->out.args[0].size;\n\t}\n\tfuse_put_request(fc, req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lookup_init",
          "args": [
            "fc",
            "&args",
            "get_node_id(parent->d_inode)",
            "&entry->d_name",
            "&outarg"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lookup_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "148-161",
          "snippet": "static void fuse_lookup_init(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t     u64 nodeid, struct qstr *name,\n\t\t\t     struct fuse_entry_out *outarg)\n{\n\tmemset(outarg, 0, sizeof(struct fuse_entry_out));\n\targs->in.h.opcode = FUSE_LOOKUP;\n\targs->in.h.nodeid = nodeid;\n\targs->in.numargs = 1;\n\targs->in.args[0].size = name->len + 1;\n\targs->in.args[0].value = name->name;\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(struct fuse_entry_out);\n\targs->out.args[0].value = outarg;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_lookup_init(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t     u64 nodeid, struct qstr *name,\n\t\t\t     struct fuse_entry_out *outarg)\n{\n\tmemset(outarg, 0, sizeof(struct fuse_entry_out));\n\targs->in.h.opcode = FUSE_LOOKUP;\n\targs->in.h.nodeid = nodeid;\n\targs->in.numargs = 1;\n\targs->in.args[0].size = name->len + 1;\n\targs->in.args[0].value = name->name;\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(struct fuse_entry_out);\n\targs->out.args[0].value = outarg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_get_attr_version",
          "args": [
            "fc"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_get_attr_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "163-176",
          "snippet": "u64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_alloc_forget",
          "args": [],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_alloc_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "74-77",
          "snippet": "struct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_forget_link *fuse_alloc_forget(void)\n{\n\treturn kzalloc(sizeof(struct fuse_forget_link), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "inode"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS",
          "args": [
            "args"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before64",
          "args": [
            "fuse_dentry_time(entry)",
            "get_jiffies_64()"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_jiffies_64",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_dentry_time",
          "args": [
            "entry"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_dentry_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "60-64",
          "snippet": "static u64 fuse_dentry_time(struct dentry *entry)\n{\n\treturn (u64) entry->d_time +\n\t\t((u64) (unsigned long) entry->d_fsdata << 32);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 fuse_dentry_time(struct dentry *entry)\n{\n\treturn (u64) entry->d_time +\n\t\t((u64) (unsigned long) entry->d_fsdata << 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "entry->d_inode"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic int fuse_dentry_revalidate(struct dentry *entry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\tstruct fuse_conn *fc;\n\tstruct fuse_inode *fi;\n\tint ret;\n\n\tinode = ACCESS_ONCE(entry->d_inode);\n\tif (inode && is_bad_inode(inode))\n\t\tgoto invalid;\n\telse if (time_before64(fuse_dentry_time(entry), get_jiffies_64()) ||\n\t\t (flags & LOOKUP_REVAL)) {\n\t\tstruct fuse_entry_out outarg;\n\t\tFUSE_ARGS(args);\n\t\tstruct fuse_forget_link *forget;\n\t\tu64 attr_version;\n\n\t\t/* For negative dentries, always do a fresh lookup */\n\t\tif (!inode)\n\t\t\tgoto invalid;\n\n\t\tret = -ECHILD;\n\t\tif (flags & LOOKUP_RCU)\n\t\t\tgoto out;\n\n\t\tfc = get_fuse_conn(inode);\n\n\t\tforget = fuse_alloc_forget();\n\t\tret = -ENOMEM;\n\t\tif (!forget)\n\t\t\tgoto out;\n\n\t\tattr_version = fuse_get_attr_version(fc);\n\n\t\tparent = dget_parent(entry);\n\t\tfuse_lookup_init(fc, &args, get_node_id(parent->d_inode),\n\t\t\t\t &entry->d_name, &outarg);\n\t\tret = fuse_simple_request(fc, &args);\n\t\tdput(parent);\n\t\t/* Zero nodeid is same as -ENOENT */\n\t\tif (!ret && !outarg.nodeid)\n\t\t\tret = -ENOENT;\n\t\tif (!ret) {\n\t\t\tfi = get_fuse_inode(inode);\n\t\t\tif (outarg.nodeid != get_node_id(inode)) {\n\t\t\t\tfuse_queue_forget(fc, forget, outarg.nodeid, 1);\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tspin_lock(&fc->lock);\n\t\t\tfi->nlookup++;\n\t\t\tspin_unlock(&fc->lock);\n\t\t}\n\t\tkfree(forget);\n\t\tif (ret == -ENOMEM)\n\t\t\tgoto out;\n\t\tif (ret || (outarg.attr.mode ^ inode->i_mode) & S_IFMT)\n\t\t\tgoto invalid;\n\n\t\tfuse_change_attributes(inode, &outarg.attr,\n\t\t\t\t       entry_attr_timeout(&outarg),\n\t\t\t\t       attr_version);\n\t\tfuse_change_entry_timeout(entry, &outarg);\n\t} else if (inode) {\n\t\tfi = get_fuse_inode(inode);\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tif (test_bit(FUSE_I_INIT_RDPLUS, &fi->state))\n\t\t\t\treturn -ECHILD;\n\t\t} else if (test_and_clear_bit(FUSE_I_INIT_RDPLUS, &fi->state)) {\n\t\t\tparent = dget_parent(entry);\n\t\t\tfuse_advise_use_readdirplus(parent->d_inode);\n\t\t\tdput(parent);\n\t\t}\n\t}\n\tret = 1;\nout:\n\treturn ret;\n\ninvalid:\n\tret = 0;\n\tgoto out;\n}"
  },
  {
    "function_name": "fuse_get_attr_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "163-176",
    "snippet": "u64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fc->lock"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fc->lock"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nu64 fuse_get_attr_version(struct fuse_conn *fc)\n{\n\tu64 curr_version;\n\n\t/*\n\t * The spin lock isn't actually needed on 64bit archs, but we\n\t * don't yet care too much about such optimizations.\n\t */\n\tspin_lock(&fc->lock);\n\tcurr_version = fc->attr_version;\n\tspin_unlock(&fc->lock);\n\n\treturn curr_version;\n}"
  },
  {
    "function_name": "fuse_lookup_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "148-161",
    "snippet": "static void fuse_lookup_init(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t     u64 nodeid, struct qstr *name,\n\t\t\t     struct fuse_entry_out *outarg)\n{\n\tmemset(outarg, 0, sizeof(struct fuse_entry_out));\n\targs->in.h.opcode = FUSE_LOOKUP;\n\targs->in.h.nodeid = nodeid;\n\targs->in.numargs = 1;\n\targs->in.args[0].size = name->len + 1;\n\targs->in.args[0].value = name->name;\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(struct fuse_entry_out);\n\targs->out.args[0].value = outarg;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "outarg",
            "0",
            "sizeof(struct fuse_entry_out)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_lookup_init(struct fuse_conn *fc, struct fuse_args *args,\n\t\t\t     u64 nodeid, struct qstr *name,\n\t\t\t     struct fuse_entry_out *outarg)\n{\n\tmemset(outarg, 0, sizeof(struct fuse_entry_out));\n\targs->in.h.opcode = FUSE_LOOKUP;\n\targs->in.h.nodeid = nodeid;\n\targs->in.numargs = 1;\n\targs->in.args[0].size = name->len + 1;\n\targs->in.args[0].value = name->name;\n\targs->out.numargs = 1;\n\targs->out.args[0].size = sizeof(struct fuse_entry_out);\n\targs->out.args[0].value = outarg;\n}"
  },
  {
    "function_name": "fuse_invalidate_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "142-146",
    "snippet": "static void fuse_invalidate_entry(struct dentry *entry)\n{\n\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_invalidate_entry_cache",
          "args": [
            "entry"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_entry_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "133-136",
          "snippet": "void fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_invalidate",
          "args": [
            "entry"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "d_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1465-1506",
          "snippet": "void d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_invalidate_entry(struct dentry *entry)\n{\n\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n}"
  },
  {
    "function_name": "fuse_invalidate_entry_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "133-136",
    "snippet": "void fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_dentry_settime",
          "args": [
            "entry",
            "0"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_dentry_settime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "54-58",
          "snippet": "static void fuse_dentry_settime(struct dentry *entry, u64 time)\n{\n\tentry->d_time = time;\n\tentry->d_fsdata = (void *) (unsigned long) (time >> 32);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_dentry_settime(struct dentry *entry, u64 time)\n{\n\tentry->d_time = time;\n\tentry->d_fsdata = (void *) (unsigned long) (time >> 32);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_entry_cache(struct dentry *entry)\n{\n\tfuse_dentry_settime(entry, 0);\n}"
  },
  {
    "function_name": "fuse_invalidate_atime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "119-123",
    "snippet": "void fuse_invalidate_atime(struct inode *inode)\n{\n\tif (!IS_RDONLY(inode))\n\t\tfuse_invalidate_attr(inode);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_invalidate_attr",
          "args": [
            "inode"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_invalidate_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "110-113",
          "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_RDONLY",
          "args": [
            "inode"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_atime(struct inode *inode)\n{\n\tif (!IS_RDONLY(inode))\n\t\tfuse_invalidate_attr(inode);\n}"
  },
  {
    "function_name": "fuse_invalidate_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "110-113",
    "snippet": "void fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "inode"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_invalidate_attr(struct inode *inode)\n{\n\tget_fuse_inode(inode)->i_time = 0;\n}"
  },
  {
    "function_name": "entry_attr_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "101-104",
    "snippet": "static u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_to_jiffies",
          "args": [
            "o->attr_valid",
            "o->attr_valid_nsec"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "time_to_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "76-83",
          "snippet": "static u64 time_to_jiffies(unsigned long sec, unsigned long nsec)\n{\n\tif (sec || nsec) {\n\t\tstruct timespec ts = {sec, nsec};\n\t\treturn get_jiffies_64() + timespec_to_jiffies(&ts);\n\t} else\n\t\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 time_to_jiffies(unsigned long sec, unsigned long nsec)\n{\n\tif (sec || nsec) {\n\t\tstruct timespec ts = {sec, nsec};\n\t\treturn get_jiffies_64() + timespec_to_jiffies(&ts);\n\t} else\n\t\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 entry_attr_timeout(struct fuse_entry_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}"
  },
  {
    "function_name": "attr_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "96-99",
    "snippet": "static u64 attr_timeout(struct fuse_attr_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_to_jiffies",
          "args": [
            "o->attr_valid",
            "o->attr_valid_nsec"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "time_to_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "76-83",
          "snippet": "static u64 time_to_jiffies(unsigned long sec, unsigned long nsec)\n{\n\tif (sec || nsec) {\n\t\tstruct timespec ts = {sec, nsec};\n\t\treturn get_jiffies_64() + timespec_to_jiffies(&ts);\n\t} else\n\t\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 time_to_jiffies(unsigned long sec, unsigned long nsec)\n{\n\tif (sec || nsec) {\n\t\tstruct timespec ts = {sec, nsec};\n\t\treturn get_jiffies_64() + timespec_to_jiffies(&ts);\n\t} else\n\t\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 attr_timeout(struct fuse_attr_out *o)\n{\n\treturn time_to_jiffies(o->attr_valid, o->attr_valid_nsec);\n}"
  },
  {
    "function_name": "fuse_change_entry_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "89-94",
    "snippet": "static void fuse_change_entry_timeout(struct dentry *entry,\n\t\t\t\t      struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\ttime_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_dentry_settime",
          "args": [
            "entry",
            "time_to_jiffies(o->entry_valid, o->entry_valid_nsec)"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_dentry_settime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "54-58",
          "snippet": "static void fuse_dentry_settime(struct dentry *entry, u64 time)\n{\n\tentry->d_time = time;\n\tentry->d_fsdata = (void *) (unsigned long) (time >> 32);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_dentry_settime(struct dentry *entry, u64 time)\n{\n\tentry->d_time = time;\n\tentry->d_fsdata = (void *) (unsigned long) (time >> 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_to_jiffies",
          "args": [
            "o->entry_valid",
            "o->entry_valid_nsec"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "time_to_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
          "lines": "76-83",
          "snippet": "static u64 time_to_jiffies(unsigned long sec, unsigned long nsec)\n{\n\tif (sec || nsec) {\n\t\tstruct timespec ts = {sec, nsec};\n\t\treturn get_jiffies_64() + timespec_to_jiffies(&ts);\n\t} else\n\t\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 time_to_jiffies(unsigned long sec, unsigned long nsec)\n{\n\tif (sec || nsec) {\n\t\tstruct timespec ts = {sec, nsec};\n\t\treturn get_jiffies_64() + timespec_to_jiffies(&ts);\n\t} else\n\t\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_change_entry_timeout(struct dentry *entry,\n\t\t\t\t      struct fuse_entry_out *o)\n{\n\tfuse_dentry_settime(entry,\n\t\ttime_to_jiffies(o->entry_valid, o->entry_valid_nsec));\n}"
  },
  {
    "function_name": "time_to_jiffies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "76-83",
    "snippet": "static u64 time_to_jiffies(unsigned long sec, unsigned long nsec)\n{\n\tif (sec || nsec) {\n\t\tstruct timespec ts = {sec, nsec};\n\t\treturn get_jiffies_64() + timespec_to_jiffies(&ts);\n\t} else\n\t\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec_to_jiffies",
          "args": [
            "&ts"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_jiffies_64",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 time_to_jiffies(unsigned long sec, unsigned long nsec)\n{\n\tif (sec || nsec) {\n\t\tstruct timespec ts = {sec, nsec};\n\t\treturn get_jiffies_64() + timespec_to_jiffies(&ts);\n\t} else\n\t\treturn 0;\n}"
  },
  {
    "function_name": "fuse_dentry_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "60-64",
    "snippet": "static u64 fuse_dentry_time(struct dentry *entry)\n{\n\treturn (u64) entry->d_time +\n\t\t((u64) (unsigned long) entry->d_fsdata << 32);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic u64 fuse_dentry_time(struct dentry *entry)\n{\n\treturn (u64) entry->d_time +\n\t\t((u64) (unsigned long) entry->d_fsdata << 32);\n}"
  },
  {
    "function_name": "fuse_dentry_settime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "54-58",
    "snippet": "static void fuse_dentry_settime(struct dentry *entry, u64 time)\n{\n\tentry->d_time = time;\n\tentry->d_fsdata = (void *) (unsigned long) (time >> 32);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_dentry_settime(struct dentry *entry, u64 time)\n{\n\tentry->d_time = time;\n\tentry->d_fsdata = (void *) (unsigned long) (time >> 32);\n}"
  },
  {
    "function_name": "fuse_dentry_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "46-49",
    "snippet": "static inline u64 fuse_dentry_time(struct dentry *entry)\n{\n\treturn entry->d_time;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline u64 fuse_dentry_time(struct dentry *entry)\n{\n\treturn entry->d_time;\n}"
  },
  {
    "function_name": "fuse_dentry_settime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "41-44",
    "snippet": "static inline void fuse_dentry_settime(struct dentry *entry, u64 time)\n{\n\tentry->d_time = time;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic inline void fuse_dentry_settime(struct dentry *entry, u64 time)\n{\n\tentry->d_time = time;\n}"
  },
  {
    "function_name": "fuse_advise_use_readdirplus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "33-38",
    "snippet": "static void fuse_advise_use_readdirplus(struct inode *dir)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(dir);\n\n\tset_bit(FUSE_I_ADVISE_RDPLUS, &fi->state);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FUSE_I_ADVISE_RDPLUS",
            "&fi->state"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "dir"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_advise_use_readdirplus(struct inode *dir)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(dir);\n\n\tset_bit(FUSE_I_ADVISE_RDPLUS, &fi->state);\n}"
  },
  {
    "function_name": "fuse_use_readdirplus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dir.c",
    "lines": "17-31",
    "snippet": "static bool fuse_use_readdirplus(struct inode *dir, struct dir_context *ctx)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tstruct fuse_inode *fi = get_fuse_inode(dir);\n\n\tif (!fc->do_readdirplus)\n\t\treturn false;\n\tif (!fc->readdirplus_auto)\n\t\treturn true;\n\tif (test_and_clear_bit(FUSE_I_ADVISE_RDPLUS, &fi->state))\n\t\treturn true;\n\tif (ctx->pos == 0)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "FUSE_I_ADVISE_RDPLUS",
            "&fi->state"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_inode",
          "args": [
            "dir"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "628-631",
          "snippet": "static inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode)\n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fuse_conn",
          "args": [
            "dir"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "get_fuse_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/fuse_i.h",
          "lines": "623-626",
          "snippet": "static inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/poll.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/fuse.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/poll.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/fuse.h>\n\nstatic inline struct fuse_conn *get_fuse_conn(struct inode *inode)\n{\n\treturn get_fuse_conn_super(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic bool fuse_use_readdirplus(struct inode *dir, struct dir_context *ctx)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(dir);\n\tstruct fuse_inode *fi = get_fuse_inode(dir);\n\n\tif (!fc->do_readdirplus)\n\t\treturn false;\n\tif (!fc->readdirplus_auto)\n\t\treturn true;\n\tif (test_and_clear_bit(FUSE_I_ADVISE_RDPLUS, &fi->state))\n\t\treturn true;\n\tif (ctx->pos == 0)\n\t\treturn true;\n\treturn false;\n}"
  }
]