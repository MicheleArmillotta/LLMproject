[
  {
    "function_name": "ext2_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
    "lines": "322-403",
    "snippet": "static int ext2_rename (struct inode * old_dir, struct dentry * old_dentry,\n\tstruct inode * new_dir,\tstruct dentry * new_dentry )\n{\n\tstruct inode * old_inode = old_dentry->d_inode;\n\tstruct inode * new_inode = new_dentry->d_inode;\n\tstruct page * dir_page = NULL;\n\tstruct ext2_dir_entry_2 * dir_de = NULL;\n\tstruct page * old_page;\n\tstruct ext2_dir_entry_2 * old_de;\n\tint err = -ENOENT;\n\n\tdquot_initialize(old_dir);\n\tdquot_initialize(new_dir);\n\n\told_de = ext2_find_entry (old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_de)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\tdir_de = ext2_dotdot(old_inode, &dir_page);\n\t\tif (!dir_de)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\t\tstruct page *new_page;\n\t\tstruct ext2_dir_entry_2 *new_de;\n\n\t\terr = -ENOTEMPTY;\n\t\tif (dir_de && !ext2_empty_dir (new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_de = ext2_find_entry (new_dir, &new_dentry->d_name, &new_page);\n\t\tif (!new_de)\n\t\t\tgoto out_dir;\n\t\text2_set_link(new_dir, new_de, new_page, old_inode, 1);\n\t\tnew_inode->i_ctime = CURRENT_TIME_SEC;\n\t\tif (dir_de)\n\t\t\tdrop_nlink(new_inode);\n\t\tinode_dec_link_count(new_inode);\n\t} else {\n\t\terr = ext2_add_link(new_dentry, old_inode);\n\t\tif (err)\n\t\t\tgoto out_dir;\n\t\tif (dir_de)\n\t\t\tinode_inc_link_count(new_dir);\n\t}\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n \t * rename.\n\t */\n\told_inode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(old_inode);\n\n\text2_delete_entry (old_de, old_page);\n\n\tif (dir_de) {\n\t\tif (old_dir != new_dir)\n\t\t\text2_set_link(old_inode, dir_de, dir_page, new_dir, 0);\n\t\telse {\n\t\t\tkunmap(dir_page);\n\t\t\tpage_cache_release(dir_page);\n\t\t}\n\t\tinode_dec_link_count(old_dir);\n\t}\n\treturn 0;\n\n\nout_dir:\n\tif (dir_de) {\n\t\tkunmap(dir_page);\n\t\tpage_cache_release(dir_page);\n\t}\nout_old:\n\tkunmap(old_page);\n\tpage_cache_release(old_page);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "old_page"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "old_page"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "dir_page"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "dir_page"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "old_dir"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "dir_page"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "dir_page"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_set_link",
          "args": [
            "old_inode",
            "dir_de",
            "dir_page",
            "new_dir",
            "0"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "463-482",
          "snippet": "void ext2_set_link(struct inode *dir, struct ext2_dir_entry_2 *de,\n\t\t   struct page *page, struct inode *inode, int update_times)\n{\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *) de - (char *) page_address(page);\n\tunsigned len = ext2_rec_len_from_disk(de->rec_len);\n\tint err;\n\n\tlock_page(page);\n\terr = ext2_prepare_chunk(page, pos, len);\n\tBUG_ON(err);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type(de, inode);\n\terr = ext2_commit_chunk(page, pos, len);\n\text2_put_page(page);\n\tif (update_times)\n\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tEXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(dir);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nvoid ext2_set_link(struct inode *dir, struct ext2_dir_entry_2 *de,\n\t\t   struct page *page, struct inode *inode, int update_times)\n{\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *) de - (char *) page_address(page);\n\tunsigned len = ext2_rec_len_from_disk(de->rec_len);\n\tint err;\n\n\tlock_page(page);\n\terr = ext2_prepare_chunk(page, pos, len);\n\tBUG_ON(err);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type(de, inode);\n\terr = ext2_commit_chunk(page, pos, len);\n\text2_put_page(page);\n\tif (update_times)\n\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tEXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_delete_entry",
          "args": [
            "old_de",
            "old_page"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "586-624",
          "snippet": "int ext2_delete_entry (struct ext2_dir_entry_2 * dir, struct page * page )\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char*)dir - kaddr) & ~(ext2_chunk_size(inode)-1);\n\tunsigned to = ((char *)dir - kaddr) +\n\t\t\t\text2_rec_len_from_disk(dir->rec_len);\n\tloff_t pos;\n\text2_dirent * pde = NULL;\n\text2_dirent * de = (ext2_dirent *) (kaddr + from);\n\tint err;\n\n\twhile ((char*)de < (char*)dir) {\n\t\tif (de->rec_len == 0) {\n\t\t\text2_error(inode->i_sb, __func__,\n\t\t\t\t\"zero-length directory entry\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = ext2_next_entry(de);\n\t}\n\tif (pde)\n\t\tfrom = (char*)pde - (char*)page_address(page);\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = ext2_prepare_chunk(page, pos, to - from);\n\tBUG_ON(err);\n\tif (pde)\n\t\tpde->rec_len = ext2_rec_len_to_disk(to - from);\n\tdir->inode = 0;\n\terr = ext2_commit_chunk(page, pos, to - from);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tEXT2_I(inode)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(inode);\nout:\n\text2_put_page(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nint ext2_delete_entry (struct ext2_dir_entry_2 * dir, struct page * page )\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char*)dir - kaddr) & ~(ext2_chunk_size(inode)-1);\n\tunsigned to = ((char *)dir - kaddr) +\n\t\t\t\text2_rec_len_from_disk(dir->rec_len);\n\tloff_t pos;\n\text2_dirent * pde = NULL;\n\text2_dirent * de = (ext2_dirent *) (kaddr + from);\n\tint err;\n\n\twhile ((char*)de < (char*)dir) {\n\t\tif (de->rec_len == 0) {\n\t\t\text2_error(inode->i_sb, __func__,\n\t\t\t\t\"zero-length directory entry\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = ext2_next_entry(de);\n\t}\n\tif (pde)\n\t\tfrom = (char*)pde - (char*)page_address(page);\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = ext2_prepare_chunk(page, pos, to - from);\n\tBUG_ON(err);\n\tif (pde)\n\t\tpde->rec_len = ext2_rec_len_to_disk(to - from);\n\tdir->inode = 0;\n\terr = ext2_commit_chunk(page, pos, to - from);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tEXT2_I(inode)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(inode);\nout:\n\text2_put_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "old_inode"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "new_dir"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_add_link",
          "args": [
            "new_dentry",
            "old_inode"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "487-580",
          "snippet": "int ext2_add_link (struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned chunk_size = ext2_chunk_size(dir);\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\text2_dirent * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ext2_get_page(dir, n, 0);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ext2_last_byte(dir, n);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->rec_len = ext2_rec_len_to_disk(chunk_size);\n\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = EXT2_DIR_REC_LEN(de->name_len);\n\t\t\trec_len = ext2_rec_len_from_disk(de->rec_len);\n\t\t\tif (!de->inode && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (ext2_dirent *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\text2_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t(char*)de - (char*)page_address(page);\n\terr = ext2_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->inode) {\n\t\text2_dirent *de1 = (ext2_dirent *) ((char *) de + name_len);\n\t\tde1->rec_len = ext2_rec_len_to_disk(rec_len - name_len);\n\t\tde->rec_len = ext2_rec_len_to_disk(name_len);\n\t\tde = de1;\n\t}\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type (de, inode);\n\terr = ext2_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tEXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\text2_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nint ext2_add_link (struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned chunk_size = ext2_chunk_size(dir);\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\text2_dirent * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ext2_get_page(dir, n, 0);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ext2_last_byte(dir, n);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->rec_len = ext2_rec_len_to_disk(chunk_size);\n\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = EXT2_DIR_REC_LEN(de->name_len);\n\t\t\trec_len = ext2_rec_len_from_disk(de->rec_len);\n\t\t\tif (!de->inode && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (ext2_dirent *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\text2_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t(char*)de - (char*)page_address(page);\n\terr = ext2_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->inode) {\n\t\text2_dirent *de1 = (ext2_dirent *) ((char *) de + name_len);\n\t\tde1->rec_len = ext2_rec_len_to_disk(rec_len - name_len);\n\t\tde->rec_len = ext2_rec_len_to_disk(name_len);\n\t\tde = de1;\n\t}\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type (de, inode);\n\terr = ext2_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tEXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\text2_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "new_inode"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "new_inode"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_find_entry",
          "args": [
            "new_dir",
            "&new_dentry->d_name",
            "&new_page"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "366-429",
          "snippet": "struct ext2_dir_entry_2 *ext2_find_entry (struct inode * dir,\n\t\t\tstruct qstr *child, struct page ** res_page)\n{\n\tconst char *name = child->name;\n\tint namelen = child->len;\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ext2_inode_info *ei = EXT2_I(dir);\n\text2_dirent * de;\n\tint dir_has_error = 0;\n\n\tif (npages == 0)\n\t\tgoto out;\n\n\t/* OFFSET_CACHE */\n\t*res_page = NULL;\n\n\tstart = ei->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ext2_get_page(dir, n, dir_has_error);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (ext2_dirent *) kaddr;\n\t\t\tkaddr += ext2_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->rec_len == 0) {\n\t\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\t\text2_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ext2_next_entry(de);\n\t\t\t}\n\t\t\text2_put_page(page);\n\t\t} else\n\t\t\tdir_has_error = 1;\n\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t\t/* next page is past the blocks we've got */\n\t\tif (unlikely(n > (dir->i_blocks >> (PAGE_CACHE_SHIFT - 9)))) {\n\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\"dir %lu size %lld exceeds block count %llu\",\n\t\t\t\tdir->i_ino, dir->i_size,\n\t\t\t\t(unsigned long long)dir->i_blocks);\n\t\t\tgoto out;\n\t\t}\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tei->i_dir_start_lookup = n;\n\treturn de;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nstruct ext2_dir_entry_2 *ext2_find_entry (struct inode * dir,\n\t\t\tstruct qstr *child, struct page ** res_page)\n{\n\tconst char *name = child->name;\n\tint namelen = child->len;\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ext2_inode_info *ei = EXT2_I(dir);\n\text2_dirent * de;\n\tint dir_has_error = 0;\n\n\tif (npages == 0)\n\t\tgoto out;\n\n\t/* OFFSET_CACHE */\n\t*res_page = NULL;\n\n\tstart = ei->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ext2_get_page(dir, n, dir_has_error);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (ext2_dirent *) kaddr;\n\t\t\tkaddr += ext2_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->rec_len == 0) {\n\t\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\t\text2_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ext2_next_entry(de);\n\t\t\t}\n\t\t\text2_put_page(page);\n\t\t} else\n\t\t\tdir_has_error = 1;\n\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t\t/* next page is past the blocks we've got */\n\t\tif (unlikely(n > (dir->i_blocks >> (PAGE_CACHE_SHIFT - 9)))) {\n\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\"dir %lu size %lld exceeds block count %llu\",\n\t\t\t\tdir->i_ino, dir->i_size,\n\t\t\t\t(unsigned long long)dir->i_blocks);\n\t\t\tgoto out;\n\t\t}\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tei->i_dir_start_lookup = n;\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_empty_dir",
          "args": [
            "new_inode"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "670-719",
          "snippet": "int ext2_empty_dir (struct inode * inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\tint dir_has_error = 0;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\text2_dirent * de;\n\t\tpage = ext2_get_page(inode, i, dir_has_error);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tdir_has_error = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = page_address(page);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += ext2_last_byte(inode, i) - EXT2_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(inode->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\tprintk(\"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->inode != 0) {\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (de->name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len < 2) {\n\t\t\t\t\tif (de->inode !=\n\t\t\t\t\t    cpu_to_le32(inode->i_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = ext2_next_entry(de);\n\t\t}\n\t\text2_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\text2_put_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nint ext2_empty_dir (struct inode * inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\tint dir_has_error = 0;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\text2_dirent * de;\n\t\tpage = ext2_get_page(inode, i, dir_has_error);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tdir_has_error = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = page_address(page);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += ext2_last_byte(inode, i) - EXT2_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(inode->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\tprintk(\"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->inode != 0) {\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (de->name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len < 2) {\n\t\t\t\t\tif (de->inode !=\n\t\t\t\t\t    cpu_to_le32(inode->i_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = ext2_next_entry(de);\n\t\t}\n\t\text2_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\text2_put_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_dotdot",
          "args": [
            "old_inode",
            "&dir_page"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_dotdot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "431-441",
          "snippet": "struct ext2_dir_entry_2 * ext2_dotdot (struct inode *dir, struct page **p)\n{\n\tstruct page *page = ext2_get_page(dir, 0, 0);\n\text2_dirent *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = ext2_next_entry((ext2_dirent *) page_address(page));\n\t\t*p = page;\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nstruct ext2_dir_entry_2 * ext2_dotdot (struct inode *dir, struct page **p)\n{\n\tstruct page *page = ext2_get_page(dir, 0, 0);\n\text2_dirent *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = ext2_next_entry((ext2_dirent *) page_address(page));\n\t\t*p = page;\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "new_dir"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic int ext2_rename (struct inode * old_dir, struct dentry * old_dentry,\n\tstruct inode * new_dir,\tstruct dentry * new_dentry )\n{\n\tstruct inode * old_inode = old_dentry->d_inode;\n\tstruct inode * new_inode = new_dentry->d_inode;\n\tstruct page * dir_page = NULL;\n\tstruct ext2_dir_entry_2 * dir_de = NULL;\n\tstruct page * old_page;\n\tstruct ext2_dir_entry_2 * old_de;\n\tint err = -ENOENT;\n\n\tdquot_initialize(old_dir);\n\tdquot_initialize(new_dir);\n\n\told_de = ext2_find_entry (old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_de)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\tdir_de = ext2_dotdot(old_inode, &dir_page);\n\t\tif (!dir_de)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\t\tstruct page *new_page;\n\t\tstruct ext2_dir_entry_2 *new_de;\n\n\t\terr = -ENOTEMPTY;\n\t\tif (dir_de && !ext2_empty_dir (new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_de = ext2_find_entry (new_dir, &new_dentry->d_name, &new_page);\n\t\tif (!new_de)\n\t\t\tgoto out_dir;\n\t\text2_set_link(new_dir, new_de, new_page, old_inode, 1);\n\t\tnew_inode->i_ctime = CURRENT_TIME_SEC;\n\t\tif (dir_de)\n\t\t\tdrop_nlink(new_inode);\n\t\tinode_dec_link_count(new_inode);\n\t} else {\n\t\terr = ext2_add_link(new_dentry, old_inode);\n\t\tif (err)\n\t\t\tgoto out_dir;\n\t\tif (dir_de)\n\t\t\tinode_inc_link_count(new_dir);\n\t}\n\n\t/*\n\t * Like most other Unix systems, set the ctime for inodes on a\n \t * rename.\n\t */\n\told_inode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(old_inode);\n\n\text2_delete_entry (old_de, old_page);\n\n\tif (dir_de) {\n\t\tif (old_dir != new_dir)\n\t\t\text2_set_link(old_inode, dir_de, dir_page, new_dir, 0);\n\t\telse {\n\t\t\tkunmap(dir_page);\n\t\t\tpage_cache_release(dir_page);\n\t\t}\n\t\tinode_dec_link_count(old_dir);\n\t}\n\treturn 0;\n\n\nout_dir:\n\tif (dir_de) {\n\t\tkunmap(dir_page);\n\t\tpage_cache_release(dir_page);\n\t}\nout_old:\n\tkunmap(old_page);\n\tpage_cache_release(old_page);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ext2_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
    "lines": "306-320",
    "snippet": "static int ext2_rmdir (struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tint err = -ENOTEMPTY;\n\n\tif (ext2_empty_dir(inode)) {\n\t\terr = ext2_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode->i_size = 0;\n\t\t\tinode_dec_link_count(inode);\n\t\t\tinode_dec_link_count(dir);\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "dir"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
          "lines": "282-304",
          "snippet": "static int ext2_unlink(struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct ext2_dir_entry_2 * de;\n\tstruct page * page;\n\tint err = -ENOENT;\n\n\tdquot_initialize(dir);\n\n\tde = ext2_find_entry (dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = ext2_delete_entry (de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\n\terr = 0;\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic int ext2_unlink(struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct ext2_dir_entry_2 * de;\n\tstruct page * page;\n\tint err = -ENOENT;\n\n\tdquot_initialize(dir);\n\n\tde = ext2_find_entry (dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = ext2_delete_entry (de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\n\terr = 0;\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_empty_dir",
          "args": [
            "inode"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "670-719",
          "snippet": "int ext2_empty_dir (struct inode * inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\tint dir_has_error = 0;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\text2_dirent * de;\n\t\tpage = ext2_get_page(inode, i, dir_has_error);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tdir_has_error = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = page_address(page);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += ext2_last_byte(inode, i) - EXT2_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(inode->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\tprintk(\"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->inode != 0) {\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (de->name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len < 2) {\n\t\t\t\t\tif (de->inode !=\n\t\t\t\t\t    cpu_to_le32(inode->i_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = ext2_next_entry(de);\n\t\t}\n\t\text2_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\text2_put_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nint ext2_empty_dir (struct inode * inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\tint dir_has_error = 0;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\text2_dirent * de;\n\t\tpage = ext2_get_page(inode, i, dir_has_error);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tdir_has_error = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkaddr = page_address(page);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += ext2_last_byte(inode, i) - EXT2_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(inode->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\tprintk(\"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->inode != 0) {\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (de->name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len < 2) {\n\t\t\t\t\tif (de->inode !=\n\t\t\t\t\t    cpu_to_le32(inode->i_ino))\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = ext2_next_entry(de);\n\t\t}\n\t\text2_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\text2_put_page(page);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic int ext2_rmdir (struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tint err = -ENOTEMPTY;\n\n\tif (ext2_empty_dir(inode)) {\n\t\terr = ext2_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode->i_size = 0;\n\t\t\tinode_dec_link_count(inode);\n\t\t\tinode_dec_link_count(dir);\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ext2_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
    "lines": "282-304",
    "snippet": "static int ext2_unlink(struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct ext2_dir_entry_2 * de;\n\tstruct page * page;\n\tint err = -ENOENT;\n\n\tdquot_initialize(dir);\n\n\tde = ext2_find_entry (dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = ext2_delete_entry (de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\n\terr = 0;\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_delete_entry",
          "args": [
            "de",
            "page"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "586-624",
          "snippet": "int ext2_delete_entry (struct ext2_dir_entry_2 * dir, struct page * page )\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char*)dir - kaddr) & ~(ext2_chunk_size(inode)-1);\n\tunsigned to = ((char *)dir - kaddr) +\n\t\t\t\text2_rec_len_from_disk(dir->rec_len);\n\tloff_t pos;\n\text2_dirent * pde = NULL;\n\text2_dirent * de = (ext2_dirent *) (kaddr + from);\n\tint err;\n\n\twhile ((char*)de < (char*)dir) {\n\t\tif (de->rec_len == 0) {\n\t\t\text2_error(inode->i_sb, __func__,\n\t\t\t\t\"zero-length directory entry\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = ext2_next_entry(de);\n\t}\n\tif (pde)\n\t\tfrom = (char*)pde - (char*)page_address(page);\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = ext2_prepare_chunk(page, pos, to - from);\n\tBUG_ON(err);\n\tif (pde)\n\t\tpde->rec_len = ext2_rec_len_to_disk(to - from);\n\tdir->inode = 0;\n\terr = ext2_commit_chunk(page, pos, to - from);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tEXT2_I(inode)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(inode);\nout:\n\text2_put_page(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nint ext2_delete_entry (struct ext2_dir_entry_2 * dir, struct page * page )\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char*)dir - kaddr) & ~(ext2_chunk_size(inode)-1);\n\tunsigned to = ((char *)dir - kaddr) +\n\t\t\t\text2_rec_len_from_disk(dir->rec_len);\n\tloff_t pos;\n\text2_dirent * pde = NULL;\n\text2_dirent * de = (ext2_dirent *) (kaddr + from);\n\tint err;\n\n\twhile ((char*)de < (char*)dir) {\n\t\tif (de->rec_len == 0) {\n\t\t\text2_error(inode->i_sb, __func__,\n\t\t\t\t\"zero-length directory entry\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = ext2_next_entry(de);\n\t}\n\tif (pde)\n\t\tfrom = (char*)pde - (char*)page_address(page);\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = ext2_prepare_chunk(page, pos, to - from);\n\tBUG_ON(err);\n\tif (pde)\n\t\tpde->rec_len = ext2_rec_len_to_disk(to - from);\n\tdir->inode = 0;\n\terr = ext2_commit_chunk(page, pos, to - from);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tEXT2_I(inode)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(inode);\nout:\n\text2_put_page(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&page"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "366-429",
          "snippet": "struct ext2_dir_entry_2 *ext2_find_entry (struct inode * dir,\n\t\t\tstruct qstr *child, struct page ** res_page)\n{\n\tconst char *name = child->name;\n\tint namelen = child->len;\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ext2_inode_info *ei = EXT2_I(dir);\n\text2_dirent * de;\n\tint dir_has_error = 0;\n\n\tif (npages == 0)\n\t\tgoto out;\n\n\t/* OFFSET_CACHE */\n\t*res_page = NULL;\n\n\tstart = ei->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ext2_get_page(dir, n, dir_has_error);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (ext2_dirent *) kaddr;\n\t\t\tkaddr += ext2_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->rec_len == 0) {\n\t\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\t\text2_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ext2_next_entry(de);\n\t\t\t}\n\t\t\text2_put_page(page);\n\t\t} else\n\t\t\tdir_has_error = 1;\n\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t\t/* next page is past the blocks we've got */\n\t\tif (unlikely(n > (dir->i_blocks >> (PAGE_CACHE_SHIFT - 9)))) {\n\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\"dir %lu size %lld exceeds block count %llu\",\n\t\t\t\tdir->i_ino, dir->i_size,\n\t\t\t\t(unsigned long long)dir->i_blocks);\n\t\t\tgoto out;\n\t\t}\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tei->i_dir_start_lookup = n;\n\treturn de;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nstruct ext2_dir_entry_2 *ext2_find_entry (struct inode * dir,\n\t\t\tstruct qstr *child, struct page ** res_page)\n{\n\tconst char *name = child->name;\n\tint namelen = child->len;\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct ext2_inode_info *ei = EXT2_I(dir);\n\text2_dirent * de;\n\tint dir_has_error = 0;\n\n\tif (npages == 0)\n\t\tgoto out;\n\n\t/* OFFSET_CACHE */\n\t*res_page = NULL;\n\n\tstart = ei->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = ext2_get_page(dir, n, dir_has_error);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (ext2_dirent *) kaddr;\n\t\t\tkaddr += ext2_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->rec_len == 0) {\n\t\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\t\text2_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = ext2_next_entry(de);\n\t\t\t}\n\t\t\text2_put_page(page);\n\t\t} else\n\t\t\tdir_has_error = 1;\n\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t\t/* next page is past the blocks we've got */\n\t\tif (unlikely(n > (dir->i_blocks >> (PAGE_CACHE_SHIFT - 9)))) {\n\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\"dir %lu size %lld exceeds block count %llu\",\n\t\t\t\tdir->i_ino, dir->i_size,\n\t\t\t\t(unsigned long long)dir->i_blocks);\n\t\t\tgoto out;\n\t\t}\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\tei->i_dir_start_lookup = n;\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic int ext2_unlink(struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct ext2_dir_entry_2 * de;\n\tstruct page * page;\n\tint err = -ENOENT;\n\n\tdquot_initialize(dir);\n\n\tde = ext2_find_entry (dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = ext2_delete_entry (de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\n\terr = 0;\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ext2_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
    "lines": "236-280",
    "snippet": "static int ext2_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tdquot_initialize(dir);\n\n\tinode_inc_link_count(dir);\n\n\tinode = ext2_new_inode(dir, S_IFDIR | mode, &dentry->d_name);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_dir;\n\n\tinode->i_op = &ext2_dir_inode_operations;\n\tinode->i_fop = &ext2_dir_operations;\n\tif (test_opt(inode->i_sb, NOBH))\n\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext2_aops;\n\n\tinode_inc_link_count(inode);\n\n\terr = ext2_make_empty(inode, dir);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ext2_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\nout_dir:\n\tinode_dec_link_count(dir);\n\tgoto out;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations ext2_dir_inode_operations = {\n\t.create\t\t= ext2_create,\n\t.lookup\t\t= ext2_lookup,\n\t.link\t\t= ext2_link,\n\t.unlink\t\t= ext2_unlink,\n\t.symlink\t= ext2_symlink,\n\t.mkdir\t\t= ext2_mkdir,\n\t.rmdir\t\t= ext2_rmdir,\n\t.mknod\t\t= ext2_mknod,\n\t.rename\t\t= ext2_rename,\n#ifdef CONFIG_EXT2_FS_XATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext2_listxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n\t.setattr\t= ext2_setattr,\n\t.get_acl\t= ext2_get_acl,\n\t.set_acl\t= ext2_set_acl,\n\t.tmpfile\t= ext2_tmpfile,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "dir"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "487-580",
          "snippet": "int ext2_add_link (struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned chunk_size = ext2_chunk_size(dir);\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\text2_dirent * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ext2_get_page(dir, n, 0);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ext2_last_byte(dir, n);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->rec_len = ext2_rec_len_to_disk(chunk_size);\n\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = EXT2_DIR_REC_LEN(de->name_len);\n\t\t\trec_len = ext2_rec_len_from_disk(de->rec_len);\n\t\t\tif (!de->inode && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (ext2_dirent *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\text2_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t(char*)de - (char*)page_address(page);\n\terr = ext2_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->inode) {\n\t\text2_dirent *de1 = (ext2_dirent *) ((char *) de + name_len);\n\t\tde1->rec_len = ext2_rec_len_to_disk(rec_len - name_len);\n\t\tde->rec_len = ext2_rec_len_to_disk(name_len);\n\t\tde = de1;\n\t}\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type (de, inode);\n\terr = ext2_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tEXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\text2_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nint ext2_add_link (struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned chunk_size = ext2_chunk_size(dir);\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\text2_dirent * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ext2_get_page(dir, n, 0);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ext2_last_byte(dir, n);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->rec_len = ext2_rec_len_to_disk(chunk_size);\n\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = EXT2_DIR_REC_LEN(de->name_len);\n\t\t\trec_len = ext2_rec_len_from_disk(de->rec_len);\n\t\t\tif (!de->inode && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (ext2_dirent *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\text2_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t(char*)de - (char*)page_address(page);\n\terr = ext2_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->inode) {\n\t\text2_dirent *de1 = (ext2_dirent *) ((char *) de + name_len);\n\t\tde1->rec_len = ext2_rec_len_to_disk(rec_len - name_len);\n\t\tde->rec_len = ext2_rec_len_to_disk(name_len);\n\t\tde = de1;\n\t}\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type (de, inode);\n\terr = ext2_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tEXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\text2_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_make_empty",
          "args": [
            "inode",
            "dir"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_make_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "629-665",
          "snippet": "int ext2_make_empty(struct inode *inode, struct inode *parent)\n{\n\tstruct page *page = grab_cache_page(inode->i_mapping, 0);\n\tunsigned chunk_size = ext2_chunk_size(inode);\n\tstruct ext2_dir_entry_2 * de;\n\tint err;\n\tvoid *kaddr;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = ext2_prepare_chunk(page, 0, chunk_size);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\tkaddr = kmap_atomic(page);\n\tmemset(kaddr, 0, chunk_size);\n\tde = (struct ext2_dir_entry_2 *)kaddr;\n\tde->name_len = 1;\n\tde->rec_len = ext2_rec_len_to_disk(EXT2_DIR_REC_LEN(1));\n\tmemcpy (de->name, \".\\0\\0\", 4);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type (de, inode);\n\n\tde = (struct ext2_dir_entry_2 *)(kaddr + EXT2_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tde->rec_len = ext2_rec_len_to_disk(chunk_size - EXT2_DIR_REC_LEN(1));\n\tde->inode = cpu_to_le32(parent->i_ino);\n\tmemcpy (de->name, \"..\\0\", 4);\n\text2_set_de_type (de, inode);\n\tkunmap_atomic(kaddr);\n\terr = ext2_commit_chunk(page, 0, chunk_size);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nint ext2_make_empty(struct inode *inode, struct inode *parent)\n{\n\tstruct page *page = grab_cache_page(inode->i_mapping, 0);\n\tunsigned chunk_size = ext2_chunk_size(inode);\n\tstruct ext2_dir_entry_2 * de;\n\tint err;\n\tvoid *kaddr;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = ext2_prepare_chunk(page, 0, chunk_size);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\tkaddr = kmap_atomic(page);\n\tmemset(kaddr, 0, chunk_size);\n\tde = (struct ext2_dir_entry_2 *)kaddr;\n\tde->name_len = 1;\n\tde->rec_len = ext2_rec_len_to_disk(EXT2_DIR_REC_LEN(1));\n\tmemcpy (de->name, \".\\0\\0\", 4);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type (de, inode);\n\n\tde = (struct ext2_dir_entry_2 *)(kaddr + EXT2_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tde->rec_len = ext2_rec_len_to_disk(chunk_size - EXT2_DIR_REC_LEN(1));\n\tde->inode = cpu_to_le32(parent->i_ino);\n\tmemcpy (de->name, \"..\\0\", 4);\n\text2_set_de_type (de, inode);\n\tkunmap_atomic(kaddr);\n\terr = ext2_commit_chunk(page, 0, chunk_size);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "inode"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NOBH"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_new_inode",
          "args": [
            "dir",
            "S_IFDIR | mode",
            "&dentry->d_name"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "430-613",
          "snippet": "struct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * Rare race: find_group_xx() decided that there were\n\t\t\t * free inodes in this group, but by the time we tried\n\t\t\t * to allocate one, they're all gone.  This can also\n\t\t\t * occur because the counters which find_group_orlov()\n\t\t\t * uses are approximate.  So just go and search the\n\t\t\t * next block group.\n\t\t\t */\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t/* we lost this inode */\n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t/* this group is exhausted, try next group */\n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* try to find free inode in the same group */\n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t/*\n\t * Scanned all blockgroups.\n\t */\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_add(&sbi->s_freeinodes_counter, -1);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * Rare race: find_group_xx() decided that there were\n\t\t\t * free inodes in this group, but by the time we tried\n\t\t\t * to allocate one, they're all gone.  This can also\n\t\t\t * occur because the counters which find_group_orlov()\n\t\t\t * uses are approximate.  So just go and search the\n\t\t\t * next block group.\n\t\t\t */\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t/* we lost this inode */\n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t/* this group is exhausted, try next group */\n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* try to find free inode in the same group */\n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t/*\n\t * Scanned all blockgroups.\n\t */\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_add(&sbi->s_freeinodes_counter, -1);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "dir"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nconst struct inode_operations ext2_dir_inode_operations = {\n\t.create\t\t= ext2_create,\n\t.lookup\t\t= ext2_lookup,\n\t.link\t\t= ext2_link,\n\t.unlink\t\t= ext2_unlink,\n\t.symlink\t= ext2_symlink,\n\t.mkdir\t\t= ext2_mkdir,\n\t.rmdir\t\t= ext2_rmdir,\n\t.mknod\t\t= ext2_mknod,\n\t.rename\t\t= ext2_rename,\n#ifdef CONFIG_EXT2_FS_XATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext2_listxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n\t.setattr\t= ext2_setattr,\n\t.get_acl\t= ext2_get_acl,\n\t.set_acl\t= ext2_set_acl,\n\t.tmpfile\t= ext2_tmpfile,\n};\n\nstatic int ext2_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tdquot_initialize(dir);\n\n\tinode_inc_link_count(dir);\n\n\tinode = ext2_new_inode(dir, S_IFDIR | mode, &dentry->d_name);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_dir;\n\n\tinode->i_op = &ext2_dir_inode_operations;\n\tinode->i_fop = &ext2_dir_operations;\n\tif (test_opt(inode->i_sb, NOBH))\n\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext2_aops;\n\n\tinode_inc_link_count(inode);\n\n\terr = ext2_make_empty(inode, dir);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ext2_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\n\tunlock_new_inode(inode);\n\td_instantiate(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\nout_dir:\n\tinode_dec_link_count(dir);\n\tgoto out;\n}"
  },
  {
    "function_name": "ext2_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
    "lines": "214-234",
    "snippet": "static int ext2_link (struct dentry * old_dentry, struct inode * dir,\n\tstruct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint err;\n\n\tdquot_initialize(dir);\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tinode_inc_link_count(inode);\n\tihold(inode);\n\n\terr = ext2_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "487-580",
          "snippet": "int ext2_add_link (struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned chunk_size = ext2_chunk_size(dir);\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\text2_dirent * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ext2_get_page(dir, n, 0);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ext2_last_byte(dir, n);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->rec_len = ext2_rec_len_to_disk(chunk_size);\n\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = EXT2_DIR_REC_LEN(de->name_len);\n\t\t\trec_len = ext2_rec_len_from_disk(de->rec_len);\n\t\t\tif (!de->inode && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (ext2_dirent *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\text2_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t(char*)de - (char*)page_address(page);\n\terr = ext2_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->inode) {\n\t\text2_dirent *de1 = (ext2_dirent *) ((char *) de + name_len);\n\t\tde1->rec_len = ext2_rec_len_to_disk(rec_len - name_len);\n\t\tde->rec_len = ext2_rec_len_to_disk(name_len);\n\t\tde = de1;\n\t}\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type (de, inode);\n\terr = ext2_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tEXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\text2_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nint ext2_add_link (struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned chunk_size = ext2_chunk_size(dir);\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\text2_dirent * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ext2_get_page(dir, n, 0);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ext2_last_byte(dir, n);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->rec_len = ext2_rec_len_to_disk(chunk_size);\n\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = EXT2_DIR_REC_LEN(de->name_len);\n\t\t\trec_len = ext2_rec_len_from_disk(de->rec_len);\n\t\t\tif (!de->inode && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (ext2_dirent *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\text2_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t(char*)de - (char*)page_address(page);\n\terr = ext2_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->inode) {\n\t\text2_dirent *de1 = (ext2_dirent *) ((char *) de + name_len);\n\t\tde1->rec_len = ext2_rec_len_to_disk(rec_len - name_len);\n\t\tde->rec_len = ext2_rec_len_to_disk(name_len);\n\t\tde = de1;\n\t}\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type (de, inode);\n\terr = ext2_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tEXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\text2_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "inode"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic int ext2_link (struct dentry * old_dentry, struct inode * dir,\n\tstruct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint err;\n\n\tdquot_initialize(dir);\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tinode_inc_link_count(inode);\n\tihold(inode);\n\n\terr = ext2_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "ext2_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
    "lines": "167-212",
    "snippet": "static int ext2_symlink (struct inode * dir, struct dentry * dentry,\n\tconst char * symname)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tint err = -ENAMETOOLONG;\n\tunsigned l = strlen(symname)+1;\n\tstruct inode * inode;\n\n\tif (l > sb->s_blocksize)\n\t\tgoto out;\n\n\tdquot_initialize(dir);\n\n\tinode = ext2_new_inode (dir, S_IFLNK | S_IRWXUGO, &dentry->d_name);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\tif (l > sizeof (EXT2_I(inode)->i_data)) {\n\t\t/* slow symlink */\n\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\terr = page_symlink(inode, symname, l);\n\t\tif (err)\n\t\t\tgoto out_fail;\n\t} else {\n\t\t/* fast symlink */\n\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\tmemcpy((char*)(EXT2_I(inode)->i_data),symname,l);\n\t\tinode->i_size = l-1;\n\t}\n\tmark_inode_dirty(inode);\n\n\terr = ext2_add_nondir(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput (inode);\n\tgoto out;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
          "lines": "39-51",
          "snippet": "static inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ext2_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ext2_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char*)(EXT2_I(inode)->i_data)",
            "symname",
            "l"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_symlink",
          "args": [
            "inode",
            "symname",
            "l"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "page_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4532-4536",
          "snippet": "int page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NOBH"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_new_inode",
          "args": [
            "dir",
            "S_IFLNK | S_IRWXUGO",
            "&dentry->d_name"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "430-613",
          "snippet": "struct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * Rare race: find_group_xx() decided that there were\n\t\t\t * free inodes in this group, but by the time we tried\n\t\t\t * to allocate one, they're all gone.  This can also\n\t\t\t * occur because the counters which find_group_orlov()\n\t\t\t * uses are approximate.  So just go and search the\n\t\t\t * next block group.\n\t\t\t */\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t/* we lost this inode */\n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t/* this group is exhausted, try next group */\n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* try to find free inode in the same group */\n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t/*\n\t * Scanned all blockgroups.\n\t */\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_add(&sbi->s_freeinodes_counter, -1);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * Rare race: find_group_xx() decided that there were\n\t\t\t * free inodes in this group, but by the time we tried\n\t\t\t * to allocate one, they're all gone.  This can also\n\t\t\t * occur because the counters which find_group_orlov()\n\t\t\t * uses are approximate.  So just go and search the\n\t\t\t * next block group.\n\t\t\t */\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t/* we lost this inode */\n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t/* this group is exhausted, try next group */\n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* try to find free inode in the same group */\n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t/*\n\t * Scanned all blockgroups.\n\t */\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_add(&sbi->s_freeinodes_counter, -1);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic int ext2_symlink (struct inode * dir, struct dentry * dentry,\n\tconst char * symname)\n{\n\tstruct super_block * sb = dir->i_sb;\n\tint err = -ENAMETOOLONG;\n\tunsigned l = strlen(symname)+1;\n\tstruct inode * inode;\n\n\tif (l > sb->s_blocksize)\n\t\tgoto out;\n\n\tdquot_initialize(dir);\n\n\tinode = ext2_new_inode (dir, S_IFLNK | S_IRWXUGO, &dentry->d_name);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\tif (l > sizeof (EXT2_I(inode)->i_data)) {\n\t\t/* slow symlink */\n\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\terr = page_symlink(inode, symname, l);\n\t\tif (err)\n\t\t\tgoto out_fail;\n\t} else {\n\t\t/* fast symlink */\n\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\tmemcpy((char*)(EXT2_I(inode)->i_data),symname,l);\n\t\tinode->i_size = l-1;\n\t}\n\tmark_inode_dirty(inode);\n\n\terr = ext2_add_nondir(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput (inode);\n\tgoto out;\n}"
  },
  {
    "function_name": "ext2_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
    "lines": "144-165",
    "snippet": "static int ext2_mknod (struct inode * dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tdquot_initialize(dir);\n\n\tinode = ext2_new_inode (dir, mode, &dentry->d_name);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n#ifdef CONFIG_EXT2_FS_XATTR\n\t\tinode->i_op = &ext2_special_inode_operations;\n#endif\n\t\tmark_inode_dirty(inode);\n\t\terr = ext2_add_nondir(dentry, inode);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations ext2_special_inode_operations = {\n#ifdef CONFIG_EXT2_FS_XATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext2_listxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n\t.setattr\t= ext2_setattr,\n\t.get_acl\t= ext2_get_acl,\n\t.set_acl\t= ext2_set_acl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
          "lines": "39-51",
          "snippet": "static inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ext2_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ext2_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "rdev"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_new_inode",
          "args": [
            "dir",
            "mode",
            "&dentry->d_name"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "430-613",
          "snippet": "struct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * Rare race: find_group_xx() decided that there were\n\t\t\t * free inodes in this group, but by the time we tried\n\t\t\t * to allocate one, they're all gone.  This can also\n\t\t\t * occur because the counters which find_group_orlov()\n\t\t\t * uses are approximate.  So just go and search the\n\t\t\t * next block group.\n\t\t\t */\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t/* we lost this inode */\n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t/* this group is exhausted, try next group */\n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* try to find free inode in the same group */\n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t/*\n\t * Scanned all blockgroups.\n\t */\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_add(&sbi->s_freeinodes_counter, -1);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * Rare race: find_group_xx() decided that there were\n\t\t\t * free inodes in this group, but by the time we tried\n\t\t\t * to allocate one, they're all gone.  This can also\n\t\t\t * occur because the counters which find_group_orlov()\n\t\t\t * uses are approximate.  So just go and search the\n\t\t\t * next block group.\n\t\t\t */\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t/* we lost this inode */\n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t/* this group is exhausted, try next group */\n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* try to find free inode in the same group */\n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t/*\n\t * Scanned all blockgroups.\n\t */\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_add(&sbi->s_freeinodes_counter, -1);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nconst struct inode_operations ext2_special_inode_operations = {\n#ifdef CONFIG_EXT2_FS_XATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= ext2_listxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n\t.setattr\t= ext2_setattr,\n\t.get_acl\t= ext2_get_acl,\n\t.set_acl\t= ext2_set_acl,\n};\n\nstatic int ext2_mknod (struct inode * dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tdquot_initialize(dir);\n\n\tinode = ext2_new_inode (dir, mode, &dentry->d_name);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n#ifdef CONFIG_EXT2_FS_XATTR\n\t\tinode->i_op = &ext2_special_inode_operations;\n#endif\n\t\tmark_inode_dirty(inode);\n\t\terr = ext2_add_nondir(dentry, inode);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ext2_tmpfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
    "lines": "121-142",
    "snippet": "static int ext2_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode = ext2_new_inode(dir, mode, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &ext2_file_inode_operations;\n\tif (test_opt(inode->i_sb, DAX)) {\n\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\tinode->i_fop = &ext2_dax_file_operations;\n\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\tinode->i_fop = &ext2_file_operations;\n\t} else {\n\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\tinode->i_fop = &ext2_file_operations;\n\t}\n\tmark_inode_dirty(inode);\n\td_tmpfile(dentry, inode);\n\tunlock_new_inode(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_tmpfile",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "d_tmpfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3325-3338",
          "snippet": "void d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NOBH"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DAX"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_new_inode",
          "args": [
            "dir",
            "mode",
            "NULL"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "430-613",
          "snippet": "struct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * Rare race: find_group_xx() decided that there were\n\t\t\t * free inodes in this group, but by the time we tried\n\t\t\t * to allocate one, they're all gone.  This can also\n\t\t\t * occur because the counters which find_group_orlov()\n\t\t\t * uses are approximate.  So just go and search the\n\t\t\t * next block group.\n\t\t\t */\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t/* we lost this inode */\n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t/* this group is exhausted, try next group */\n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* try to find free inode in the same group */\n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t/*\n\t * Scanned all blockgroups.\n\t */\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_add(&sbi->s_freeinodes_counter, -1);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * Rare race: find_group_xx() decided that there were\n\t\t\t * free inodes in this group, but by the time we tried\n\t\t\t * to allocate one, they're all gone.  This can also\n\t\t\t * occur because the counters which find_group_orlov()\n\t\t\t * uses are approximate.  So just go and search the\n\t\t\t * next block group.\n\t\t\t */\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t/* we lost this inode */\n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t/* this group is exhausted, try next group */\n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* try to find free inode in the same group */\n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t/*\n\t * Scanned all blockgroups.\n\t */\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_add(&sbi->s_freeinodes_counter, -1);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic int ext2_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode = ext2_new_inode(dir, mode, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &ext2_file_inode_operations;\n\tif (test_opt(inode->i_sb, DAX)) {\n\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\tinode->i_fop = &ext2_dax_file_operations;\n\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\tinode->i_fop = &ext2_file_operations;\n\t} else {\n\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\tinode->i_fop = &ext2_file_operations;\n\t}\n\tmark_inode_dirty(inode);\n\td_tmpfile(dentry, inode);\n\tunlock_new_inode(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext2_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
    "lines": "96-119",
    "snippet": "static int ext2_create (struct inode * dir, struct dentry * dentry, umode_t mode, bool excl)\n{\n\tstruct inode *inode;\n\n\tdquot_initialize(dir);\n\n\tinode = ext2_new_inode(dir, mode, &dentry->d_name);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &ext2_file_inode_operations;\n\tif (test_opt(inode->i_sb, DAX)) {\n\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\tinode->i_fop = &ext2_dax_file_operations;\n\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\tinode->i_fop = &ext2_file_operations;\n\t} else {\n\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\tinode->i_fop = &ext2_file_operations;\n\t}\n\tmark_inode_dirty(inode);\n\treturn ext2_add_nondir(dentry, inode);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
          "lines": "39-51",
          "snippet": "static inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ext2_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ext2_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NOBH"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DAX"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_new_inode",
          "args": [
            "dir",
            "mode",
            "&dentry->d_name"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "430-613",
          "snippet": "struct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * Rare race: find_group_xx() decided that there were\n\t\t\t * free inodes in this group, but by the time we tried\n\t\t\t * to allocate one, they're all gone.  This can also\n\t\t\t * occur because the counters which find_group_orlov()\n\t\t\t * uses are approximate.  So just go and search the\n\t\t\t * next block group.\n\t\t\t */\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t/* we lost this inode */\n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t/* this group is exhausted, try next group */\n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* try to find free inode in the same group */\n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t/*\n\t * Scanned all blockgroups.\n\t */\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_add(&sbi->s_freeinodes_counter, -1);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nstruct inode *ext2_new_inode(struct inode *dir, umode_t mode,\n\t\t\t     const struct qstr *qstr)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\tint group, i;\n\tino_t ino = 0;\n\tstruct inode * inode;\n\tstruct ext2_group_desc *gdp;\n\tstruct ext2_super_block *es;\n\tstruct ext2_inode_info *ei;\n\tstruct ext2_sb_info *sbi;\n\tint err;\n\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tei = EXT2_I(inode);\n\tsbi = EXT2_SB(sb);\n\tes = sbi->s_es;\n\tif (S_ISDIR(mode)) {\n\t\tif (test_opt(sb, OLDALLOC))\n\t\t\tgroup = find_group_dir(sb, dir);\n\t\telse\n\t\t\tgroup = find_group_orlov(sb, dir);\n\t} else \n\t\tgroup = find_group_other(sb, dir);\n\n\tif (group == -1) {\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext2_get_group_desc(sb, group, &bh2);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, group);\n\t\tif (!bitmap_bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tino = 0;\n\nrepeat_in_this_group:\n\t\tino = ext2_find_next_zero_bit((unsigned long *)bitmap_bh->b_data,\n\t\t\t\t\t      EXT2_INODES_PER_GROUP(sb), ino);\n\t\tif (ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * Rare race: find_group_xx() decided that there were\n\t\t\t * free inodes in this group, but by the time we tried\n\t\t\t * to allocate one, they're all gone.  This can also\n\t\t\t * occur because the counters which find_group_orlov()\n\t\t\t * uses are approximate.  So just go and search the\n\t\t\t * next block group.\n\t\t\t */\n\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\tgroup = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ext2_set_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tino, bitmap_bh->b_data)) {\n\t\t\t/* we lost this inode */\n\t\t\tif (++ino >= EXT2_INODES_PER_GROUP(sb)) {\n\t\t\t\t/* this group is exhausted, try next group */\n\t\t\t\tif (++group == sbi->s_groups_count)\n\t\t\t\t\tgroup = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* try to find free inode in the same group */\n\t\t\tgoto repeat_in_this_group;\n\t\t}\n\t\tgoto got;\n\t}\n\n\t/*\n\t * Scanned all blockgroups.\n\t */\n\terr = -ENOSPC;\n\tgoto fail;\ngot:\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\tbrelse(bitmap_bh);\n\n\tino += group * EXT2_INODES_PER_GROUP(sb) + 1;\n\tif (ino < EXT2_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text2_error (sb, \"ext2_new_inode\",\n\t\t\t    \"reserved inode or inode > inodes count - \"\n\t\t\t    \"block_group = %d,inode=%lu\", group,\n\t\t\t    (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tpercpu_counter_add(&sbi->s_freeinodes_counter, -1);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tspin_lock(sb_bgl_lock(sbi, group));\n\tle16_add_cpu(&gdp->bg_free_inodes_count, -1);\n\tif (S_ISDIR(mode)) {\n\t\tif (sbi->s_debts[group] < 255)\n\t\t\tsbi->s_debts[group]++;\n\t\tle16_add_cpu(&gdp->bg_used_dirs_count, 1);\n\t} else {\n\t\tif (sbi->s_debts[group])\n\t\t\tsbi->s_debts[group]--;\n\t}\n\tspin_unlock(sb_bgl_lock(sbi, group));\n\n\tmark_buffer_dirty(bh2);\n\tif (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_flags =\n\t\text2_mask_flags(mode, EXT2_I(dir)->i_flags & EXT2_FL_INHERITED);\n\tei->i_faddr = 0;\n\tei->i_frag_no = 0;\n\tei->i_frag_size = 0;\n\tei->i_file_acl = 0;\n\tei->i_dir_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_alloc_info = NULL;\n\tei->i_block_group = group;\n\tei->i_dir_start_lookup = 0;\n\tei->i_state = EXT2_STATE_NEW;\n\text2_set_inode_flags(inode);\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\tif (insert_inode_locked(inode) < 0) {\n\t\text2_error(sb, \"ext2_new_inode\",\n\t\t\t   \"inode number already in use - inode=%lu\",\n\t\t\t   (unsigned long) ino);\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\tdquot_initialize(inode);\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\terr = ext2_init_acl(inode, dir);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\terr = ext2_init_security(inode, dir, qstr);\n\tif (err)\n\t\tgoto fail_free_drop;\n\n\tmark_inode_dirty(inode);\n\text2_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\text2_preread_inode(inode);\n\treturn inode;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic int ext2_create (struct inode * dir, struct dentry * dentry, umode_t mode, bool excl)\n{\n\tstruct inode *inode;\n\n\tdquot_initialize(dir);\n\n\tinode = ext2_new_inode(dir, mode, &dentry->d_name);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &ext2_file_inode_operations;\n\tif (test_opt(inode->i_sb, DAX)) {\n\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\tinode->i_fop = &ext2_dax_file_operations;\n\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\tinode->i_fop = &ext2_file_operations;\n\t} else {\n\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\tinode->i_fop = &ext2_file_operations;\n\t}\n\tmark_inode_dirty(inode);\n\treturn ext2_add_nondir(dentry, inode);\n}"
  },
  {
    "function_name": "ext2_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
    "lines": "79-86",
    "snippet": "struct dentry *ext2_get_parent(struct dentry *child)\n{\n\tstruct qstr dotdot = QSTR_INIT(\"..\", 2);\n\tunsigned long ino = ext2_inode_by_name(child->d_inode, &dotdot);\n\tif (!ino)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn d_obtain_alias(ext2_iget(child->d_inode->i_sb, ino));\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "ext2_iget(child->d_inode->i_sb, ino)"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_iget",
          "args": [
            "child->d_inode->i_sb",
            "ino"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1312-1437",
          "snippet": "struct inode *ext2_iget (struct super_block *sb, unsigned long ino)\n{\n\tstruct ext2_inode_info *ei;\n\tstruct buffer_head * bh;\n\tstruct ext2_inode *raw_inode;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\tint n;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT2_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\traw_inode = ext2_get_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(raw_inode)) {\n\t\tret = PTR_ERR(raw_inode);\n \t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0 && (inode->i_mode == 0 || ei->i_dtime)) {\n\t\t/* this inode is deleted */\n\t\tbrelse (bh);\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tei->i_dir_acl = 0;\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\telse\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\tei->i_dtime = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_state = 0;\n\tei->i_block_group = (ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tei->i_dir_start_lookup = 0;\n\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\tei->i_data[n] = raw_inode->i_block[n];\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext2_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_dax_file_operations;\n\t\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t} else {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext2_dir_inode_operations;\n\t\tinode->i_fop = &ext2_dir_operations;\n\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext2_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\telse\n\t\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext2_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse \n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (bh);\n\text2_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\t\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations ext2_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_writepage,\n\t.write_begin\t\t= ext2_write_begin,\n\t.write_end\t\t= ext2_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "const struct address_space_operations ext2_nobh_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_nobh_writepage,\n\t.write_begin\t\t= ext2_nobh_write_begin,\n\t.write_end\t\t= nobh_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nconst struct address_space_operations ext2_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_writepage,\n\t.write_begin\t\t= ext2_write_begin,\n\t.write_end\t\t= ext2_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nconst struct address_space_operations ext2_nobh_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_nobh_writepage,\n\t.write_begin\t\t= ext2_nobh_write_begin,\n\t.write_end\t\t= nobh_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nstruct inode *ext2_iget (struct super_block *sb, unsigned long ino)\n{\n\tstruct ext2_inode_info *ei;\n\tstruct buffer_head * bh;\n\tstruct ext2_inode *raw_inode;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\tint n;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT2_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\traw_inode = ext2_get_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(raw_inode)) {\n\t\tret = PTR_ERR(raw_inode);\n \t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0 && (inode->i_mode == 0 || ei->i_dtime)) {\n\t\t/* this inode is deleted */\n\t\tbrelse (bh);\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tei->i_dir_acl = 0;\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\telse\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\tei->i_dtime = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_state = 0;\n\tei->i_block_group = (ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tei->i_dir_start_lookup = 0;\n\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\tei->i_data[n] = raw_inode->i_block[n];\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext2_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_dax_file_operations;\n\t\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t} else {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext2_dir_inode_operations;\n\t\tinode->i_fop = &ext2_dir_operations;\n\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext2_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\telse\n\t\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext2_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse \n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (bh);\n\text2_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\t\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_inode_by_name",
          "args": [
            "child->d_inode",
            "&dotdot"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_inode_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "443-455",
          "snippet": "ino_t ext2_inode_by_name(struct inode *dir, struct qstr *child)\n{\n\tino_t res = 0;\n\tstruct ext2_dir_entry_2 *de;\n\tstruct page *page;\n\t\n\tde = ext2_find_entry (dir, child, &page);\n\tif (de) {\n\t\tres = le32_to_cpu(de->inode);\n\t\text2_put_page(page);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nino_t ext2_inode_by_name(struct inode *dir, struct qstr *child)\n{\n\tino_t res = 0;\n\tstruct ext2_dir_entry_2 *de;\n\tstruct page *page;\n\t\n\tde = ext2_find_entry (dir, child, &page);\n\tif (de) {\n\t\tres = le32_to_cpu(de->inode);\n\t\text2_put_page(page);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSTR_INIT",
          "args": [
            "\"..\"",
            "2"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstruct dentry *ext2_get_parent(struct dentry *child)\n{\n\tstruct qstr dotdot = QSTR_INIT(\"..\", 2);\n\tunsigned long ino = ext2_inode_by_name(child->d_inode, &dotdot);\n\tif (!ino)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn d_obtain_alias(ext2_iget(child->d_inode->i_sb, ino));\n}"
  },
  {
    "function_name": "ext2_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
    "lines": "57-77",
    "snippet": "static struct dentry *ext2_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode * inode;\n\tino_t ino;\n\t\n\tif (dentry->d_name.len > EXT2_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tino = ext2_inode_by_name(dir, &dentry->d_name);\n\tinode = NULL;\n\tif (ino) {\n\t\tinode = ext2_iget(dir->i_sb, ino);\n\t\tif (inode == ERR_PTR(-ESTALE)) {\n\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"deleted inode referenced: %lu\",\n\t\t\t\t\t(unsigned long) ino);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn d_splice_alias(inode, dentry);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "dir->i_sb",
            "__func__",
            "\"deleted inode referenced: %lu\"",
            "(unsigned long) ino"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_iget",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1312-1437",
          "snippet": "struct inode *ext2_iget (struct super_block *sb, unsigned long ino)\n{\n\tstruct ext2_inode_info *ei;\n\tstruct buffer_head * bh;\n\tstruct ext2_inode *raw_inode;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\tint n;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT2_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\traw_inode = ext2_get_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(raw_inode)) {\n\t\tret = PTR_ERR(raw_inode);\n \t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0 && (inode->i_mode == 0 || ei->i_dtime)) {\n\t\t/* this inode is deleted */\n\t\tbrelse (bh);\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tei->i_dir_acl = 0;\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\telse\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\tei->i_dtime = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_state = 0;\n\tei->i_block_group = (ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tei->i_dir_start_lookup = 0;\n\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\tei->i_data[n] = raw_inode->i_block[n];\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext2_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_dax_file_operations;\n\t\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t} else {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext2_dir_inode_operations;\n\t\tinode->i_fop = &ext2_dir_operations;\n\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext2_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\telse\n\t\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext2_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse \n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (bh);\n\text2_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\t\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations ext2_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_writepage,\n\t.write_begin\t\t= ext2_write_begin,\n\t.write_end\t\t= ext2_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "const struct address_space_operations ext2_nobh_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_nobh_writepage,\n\t.write_begin\t\t= ext2_nobh_write_begin,\n\t.write_end\t\t= nobh_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nconst struct address_space_operations ext2_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_writepage,\n\t.write_begin\t\t= ext2_write_begin,\n\t.write_end\t\t= ext2_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nconst struct address_space_operations ext2_nobh_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_nobh_writepage,\n\t.write_begin\t\t= ext2_nobh_write_begin,\n\t.write_end\t\t= nobh_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nstruct inode *ext2_iget (struct super_block *sb, unsigned long ino)\n{\n\tstruct ext2_inode_info *ei;\n\tstruct buffer_head * bh;\n\tstruct ext2_inode *raw_inode;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\tint n;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT2_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\traw_inode = ext2_get_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(raw_inode)) {\n\t\tret = PTR_ERR(raw_inode);\n \t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0 && (inode->i_mode == 0 || ei->i_dtime)) {\n\t\t/* this inode is deleted */\n\t\tbrelse (bh);\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tei->i_dir_acl = 0;\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\telse\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\tei->i_dtime = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_state = 0;\n\tei->i_block_group = (ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tei->i_dir_start_lookup = 0;\n\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\tei->i_data[n] = raw_inode->i_block[n];\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext2_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_dax_file_operations;\n\t\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t} else {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext2_dir_inode_operations;\n\t\tinode->i_fop = &ext2_dir_operations;\n\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext2_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\telse\n\t\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext2_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse \n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (bh);\n\text2_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\t\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_inode_by_name",
          "args": [
            "dir",
            "&dentry->d_name"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_inode_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "443-455",
          "snippet": "ino_t ext2_inode_by_name(struct inode *dir, struct qstr *child)\n{\n\tino_t res = 0;\n\tstruct ext2_dir_entry_2 *de;\n\tstruct page *page;\n\t\n\tde = ext2_find_entry (dir, child, &page);\n\tif (de) {\n\t\tres = le32_to_cpu(de->inode);\n\t\text2_put_page(page);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nino_t ext2_inode_by_name(struct inode *dir, struct qstr *child)\n{\n\tino_t res = 0;\n\tstruct ext2_dir_entry_2 *de;\n\tstruct page *page;\n\t\n\tde = ext2_find_entry (dir, child, &page);\n\tif (de) {\n\t\tres = le32_to_cpu(de->inode);\n\t\text2_put_page(page);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic struct dentry *ext2_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode * inode;\n\tino_t ino;\n\t\n\tif (dentry->d_name.len > EXT2_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tino = ext2_inode_by_name(dir, &dentry->d_name);\n\tinode = NULL;\n\tif (ino) {\n\t\tinode = ext2_iget(dir->i_sb, ino);\n\t\tif (inode == ERR_PTR(-ESTALE)) {\n\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"deleted inode referenced: %lu\",\n\t\t\t\t\t(unsigned long) ino);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\treturn d_splice_alias(inode, dentry);\n}"
  },
  {
    "function_name": "ext2_add_nondir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/namei.c",
    "lines": "39-51",
    "snippet": "static inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ext2_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/dir.c",
          "lines": "487-580",
          "snippet": "int ext2_add_link (struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned chunk_size = ext2_chunk_size(dir);\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\text2_dirent * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ext2_get_page(dir, n, 0);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ext2_last_byte(dir, n);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->rec_len = ext2_rec_len_to_disk(chunk_size);\n\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = EXT2_DIR_REC_LEN(de->name_len);\n\t\t\trec_len = ext2_rec_len_from_disk(de->rec_len);\n\t\t\tif (!de->inode && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (ext2_dirent *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\text2_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t(char*)de - (char*)page_address(page);\n\terr = ext2_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->inode) {\n\t\text2_dirent *de1 = (ext2_dirent *) ((char *) de + name_len);\n\t\tde1->rec_len = ext2_rec_len_to_disk(rec_len - name_len);\n\t\tde->rec_len = ext2_rec_len_to_disk(name_len);\n\t\tde = de1;\n\t}\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type (de, inode);\n\terr = ext2_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tEXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\text2_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include \"ext2.h\"\n\nint ext2_add_link (struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned chunk_size = ext2_chunk_size(dir);\n\tunsigned reclen = EXT2_DIR_REC_LEN(namelen);\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\text2_dirent * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/*\n\t * We take care of directory expansion in the same loop.\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = ext2_get_page(dir, n, 0);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + ext2_last_byte(dir, n);\n\t\tde = (ext2_dirent *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->rec_len = ext2_rec_len_to_disk(chunk_size);\n\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\text2_error(dir->i_sb, __func__,\n\t\t\t\t\t\"zero-length directory entry\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (ext2_match (namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = EXT2_DIR_REC_LEN(de->name_len);\n\t\t\trec_len = ext2_rec_len_from_disk(de->rec_len);\n\t\t\tif (!de->inode && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (ext2_dirent *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\text2_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t(char*)de - (char*)page_address(page);\n\terr = ext2_prepare_chunk(page, pos, rec_len);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->inode) {\n\t\text2_dirent *de1 = (ext2_dirent *) ((char *) de + name_len);\n\t\tde1->rec_len = ext2_rec_len_to_disk(rec_len - name_len);\n\t\tde->rec_len = ext2_rec_len_to_disk(name_len);\n\t\tde = de1;\n\t}\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n\tde->inode = cpu_to_le32(inode->i_ino);\n\text2_set_de_type (de, inode);\n\terr = ext2_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tEXT2_I(dir)->i_flags &= ~EXT2_BTREE_FL;\n\tmark_inode_dirty(dir);\n\t/* OFFSET_CACHE */\nout_put:\n\text2_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n\nstatic inline int ext2_add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = ext2_add_link(dentry, inode);\n\tif (!err) {\n\t\tunlock_new_inode(inode);\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn err;\n}"
  }
]