[
  {
    "function_name": "dlm_change_lockres_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "1140-1148",
    "snippet": "static inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_set_lockres_owner",
          "args": [
            "dlm",
            "res",
            "owner"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_lockres_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1131-1138",
          "snippet": "static inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}"
  },
  {
    "function_name": "dlm_set_lockres_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "1131-1138",
    "snippet": "static inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_set_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tres->owner = owner;\n}"
  },
  {
    "function_name": "dlm_node_iter_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "1119-1129",
    "snippet": "static inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "iter->node_map",
            "O2NM_MAX_NODES",
            "iter->curnode+1"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}"
  },
  {
    "function_name": "dlm_node_iter_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "1112-1117",
    "snippet": "static inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iter->node_map",
            "map",
            "sizeof(iter->node_map)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}"
  },
  {
    "function_name": "dlm_err_to_dlm_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "1095-1109",
    "snippet": "static inline enum dlm_status dlm_err_to_dlm_status(int err)\n{\n\tenum dlm_status ret;\n\tif (err == -ENOMEM)\n\t\tret = DLM_SYSERR;\n\telse if (err == -ETIMEDOUT || o2net_link_down(err, NULL))\n\t\tret = DLM_NOLOCKMGR;\n\telse if (err == -EINVAL)\n\t\tret = DLM_BADPARAM;\n\telse if (err == -ENAMETOOLONG)\n\t\tret = DLM_IVBUFLEN;\n\telse\n\t\tret = DLM_BADARGS;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_link_down",
          "args": [
            "err",
            "NULL"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_link_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.h",
          "lines": "69-92",
          "snippet": "static inline int o2net_link_down(int err, struct socket *sock)\n{\n\tif (sock) {\n\t\tif (sock->sk->sk_state != TCP_ESTABLISHED &&\n\t    \t    sock->sk->sk_state != TCP_CLOSE_WAIT)\n\t\t\treturn 1;\n\t}\n\n\tif (err >= 0)\n\t\treturn 0;\n\tswitch (err) {\n\t\t/* ????????????????????????? */\n\t\tcase -ERESTARTSYS:\n\t\tcase -EBADF:\n\t\t/* When the server has died, an ICMP port unreachable\n\t\t * message prompts ECONNREFUSED. */\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <sys/socket.h>",
            "#include <linux/tcp.h>",
            "#include <net/sock.h>",
            "#include <linux/socket.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/in.h>\n#include <linux/inet.h>\n#include <sys/socket.h>\n#include <linux/tcp.h>\n#include <net/sock.h>\n#include <linux/socket.h>\n\nstatic inline int o2net_link_down(int err, struct socket *sock)\n{\n\tif (sock) {\n\t\tif (sock->sk->sk_state != TCP_ESTABLISHED &&\n\t    \t    sock->sk->sk_state != TCP_CLOSE_WAIT)\n\t\t\treturn 1;\n\t}\n\n\tif (err >= 0)\n\t\treturn 0;\n\tswitch (err) {\n\t\t/* ????????????????????????? */\n\t\tcase -ERESTARTSYS:\n\t\tcase -EBADF:\n\t\t/* When the server has died, an ICMP port unreachable\n\t\t * message prompts ECONNREFUSED. */\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline enum dlm_status dlm_err_to_dlm_status(int err)\n{\n\tenum dlm_status ret;\n\tif (err == -ENOMEM)\n\t\tret = DLM_SYSERR;\n\telse if (err == -ETIMEDOUT || o2net_link_down(err, NULL))\n\t\tret = DLM_NOLOCKMGR;\n\telse if (err == -EINVAL)\n\t\tret = DLM_BADPARAM;\n\telse if (err == -ENAMETOOLONG)\n\t\tret = DLM_IVBUFLEN;\n\telse\n\t\tret = DLM_BADARGS;\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_lock_on_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "1082-1092",
    "snippet": "static inline int dlm_lock_on_list(struct list_head *head,\n\t\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, head, list) {\n\t\tif (tmplock == lock)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmplock",
            "head",
            "list"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_lock_on_list(struct list_head *head,\n\t\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, head, list) {\n\t\tif (tmplock == lock)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_lock_compatible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "1064-1080",
    "snippet": "static inline int dlm_lock_compatible(int existing, int request)\n{\n\t/* NO_LOCK compatible with all */\n\tif (request == LKM_NLMODE ||\n\t    existing == LKM_NLMODE)\n\t\treturn 1;\n\n\t/* EX incompatible with all non-NO_LOCK */\n\tif (request == LKM_EXMODE)\n\t\treturn 0;\n\n\t/* request must be PR, which is compatible with PR */\n\tif (existing == LKM_PRMODE)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_lock_compatible(int existing, int request)\n{\n\t/* NO_LOCK compatible with all */\n\tif (request == LKM_NLMODE ||\n\t    existing == LKM_NLMODE)\n\t\treturn 1;\n\n\t/* EX incompatible with all non-NO_LOCK */\n\tif (request == LKM_EXMODE)\n\t\treturn 0;\n\n\t/* request must be PR, which is compatible with PR */\n\tif (existing == LKM_PRMODE)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_lock_mode_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "1050-1061",
    "snippet": "static inline const char * dlm_lock_mode_name(int mode)\n{\n\tswitch (mode) {\n\t\tcase LKM_EXMODE:\n\t\t\treturn \"EX\";\n\t\tcase LKM_PRMODE:\n\t\t\treturn \"PR\";\n\t\tcase LKM_NLMODE:\n\t\t\treturn \"NL\";\n\t}\n\treturn \"UNKNOWN\";\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline const char * dlm_lock_mode_name(int mode)\n{\n\tswitch (mode) {\n\t\tcase LKM_EXMODE:\n\t\t\treturn \"EX\";\n\t\tcase LKM_PRMODE:\n\t\t\treturn \"PR\";\n\t\tcase LKM_NLMODE:\n\t\t\treturn \"NL\";\n\t}\n\treturn \"UNKNOWN\";\n}"
  },
  {
    "function_name": "__dlm_wait_on_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "1020-1025",
    "snippet": "static inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [
      "#define DLM_LOCK_RES_MIGRATING            0x00000020",
      "#define DLM_LOCK_RES_IN_PROGRESS          0x00000010",
      "#define DLM_LOCK_RES_RECOVERING           0x00000002"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dlm_wait_on_lockres_flags",
          "args": [
            "res",
            "(DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING)"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_wait_on_lockres_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "61-78",
          "snippet": "void __dlm_wait_on_lockres_flags(struct dlm_lock_resource *res, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tassert_spin_locked(&res->spinlock);\n\n\tadd_wait_queue(&res->wq, &wait);\nrepeat:\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (res->state & flags) {\n\t\tspin_unlock(&res->spinlock);\n\t\tschedule();\n\t\tspin_lock(&res->spinlock);\n\t\tgoto repeat;\n\t}\n\tremove_wait_queue(&res->wq, &wait);\n\t__set_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __dlm_wait_on_lockres_flags(struct dlm_lock_resource *res, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tassert_spin_locked(&res->spinlock);\n\n\tadd_wait_queue(&res->wq, &wait);\nrepeat:\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (res->state & flags) {\n\t\tspin_unlock(&res->spinlock);\n\t\tschedule();\n\t\tspin_lock(&res->spinlock);\n\t\tgoto repeat;\n\t}\n\tremove_wait_queue(&res->wq, &wait);\n\t__set_current_state(TASK_RUNNING);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_LOCK_RES_MIGRATING            0x00000020\n#define DLM_LOCK_RES_IN_PROGRESS          0x00000010\n#define DLM_LOCK_RES_RECOVERING           0x00000002\n\nstatic inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}"
  },
  {
    "function_name": "dlm_send_proxy_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "945-952",
    "snippet": "static inline int dlm_send_proxy_ast(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_lock *lock,\n\t\t\t\t     int flags)\n{\n\treturn dlm_send_proxy_ast_msg(dlm, res, lock, DLM_AST,\n\t\t\t\t      0, flags);\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_send_proxy_ast_msg",
          "args": [
            "dlm",
            "res",
            "lock",
            "DLM_AST",
            "0",
            "flags"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_proxy_ast_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "450-504",
          "snippet": "int dlm_send_proxy_ast_msg(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock, int msg_type,\n\t\t\t   int blocked_type, int flags)\n{\n\tint ret = 0;\n\tstruct dlm_proxy_ast past;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\tint status;\n\n\tmlog(0, \"%s: res %.*s, to %u, type %d, blocked_type %d\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, lock->ml.node, msg_type,\n\t     blocked_type);\n\n\tmemset(&past, 0, sizeof(struct dlm_proxy_ast));\n\tpast.node_idx = dlm->node_num;\n\tpast.type = msg_type;\n\tpast.blocked_type = blocked_type;\n\tpast.namelen = res->lockname.len;\n\tmemcpy(past.name, res->lockname.name, past.namelen);\n\tpast.cookie = lock->ml.cookie;\n\n\tvec[0].iov_len = sizeof(struct dlm_proxy_ast);\n\tvec[0].iov_base = &past;\n\tif (flags & DLM_LKSB_GET_LVB) {\n\t\tbe32_add_cpu(&past.flags, LKM_GET_LVB);\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\tret = o2net_send_message_vec(DLM_PROXY_AST_MSG, dlm->key, vec, veclen,\n\t\t\t\t     lock->ml.node, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: res %.*s, error %d send AST to node %u\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, ret,\n\t\t     lock->ml.node);\n\telse {\n\t\tif (status == DLM_RECOVERING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it thinks this \"\n\t\t\t     \"node is dead!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status == DLM_MIGRATING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it returned \"\n\t\t\t     \"DLM_MIGRATING!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status != DLM_NORMAL && status != DLM_IVLOCKID) {\n\t\t\tmlog(ML_ERROR, \"AST to node %u returned %d!\\n\",\n\t\t\t     lock->ml.node, status);\n\t\t\t/* ignore it */\n\t\t}\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nint dlm_send_proxy_ast_msg(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock, int msg_type,\n\t\t\t   int blocked_type, int flags)\n{\n\tint ret = 0;\n\tstruct dlm_proxy_ast past;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\tint status;\n\n\tmlog(0, \"%s: res %.*s, to %u, type %d, blocked_type %d\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, lock->ml.node, msg_type,\n\t     blocked_type);\n\n\tmemset(&past, 0, sizeof(struct dlm_proxy_ast));\n\tpast.node_idx = dlm->node_num;\n\tpast.type = msg_type;\n\tpast.blocked_type = blocked_type;\n\tpast.namelen = res->lockname.len;\n\tmemcpy(past.name, res->lockname.name, past.namelen);\n\tpast.cookie = lock->ml.cookie;\n\n\tvec[0].iov_len = sizeof(struct dlm_proxy_ast);\n\tvec[0].iov_base = &past;\n\tif (flags & DLM_LKSB_GET_LVB) {\n\t\tbe32_add_cpu(&past.flags, LKM_GET_LVB);\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\tret = o2net_send_message_vec(DLM_PROXY_AST_MSG, dlm->key, vec, veclen,\n\t\t\t\t     lock->ml.node, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: res %.*s, error %d send AST to node %u\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, ret,\n\t\t     lock->ml.node);\n\telse {\n\t\tif (status == DLM_RECOVERING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it thinks this \"\n\t\t\t     \"node is dead!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status == DLM_MIGRATING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it returned \"\n\t\t\t     \"DLM_MIGRATING!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status != DLM_NORMAL && status != DLM_IVLOCKID) {\n\t\t\tmlog(ML_ERROR, \"AST to node %u returned %d!\\n\",\n\t\t\t     lock->ml.node, status);\n\t\t\t/* ignore it */\n\t\t}\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_send_proxy_ast(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_lock *lock,\n\t\t\t\t     int flags)\n{\n\treturn dlm_send_proxy_ast_msg(dlm, res, lock, DLM_AST,\n\t\t\t\t      0, flags);\n}"
  },
  {
    "function_name": "dlm_send_proxy_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "936-943",
    "snippet": "static inline int dlm_send_proxy_bast(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t      int blocked_type)\n{\n\treturn dlm_send_proxy_ast_msg(dlm, res, lock, DLM_BAST,\n\t\t\t\t      blocked_type, 0);\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_send_proxy_ast_msg",
          "args": [
            "dlm",
            "res",
            "lock",
            "DLM_BAST",
            "blocked_type",
            "0"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_proxy_ast_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "450-504",
          "snippet": "int dlm_send_proxy_ast_msg(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock, int msg_type,\n\t\t\t   int blocked_type, int flags)\n{\n\tint ret = 0;\n\tstruct dlm_proxy_ast past;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\tint status;\n\n\tmlog(0, \"%s: res %.*s, to %u, type %d, blocked_type %d\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, lock->ml.node, msg_type,\n\t     blocked_type);\n\n\tmemset(&past, 0, sizeof(struct dlm_proxy_ast));\n\tpast.node_idx = dlm->node_num;\n\tpast.type = msg_type;\n\tpast.blocked_type = blocked_type;\n\tpast.namelen = res->lockname.len;\n\tmemcpy(past.name, res->lockname.name, past.namelen);\n\tpast.cookie = lock->ml.cookie;\n\n\tvec[0].iov_len = sizeof(struct dlm_proxy_ast);\n\tvec[0].iov_base = &past;\n\tif (flags & DLM_LKSB_GET_LVB) {\n\t\tbe32_add_cpu(&past.flags, LKM_GET_LVB);\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\tret = o2net_send_message_vec(DLM_PROXY_AST_MSG, dlm->key, vec, veclen,\n\t\t\t\t     lock->ml.node, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: res %.*s, error %d send AST to node %u\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, ret,\n\t\t     lock->ml.node);\n\telse {\n\t\tif (status == DLM_RECOVERING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it thinks this \"\n\t\t\t     \"node is dead!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status == DLM_MIGRATING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it returned \"\n\t\t\t     \"DLM_MIGRATING!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status != DLM_NORMAL && status != DLM_IVLOCKID) {\n\t\t\tmlog(ML_ERROR, \"AST to node %u returned %d!\\n\",\n\t\t\t     lock->ml.node, status);\n\t\t\t/* ignore it */\n\t\t}\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nint dlm_send_proxy_ast_msg(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock, int msg_type,\n\t\t\t   int blocked_type, int flags)\n{\n\tint ret = 0;\n\tstruct dlm_proxy_ast past;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\tint status;\n\n\tmlog(0, \"%s: res %.*s, to %u, type %d, blocked_type %d\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, lock->ml.node, msg_type,\n\t     blocked_type);\n\n\tmemset(&past, 0, sizeof(struct dlm_proxy_ast));\n\tpast.node_idx = dlm->node_num;\n\tpast.type = msg_type;\n\tpast.blocked_type = blocked_type;\n\tpast.namelen = res->lockname.len;\n\tmemcpy(past.name, res->lockname.name, past.namelen);\n\tpast.cookie = lock->ml.cookie;\n\n\tvec[0].iov_len = sizeof(struct dlm_proxy_ast);\n\tvec[0].iov_base = &past;\n\tif (flags & DLM_LKSB_GET_LVB) {\n\t\tbe32_add_cpu(&past.flags, LKM_GET_LVB);\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\tret = o2net_send_message_vec(DLM_PROXY_AST_MSG, dlm->key, vec, veclen,\n\t\t\t\t     lock->ml.node, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: res %.*s, error %d send AST to node %u\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, ret,\n\t\t     lock->ml.node);\n\telse {\n\t\tif (status == DLM_RECOVERING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it thinks this \"\n\t\t\t     \"node is dead!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status == DLM_MIGRATING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it returned \"\n\t\t\t     \"DLM_MIGRATING!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status != DLM_NORMAL && status != DLM_IVLOCKID) {\n\t\t\tmlog(ML_ERROR, \"AST to node %u returned %d!\\n\",\n\t\t\t     lock->ml.node, status);\n\t\t\t/* ignore it */\n\t\t}\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_send_proxy_bast(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      struct dlm_lock *lock,\n\t\t\t\t      int blocked_type)\n{\n\treturn dlm_send_proxy_ast_msg(dlm, res, lock, DLM_BAST,\n\t\t\t\t      blocked_type, 0);\n}"
  },
  {
    "function_name": "dlm_lockres_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "873-878",
    "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&res->refs"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
  },
  {
    "function_name": "dlm_get_lock_cookie_seq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "821-826",
    "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_get_lock_cookie_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "813-819",
    "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "cookie & 0xffULL"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
  },
  {
    "function_name": "__dlm_lockres_state_to_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "796-811",
    "snippet": "static inline enum dlm_status\n__dlm_lockres_state_to_status(struct dlm_lock_resource *res)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\tstatus = DLM_RECOVERING;\n\telse if (res->state & DLM_LOCK_RES_MIGRATING)\n\t\tstatus = DLM_MIGRATING;\n\telse if (res->state & DLM_LOCK_RES_IN_PROGRESS)\n\t\tstatus = DLM_FORWARD;\n\n\treturn status;\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [
      "#define DLM_LOCK_RES_MIGRATING            0x00000020",
      "#define DLM_LOCK_RES_IN_PROGRESS          0x00000010",
      "#define DLM_LOCK_RES_RECOVERING           0x00000002"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_LOCK_RES_MIGRATING            0x00000020\n#define DLM_LOCK_RES_IN_PROGRESS          0x00000010\n#define DLM_LOCK_RES_RECOVERING           0x00000002\n\nstatic inline enum dlm_status\n__dlm_lockres_state_to_status(struct dlm_lock_resource *res)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\tstatus = DLM_RECOVERING;\n\telse if (res->state & DLM_LOCK_RES_MIGRATING)\n\t\tstatus = DLM_MIGRATING;\n\telse if (res->state & DLM_LOCK_RES_IN_PROGRESS)\n\t\tstatus = DLM_FORWARD;\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_list_idx_to_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "417-430",
    "snippet": "static inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_list_in_text",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "405-415",
    "snippet": "static inline char *dlm_list_in_text(enum dlm_lockres_list idx)\n{\n\tif (idx == DLM_GRANTED_LIST)\n\t\treturn \"granted\";\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\treturn \"converting\";\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\treturn \"blocked\";\n\telse\n\t\treturn \"unknown\";\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline char *dlm_list_in_text(enum dlm_lockres_list idx)\n{\n\tif (idx == DLM_GRANTED_LIST)\n\t\treturn \"granted\";\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\treturn \"converting\";\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\treturn \"blocked\";\n\telse\n\t\treturn \"unknown\";\n}"
  },
  {
    "function_name": "dlm_lvb_is_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "396-403",
    "snippet": "static inline int dlm_lvb_is_empty(char *lvb)\n{\n\tint i;\n\tfor (i=0; i<DLM_LVB_LEN; i++)\n\t\tif (lvb[i])\n\t\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_lvb_is_empty(char *lvb)\n{\n\tint i;\n\tfor (i=0; i<DLM_LVB_LEN; i++)\n\t\tif (lvb[i])\n\t\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "__dlm_set_joining_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "267-274",
    "snippet": "static inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&dlm->dlm_join_events"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}"
  },
  {
    "function_name": "dlm_init_work_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "254-263",
    "snippet": "static inline void dlm_init_work_item(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_work_item *i,\n\t\t\t\t      dlm_workfunc_t *f, void *data)\n{\n\tmemset(i, 0, sizeof(*i));\n\ti->func = f;\n\tINIT_LIST_HEAD(&i->list);\n\ti->data = data;\n\ti->dlm = dlm;  /* must have already done a dlm_grab on this! */\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&i->list"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "i",
            "0",
            "sizeof(*i)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_init_work_item(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_work_item *i,\n\t\t\t\t      dlm_workfunc_t *f, void *data)\n{\n\tmemset(i, 0, sizeof(*i));\n\ti->func = f;\n\tINIT_LIST_HEAD(&i->list);\n\ti->data = data;\n\ti->dlm = dlm;  /* must have already done a dlm_grab on this! */\n}"
  },
  {
    "function_name": "dlm_master_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "195-200",
    "snippet": "static inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [
      "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_master_hash(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t unsigned i)\n{\n\treturn dlm->master_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] +\n\t\t\t(i % DLM_BUCKETS_PER_PAGE);\n}"
  },
  {
    "function_name": "dlm_lockres_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "190-193",
    "snippet": "static inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [
      "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}"
  },
  {
    "function_name": "dlm_is_recovery_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
    "lines": "97-103",
    "snippet": "static inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kref.h>"
    ],
    "macros_used": [
      "#define DLM_RECOVERY_LOCK_NAME_LEN   9",
      "#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "lock_name",
            "DLM_RECOVERY_LOCK_NAME",
            "name_len"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_RECOVERY_LOCK_NAME_LEN   9\n#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\"\n\nstatic inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}"
  }
]