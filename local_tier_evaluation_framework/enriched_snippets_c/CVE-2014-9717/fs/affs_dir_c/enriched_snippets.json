[
  {
    "function_name": "affs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/dir.c",
    "lines": "42-142",
    "snippet": "static int\naffs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode\t\t*inode = file_inode(file);\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*dir_bh = NULL;\n\tstruct buffer_head\t*fh_bh = NULL;\n\tunsigned char\t\t*name;\n\tint\t\t\t namelen;\n\tu32\t\t\t i;\n\tint\t\t\t hash_pos;\n\tint\t\t\t chain_pos;\n\tu32\t\t\t ino;\n\tint\t\t\t error = 0;\n\n\tpr_debug(\"%s(ino=%lu,f_pos=%llx)\\n\", __func__, inode->i_ino, ctx->pos);\n\n\tif (ctx->pos < 2) {\n\t\tfile->private_data = (void *)0;\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\treturn 0;\n\t}\n\n\taffs_lock_dir(inode);\n\tchain_pos = (ctx->pos - 2) & 0xffff;\n\thash_pos  = (ctx->pos - 2) >> 16;\n\tif (chain_pos == 0xffff) {\n\t\taffs_warning(sb, \"readdir\", \"More than 65535 entries in chain\");\n\t\tchain_pos = 0;\n\t\thash_pos++;\n\t\tctx->pos = ((hash_pos << 16) | chain_pos) + 2;\n\t}\n\tdir_bh = affs_bread(sb, inode->i_ino);\n\tif (!dir_bh)\n\t\tgoto out_unlock_dir;\n\n\t/* If the directory hasn't changed since the last call to readdir(),\n\t * we can jump directly to where we left off.\n\t */\n\tino = (u32)(long)file->private_data;\n\tif (ino && file->f_version == inode->i_version) {\n\t\tpr_debug(\"readdir() left off=%d\\n\", ino);\n\t\tgoto inside;\n\t}\n\n\tino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[hash_pos]);\n\tfor (i = 0; ino && i < chain_pos; i++) {\n\t\tfh_bh = affs_bread(sb, ino);\n\t\tif (!fh_bh) {\n\t\t\taffs_error(sb, \"readdir\",\"Cannot read block %d\", i);\n\t\t\terror = -EIO;\n\t\t\tgoto out_brelse_dir;\n\t\t}\n\t\tino = be32_to_cpu(AFFS_TAIL(sb, fh_bh)->hash_chain);\n\t\taffs_brelse(fh_bh);\n\t\tfh_bh = NULL;\n\t}\n\tif (ino)\n\t\tgoto inside;\n\thash_pos++;\n\n\tfor (; hash_pos < AFFS_SB(sb)->s_hashsize; hash_pos++) {\n\t\tino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[hash_pos]);\n\t\tif (!ino)\n\t\t\tcontinue;\n\t\tctx->pos = (hash_pos << 16) + 2;\ninside:\n\t\tdo {\n\t\t\tfh_bh = affs_bread(sb, ino);\n\t\t\tif (!fh_bh) {\n\t\t\t\taffs_error(sb, \"readdir\",\n\t\t\t\t\t   \"Cannot read block %d\", ino);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnamelen = min(AFFS_TAIL(sb, fh_bh)->name[0],\n\t\t\t\t      (u8)AFFSNAMEMAX);\n\t\t\tname = AFFS_TAIL(sb, fh_bh)->name + 1;\n\t\t\tpr_debug(\"readdir(): dir_emit(\\\"%.*s\\\", ino=%u), hash=%d, f_pos=%llx\\n\",\n\t\t\t\t namelen, name, ino, hash_pos, ctx->pos);\n\n\t\t\tif (!dir_emit(ctx, name, namelen, ino, DT_UNKNOWN))\n\t\t\t\tgoto done;\n\t\t\tctx->pos++;\n\t\t\tino = be32_to_cpu(AFFS_TAIL(sb, fh_bh)->hash_chain);\n\t\t\taffs_brelse(fh_bh);\n\t\t\tfh_bh = NULL;\n\t\t} while (ino);\n\t}\ndone:\n\tfile->f_version = inode->i_version;\n\tfile->private_data = (void *)(long)ino;\n\taffs_brelse(fh_bh);\n\nout_brelse_dir:\n\taffs_brelse(dir_bh);\n\nout_unlock_dir:\n\taffs_unlock_dir(inode);\n\treturn error;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int affs_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_unlock_dir",
          "args": [
            "inode"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "affs_unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "296-300",
          "snippet": "static inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_hash_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define i_hash_lock i_ext_lock"
          ],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define i_hash_lock i_ext_lock\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "dir_bh"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, fh_bh)->hash_chain"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "fh_bh"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "name",
            "namelen",
            "ino",
            "DT_UNKNOWN"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"readdir(): dir_emit(\\\"%.*s\\\", ino=%u), hash=%d, f_pos=%llx\\n\"",
            "namelen",
            "name",
            "ino",
            "hash_pos",
            "ctx->pos"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "fh_bh"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "AFFS_TAIL(sb, fh_bh)->name[0]",
            "(u8)AFFSNAMEMAX"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "244-251",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "fh_bh"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_error",
          "args": [
            "sb",
            "\"readdir\"",
            "\"Cannot read block %d\"",
            "ino"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "affs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "442-456",
          "snippet": "void\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_crit(\"error (device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tpr_warn(\"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "ino"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_HEAD(dir_bh)->table[hash_pos]"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "dir_bh"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, fh_bh)->hash_chain"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "fh_bh"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_HEAD(dir_bh)->table[hash_pos]"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "dir_bh"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"readdir() left off=%d\\n\"",
            "ino"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_warning",
          "args": [
            "sb",
            "\"readdir\"",
            "\"More than 65535 entries in chain\""
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "affs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "458-469",
          "snippet": "void\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s(): %pV\\n\", sb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_lock_dir",
          "args": [
            "inode"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "affs_lock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "291-295",
          "snippet": "static inline void\naffs_lock_dir(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_hash_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define i_hash_lock i_ext_lock"
          ],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define i_hash_lock i_ext_lock\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_lock_dir(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(ino=%lu,f_pos=%llx)\\n\"",
            "__func__",
            "inode->i_ino",
            "ctx->pos"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int affs_readdir(struct file *, struct dir_context *);\n\nstatic int\naffs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode\t\t*inode = file_inode(file);\n\tstruct super_block\t*sb = inode->i_sb;\n\tstruct buffer_head\t*dir_bh = NULL;\n\tstruct buffer_head\t*fh_bh = NULL;\n\tunsigned char\t\t*name;\n\tint\t\t\t namelen;\n\tu32\t\t\t i;\n\tint\t\t\t hash_pos;\n\tint\t\t\t chain_pos;\n\tu32\t\t\t ino;\n\tint\t\t\t error = 0;\n\n\tpr_debug(\"%s(ino=%lu,f_pos=%llx)\\n\", __func__, inode->i_ino, ctx->pos);\n\n\tif (ctx->pos < 2) {\n\t\tfile->private_data = (void *)0;\n\t\tif (!dir_emit_dots(file, ctx))\n\t\t\treturn 0;\n\t}\n\n\taffs_lock_dir(inode);\n\tchain_pos = (ctx->pos - 2) & 0xffff;\n\thash_pos  = (ctx->pos - 2) >> 16;\n\tif (chain_pos == 0xffff) {\n\t\taffs_warning(sb, \"readdir\", \"More than 65535 entries in chain\");\n\t\tchain_pos = 0;\n\t\thash_pos++;\n\t\tctx->pos = ((hash_pos << 16) | chain_pos) + 2;\n\t}\n\tdir_bh = affs_bread(sb, inode->i_ino);\n\tif (!dir_bh)\n\t\tgoto out_unlock_dir;\n\n\t/* If the directory hasn't changed since the last call to readdir(),\n\t * we can jump directly to where we left off.\n\t */\n\tino = (u32)(long)file->private_data;\n\tif (ino && file->f_version == inode->i_version) {\n\t\tpr_debug(\"readdir() left off=%d\\n\", ino);\n\t\tgoto inside;\n\t}\n\n\tino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[hash_pos]);\n\tfor (i = 0; ino && i < chain_pos; i++) {\n\t\tfh_bh = affs_bread(sb, ino);\n\t\tif (!fh_bh) {\n\t\t\taffs_error(sb, \"readdir\",\"Cannot read block %d\", i);\n\t\t\terror = -EIO;\n\t\t\tgoto out_brelse_dir;\n\t\t}\n\t\tino = be32_to_cpu(AFFS_TAIL(sb, fh_bh)->hash_chain);\n\t\taffs_brelse(fh_bh);\n\t\tfh_bh = NULL;\n\t}\n\tif (ino)\n\t\tgoto inside;\n\thash_pos++;\n\n\tfor (; hash_pos < AFFS_SB(sb)->s_hashsize; hash_pos++) {\n\t\tino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[hash_pos]);\n\t\tif (!ino)\n\t\t\tcontinue;\n\t\tctx->pos = (hash_pos << 16) + 2;\ninside:\n\t\tdo {\n\t\t\tfh_bh = affs_bread(sb, ino);\n\t\t\tif (!fh_bh) {\n\t\t\t\taffs_error(sb, \"readdir\",\n\t\t\t\t\t   \"Cannot read block %d\", ino);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnamelen = min(AFFS_TAIL(sb, fh_bh)->name[0],\n\t\t\t\t      (u8)AFFSNAMEMAX);\n\t\t\tname = AFFS_TAIL(sb, fh_bh)->name + 1;\n\t\t\tpr_debug(\"readdir(): dir_emit(\\\"%.*s\\\", ino=%u), hash=%d, f_pos=%llx\\n\",\n\t\t\t\t namelen, name, ino, hash_pos, ctx->pos);\n\n\t\t\tif (!dir_emit(ctx, name, namelen, ino, DT_UNKNOWN))\n\t\t\t\tgoto done;\n\t\t\tctx->pos++;\n\t\t\tino = be32_to_cpu(AFFS_TAIL(sb, fh_bh)->hash_chain);\n\t\t\taffs_brelse(fh_bh);\n\t\t\tfh_bh = NULL;\n\t\t} while (ino);\n\t}\ndone:\n\tfile->f_version = inode->i_version;\n\tfile->private_data = (void *)(long)ino;\n\taffs_brelse(fh_bh);\n\nout_brelse_dir:\n\taffs_brelse(dir_bh);\n\nout_unlock_dir:\n\taffs_unlock_dir(inode);\n\treturn error;\n}"
  }
]