[
  {
    "function_name": "xfs_file_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "1369-1386",
    "snippet": "STATIC loff_t\nxfs_file_llseek(\n\tstruct file\t*file,\n\tloff_t\t\toffset,\n\tint\t\twhence)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\tcase SEEK_CUR:\n\tcase SEEK_SET:\n\t\treturn generic_file_llseek(file, offset, whence);\n\tcase SEEK_HOLE:\n\tcase SEEK_DATA:\n\t\treturn xfs_seek_hole_data(file, offset, whence);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_seek_hole_data",
          "args": [
            "file",
            "offset",
            "whence"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_seek_hole_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "1231-1367",
          "snippet": "STATIC loff_t\nxfs_seek_hole_data(\n\tstruct file\t\t*file,\n\tloff_t\t\t\tstart,\n\tint\t\t\twhence)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tloff_t\t\t\tuninitialized_var(offset);\n\txfs_fsize_t\t\tisize;\n\txfs_fileoff_t\t\tfsbno;\n\txfs_filblks_t\t\tend;\n\tuint\t\t\tlock;\n\tint\t\t\terror;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tlock = xfs_ilock_data_map_shared(ip);\n\n\tisize = i_size_read(inode);\n\tif (start >= isize) {\n\t\terror = -ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Try to read extents from the first block indicated\n\t * by fsbno to the end block of the file.\n\t */\n\tfsbno = XFS_B_TO_FSBT(mp, start);\n\tend = XFS_B_TO_FSB(mp, isize);\n\n\tfor (;;) {\n\t\tstruct xfs_bmbt_irec\tmap[2];\n\t\tint\t\t\tnmap = 2;\n\t\tunsigned int\t\ti;\n\n\t\terror = xfs_bmapi_read(ip, fsbno, end - fsbno, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ENTIRE);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\t/* No extents at given offset, must be beyond EOF */\n\t\tif (nmap == 0) {\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfor (i = 0; i < nmap; i++) {\n\t\t\toffset = max_t(loff_t, start,\n\t\t\t\t       XFS_FSB_TO_B(mp, map[i].br_startoff));\n\n\t\t\t/* Landed in the hole we wanted? */\n\t\t\tif (whence == SEEK_HOLE &&\n\t\t\t    map[i].br_startblock == HOLESTARTBLOCK)\n\t\t\t\tgoto out;\n\n\t\t\t/* Landed in the data extent we wanted? */\n\t\t\tif (whence == SEEK_DATA &&\n\t\t\t    (map[i].br_startblock == DELAYSTARTBLOCK ||\n\t\t\t     (map[i].br_state == XFS_EXT_NORM &&\n\t\t\t      !isnullstartblock(map[i].br_startblock))))\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Landed in an unwritten extent, try to search\n\t\t\t * for hole or data from page cache.\n\t\t\t */\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\tif (xfs_find_get_desired_pgoff(inode, &map[i],\n\t\t\t\t      whence == SEEK_HOLE ? HOLE_OFF : DATA_OFF,\n\t\t\t\t\t\t\t&offset))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We only received one extent out of the two requested. This\n\t\t * means we've hit EOF and didn't find what we are looking for.\n\t\t */\n\t\tif (nmap == 1) {\n\t\t\t/*\n\t\t\t * If we were looking for a hole, set offset to\n\t\t\t * the end of the file (i.e., there is an implicit\n\t\t\t * hole at the end of any file).\n\t\t \t */\n\t\t\tif (whence == SEEK_HOLE) {\n\t\t\t\toffset = isize;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we were looking for data, it's nowhere to be found\n\t\t\t */\n\t\t\tASSERT(whence == SEEK_DATA);\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tASSERT(i > 1);\n\n\t\t/*\n\t\t * Nothing was found, proceed to the next round of search\n\t\t * if the next reading offset is not at or beyond EOF.\n\t\t */\n\t\tfsbno = map[i - 1].br_startoff + map[i - 1].br_blockcount;\n\t\tstart = XFS_FSB_TO_B(mp, fsbno);\n\t\tif (start >= isize) {\n\t\t\tif (whence == SEEK_HOLE) {\n\t\t\t\toffset = isize;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tASSERT(whence == SEEK_DATA);\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * If at this point we have found the hole we wanted, the returned\n\t * offset may be bigger than the file size as it may be aligned to\n\t * page boundary for unwritten extents.  We need to deal with this\n\t * situation in particular.\n\t */\n\tif (whence == SEEK_HOLE)\n\t\toffset = min_t(loff_t, offset, isize);\n\toffset = vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n\nout_unlock:\n\txfs_iunlock(ip, lock);\n\n\tif (error)\n\t\treturn error;\n\treturn offset;\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC loff_t\nxfs_seek_hole_data(\n\tstruct file\t\t*file,\n\tloff_t\t\t\tstart,\n\tint\t\t\twhence)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tloff_t\t\t\tuninitialized_var(offset);\n\txfs_fsize_t\t\tisize;\n\txfs_fileoff_t\t\tfsbno;\n\txfs_filblks_t\t\tend;\n\tuint\t\t\tlock;\n\tint\t\t\terror;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tlock = xfs_ilock_data_map_shared(ip);\n\n\tisize = i_size_read(inode);\n\tif (start >= isize) {\n\t\terror = -ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Try to read extents from the first block indicated\n\t * by fsbno to the end block of the file.\n\t */\n\tfsbno = XFS_B_TO_FSBT(mp, start);\n\tend = XFS_B_TO_FSB(mp, isize);\n\n\tfor (;;) {\n\t\tstruct xfs_bmbt_irec\tmap[2];\n\t\tint\t\t\tnmap = 2;\n\t\tunsigned int\t\ti;\n\n\t\terror = xfs_bmapi_read(ip, fsbno, end - fsbno, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ENTIRE);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\t/* No extents at given offset, must be beyond EOF */\n\t\tif (nmap == 0) {\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfor (i = 0; i < nmap; i++) {\n\t\t\toffset = max_t(loff_t, start,\n\t\t\t\t       XFS_FSB_TO_B(mp, map[i].br_startoff));\n\n\t\t\t/* Landed in the hole we wanted? */\n\t\t\tif (whence == SEEK_HOLE &&\n\t\t\t    map[i].br_startblock == HOLESTARTBLOCK)\n\t\t\t\tgoto out;\n\n\t\t\t/* Landed in the data extent we wanted? */\n\t\t\tif (whence == SEEK_DATA &&\n\t\t\t    (map[i].br_startblock == DELAYSTARTBLOCK ||\n\t\t\t     (map[i].br_state == XFS_EXT_NORM &&\n\t\t\t      !isnullstartblock(map[i].br_startblock))))\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Landed in an unwritten extent, try to search\n\t\t\t * for hole or data from page cache.\n\t\t\t */\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\tif (xfs_find_get_desired_pgoff(inode, &map[i],\n\t\t\t\t      whence == SEEK_HOLE ? HOLE_OFF : DATA_OFF,\n\t\t\t\t\t\t\t&offset))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We only received one extent out of the two requested. This\n\t\t * means we've hit EOF and didn't find what we are looking for.\n\t\t */\n\t\tif (nmap == 1) {\n\t\t\t/*\n\t\t\t * If we were looking for a hole, set offset to\n\t\t\t * the end of the file (i.e., there is an implicit\n\t\t\t * hole at the end of any file).\n\t\t \t */\n\t\t\tif (whence == SEEK_HOLE) {\n\t\t\t\toffset = isize;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we were looking for data, it's nowhere to be found\n\t\t\t */\n\t\t\tASSERT(whence == SEEK_DATA);\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tASSERT(i > 1);\n\n\t\t/*\n\t\t * Nothing was found, proceed to the next round of search\n\t\t * if the next reading offset is not at or beyond EOF.\n\t\t */\n\t\tfsbno = map[i - 1].br_startoff + map[i - 1].br_blockcount;\n\t\tstart = XFS_FSB_TO_B(mp, fsbno);\n\t\tif (start >= isize) {\n\t\t\tif (whence == SEEK_HOLE) {\n\t\t\t\toffset = isize;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tASSERT(whence == SEEK_DATA);\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * If at this point we have found the hole we wanted, the returned\n\t * offset may be bigger than the file size as it may be aligned to\n\t * page boundary for unwritten extents.  We need to deal with this\n\t * situation in particular.\n\t */\n\tif (whence == SEEK_HOLE)\n\t\toffset = min_t(loff_t, offset, isize);\n\toffset = vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n\nout_unlock:\n\txfs_iunlock(ip, lock);\n\n\tif (error)\n\t\treturn error;\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_llseek",
          "args": [
            "file",
            "offset",
            "whence"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "147-154",
          "snippet": "loff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC loff_t\nxfs_file_llseek(\n\tstruct file\t*file,\n\tloff_t\t\toffset,\n\tint\t\twhence)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\tcase SEEK_CUR:\n\tcase SEEK_SET:\n\t\treturn generic_file_llseek(file, offset, whence);\n\tcase SEEK_HOLE:\n\tcase SEEK_DATA:\n\t\treturn xfs_seek_hole_data(file, offset, whence);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "xfs_seek_hole_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "1231-1367",
    "snippet": "STATIC loff_t\nxfs_seek_hole_data(\n\tstruct file\t\t*file,\n\tloff_t\t\t\tstart,\n\tint\t\t\twhence)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tloff_t\t\t\tuninitialized_var(offset);\n\txfs_fsize_t\t\tisize;\n\txfs_fileoff_t\t\tfsbno;\n\txfs_filblks_t\t\tend;\n\tuint\t\t\tlock;\n\tint\t\t\terror;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tlock = xfs_ilock_data_map_shared(ip);\n\n\tisize = i_size_read(inode);\n\tif (start >= isize) {\n\t\terror = -ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Try to read extents from the first block indicated\n\t * by fsbno to the end block of the file.\n\t */\n\tfsbno = XFS_B_TO_FSBT(mp, start);\n\tend = XFS_B_TO_FSB(mp, isize);\n\n\tfor (;;) {\n\t\tstruct xfs_bmbt_irec\tmap[2];\n\t\tint\t\t\tnmap = 2;\n\t\tunsigned int\t\ti;\n\n\t\terror = xfs_bmapi_read(ip, fsbno, end - fsbno, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ENTIRE);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\t/* No extents at given offset, must be beyond EOF */\n\t\tif (nmap == 0) {\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfor (i = 0; i < nmap; i++) {\n\t\t\toffset = max_t(loff_t, start,\n\t\t\t\t       XFS_FSB_TO_B(mp, map[i].br_startoff));\n\n\t\t\t/* Landed in the hole we wanted? */\n\t\t\tif (whence == SEEK_HOLE &&\n\t\t\t    map[i].br_startblock == HOLESTARTBLOCK)\n\t\t\t\tgoto out;\n\n\t\t\t/* Landed in the data extent we wanted? */\n\t\t\tif (whence == SEEK_DATA &&\n\t\t\t    (map[i].br_startblock == DELAYSTARTBLOCK ||\n\t\t\t     (map[i].br_state == XFS_EXT_NORM &&\n\t\t\t      !isnullstartblock(map[i].br_startblock))))\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Landed in an unwritten extent, try to search\n\t\t\t * for hole or data from page cache.\n\t\t\t */\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\tif (xfs_find_get_desired_pgoff(inode, &map[i],\n\t\t\t\t      whence == SEEK_HOLE ? HOLE_OFF : DATA_OFF,\n\t\t\t\t\t\t\t&offset))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We only received one extent out of the two requested. This\n\t\t * means we've hit EOF and didn't find what we are looking for.\n\t\t */\n\t\tif (nmap == 1) {\n\t\t\t/*\n\t\t\t * If we were looking for a hole, set offset to\n\t\t\t * the end of the file (i.e., there is an implicit\n\t\t\t * hole at the end of any file).\n\t\t \t */\n\t\t\tif (whence == SEEK_HOLE) {\n\t\t\t\toffset = isize;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we were looking for data, it's nowhere to be found\n\t\t\t */\n\t\t\tASSERT(whence == SEEK_DATA);\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tASSERT(i > 1);\n\n\t\t/*\n\t\t * Nothing was found, proceed to the next round of search\n\t\t * if the next reading offset is not at or beyond EOF.\n\t\t */\n\t\tfsbno = map[i - 1].br_startoff + map[i - 1].br_blockcount;\n\t\tstart = XFS_FSB_TO_B(mp, fsbno);\n\t\tif (start >= isize) {\n\t\t\tif (whence == SEEK_HOLE) {\n\t\t\t\toffset = isize;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tASSERT(whence == SEEK_DATA);\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * If at this point we have found the hole we wanted, the returned\n\t * offset may be bigger than the file size as it may be aligned to\n\t * page boundary for unwritten extents.  We need to deal with this\n\t * situation in particular.\n\t */\n\tif (whence == SEEK_HOLE)\n\t\toffset = min_t(loff_t, offset, isize);\n\toffset = vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n\nout_unlock:\n\txfs_iunlock(ip, lock);\n\n\tif (error)\n\t\treturn error;\n\treturn offset;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "lock"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_setpos",
          "args": [
            "file",
            "offset",
            "inode->i_sb->s_maxbytes"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "57-69",
          "snippet": "loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "loff_t",
            "offset",
            "isize"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "whence == SEEK_DATA"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "fsbno"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i > 1"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "whence == SEEK_DATA"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_find_get_desired_pgoff",
          "args": [
            "inode",
            "&map[i]",
            "whence == SEEK_HOLE ? HOLE_OFF : DATA_OFF",
            "&offset"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_find_get_desired_pgoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "1082-1229",
          "snippet": "STATIC bool\nxfs_find_get_desired_pgoff(\n\tstruct inode\t\t*inode,\n\tstruct xfs_bmbt_irec\t*map,\n\tunsigned int\t\ttype,\n\tloff_t\t\t\t*offset)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct pagevec\t\tpvec;\n\tpgoff_t\t\t\tindex;\n\tpgoff_t\t\t\tend;\n\tloff_t\t\t\tendoff;\n\tloff_t\t\t\tstartoff = *offset;\n\tloff_t\t\t\tlastoff = startoff;\n\tbool\t\t\tfound = false;\n\n\tpagevec_init(&pvec, 0);\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tendoff = XFS_FSB_TO_B(mp, map->br_startoff + map->br_blockcount);\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\tint\t\twant;\n\t\tunsigned\tnr_pages;\n\t\tunsigned int\ti;\n\n\t\twant = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  want);\n\t\t/*\n\t\t * No page mapped into given range.  If we are searching holes\n\t\t * and if this is the first time we got into the loop, it means\n\t\t * that the given offset is landed in a hole, return it.\n\t\t *\n\t\t * If we have already stepped through some block buffers to find\n\t\t * holes but they all contains data.  In this case, the last\n\t\t * offset is already updated and pointed to the end of the last\n\t\t * mapped page, if it does not reach the endpoint to search,\n\t\t * that means there should be a hole between them.\n\t\t */\n\t\tif (nr_pages == 0) {\n\t\t\t/* Data search found nothing */\n\t\t\tif (type == DATA_OFF)\n\t\t\t\tbreak;\n\n\t\t\tASSERT(type == HOLE_OFF);\n\t\t\tif (lastoff == startoff || lastoff < endoff) {\n\t\t\t\tfound = true;\n\t\t\t\t*offset = lastoff;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * At lease we found one page.  If this is the first time we\n\t\t * step into the loop, and if the first page index offset is\n\t\t * greater than the given search offset, a hole was found.\n\t\t */\n\t\tif (type == HOLE_OFF && lastoff == startoff &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page\t*page = pvec.pages[i];\n\t\t\tloff_t\t\tb_offset;\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL),\n\t\t\t * or even swizzled back from swapper_space to tmpfs\n\t\t\t * file mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t *\n\t\t\t * Searching done if the page index is out of range.\n\t\t\t * If the current offset is not reaches the end of\n\t\t\t * the specified search range, there should be a hole\n\t\t\t * between them.\n\t\t\t */\n\t\t\tif (page->index > end) {\n\t\t\t\tif (type == HOLE_OFF && lastoff < endoff) {\n\t\t\t\t\t*offset = lastoff;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * Page truncated or invalidated(page->mapping == NULL).\n\t\t\t * We can freely skip it and proceed to check the next\n\t\t\t * page.\n\t\t\t */\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfound = xfs_lookup_buffer_offset(page, &b_offset, type);\n\t\t\tif (found) {\n\t\t\t\t/*\n\t\t\t\t * The found offset may be less than the start\n\t\t\t\t * point to search if this is the first time to\n\t\t\t\t * come here.\n\t\t\t\t */\n\t\t\t\t*offset = max_t(loff_t, startoff, b_offset);\n\t\t\t\tunlock_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We either searching data but nothing was found, or\n\t\t\t * searching hole but found a data buffer.  In either\n\t\t\t * case, probably the next page contains the desired\n\t\t\t * things, update the last offset to it so.\n\t\t\t */\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The number of returned pages less than our desired, search\n\t\t * done.  In this case, nothing was found for searching data,\n\t\t * but we found a hole behind the last offset.\n\t\t */\n\t\tif (nr_pages < want) {\n\t\t\tif (type == HOLE_OFF) {\n\t\t\t\t*offset = lastoff;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_find_get_desired_pgoff(\n\tstruct inode\t\t*inode,\n\tstruct xfs_bmbt_irec\t*map,\n\tunsigned int\t\ttype,\n\tloff_t\t\t\t*offset)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct pagevec\t\tpvec;\n\tpgoff_t\t\t\tindex;\n\tpgoff_t\t\t\tend;\n\tloff_t\t\t\tendoff;\n\tloff_t\t\t\tstartoff = *offset;\n\tloff_t\t\t\tlastoff = startoff;\n\tbool\t\t\tfound = false;\n\n\tpagevec_init(&pvec, 0);\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tendoff = XFS_FSB_TO_B(mp, map->br_startoff + map->br_blockcount);\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\tint\t\twant;\n\t\tunsigned\tnr_pages;\n\t\tunsigned int\ti;\n\n\t\twant = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  want);\n\t\t/*\n\t\t * No page mapped into given range.  If we are searching holes\n\t\t * and if this is the first time we got into the loop, it means\n\t\t * that the given offset is landed in a hole, return it.\n\t\t *\n\t\t * If we have already stepped through some block buffers to find\n\t\t * holes but they all contains data.  In this case, the last\n\t\t * offset is already updated and pointed to the end of the last\n\t\t * mapped page, if it does not reach the endpoint to search,\n\t\t * that means there should be a hole between them.\n\t\t */\n\t\tif (nr_pages == 0) {\n\t\t\t/* Data search found nothing */\n\t\t\tif (type == DATA_OFF)\n\t\t\t\tbreak;\n\n\t\t\tASSERT(type == HOLE_OFF);\n\t\t\tif (lastoff == startoff || lastoff < endoff) {\n\t\t\t\tfound = true;\n\t\t\t\t*offset = lastoff;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * At lease we found one page.  If this is the first time we\n\t\t * step into the loop, and if the first page index offset is\n\t\t * greater than the given search offset, a hole was found.\n\t\t */\n\t\tif (type == HOLE_OFF && lastoff == startoff &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page\t*page = pvec.pages[i];\n\t\t\tloff_t\t\tb_offset;\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL),\n\t\t\t * or even swizzled back from swapper_space to tmpfs\n\t\t\t * file mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t *\n\t\t\t * Searching done if the page index is out of range.\n\t\t\t * If the current offset is not reaches the end of\n\t\t\t * the specified search range, there should be a hole\n\t\t\t * between them.\n\t\t\t */\n\t\t\tif (page->index > end) {\n\t\t\t\tif (type == HOLE_OFF && lastoff < endoff) {\n\t\t\t\t\t*offset = lastoff;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * Page truncated or invalidated(page->mapping == NULL).\n\t\t\t * We can freely skip it and proceed to check the next\n\t\t\t * page.\n\t\t\t */\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfound = xfs_lookup_buffer_offset(page, &b_offset, type);\n\t\t\tif (found) {\n\t\t\t\t/*\n\t\t\t\t * The found offset may be less than the start\n\t\t\t\t * point to search if this is the first time to\n\t\t\t\t * come here.\n\t\t\t\t */\n\t\t\t\t*offset = max_t(loff_t, startoff, b_offset);\n\t\t\t\tunlock_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We either searching data but nothing was found, or\n\t\t\t * searching hole but found a data buffer.  In either\n\t\t\t * case, probably the next page contains the desired\n\t\t\t * things, update the last offset to it so.\n\t\t\t */\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The number of returned pages less than our desired, search\n\t\t * done.  In this case, nothing was found for searching data,\n\t\t * but we found a hole behind the last offset.\n\t\t */\n\t\tif (nr_pages < want) {\n\t\t\tif (type == HOLE_OFF) {\n\t\t\t\t*offset = lastoff;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "map[i].br_startblock"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "loff_t",
            "start",
            "XFS_FSB_TO_B(mp, map[i].br_startoff)"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "map[i].br_startoff"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "fsbno",
            "end - fsbno",
            "map",
            "&nmap",
            "XFS_BMAPI_ENTIRE"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "isize"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "start"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock_data_map_shared",
          "args": [
            "ip"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_data_map_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "93-104",
          "snippet": "uint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC loff_t\nxfs_seek_hole_data(\n\tstruct file\t\t*file,\n\tloff_t\t\t\tstart,\n\tint\t\t\twhence)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tloff_t\t\t\tuninitialized_var(offset);\n\txfs_fsize_t\t\tisize;\n\txfs_fileoff_t\t\tfsbno;\n\txfs_filblks_t\t\tend;\n\tuint\t\t\tlock;\n\tint\t\t\terror;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tlock = xfs_ilock_data_map_shared(ip);\n\n\tisize = i_size_read(inode);\n\tif (start >= isize) {\n\t\terror = -ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Try to read extents from the first block indicated\n\t * by fsbno to the end block of the file.\n\t */\n\tfsbno = XFS_B_TO_FSBT(mp, start);\n\tend = XFS_B_TO_FSB(mp, isize);\n\n\tfor (;;) {\n\t\tstruct xfs_bmbt_irec\tmap[2];\n\t\tint\t\t\tnmap = 2;\n\t\tunsigned int\t\ti;\n\n\t\terror = xfs_bmapi_read(ip, fsbno, end - fsbno, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ENTIRE);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\t/* No extents at given offset, must be beyond EOF */\n\t\tif (nmap == 0) {\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfor (i = 0; i < nmap; i++) {\n\t\t\toffset = max_t(loff_t, start,\n\t\t\t\t       XFS_FSB_TO_B(mp, map[i].br_startoff));\n\n\t\t\t/* Landed in the hole we wanted? */\n\t\t\tif (whence == SEEK_HOLE &&\n\t\t\t    map[i].br_startblock == HOLESTARTBLOCK)\n\t\t\t\tgoto out;\n\n\t\t\t/* Landed in the data extent we wanted? */\n\t\t\tif (whence == SEEK_DATA &&\n\t\t\t    (map[i].br_startblock == DELAYSTARTBLOCK ||\n\t\t\t     (map[i].br_state == XFS_EXT_NORM &&\n\t\t\t      !isnullstartblock(map[i].br_startblock))))\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Landed in an unwritten extent, try to search\n\t\t\t * for hole or data from page cache.\n\t\t\t */\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\tif (xfs_find_get_desired_pgoff(inode, &map[i],\n\t\t\t\t      whence == SEEK_HOLE ? HOLE_OFF : DATA_OFF,\n\t\t\t\t\t\t\t&offset))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We only received one extent out of the two requested. This\n\t\t * means we've hit EOF and didn't find what we are looking for.\n\t\t */\n\t\tif (nmap == 1) {\n\t\t\t/*\n\t\t\t * If we were looking for a hole, set offset to\n\t\t\t * the end of the file (i.e., there is an implicit\n\t\t\t * hole at the end of any file).\n\t\t \t */\n\t\t\tif (whence == SEEK_HOLE) {\n\t\t\t\toffset = isize;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we were looking for data, it's nowhere to be found\n\t\t\t */\n\t\t\tASSERT(whence == SEEK_DATA);\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tASSERT(i > 1);\n\n\t\t/*\n\t\t * Nothing was found, proceed to the next round of search\n\t\t * if the next reading offset is not at or beyond EOF.\n\t\t */\n\t\tfsbno = map[i - 1].br_startoff + map[i - 1].br_blockcount;\n\t\tstart = XFS_FSB_TO_B(mp, fsbno);\n\t\tif (start >= isize) {\n\t\t\tif (whence == SEEK_HOLE) {\n\t\t\t\toffset = isize;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tASSERT(whence == SEEK_DATA);\n\t\t\terror = -ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * If at this point we have found the hole we wanted, the returned\n\t * offset may be bigger than the file size as it may be aligned to\n\t * page boundary for unwritten extents.  We need to deal with this\n\t * situation in particular.\n\t */\n\tif (whence == SEEK_HOLE)\n\t\toffset = min_t(loff_t, offset, isize);\n\toffset = vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n\nout_unlock:\n\txfs_iunlock(ip, lock);\n\n\tif (error)\n\t\treturn error;\n\treturn offset;\n}"
  },
  {
    "function_name": "xfs_find_get_desired_pgoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "1082-1229",
    "snippet": "STATIC bool\nxfs_find_get_desired_pgoff(\n\tstruct inode\t\t*inode,\n\tstruct xfs_bmbt_irec\t*map,\n\tunsigned int\t\ttype,\n\tloff_t\t\t\t*offset)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct pagevec\t\tpvec;\n\tpgoff_t\t\t\tindex;\n\tpgoff_t\t\t\tend;\n\tloff_t\t\t\tendoff;\n\tloff_t\t\t\tstartoff = *offset;\n\tloff_t\t\t\tlastoff = startoff;\n\tbool\t\t\tfound = false;\n\n\tpagevec_init(&pvec, 0);\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tendoff = XFS_FSB_TO_B(mp, map->br_startoff + map->br_blockcount);\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\tint\t\twant;\n\t\tunsigned\tnr_pages;\n\t\tunsigned int\ti;\n\n\t\twant = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  want);\n\t\t/*\n\t\t * No page mapped into given range.  If we are searching holes\n\t\t * and if this is the first time we got into the loop, it means\n\t\t * that the given offset is landed in a hole, return it.\n\t\t *\n\t\t * If we have already stepped through some block buffers to find\n\t\t * holes but they all contains data.  In this case, the last\n\t\t * offset is already updated and pointed to the end of the last\n\t\t * mapped page, if it does not reach the endpoint to search,\n\t\t * that means there should be a hole between them.\n\t\t */\n\t\tif (nr_pages == 0) {\n\t\t\t/* Data search found nothing */\n\t\t\tif (type == DATA_OFF)\n\t\t\t\tbreak;\n\n\t\t\tASSERT(type == HOLE_OFF);\n\t\t\tif (lastoff == startoff || lastoff < endoff) {\n\t\t\t\tfound = true;\n\t\t\t\t*offset = lastoff;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * At lease we found one page.  If this is the first time we\n\t\t * step into the loop, and if the first page index offset is\n\t\t * greater than the given search offset, a hole was found.\n\t\t */\n\t\tif (type == HOLE_OFF && lastoff == startoff &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page\t*page = pvec.pages[i];\n\t\t\tloff_t\t\tb_offset;\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL),\n\t\t\t * or even swizzled back from swapper_space to tmpfs\n\t\t\t * file mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t *\n\t\t\t * Searching done if the page index is out of range.\n\t\t\t * If the current offset is not reaches the end of\n\t\t\t * the specified search range, there should be a hole\n\t\t\t * between them.\n\t\t\t */\n\t\t\tif (page->index > end) {\n\t\t\t\tif (type == HOLE_OFF && lastoff < endoff) {\n\t\t\t\t\t*offset = lastoff;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * Page truncated or invalidated(page->mapping == NULL).\n\t\t\t * We can freely skip it and proceed to check the next\n\t\t\t * page.\n\t\t\t */\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfound = xfs_lookup_buffer_offset(page, &b_offset, type);\n\t\t\tif (found) {\n\t\t\t\t/*\n\t\t\t\t * The found offset may be less than the start\n\t\t\t\t * point to search if this is the first time to\n\t\t\t\t * come here.\n\t\t\t\t */\n\t\t\t\t*offset = max_t(loff_t, startoff, b_offset);\n\t\t\t\tunlock_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We either searching data but nothing was found, or\n\t\t\t * searching hole but found a data buffer.  In either\n\t\t\t * case, probably the next page contains the desired\n\t\t\t * things, update the last offset to it so.\n\t\t\t */\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The number of returned pages less than our desired, search\n\t\t * done.  In this case, nothing was found for searching data,\n\t\t * but we found a hole behind the last offset.\n\t\t */\n\t\tif (nr_pages < want) {\n\t\t\tif (type == HOLE_OFF) {\n\t\t\t\t*offset = lastoff;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "loff_t",
            "startoff",
            "b_offset"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_lookup_buffer_offset",
          "args": [
            "page",
            "&b_offset",
            "type"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lookup_buffer_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "1029-1067",
          "snippet": "STATIC bool\nxfs_lookup_buffer_offset(\n\tstruct page\t\t*page,\n\tloff_t\t\t\t*offset,\n\tunsigned int\t\ttype)\n{\n\tloff_t\t\t\tlastoff = page_offset(page);\n\tbool\t\t\tfound = false;\n\tstruct buffer_head\t*bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\t/*\n\t\t * Unwritten extents that have data in the page\n\t\t * cache covering them can be identified by the\n\t\t * BH_Unwritten state flag.  Pages with multiple\n\t\t * buffers might have a mix of holes, data and\n\t\t * unwritten extents - any buffer with valid\n\t\t * data in it should have BH_Uptodate flag set\n\t\t * on it.\n\t\t */\n\t\tif (buffer_unwritten(bh) ||\n\t\t    buffer_uptodate(bh)) {\n\t\t\tif (type == DATA_OFF)\n\t\t\t\tfound = true;\n\t\t} else {\n\t\t\tif (type == HOLE_OFF)\n\t\t\t\tfound = true;\n\t\t}\n\n\t\tif (found) {\n\t\t\t*offset = lastoff;\n\t\t\tbreak;\n\t\t}\n\t\tlastoff += bh->b_size;\n\t} while ((bh = bh->b_this_page) != head);\n\n\treturn found;\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_lookup_buffer_offset(\n\tstruct page\t\t*page,\n\tloff_t\t\t\t*offset,\n\tunsigned int\t\ttype)\n{\n\tloff_t\t\t\tlastoff = page_offset(page);\n\tbool\t\t\tfound = false;\n\tstruct buffer_head\t*bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\t/*\n\t\t * Unwritten extents that have data in the page\n\t\t * cache covering them can be identified by the\n\t\t * BH_Unwritten state flag.  Pages with multiple\n\t\t * buffers might have a mix of holes, data and\n\t\t * unwritten extents - any buffer with valid\n\t\t * data in it should have BH_Uptodate flag set\n\t\t * on it.\n\t\t */\n\t\tif (buffer_unwritten(bh) ||\n\t\t    buffer_uptodate(bh)) {\n\t\t\tif (type == DATA_OFF)\n\t\t\t\tfound = true;\n\t\t} else {\n\t\t\tif (type == HOLE_OFF)\n\t\t\t\tfound = true;\n\t\t}\n\n\t\tif (found) {\n\t\t\t*offset = lastoff;\n\t\t\tbreak;\n\t\t}\n\t\tlastoff += bh->b_size;\n\t} while ((bh = bh->b_this_page) != head);\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != inode->i_mapping"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "pvec.pages[0]"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "type == HOLE_OFF"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup",
          "args": [
            "&pvec",
            "inode->i_mapping",
            "index",
            "want"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "pgoff_t",
            "end - index",
            "PAGEVEC_SIZE"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "map->br_startoff + map->br_blockcount"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_find_get_desired_pgoff(\n\tstruct inode\t\t*inode,\n\tstruct xfs_bmbt_irec\t*map,\n\tunsigned int\t\ttype,\n\tloff_t\t\t\t*offset)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct pagevec\t\tpvec;\n\tpgoff_t\t\t\tindex;\n\tpgoff_t\t\t\tend;\n\tloff_t\t\t\tendoff;\n\tloff_t\t\t\tstartoff = *offset;\n\tloff_t\t\t\tlastoff = startoff;\n\tbool\t\t\tfound = false;\n\n\tpagevec_init(&pvec, 0);\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tendoff = XFS_FSB_TO_B(mp, map->br_startoff + map->br_blockcount);\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\tint\t\twant;\n\t\tunsigned\tnr_pages;\n\t\tunsigned int\ti;\n\n\t\twant = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  want);\n\t\t/*\n\t\t * No page mapped into given range.  If we are searching holes\n\t\t * and if this is the first time we got into the loop, it means\n\t\t * that the given offset is landed in a hole, return it.\n\t\t *\n\t\t * If we have already stepped through some block buffers to find\n\t\t * holes but they all contains data.  In this case, the last\n\t\t * offset is already updated and pointed to the end of the last\n\t\t * mapped page, if it does not reach the endpoint to search,\n\t\t * that means there should be a hole between them.\n\t\t */\n\t\tif (nr_pages == 0) {\n\t\t\t/* Data search found nothing */\n\t\t\tif (type == DATA_OFF)\n\t\t\t\tbreak;\n\n\t\t\tASSERT(type == HOLE_OFF);\n\t\t\tif (lastoff == startoff || lastoff < endoff) {\n\t\t\t\tfound = true;\n\t\t\t\t*offset = lastoff;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * At lease we found one page.  If this is the first time we\n\t\t * step into the loop, and if the first page index offset is\n\t\t * greater than the given search offset, a hole was found.\n\t\t */\n\t\tif (type == HOLE_OFF && lastoff == startoff &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page\t*page = pvec.pages[i];\n\t\t\tloff_t\t\tb_offset;\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL),\n\t\t\t * or even swizzled back from swapper_space to tmpfs\n\t\t\t * file mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t *\n\t\t\t * Searching done if the page index is out of range.\n\t\t\t * If the current offset is not reaches the end of\n\t\t\t * the specified search range, there should be a hole\n\t\t\t * between them.\n\t\t\t */\n\t\t\tif (page->index > end) {\n\t\t\t\tif (type == HOLE_OFF && lastoff < endoff) {\n\t\t\t\t\t*offset = lastoff;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * Page truncated or invalidated(page->mapping == NULL).\n\t\t\t * We can freely skip it and proceed to check the next\n\t\t\t * page.\n\t\t\t */\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfound = xfs_lookup_buffer_offset(page, &b_offset, type);\n\t\t\tif (found) {\n\t\t\t\t/*\n\t\t\t\t * The found offset may be less than the start\n\t\t\t\t * point to search if this is the first time to\n\t\t\t\t * come here.\n\t\t\t\t */\n\t\t\t\t*offset = max_t(loff_t, startoff, b_offset);\n\t\t\t\tunlock_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We either searching data but nothing was found, or\n\t\t\t * searching hole but found a data buffer.  In either\n\t\t\t * case, probably the next page contains the desired\n\t\t\t * things, update the last offset to it so.\n\t\t\t */\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The number of returned pages less than our desired, search\n\t\t * done.  In this case, nothing was found for searching data,\n\t\t * but we found a hole behind the last offset.\n\t\t */\n\t\tif (nr_pages < want) {\n\t\t\tif (type == HOLE_OFF) {\n\t\t\t\t*offset = lastoff;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}"
  },
  {
    "function_name": "xfs_lookup_buffer_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "1029-1067",
    "snippet": "STATIC bool\nxfs_lookup_buffer_offset(\n\tstruct page\t\t*page,\n\tloff_t\t\t\t*offset,\n\tunsigned int\t\ttype)\n{\n\tloff_t\t\t\tlastoff = page_offset(page);\n\tbool\t\t\tfound = false;\n\tstruct buffer_head\t*bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\t/*\n\t\t * Unwritten extents that have data in the page\n\t\t * cache covering them can be identified by the\n\t\t * BH_Unwritten state flag.  Pages with multiple\n\t\t * buffers might have a mix of holes, data and\n\t\t * unwritten extents - any buffer with valid\n\t\t * data in it should have BH_Uptodate flag set\n\t\t * on it.\n\t\t */\n\t\tif (buffer_unwritten(bh) ||\n\t\t    buffer_uptodate(bh)) {\n\t\t\tif (type == DATA_OFF)\n\t\t\t\tfound = true;\n\t\t} else {\n\t\t\tif (type == HOLE_OFF)\n\t\t\t\tfound = true;\n\t\t}\n\n\t\tif (found) {\n\t\t\t*offset = lastoff;\n\t\t\tbreak;\n\t\t}\n\t\tlastoff += bh->b_size;\n\t} while ((bh = bh->b_this_page) != head);\n\n\treturn found;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_lookup_buffer_offset(\n\tstruct page\t\t*page,\n\tloff_t\t\t\t*offset,\n\tunsigned int\t\ttype)\n{\n\tloff_t\t\t\tlastoff = page_offset(page);\n\tbool\t\t\tfound = false;\n\tstruct buffer_head\t*bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\t/*\n\t\t * Unwritten extents that have data in the page\n\t\t * cache covering them can be identified by the\n\t\t * BH_Unwritten state flag.  Pages with multiple\n\t\t * buffers might have a mix of holes, data and\n\t\t * unwritten extents - any buffer with valid\n\t\t * data in it should have BH_Uptodate flag set\n\t\t * on it.\n\t\t */\n\t\tif (buffer_unwritten(bh) ||\n\t\t    buffer_uptodate(bh)) {\n\t\t\tif (type == DATA_OFF)\n\t\t\t\tfound = true;\n\t\t} else {\n\t\t\tif (type == HOLE_OFF)\n\t\t\t\tfound = true;\n\t\t}\n\n\t\tif (found) {\n\t\t\t*offset = lastoff;\n\t\t\tbreak;\n\t\t}\n\t\tlastoff += bh->b_size;\n\t} while ((bh = bh->b_this_page) != head);\n\n\treturn found;\n}"
  },
  {
    "function_name": "xfs_vm_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "1005-1011",
    "snippet": "STATIC int\nxfs_vm_page_mkwrite(\n\tstruct vm_area_struct\t*vma,\n\tstruct vm_fault\t\t*vmf)\n{\n\treturn block_page_mkwrite(vma, vmf, xfs_get_blocks);\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_page_mkwrite",
          "args": [
            "vma",
            "vmf",
            "xfs_get_blocks"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "block_page_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2441-2458",
          "snippet": "int block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t   get_block_t get_block)\n{\n\tint ret;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\n\tsb_start_pagefault(sb);\n\n\t/*\n\t * Update file times before taking page lock. We may end up failing the\n\t * fault so this update may be superfluous but who really cares...\n\t */\n\tfile_update_time(vma->vm_file);\n\n\tret = __block_page_mkwrite(vma, vmf, get_block);\n\tsb_end_pagefault(sb);\n\treturn block_page_mkwrite_return(ret);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t   get_block_t get_block)\n{\n\tint ret;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\n\tsb_start_pagefault(sb);\n\n\t/*\n\t * Update file times before taking page lock. We may end up failing the\n\t * fault so this update may be superfluous but who really cares...\n\t */\n\tfile_update_time(vma->vm_file);\n\n\tret = __block_page_mkwrite(vma, vmf, get_block);\n\tsb_end_pagefault(sb);\n\treturn block_page_mkwrite_return(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_vm_page_mkwrite(\n\tstruct vm_area_struct\t*vma,\n\tstruct vm_fault\t\t*vmf)\n{\n\treturn block_page_mkwrite(vma, vmf, xfs_get_blocks);\n}"
  },
  {
    "function_name": "xfs_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "988-997",
    "snippet": "STATIC int\nxfs_file_mmap(\n\tstruct file\t*filp,\n\tstruct vm_area_struct *vma)\n{\n\tvma->vm_ops = &xfs_file_vm_ops;\n\n\tfile_accessed(filp);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct xfs_file_vm_ops;",
      "static const struct vm_operations_struct xfs_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= xfs_vm_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "filp"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct vm_operations_struct xfs_file_vm_ops;\nstatic const struct vm_operations_struct xfs_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= xfs_vm_page_mkwrite,\n};\n\nSTATIC int\nxfs_file_mmap(\n\tstruct file\t*filp,\n\tstruct vm_area_struct *vma)\n{\n\tvma->vm_ops = &xfs_file_vm_ops;\n\n\tfile_accessed(filp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_file_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "962-986",
    "snippet": "STATIC int\nxfs_file_readdir(\n\tstruct file\t*file,\n\tstruct dir_context *ctx)\n{\n\tstruct inode\t*inode = file_inode(file);\n\txfs_inode_t\t*ip = XFS_I(inode);\n\tsize_t\t\tbufsize;\n\n\t/*\n\t * The Linux API doesn't pass down the total size of the buffer\n\t * we read into down to the filesystem.  With the filldir concept\n\t * it's not needed for correct information, but the XFS dir2 leaf\n\t * code wants an estimate of the buffer size to calculate it's\n\t * readahead window and size the buffers used for mapping to\n\t * physical blocks.\n\t *\n\t * Try to give it an estimate that's good enough, maybe at some\n\t * point we can change the ->readdir prototype to include the\n\t * buffer size.  For now we use the current glibc buffer size.\n\t */\n\tbufsize = (size_t)min_t(loff_t, 32768, ip->i_d.di_size);\n\n\treturn xfs_readdir(ip, ctx, bufsize);\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_readdir",
          "args": [
            "ip",
            "ctx",
            "bufsize"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
          "lines": "647-681",
          "snippet": "int\nxfs_readdir(\n\tstruct xfs_inode\t*dp,\n\tstruct dir_context\t*ctx,\n\tsize_t\t\t\tbufsize)\n{\n\tstruct xfs_da_args\targs = { NULL };\n\tint\t\t\trval;\n\tint\t\t\tv;\n\tuint\t\t\tlock_mode;\n\n\ttrace_xfs_readdir(dp);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_getdents);\n\n\targs.dp = dp;\n\targs.geo = dp->i_mount->m_dir_geo;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL)\n\t\trval = xfs_dir2_sf_getdents(&args, ctx);\n\telse if ((rval = xfs_dir2_isblock(&args, &v)))\n\t\t;\n\telse if (v)\n\t\trval = xfs_dir2_block_getdents(&args, ctx);\n\telse\n\t\trval = xfs_dir2_leaf_getdents(&args, ctx, bufsize);\n\txfs_iunlock(dp, lock_mode);\n\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_readdir(\n\tstruct xfs_inode\t*dp,\n\tstruct dir_context\t*ctx,\n\tsize_t\t\t\tbufsize)\n{\n\tstruct xfs_da_args\targs = { NULL };\n\tint\t\t\trval;\n\tint\t\t\tv;\n\tuint\t\t\tlock_mode;\n\n\ttrace_xfs_readdir(dp);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_getdents);\n\n\targs.dp = dp;\n\targs.geo = dp->i_mount->m_dir_geo;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL)\n\t\trval = xfs_dir2_sf_getdents(&args, ctx);\n\telse if ((rval = xfs_dir2_isblock(&args, &v)))\n\t\t;\n\telse if (v)\n\t\trval = xfs_dir2_block_getdents(&args, ctx);\n\telse\n\t\trval = xfs_dir2_leaf_getdents(&args, ctx, bufsize);\n\txfs_iunlock(dp, lock_mode);\n\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "loff_t",
            "32768",
            "ip->i_d.di_size"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_file_readdir(\n\tstruct file\t*file,\n\tstruct dir_context *ctx)\n{\n\tstruct inode\t*inode = file_inode(file);\n\txfs_inode_t\t*ip = XFS_I(inode);\n\tsize_t\t\tbufsize;\n\n\t/*\n\t * The Linux API doesn't pass down the total size of the buffer\n\t * we read into down to the filesystem.  With the filldir concept\n\t * it's not needed for correct information, but the XFS dir2 leaf\n\t * code wants an estimate of the buffer size to calculate it's\n\t * readahead window and size the buffers used for mapping to\n\t * physical blocks.\n\t *\n\t * Try to give it an estimate that's good enough, maybe at some\n\t * point we can change the ->readdir prototype to include the\n\t * buffer size.  For now we use the current glibc buffer size.\n\t */\n\tbufsize = (size_t)min_t(loff_t, 32768, ip->i_d.di_size);\n\n\treturn xfs_readdir(ip, ctx, bufsize);\n}"
  },
  {
    "function_name": "xfs_file_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "954-960",
    "snippet": "STATIC int\nxfs_file_release(\n\tstruct inode\t*inode,\n\tstruct file\t*filp)\n{\n\treturn xfs_release(XFS_I(inode));\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_release",
          "args": [
            "XFS_I(inode)"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1607-1683",
          "snippet": "int\nxfs_release(\n\txfs_inode_t\t*ip)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror;\n\n\tif (!S_ISREG(ip->i_d.di_mode) || (ip->i_d.di_mode == 0))\n\t\treturn 0;\n\n\t/* If this is a read-only mount, don't do this (would generate I/O) */\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn 0;\n\n\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tint truncated;\n\n\t\t/*\n\t\t * If we previously truncated this file and removed old data\n\t\t * in the process, we want to initiate \"early\" writeout on\n\t\t * the last close.  This is an attempt to combat the notorious\n\t\t * NULL files problem which is particularly noticeable from a\n\t\t * truncate down, buffered (re-)write (delalloc), followed by\n\t\t * a crash.  What we are effectively doing here is\n\t\t * significantly reducing the time window where we'd otherwise\n\t\t * be exposed to that problem.\n\t\t */\n\t\ttruncated = xfs_iflags_test_and_clear(ip, XFS_ITRUNCATED);\n\t\tif (truncated) {\n\t\t\txfs_iflags_clear(ip, XFS_IDIRTY_RELEASE);\n\t\t\tif (ip->i_delayed_blks > 0) {\n\t\t\t\terror = filemap_flush(VFS_I(ip)->i_mapping);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ip->i_d.di_nlink == 0)\n\t\treturn 0;\n\n\tif (xfs_can_free_eofblocks(ip, false)) {\n\n\t\t/*\n\t\t * If we can't get the iolock just skip truncating the blocks\n\t\t * past EOF because we could deadlock with the mmap_sem\n\t\t * otherwise.  We'll get another chance to drop them once the\n\t\t * last reference to the inode is dropped, so we'll never leak\n\t\t * blocks permanently.\n\t\t *\n\t\t * Further, check if the inode is being opened, written and\n\t\t * closed frequently and we have delayed allocation blocks\n\t\t * outstanding (e.g. streaming writes from the NFS server),\n\t\t * truncating the blocks past EOF will cause fragmentation to\n\t\t * occur.\n\t\t *\n\t\t * In this case don't do the truncation, either, but we have to\n\t\t * be careful how we detect this case. Blocks beyond EOF show\n\t\t * up as i_delayed_blks even when the inode is clean, so we\n\t\t * need to truncate them away first before checking for a dirty\n\t\t * release. Hence on the first dirty close we will still remove\n\t\t * the speculative allocation, but after that we will leave it\n\t\t * in place.\n\t\t */\n\t\tif (xfs_iflags_test(ip, XFS_IDIRTY_RELEASE))\n\t\t\treturn 0;\n\n\t\terror = xfs_free_eofblocks(mp, ip, true);\n\t\tif (error && error != -EAGAIN)\n\t\t\treturn error;\n\n\t\t/* delalloc blocks after truncation means it really is dirty */\n\t\tif (ip->i_delayed_blks)\n\t\t\txfs_iflags_set(ip, XFS_IDIRTY_RELEASE);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_release(\n\txfs_inode_t\t*ip)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror;\n\n\tif (!S_ISREG(ip->i_d.di_mode) || (ip->i_d.di_mode == 0))\n\t\treturn 0;\n\n\t/* If this is a read-only mount, don't do this (would generate I/O) */\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn 0;\n\n\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tint truncated;\n\n\t\t/*\n\t\t * If we previously truncated this file and removed old data\n\t\t * in the process, we want to initiate \"early\" writeout on\n\t\t * the last close.  This is an attempt to combat the notorious\n\t\t * NULL files problem which is particularly noticeable from a\n\t\t * truncate down, buffered (re-)write (delalloc), followed by\n\t\t * a crash.  What we are effectively doing here is\n\t\t * significantly reducing the time window where we'd otherwise\n\t\t * be exposed to that problem.\n\t\t */\n\t\ttruncated = xfs_iflags_test_and_clear(ip, XFS_ITRUNCATED);\n\t\tif (truncated) {\n\t\t\txfs_iflags_clear(ip, XFS_IDIRTY_RELEASE);\n\t\t\tif (ip->i_delayed_blks > 0) {\n\t\t\t\terror = filemap_flush(VFS_I(ip)->i_mapping);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ip->i_d.di_nlink == 0)\n\t\treturn 0;\n\n\tif (xfs_can_free_eofblocks(ip, false)) {\n\n\t\t/*\n\t\t * If we can't get the iolock just skip truncating the blocks\n\t\t * past EOF because we could deadlock with the mmap_sem\n\t\t * otherwise.  We'll get another chance to drop them once the\n\t\t * last reference to the inode is dropped, so we'll never leak\n\t\t * blocks permanently.\n\t\t *\n\t\t * Further, check if the inode is being opened, written and\n\t\t * closed frequently and we have delayed allocation blocks\n\t\t * outstanding (e.g. streaming writes from the NFS server),\n\t\t * truncating the blocks past EOF will cause fragmentation to\n\t\t * occur.\n\t\t *\n\t\t * In this case don't do the truncation, either, but we have to\n\t\t * be careful how we detect this case. Blocks beyond EOF show\n\t\t * up as i_delayed_blks even when the inode is clean, so we\n\t\t * need to truncate them away first before checking for a dirty\n\t\t * release. Hence on the first dirty close we will still remove\n\t\t * the speculative allocation, but after that we will leave it\n\t\t * in place.\n\t\t */\n\t\tif (xfs_iflags_test(ip, XFS_IDIRTY_RELEASE))\n\t\t\treturn 0;\n\n\t\terror = xfs_free_eofblocks(mp, ip, true);\n\t\tif (error && error != -EAGAIN)\n\t\t\treturn error;\n\n\t\t/* delalloc blocks after truncation means it really is dirty */\n\t\tif (ip->i_delayed_blks)\n\t\t\txfs_iflags_set(ip, XFS_IDIRTY_RELEASE);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_file_release(\n\tstruct inode\t*inode,\n\tstruct file\t*filp)\n{\n\treturn xfs_release(XFS_I(inode));\n}"
  },
  {
    "function_name": "xfs_dir_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "930-952",
    "snippet": "STATIC int\nxfs_dir_open(\n\tstruct inode\t*inode,\n\tstruct file\t*file)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tint\t\tmode;\n\tint\t\terror;\n\n\terror = xfs_file_open(inode, file);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If there are any blocks, read-ahead block 0 as we're almost\n\t * certain to have the next operation be a read there.\n\t */\n\tmode = xfs_ilock_data_map_shared(ip);\n\tif (ip->i_d.di_nextents > 0)\n\t\txfs_dir3_data_readahead(ip, 0, -1);\n\txfs_iunlock(ip, mode);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "mode"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_readahead",
          "args": [
            "ip",
            "0",
            "-1"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "330-338",
          "snippet": "int\nxfs_dir3_data_readahead(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno)\n{\n\treturn xfs_da_reada_buf(dp, bno, mapped_bno,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_reada_buf_ops);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xfs_buf_ops xfs_dir3_data_reada_buf_ops = {\n\t.verify_read = xfs_dir3_data_reada_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct xfs_buf_ops xfs_dir3_data_reada_buf_ops = {\n\t.verify_read = xfs_dir3_data_reada_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\nxfs_dir3_data_readahead(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno)\n{\n\treturn xfs_da_reada_buf(dp, bno, mapped_bno,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_reada_buf_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_data_map_shared",
          "args": [
            "ip"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_data_map_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "93-104",
          "snippet": "uint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_file_open",
          "args": [
            "inode",
            "file"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "918-928",
          "snippet": "STATIC int\nxfs_file_open(\n\tstruct inode\t*inode,\n\tstruct file\t*file)\n{\n\tif (!(file->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EFBIG;\n\tif (XFS_FORCED_SHUTDOWN(XFS_M(inode->i_sb)))\n\t\treturn -EIO;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_file_open(\n\tstruct inode\t*inode,\n\tstruct file\t*file)\n{\n\tif (!(file->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EFBIG;\n\tif (XFS_FORCED_SHUTDOWN(XFS_M(inode->i_sb)))\n\t\treturn -EIO;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dir_open(\n\tstruct inode\t*inode,\n\tstruct file\t*file)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tint\t\tmode;\n\tint\t\terror;\n\n\terror = xfs_file_open(inode, file);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If there are any blocks, read-ahead block 0 as we're almost\n\t * certain to have the next operation be a read there.\n\t */\n\tmode = xfs_ilock_data_map_shared(ip);\n\tif (ip->i_d.di_nextents > 0)\n\t\txfs_dir3_data_readahead(ip, 0, -1);\n\txfs_iunlock(ip, mode);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "918-928",
    "snippet": "STATIC int\nxfs_file_open(\n\tstruct inode\t*inode,\n\tstruct file\t*file)\n{\n\tif (!(file->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EFBIG;\n\tif (XFS_FORCED_SHUTDOWN(XFS_M(inode->i_sb)))\n\t\treturn -EIO;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "XFS_M(inode->i_sb)"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "inode->i_sb"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_file_open(\n\tstruct inode\t*inode,\n\tstruct file\t*file)\n{\n\tif (!(file->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EFBIG;\n\tif (XFS_FORCED_SHUTDOWN(XFS_M(inode->i_sb)))\n\t\treturn -EIO;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_file_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "825-915",
    "snippet": "STATIC long\nxfs_file_fallocate(\n\tstruct file\t\t*file,\n\tint\t\t\tmode,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tlen)\n{\n\tstruct inode\t\t*inode = file_inode(file);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tlong\t\t\terror;\n\tenum xfs_prealloc_flags\tflags = 0;\n\tuint\t\t\tiolock = XFS_IOLOCK_EXCL;\n\tloff_t\t\t\tnew_size = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\n\t\t     FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\txfs_ilock(ip, iolock);\n\terror = xfs_break_layouts(inode, &iolock);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\terror = xfs_free_file_space(ip, offset, len);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t} else if (mode & FALLOC_FL_COLLAPSE_RANGE) {\n\t\tunsigned blksize_mask = (1 << inode->i_blkbits) - 1;\n\n\t\tif (offset & blksize_mask || len & blksize_mask) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * There is no need to overlap collapse range with EOF,\n\t\t * in which case it is effectively a truncate operation\n\t\t */\n\t\tif (offset + len >= i_size_read(inode)) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tnew_size = i_size_read(inode) - len;\n\n\t\terror = xfs_collapse_file_space(ip, offset, len);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t} else {\n\t\tflags |= XFS_PREALLOC_SET;\n\n\t\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t\t    offset + len > i_size_read(inode)) {\n\t\t\tnew_size = offset + len;\n\t\t\terror = inode_newsize_ok(inode, new_size);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (mode & FALLOC_FL_ZERO_RANGE)\n\t\t\terror = xfs_zero_file_space(ip, offset, len);\n\t\telse\n\t\t\terror = xfs_alloc_file_space(ip, offset, len,\n\t\t\t\t\t\t     XFS_BMAPI_PREALLOC);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (file->f_flags & O_DSYNC)\n\t\tflags |= XFS_PREALLOC_SYNC;\n\n\terror = xfs_update_prealloc_flags(ip, flags);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/* Change file size if needed */\n\tif (new_size) {\n\t\tstruct iattr iattr;\n\n\t\tiattr.ia_valid = ATTR_SIZE;\n\t\tiattr.ia_size = new_size;\n\t\terror = xfs_setattr_size(ip, &iattr);\n\t}\n\nout_unlock:\n\txfs_iunlock(ip, iolock);\n\treturn error;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "iolock"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_setattr_size",
          "args": [
            "ip",
            "&iattr"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setattr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "742-964",
          "snippet": "int\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tuint\t\t\tcommit_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\ttrace_xfs_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data block beyond EOF that we may expose on\n\t * file extension.\n\t */\n\tif (newsize > oldsize) {\n\t\terror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (newsize > ip->i_d.di_size &&\n\t    (oldsize != ip->i_d.di_size || did_zeroing)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t      ip->i_d.di_size, newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Now wait for all direct I/O to complete. */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Do all the page cache truncate work outside the transaction context\n\t * as the \"lock\" order is page lock->log space reservation.  i.e.\n\t * locking pages inside the transaction can ABBA deadlock with\n\t * writeback. We have to do the VFS inode size update before we truncate\n\t * the pagecache, however, to avoid racing with page faults beyond the\n\t * new EOF they are not serialised against truncate operations except by\n\t * page locks and size updates.\n\t *\n\t * Hence we are in a situation where a truncate can fail with ENOMEM\n\t * from xfs_trans_reserve(), but having already truncated the in-memory\n\t * version of the file (i.e. made user visible changes). There's not\n\t * much we can do about this, except to hope that the caller sees ENOMEM\n\t * and retries the truncate operation.\n\t */\n\terror = block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\n\tif (error)\n\t\treturn error;\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * The \"we can't serialise against page faults\" pain gets worse.\n\t *\n\t * If the file is mapped then we have to clean the page at the old EOF\n\t * when extending the file. Extending the file can expose changes the\n\t * underlying page mapping (e.g. from beyond EOF to a hole or\n\t * unwritten), and so on the next attempt to write to that page we need\n\t * to remap it for write. i.e. we need .page_mkwrite() to be called.\n\t * Hence we need to clean the page to clean the pte and so a new write\n\t * fault will be triggered appropriately.\n\t *\n\t * If we do it before we change the inode size, then we can race with a\n\t * page fault that maps the page with exactly the same problem. If we do\n\t * it after we change the file size, then a new page fault can come in\n\t * and allocate space before we've run the rest of the truncate\n\t * transaction. That's kinda grotesque, but it's better than have data\n\t * over a hole, and so that's the lesser evil that has been chosen here.\n\t *\n\t * The real solution, however, is to have some mechanism for locking out\n\t * page faults while a truncate is in progress.\n\t */\n\tif (newsize > oldsize && mapping_mapped(VFS_I(ip)->i_mapping)) {\n\t\terror = filemap_write_and_wait_range(\n\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\tround_down(oldsize, PAGE_CACHE_SIZE),\n\t\t\t\tround_up(oldsize, PAGE_CACHE_SIZE) - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tcommit_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_abort;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_abort:\n\tcommit_flags |= XFS_TRANS_ABORT;\nout_trans_cancel:\n\txfs_trans_cancel(tp, commit_flags);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tuint\t\t\tcommit_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\ttrace_xfs_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data block beyond EOF that we may expose on\n\t * file extension.\n\t */\n\tif (newsize > oldsize) {\n\t\terror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (newsize > ip->i_d.di_size &&\n\t    (oldsize != ip->i_d.di_size || did_zeroing)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t      ip->i_d.di_size, newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Now wait for all direct I/O to complete. */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Do all the page cache truncate work outside the transaction context\n\t * as the \"lock\" order is page lock->log space reservation.  i.e.\n\t * locking pages inside the transaction can ABBA deadlock with\n\t * writeback. We have to do the VFS inode size update before we truncate\n\t * the pagecache, however, to avoid racing with page faults beyond the\n\t * new EOF they are not serialised against truncate operations except by\n\t * page locks and size updates.\n\t *\n\t * Hence we are in a situation where a truncate can fail with ENOMEM\n\t * from xfs_trans_reserve(), but having already truncated the in-memory\n\t * version of the file (i.e. made user visible changes). There's not\n\t * much we can do about this, except to hope that the caller sees ENOMEM\n\t * and retries the truncate operation.\n\t */\n\terror = block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\n\tif (error)\n\t\treturn error;\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * The \"we can't serialise against page faults\" pain gets worse.\n\t *\n\t * If the file is mapped then we have to clean the page at the old EOF\n\t * when extending the file. Extending the file can expose changes the\n\t * underlying page mapping (e.g. from beyond EOF to a hole or\n\t * unwritten), and so on the next attempt to write to that page we need\n\t * to remap it for write. i.e. we need .page_mkwrite() to be called.\n\t * Hence we need to clean the page to clean the pte and so a new write\n\t * fault will be triggered appropriately.\n\t *\n\t * If we do it before we change the inode size, then we can race with a\n\t * page fault that maps the page with exactly the same problem. If we do\n\t * it after we change the file size, then a new page fault can come in\n\t * and allocate space before we've run the rest of the truncate\n\t * transaction. That's kinda grotesque, but it's better than have data\n\t * over a hole, and so that's the lesser evil that has been chosen here.\n\t *\n\t * The real solution, however, is to have some mechanism for locking out\n\t * page faults while a truncate is in progress.\n\t */\n\tif (newsize > oldsize && mapping_mapped(VFS_I(ip)->i_mapping)) {\n\t\terror = filemap_write_and_wait_range(\n\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\tround_down(oldsize, PAGE_CACHE_SIZE),\n\t\t\t\tround_up(oldsize, PAGE_CACHE_SIZE) - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tcommit_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_abort;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_abort:\n\tcommit_flags |= XFS_TRANS_ABORT;\nout_trans_cancel:\n\txfs_trans_cancel(tp, commit_flags);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_update_prealloc_flags",
          "args": [
            "ip",
            "flags"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_update_prealloc_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "131-165",
          "snippet": "int\nxfs_update_prealloc_flags(\n\tstruct xfs_inode\t*ip,\n\tenum xfs_prealloc_flags\tflags)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(ip->i_mount, XFS_TRANS_WRITEID);\n\terror = xfs_trans_reserve(tp, &M_RES(ip->i_mount)->tr_writeid, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tif (!(flags & XFS_PREALLOC_INVISIBLE)) {\n\t\tip->i_d.di_mode &= ~S_ISUID;\n\t\tif (ip->i_d.di_mode & S_IXGRP)\n\t\t\tip->i_d.di_mode &= ~S_ISGID;\n\t\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\t}\n\n\tif (flags & XFS_PREALLOC_SET)\n\t\tip->i_d.di_flags |= XFS_DIFLAG_PREALLOC;\n\tif (flags & XFS_PREALLOC_CLEAR)\n\t\tip->i_d.di_flags &= ~XFS_DIFLAG_PREALLOC;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tif (flags & XFS_PREALLOC_SYNC)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_update_prealloc_flags(\n\tstruct xfs_inode\t*ip,\n\tenum xfs_prealloc_flags\tflags)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(ip->i_mount, XFS_TRANS_WRITEID);\n\terror = xfs_trans_reserve(tp, &M_RES(ip->i_mount)->tr_writeid, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tif (!(flags & XFS_PREALLOC_INVISIBLE)) {\n\t\tip->i_d.di_mode &= ~S_ISUID;\n\t\tif (ip->i_d.di_mode & S_IXGRP)\n\t\t\tip->i_d.di_mode &= ~S_ISGID;\n\t\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\t}\n\n\tif (flags & XFS_PREALLOC_SET)\n\t\tip->i_d.di_flags |= XFS_DIFLAG_PREALLOC;\n\tif (flags & XFS_PREALLOC_CLEAR)\n\t\tip->i_d.di_flags &= ~XFS_DIFLAG_PREALLOC;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tif (flags & XFS_PREALLOC_SYNC)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_file_space",
          "args": [
            "ip",
            "offset",
            "len",
            "XFS_BMAPI_PREALLOC"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "928-1083",
          "snippet": "int\nxfs_alloc_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen,\n\tint\t\t\talloc_type)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_off_t\t\tcount;\n\txfs_filblks_t\t\tallocated_fsb;\n\txfs_filblks_t\t\tallocatesize_fsb;\n\txfs_extlen_t\t\textsz, temp;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_fsblock_t\t\tfirstfsb;\n\tint\t\t\tnimaps;\n\tint\t\t\tquota_flag;\n\tint\t\t\trt;\n\txfs_trans_t\t\t*tp;\n\txfs_bmbt_irec_t\t\timaps[1], *imapp;\n\txfs_bmap_free_t\t\tfree_list;\n\tuint\t\t\tqblocks, resblks, resrtextents;\n\tint\t\t\tcommitted;\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_file_space(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\trt = XFS_IS_REALTIME_INODE(ip);\n\textsz = xfs_get_extsz_hint(ip);\n\n\tcount = len;\n\timapp = &imaps[0];\n\tnimaps = 1;\n\tstartoffset_fsb\t= XFS_B_TO_FSBT(mp, offset);\n\tallocatesize_fsb = XFS_B_TO_FSB(mp, count);\n\n\t/*\n\t * Allocate file space until done or until there is an error\n\t */\n\twhile (allocatesize_fsb && !error) {\n\t\txfs_fileoff_t\ts, e;\n\n\t\t/*\n\t\t * Determine space reservations for data/realtime.\n\t\t */\n\t\tif (unlikely(extsz)) {\n\t\t\ts = startoffset_fsb;\n\t\t\tdo_div(s, extsz);\n\t\t\ts *= extsz;\n\t\t\te = startoffset_fsb + allocatesize_fsb;\n\t\t\tif ((temp = do_mod(startoffset_fsb, extsz)))\n\t\t\t\te += temp;\n\t\t\tif ((temp = do_mod(e, extsz)))\n\t\t\t\te += extsz - temp;\n\t\t} else {\n\t\t\ts = 0;\n\t\t\te = allocatesize_fsb;\n\t\t}\n\n\t\t/*\n\t\t * The transaction reservation is limited to a 32-bit block\n\t\t * count, hence we need to limit the number of blocks we are\n\t\t * trying to reserve to avoid an overflow. We can't allocate\n\t\t * more than @nimaps extents, and an extent is limited on disk\n\t\t * to MAXEXTLEN (21 bits), so use that to enforce the limit.\n\t\t */\n\t\tresblks = min_t(xfs_fileoff_t, (e - s), (MAXEXTLEN * nimaps));\n\t\tif (unlikely(rt)) {\n\t\t\tresrtextents = qblocks = resblks;\n\t\t\tresrtextents /= mp->m_sb.sb_rextsize;\n\t\t\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\t\t\tquota_flag = XFS_QMOPT_RES_RTBLKS;\n\t\t} else {\n\t\t\tresrtextents = 0;\n\t\t\tresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resblks);\n\t\t\tquota_flag = XFS_QMOPT_RES_REGBLKS;\n\t\t}\n\n\t\t/*\n\t\t * Allocate and setup the transaction.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t  resblks, resrtextents);\n\t\t/*\n\t\t * Check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks,\n\t\t\t\t\t\t      0, quota_flag);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bmapi_write(tp, ip, startoffset_fsb,\n\t\t\t\t\tallocatesize_fsb, alloc_type, &firstfsb,\n\t\t\t\t\t0, imapp, &nimaps, &free_list);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * Complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error) {\n\t\t\tbreak;\n\t\t}\n\n\t\tallocated_fsb = imapp->br_blockcount;\n\n\t\tif (nimaps == 0) {\n\t\t\terror = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tstartoffset_fsb += allocated_fsb;\n\t\tallocatesize_fsb -= allocated_fsb;\n\t}\n\n\treturn error;\n\nerror0:\t/* Cancel bmap, unlock inode, unreserve quota blocks, cancel trans */\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\n\nerror1:\t/* Just cancel transaction */\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_alloc_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen,\n\tint\t\t\talloc_type)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_off_t\t\tcount;\n\txfs_filblks_t\t\tallocated_fsb;\n\txfs_filblks_t\t\tallocatesize_fsb;\n\txfs_extlen_t\t\textsz, temp;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_fsblock_t\t\tfirstfsb;\n\tint\t\t\tnimaps;\n\tint\t\t\tquota_flag;\n\tint\t\t\trt;\n\txfs_trans_t\t\t*tp;\n\txfs_bmbt_irec_t\t\timaps[1], *imapp;\n\txfs_bmap_free_t\t\tfree_list;\n\tuint\t\t\tqblocks, resblks, resrtextents;\n\tint\t\t\tcommitted;\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_file_space(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\trt = XFS_IS_REALTIME_INODE(ip);\n\textsz = xfs_get_extsz_hint(ip);\n\n\tcount = len;\n\timapp = &imaps[0];\n\tnimaps = 1;\n\tstartoffset_fsb\t= XFS_B_TO_FSBT(mp, offset);\n\tallocatesize_fsb = XFS_B_TO_FSB(mp, count);\n\n\t/*\n\t * Allocate file space until done or until there is an error\n\t */\n\twhile (allocatesize_fsb && !error) {\n\t\txfs_fileoff_t\ts, e;\n\n\t\t/*\n\t\t * Determine space reservations for data/realtime.\n\t\t */\n\t\tif (unlikely(extsz)) {\n\t\t\ts = startoffset_fsb;\n\t\t\tdo_div(s, extsz);\n\t\t\ts *= extsz;\n\t\t\te = startoffset_fsb + allocatesize_fsb;\n\t\t\tif ((temp = do_mod(startoffset_fsb, extsz)))\n\t\t\t\te += temp;\n\t\t\tif ((temp = do_mod(e, extsz)))\n\t\t\t\te += extsz - temp;\n\t\t} else {\n\t\t\ts = 0;\n\t\t\te = allocatesize_fsb;\n\t\t}\n\n\t\t/*\n\t\t * The transaction reservation is limited to a 32-bit block\n\t\t * count, hence we need to limit the number of blocks we are\n\t\t * trying to reserve to avoid an overflow. We can't allocate\n\t\t * more than @nimaps extents, and an extent is limited on disk\n\t\t * to MAXEXTLEN (21 bits), so use that to enforce the limit.\n\t\t */\n\t\tresblks = min_t(xfs_fileoff_t, (e - s), (MAXEXTLEN * nimaps));\n\t\tif (unlikely(rt)) {\n\t\t\tresrtextents = qblocks = resblks;\n\t\t\tresrtextents /= mp->m_sb.sb_rextsize;\n\t\t\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\t\t\tquota_flag = XFS_QMOPT_RES_RTBLKS;\n\t\t} else {\n\t\t\tresrtextents = 0;\n\t\t\tresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resblks);\n\t\t\tquota_flag = XFS_QMOPT_RES_REGBLKS;\n\t\t}\n\n\t\t/*\n\t\t * Allocate and setup the transaction.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t  resblks, resrtextents);\n\t\t/*\n\t\t * Check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks,\n\t\t\t\t\t\t      0, quota_flag);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bmapi_write(tp, ip, startoffset_fsb,\n\t\t\t\t\tallocatesize_fsb, alloc_type, &firstfsb,\n\t\t\t\t\t0, imapp, &nimaps, &free_list);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * Complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error) {\n\t\t\tbreak;\n\t\t}\n\n\t\tallocated_fsb = imapp->br_blockcount;\n\n\t\tif (nimaps == 0) {\n\t\t\terror = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tstartoffset_fsb += allocated_fsb;\n\t\tallocatesize_fsb -= allocated_fsb;\n\t}\n\n\treturn error;\n\nerror0:\t/* Cancel bmap, unlock inode, unreserve quota blocks, cancel trans */\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\n\nerror1:\t/* Just cancel transaction */\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_zero_file_space",
          "args": [
            "ip",
            "offset",
            "len"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_zero_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "1342-1376",
          "snippet": "int\nxfs_zero_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\tblksize;\n\tint\t\t\terror;\n\n\ttrace_xfs_zero_file_space(ip);\n\n\tblksize = 1 << mp->m_sb.sb_blocklog;\n\n\t/*\n\t * Punch a hole and prealloc the range. We use hole punch rather than\n\t * unwritten extent conversion for two reasons:\n\t *\n\t * 1.) Hole punch handles partial block zeroing for us.\n\t *\n\t * 2.) If prealloc returns ENOSPC, the file range is still zero-valued\n\t * by virtue of the hole punch.\n\t */\n\terror = xfs_free_file_space(ip, offset, len);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_alloc_file_space(ip, round_down(offset, blksize),\n\t\t\t\t     round_up(offset + len, blksize) -\n\t\t\t\t     round_down(offset, blksize),\n\t\t\t\t     XFS_BMAPI_PREALLOC);\nout:\n\treturn error;\n\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_zero_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\tblksize;\n\tint\t\t\terror;\n\n\ttrace_xfs_zero_file_space(ip);\n\n\tblksize = 1 << mp->m_sb.sb_blocklog;\n\n\t/*\n\t * Punch a hole and prealloc the range. We use hole punch rather than\n\t * unwritten extent conversion for two reasons:\n\t *\n\t * 1.) Hole punch handles partial block zeroing for us.\n\t *\n\t * 2.) If prealloc returns ENOSPC, the file range is still zero-valued\n\t * by virtue of the hole punch.\n\t */\n\terror = xfs_free_file_space(ip, offset, len);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_alloc_file_space(ip, round_down(offset, blksize),\n\t\t\t\t     round_up(offset + len, blksize) -\n\t\t\t\t     round_down(offset, blksize),\n\t\t\t\t     XFS_BMAPI_PREALLOC);\nout:\n\treturn error;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "new_size"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "99-124",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_collapse_file_space",
          "args": [
            "ip",
            "offset",
            "len"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_collapse_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "1390-1496",
          "snippet": "int\nxfs_collapse_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tdone = 0;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tstruct xfs_bmap_free\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tint\t\t\tcommitted;\n\txfs_fileoff_t\t\tstart_fsb;\n\txfs_fileoff_t\t\tnext_fsb;\n\txfs_fileoff_t\t\tshift_fsb;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\ttrace_xfs_collapse_file_space(ip);\n\n\tnext_fsb = XFS_B_TO_FSB(mp, offset + len);\n\tshift_fsb = XFS_B_TO_FSB(mp, len);\n\n\terror = xfs_free_file_space(ip, offset, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Trim eofblocks to avoid shifting uninitialized post-eof preallocation\n\t * into the accessible region of the file.\n\t */\n\tif (xfs_can_free_eofblocks(ip, true)) {\n\t\terror = xfs_free_eofblocks(mp, ip, false);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Writeback and invalidate cache for the remainder of the file as we're\n\t * about to shift down every extent from the collapse range to EOF. The\n\t * free of the collapse range above might have already done some of\n\t * this, but we shouldn't rely on it to do anything outside of the range\n\t * that was freed.\n\t */\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t     offset + len, -1);\n\tif (error)\n\t\treturn error;\n\terror = invalidate_inode_pages2_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t(offset + len) >> PAGE_CACHE_SHIFT, -1);\n\tif (error)\n\t\treturn error;\n\n\twhile (!error && !done) {\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\t/*\n\t\t * We would need to reserve permanent block for transaction.\n\t\t * This will come into picture when after shifting extent into\n\t\t * hole we found that adjacent extents can be merged which\n\t\t * may lead to freeing of a block during record update.\n\t\t */\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\tXFS_DIOSTRAT_SPACE_RES(mp, 0), 0);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp, ip->i_udquot,\n\t\t\t\tip->i_gdquot, ip->i_pdquot,\n\t\t\t\tXFS_DIOSTRAT_SPACE_RES(mp, 0), 0,\n\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\txfs_bmap_init(&free_list, &first_block);\n\n\t\t/*\n\t\t * We are using the write transaction in which max 2 bmbt\n\t\t * updates are allowed\n\t\t */\n\t\tstart_fsb = next_fsb;\n\t\terror = xfs_bmap_shift_extents(tp, ip, start_fsb, shift_fsb,\n\t\t\t\t&done, &next_fsb, &first_block, &free_list,\n\t\t\t\tXFS_BMAP_MAX_SHIFT_EXTENTS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n\treturn error;\n\nout:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_collapse_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tdone = 0;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tstruct xfs_bmap_free\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tint\t\t\tcommitted;\n\txfs_fileoff_t\t\tstart_fsb;\n\txfs_fileoff_t\t\tnext_fsb;\n\txfs_fileoff_t\t\tshift_fsb;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\ttrace_xfs_collapse_file_space(ip);\n\n\tnext_fsb = XFS_B_TO_FSB(mp, offset + len);\n\tshift_fsb = XFS_B_TO_FSB(mp, len);\n\n\terror = xfs_free_file_space(ip, offset, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Trim eofblocks to avoid shifting uninitialized post-eof preallocation\n\t * into the accessible region of the file.\n\t */\n\tif (xfs_can_free_eofblocks(ip, true)) {\n\t\terror = xfs_free_eofblocks(mp, ip, false);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Writeback and invalidate cache for the remainder of the file as we're\n\t * about to shift down every extent from the collapse range to EOF. The\n\t * free of the collapse range above might have already done some of\n\t * this, but we shouldn't rely on it to do anything outside of the range\n\t * that was freed.\n\t */\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t     offset + len, -1);\n\tif (error)\n\t\treturn error;\n\terror = invalidate_inode_pages2_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t(offset + len) >> PAGE_CACHE_SHIFT, -1);\n\tif (error)\n\t\treturn error;\n\n\twhile (!error && !done) {\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\t/*\n\t\t * We would need to reserve permanent block for transaction.\n\t\t * This will come into picture when after shifting extent into\n\t\t * hole we found that adjacent extents can be merged which\n\t\t * may lead to freeing of a block during record update.\n\t\t */\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\tXFS_DIOSTRAT_SPACE_RES(mp, 0), 0);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp, ip->i_udquot,\n\t\t\t\tip->i_gdquot, ip->i_pdquot,\n\t\t\t\tXFS_DIOSTRAT_SPACE_RES(mp, 0), 0,\n\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\txfs_bmap_init(&free_list, &first_block);\n\n\t\t/*\n\t\t * We are using the write transaction in which max 2 bmbt\n\t\t * updates are allowed\n\t\t */\n\t\tstart_fsb = next_fsb;\n\t\terror = xfs_bmap_shift_extents(tp, ip, start_fsb, shift_fsb,\n\t\t\t\t&done, &next_fsb, &first_block, &free_list,\n\t\t\t\tXFS_BMAP_MAX_SHIFT_EXTENTS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n\treturn error;\n\nout:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_free_file_space",
          "args": [
            "ip",
            "offset",
            "len"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "1165-1336",
          "snippet": "int\nxfs_free_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tcommitted;\n\tint\t\t\tdone;\n\txfs_fileoff_t\t\tendoffset_fsb;\n\tint\t\t\terror;\n\txfs_fsblock_t\t\tfirstfsb;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_bmbt_irec_t\t\timap;\n\txfs_off_t\t\tioffset;\n\txfs_off_t\t\tiendoffset;\n\txfs_extlen_t\t\tmod=0;\n\txfs_mount_t\t\t*mp;\n\tint\t\t\tnimap;\n\tuint\t\t\tresblks;\n\txfs_off_t\t\trounding;\n\tint\t\t\trt;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_trans_t\t\t*tp;\n\n\tmp = ip->i_mount;\n\n\ttrace_xfs_free_file_space(ip);\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = 0;\n\tif (len <= 0)\t/* if nothing being freed */\n\t\treturn error;\n\trt = XFS_IS_REALTIME_INODE(ip);\n\tstartoffset_fsb\t= XFS_B_TO_FSB(mp, offset);\n\tendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\n\n\t/* wait for the completion of any pending DIOs */\n\tinode_dio_wait(VFS_I(ip));\n\n\trounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);\n\tioffset = round_down(offset, rounding);\n\tiendoffset = round_up(offset + len, rounding) - 1;\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,\n\t\t\t\t\t     iendoffset);\n\tif (error)\n\t\tgoto out;\n\ttruncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);\n\n\t/*\n\t * Need to zero the stuff we're not freeing, on disk.\n\t * If it's a realtime file & can't use unwritten extents then we\n\t * actually need to zero the extent edges.  Otherwise xfs_bunmapi\n\t * will take care of it for us.\n\t */\n\tif (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, startoffset_fsb, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\txfs_daddr_t\tblock;\n\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tblock = imap.br_startblock;\n\t\t\tmod = do_div(block, mp->m_sb.sb_rextsize);\n\t\t\tif (mod)\n\t\t\t\tstartoffset_fsb += mp->m_sb.sb_rextsize - mod;\n\t\t}\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tmod++;\n\t\t\tif (mod && (mod != mp->m_sb.sb_rextsize))\n\t\t\t\tendoffset_fsb -= mod;\n\t\t}\n\t}\n\tif ((done = (endoffset_fsb <= startoffset_fsb)))\n\t\t/*\n\t\t * One contiguous piece to clear\n\t\t */\n\t\terror = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);\n\telse {\n\t\t/*\n\t\t * Some full blocks, possibly two pieces to clear\n\t\t */\n\t\tif (offset < XFS_FSB_TO_B(mp, startoffset_fsb))\n\t\t\terror = xfs_zero_remaining_bytes(ip, offset,\n\t\t\t\tXFS_FSB_TO_B(mp, startoffset_fsb) - 1);\n\t\tif (!error &&\n\t\t    XFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)\n\t\t\terror = xfs_zero_remaining_bytes(ip,\n\t\t\t\tXFS_FSB_TO_B(mp, endoffset_fsb),\n\t\t\t\toffset + len - 1);\n\t}\n\n\t/*\n\t * free file space until done or until there is an error\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\twhile (!error && !done) {\n\n\t\t/*\n\t\t * allocate and setup the transaction. Allow this\n\t\t * transaction to dip into the reserve blocks to ensure\n\t\t * the freeing of the space succeeds at ENOSPC.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write, resblks, 0);\n\n\t\t/*\n\t\t * check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp,\n\t\t\t\tip->i_udquot, ip->i_gdquot, ip->i_pdquot,\n\t\t\t\tresblks, 0, XFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * issue the bunmapi() call to free the blocks\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bunmapi(tp, ip, startoffset_fsb,\n\t\t\t\t  endoffset_fsb - startoffset_fsb,\n\t\t\t\t  0, 2, &firstfsb, &free_list, &done);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n out:\n\treturn error;\n\n error0:\n\txfs_bmap_cancel(&free_list);\n error1:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tgoto out;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_free_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tcommitted;\n\tint\t\t\tdone;\n\txfs_fileoff_t\t\tendoffset_fsb;\n\tint\t\t\terror;\n\txfs_fsblock_t\t\tfirstfsb;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_bmbt_irec_t\t\timap;\n\txfs_off_t\t\tioffset;\n\txfs_off_t\t\tiendoffset;\n\txfs_extlen_t\t\tmod=0;\n\txfs_mount_t\t\t*mp;\n\tint\t\t\tnimap;\n\tuint\t\t\tresblks;\n\txfs_off_t\t\trounding;\n\tint\t\t\trt;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_trans_t\t\t*tp;\n\n\tmp = ip->i_mount;\n\n\ttrace_xfs_free_file_space(ip);\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = 0;\n\tif (len <= 0)\t/* if nothing being freed */\n\t\treturn error;\n\trt = XFS_IS_REALTIME_INODE(ip);\n\tstartoffset_fsb\t= XFS_B_TO_FSB(mp, offset);\n\tendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\n\n\t/* wait for the completion of any pending DIOs */\n\tinode_dio_wait(VFS_I(ip));\n\n\trounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);\n\tioffset = round_down(offset, rounding);\n\tiendoffset = round_up(offset + len, rounding) - 1;\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,\n\t\t\t\t\t     iendoffset);\n\tif (error)\n\t\tgoto out;\n\ttruncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);\n\n\t/*\n\t * Need to zero the stuff we're not freeing, on disk.\n\t * If it's a realtime file & can't use unwritten extents then we\n\t * actually need to zero the extent edges.  Otherwise xfs_bunmapi\n\t * will take care of it for us.\n\t */\n\tif (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, startoffset_fsb, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\txfs_daddr_t\tblock;\n\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tblock = imap.br_startblock;\n\t\t\tmod = do_div(block, mp->m_sb.sb_rextsize);\n\t\t\tif (mod)\n\t\t\t\tstartoffset_fsb += mp->m_sb.sb_rextsize - mod;\n\t\t}\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tmod++;\n\t\t\tif (mod && (mod != mp->m_sb.sb_rextsize))\n\t\t\t\tendoffset_fsb -= mod;\n\t\t}\n\t}\n\tif ((done = (endoffset_fsb <= startoffset_fsb)))\n\t\t/*\n\t\t * One contiguous piece to clear\n\t\t */\n\t\terror = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);\n\telse {\n\t\t/*\n\t\t * Some full blocks, possibly two pieces to clear\n\t\t */\n\t\tif (offset < XFS_FSB_TO_B(mp, startoffset_fsb))\n\t\t\terror = xfs_zero_remaining_bytes(ip, offset,\n\t\t\t\tXFS_FSB_TO_B(mp, startoffset_fsb) - 1);\n\t\tif (!error &&\n\t\t    XFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)\n\t\t\terror = xfs_zero_remaining_bytes(ip,\n\t\t\t\tXFS_FSB_TO_B(mp, endoffset_fsb),\n\t\t\t\toffset + len - 1);\n\t}\n\n\t/*\n\t * free file space until done or until there is an error\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\twhile (!error && !done) {\n\n\t\t/*\n\t\t * allocate and setup the transaction. Allow this\n\t\t * transaction to dip into the reserve blocks to ensure\n\t\t * the freeing of the space succeeds at ENOSPC.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write, resblks, 0);\n\n\t\t/*\n\t\t * check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp,\n\t\t\t\tip->i_udquot, ip->i_gdquot, ip->i_pdquot,\n\t\t\t\tresblks, 0, XFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * issue the bunmapi() call to free the blocks\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bunmapi(tp, ip, startoffset_fsb,\n\t\t\t\t  endoffset_fsb - startoffset_fsb,\n\t\t\t\t  0, 2, &firstfsb, &free_list, &done);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n out:\n\treturn error;\n\n error0:\n\txfs_bmap_cancel(&free_list);\n error1:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_break_layouts",
          "args": [
            "inode",
            "&iolock"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_break_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_pnfs.h",
          "lines": "13-16",
          "snippet": "static inline int xfs_break_layouts(struct inode *inode, uint *iolock)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_break_layouts(struct inode *inode, uint *iolock)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "iolock"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC long\nxfs_file_fallocate(\n\tstruct file\t\t*file,\n\tint\t\t\tmode,\n\tloff_t\t\t\toffset,\n\tloff_t\t\t\tlen)\n{\n\tstruct inode\t\t*inode = file_inode(file);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tlong\t\t\terror;\n\tenum xfs_prealloc_flags\tflags = 0;\n\tuint\t\t\tiolock = XFS_IOLOCK_EXCL;\n\tloff_t\t\t\tnew_size = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\n\t\t     FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\txfs_ilock(ip, iolock);\n\terror = xfs_break_layouts(inode, &iolock);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\terror = xfs_free_file_space(ip, offset, len);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t} else if (mode & FALLOC_FL_COLLAPSE_RANGE) {\n\t\tunsigned blksize_mask = (1 << inode->i_blkbits) - 1;\n\n\t\tif (offset & blksize_mask || len & blksize_mask) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * There is no need to overlap collapse range with EOF,\n\t\t * in which case it is effectively a truncate operation\n\t\t */\n\t\tif (offset + len >= i_size_read(inode)) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tnew_size = i_size_read(inode) - len;\n\n\t\terror = xfs_collapse_file_space(ip, offset, len);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t} else {\n\t\tflags |= XFS_PREALLOC_SET;\n\n\t\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t\t    offset + len > i_size_read(inode)) {\n\t\t\tnew_size = offset + len;\n\t\t\terror = inode_newsize_ok(inode, new_size);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (mode & FALLOC_FL_ZERO_RANGE)\n\t\t\terror = xfs_zero_file_space(ip, offset, len);\n\t\telse\n\t\t\terror = xfs_alloc_file_space(ip, offset, len,\n\t\t\t\t\t\t     XFS_BMAPI_PREALLOC);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (file->f_flags & O_DSYNC)\n\t\tflags |= XFS_PREALLOC_SYNC;\n\n\terror = xfs_update_prealloc_flags(ip, flags);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/* Change file size if needed */\n\tif (new_size) {\n\t\tstruct iattr iattr;\n\n\t\tiattr.ia_valid = ATTR_SIZE;\n\t\tiattr.ia_size = new_size;\n\t\terror = xfs_setattr_size(ip, &iattr);\n\t}\n\nout_unlock:\n\txfs_iunlock(ip, iolock);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_file_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "787-823",
    "snippet": "STATIC ssize_t\nxfs_file_write_iter(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct address_space\t*mapping = file->f_mapping;\n\tstruct inode\t\t*inode = mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tssize_t\t\t\tret;\n\tsize_t\t\t\tocount = iov_iter_count(from);\n\n\tXFS_STATS_INC(xs_write_calls);\n\n\tif (ocount == 0)\n\t\treturn 0;\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (unlikely(file->f_flags & O_DIRECT))\n\t\tret = xfs_file_dio_aio_write(iocb, from);\n\telse\n\t\tret = xfs_file_buffered_aio_write(iocb, from);\n\n\tif (ret > 0) {\n\t\tssize_t err;\n\n\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n\n\t\t/* Handle various SYNC-type writes */\n\t\terr = generic_write_sync(file, iocb->ki_pos - ret, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_write_sync",
          "args": [
            "file",
            "iocb->ki_pos - ret",
            "ret"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_ADD",
          "args": [
            "xs_write_bytes",
            "ret"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_file_buffered_aio_write",
          "args": [
            "iocb",
            "from"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_file_buffered_aio_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "726-785",
          "snippet": "STATIC ssize_t\nxfs_file_buffered_aio_write(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct address_space\t*mapping = file->f_mapping;\n\tstruct inode\t\t*inode = mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tssize_t\t\t\tret;\n\tint\t\t\tenospc = 0;\n\tint\t\t\tiolock = XFS_IOLOCK_EXCL;\n\tloff_t\t\t\tpos = iocb->ki_pos;\n\tsize_t\t\t\tcount = iov_iter_count(from);\n\n\txfs_rw_ilock(ip, iolock);\n\n\tret = xfs_file_aio_write_checks(file, &pos, &count, &iolock);\n\tif (ret)\n\t\tgoto out;\n\n\tiov_iter_truncate(from, count);\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\nwrite_retry:\n\ttrace_xfs_file_buffered_write(ip, count, iocb->ki_pos, 0);\n\tret = generic_perform_write(file, from, pos);\n\tif (likely(ret >= 0))\n\t\tiocb->ki_pos = pos + ret;\n\n\t/*\n\t * If we hit a space limit, try to free up some lingering preallocated\n\t * space before returning an error. In the case of ENOSPC, first try to\n\t * write back all dirty inodes to free up some of the excess reserved\n\t * metadata space. This reduces the chances that the eofblocks scan\n\t * waits on dirty mappings. Since xfs_flush_inodes() is serialized, this\n\t * also behaves as a filter to prevent too many eofblocks scans from\n\t * running at the same time.\n\t */\n\tif (ret == -EDQUOT && !enospc) {\n\t\tenospc = xfs_inode_free_quota_eofblocks(ip);\n\t\tif (enospc)\n\t\t\tgoto write_retry;\n\t} else if (ret == -ENOSPC && !enospc) {\n\t\tstruct xfs_eofblocks eofb = {0};\n\n\t\tenospc = 1;\n\t\txfs_flush_inodes(ip->i_mount);\n\t\teofb.eof_scan_owner = ip->i_ino; /* for locking */\n\t\teofb.eof_flags = XFS_EOF_FLAGS_SYNC;\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\t\tgoto write_retry;\n\t}\n\n\tcurrent->backing_dev_info = NULL;\nout:\n\txfs_rw_iunlock(ip, iolock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC ssize_t\nxfs_file_buffered_aio_write(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct address_space\t*mapping = file->f_mapping;\n\tstruct inode\t\t*inode = mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tssize_t\t\t\tret;\n\tint\t\t\tenospc = 0;\n\tint\t\t\tiolock = XFS_IOLOCK_EXCL;\n\tloff_t\t\t\tpos = iocb->ki_pos;\n\tsize_t\t\t\tcount = iov_iter_count(from);\n\n\txfs_rw_ilock(ip, iolock);\n\n\tret = xfs_file_aio_write_checks(file, &pos, &count, &iolock);\n\tif (ret)\n\t\tgoto out;\n\n\tiov_iter_truncate(from, count);\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\nwrite_retry:\n\ttrace_xfs_file_buffered_write(ip, count, iocb->ki_pos, 0);\n\tret = generic_perform_write(file, from, pos);\n\tif (likely(ret >= 0))\n\t\tiocb->ki_pos = pos + ret;\n\n\t/*\n\t * If we hit a space limit, try to free up some lingering preallocated\n\t * space before returning an error. In the case of ENOSPC, first try to\n\t * write back all dirty inodes to free up some of the excess reserved\n\t * metadata space. This reduces the chances that the eofblocks scan\n\t * waits on dirty mappings. Since xfs_flush_inodes() is serialized, this\n\t * also behaves as a filter to prevent too many eofblocks scans from\n\t * running at the same time.\n\t */\n\tif (ret == -EDQUOT && !enospc) {\n\t\tenospc = xfs_inode_free_quota_eofblocks(ip);\n\t\tif (enospc)\n\t\t\tgoto write_retry;\n\t} else if (ret == -ENOSPC && !enospc) {\n\t\tstruct xfs_eofblocks eofb = {0};\n\n\t\tenospc = 1;\n\t\txfs_flush_inodes(ip->i_mount);\n\t\teofb.eof_scan_owner = ip->i_ino; /* for locking */\n\t\teofb.eof_flags = XFS_EOF_FLAGS_SYNC;\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\t\tgoto write_retry;\n\t}\n\n\tcurrent->backing_dev_info = NULL;\nout:\n\txfs_rw_iunlock(ip, iolock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_file_dio_aio_write",
          "args": [
            "iocb",
            "from"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_file_dio_aio_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "632-724",
          "snippet": "STATIC ssize_t\nxfs_file_dio_aio_write(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct address_space\t*mapping = file->f_mapping;\n\tstruct inode\t\t*inode = mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tssize_t\t\t\tret = 0;\n\tint\t\t\tunaligned_io = 0;\n\tint\t\t\tiolock;\n\tsize_t\t\t\tcount = iov_iter_count(from);\n\tloff_t\t\t\tpos = iocb->ki_pos;\n\tstruct xfs_buftarg\t*target = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp;\n\n\t/* DIO must be aligned to device logical sector size */\n\tif ((pos | count) & target->bt_logical_sectormask)\n\t\treturn -EINVAL;\n\n\t/* \"unaligned\" here means not aligned to a filesystem block */\n\tif ((pos & mp->m_blockmask) || ((pos + count) & mp->m_blockmask))\n\t\tunaligned_io = 1;\n\n\t/*\n\t * We don't need to take an exclusive lock unless there page cache needs\n\t * to be invalidated or unaligned IO is being executed. We don't need to\n\t * consider the EOF extension case here because\n\t * xfs_file_aio_write_checks() will relock the inode as necessary for\n\t * EOF zeroing cases and fill out the new inode size as appropriate.\n\t */\n\tif (unaligned_io || mapping->nrpages)\n\t\tiolock = XFS_IOLOCK_EXCL;\n\telse\n\t\tiolock = XFS_IOLOCK_SHARED;\n\txfs_rw_ilock(ip, iolock);\n\n\t/*\n\t * Recheck if there are cached pages that need invalidate after we got\n\t * the iolock to protect against other threads adding new pages while\n\t * we were waiting for the iolock.\n\t */\n\tif (mapping->nrpages && iolock == XFS_IOLOCK_SHARED) {\n\t\txfs_rw_iunlock(ip, iolock);\n\t\tiolock = XFS_IOLOCK_EXCL;\n\t\txfs_rw_ilock(ip, iolock);\n\t}\n\n\tret = xfs_file_aio_write_checks(file, &pos, &count, &iolock);\n\tif (ret)\n\t\tgoto out;\n\tiov_iter_truncate(from, count);\n\n\tif (mapping->nrpages) {\n\t\tret = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t    pos, pos + count - 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Invalidate whole pages. This can return an error if\n\t\t * we fail to invalidate a page, but this should never\n\t\t * happen on XFS. Warn if it does fail.\n\t\t */\n\t\tret = invalidate_inode_pages2_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\tpos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t(pos + count - 1) >> PAGE_CACHE_SHIFT);\n\t\tWARN_ON_ONCE(ret);\n\t\tret = 0;\n\t}\n\n\t/*\n\t * If we are doing unaligned IO, wait for all other IO to drain,\n\t * otherwise demote the lock if we had to flush cached pages\n\t */\n\tif (unaligned_io)\n\t\tinode_dio_wait(inode);\n\telse if (iolock == XFS_IOLOCK_EXCL) {\n\t\txfs_rw_ilock_demote(ip, XFS_IOLOCK_EXCL);\n\t\tiolock = XFS_IOLOCK_SHARED;\n\t}\n\n\ttrace_xfs_file_direct_write(ip, count, iocb->ki_pos, 0);\n\tret = generic_file_direct_write(iocb, from, pos);\n\nout:\n\txfs_rw_iunlock(ip, iolock);\n\n\t/* No fallback to buffered IO on errors for XFS. */\n\tASSERT(ret < 0 || ret == count);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC ssize_t\nxfs_file_dio_aio_write(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct address_space\t*mapping = file->f_mapping;\n\tstruct inode\t\t*inode = mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tssize_t\t\t\tret = 0;\n\tint\t\t\tunaligned_io = 0;\n\tint\t\t\tiolock;\n\tsize_t\t\t\tcount = iov_iter_count(from);\n\tloff_t\t\t\tpos = iocb->ki_pos;\n\tstruct xfs_buftarg\t*target = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp;\n\n\t/* DIO must be aligned to device logical sector size */\n\tif ((pos | count) & target->bt_logical_sectormask)\n\t\treturn -EINVAL;\n\n\t/* \"unaligned\" here means not aligned to a filesystem block */\n\tif ((pos & mp->m_blockmask) || ((pos + count) & mp->m_blockmask))\n\t\tunaligned_io = 1;\n\n\t/*\n\t * We don't need to take an exclusive lock unless there page cache needs\n\t * to be invalidated or unaligned IO is being executed. We don't need to\n\t * consider the EOF extension case here because\n\t * xfs_file_aio_write_checks() will relock the inode as necessary for\n\t * EOF zeroing cases and fill out the new inode size as appropriate.\n\t */\n\tif (unaligned_io || mapping->nrpages)\n\t\tiolock = XFS_IOLOCK_EXCL;\n\telse\n\t\tiolock = XFS_IOLOCK_SHARED;\n\txfs_rw_ilock(ip, iolock);\n\n\t/*\n\t * Recheck if there are cached pages that need invalidate after we got\n\t * the iolock to protect against other threads adding new pages while\n\t * we were waiting for the iolock.\n\t */\n\tif (mapping->nrpages && iolock == XFS_IOLOCK_SHARED) {\n\t\txfs_rw_iunlock(ip, iolock);\n\t\tiolock = XFS_IOLOCK_EXCL;\n\t\txfs_rw_ilock(ip, iolock);\n\t}\n\n\tret = xfs_file_aio_write_checks(file, &pos, &count, &iolock);\n\tif (ret)\n\t\tgoto out;\n\tiov_iter_truncate(from, count);\n\n\tif (mapping->nrpages) {\n\t\tret = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t    pos, pos + count - 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Invalidate whole pages. This can return an error if\n\t\t * we fail to invalidate a page, but this should never\n\t\t * happen on XFS. Warn if it does fail.\n\t\t */\n\t\tret = invalidate_inode_pages2_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\tpos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t(pos + count - 1) >> PAGE_CACHE_SHIFT);\n\t\tWARN_ON_ONCE(ret);\n\t\tret = 0;\n\t}\n\n\t/*\n\t * If we are doing unaligned IO, wait for all other IO to drain,\n\t * otherwise demote the lock if we had to flush cached pages\n\t */\n\tif (unaligned_io)\n\t\tinode_dio_wait(inode);\n\telse if (iolock == XFS_IOLOCK_EXCL) {\n\t\txfs_rw_ilock_demote(ip, XFS_IOLOCK_EXCL);\n\t\tiolock = XFS_IOLOCK_SHARED;\n\t}\n\n\ttrace_xfs_file_direct_write(ip, count, iocb->ki_pos, 0);\n\tret = generic_file_direct_write(iocb, from, pos);\n\nout:\n\txfs_rw_iunlock(ip, iolock);\n\n\t/* No fallback to buffered IO on errors for XFS. */\n\tASSERT(ret < 0 || ret == count);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "file->f_flags & O_DIRECT"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_write_calls"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC ssize_t\nxfs_file_write_iter(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct address_space\t*mapping = file->f_mapping;\n\tstruct inode\t\t*inode = mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tssize_t\t\t\tret;\n\tsize_t\t\t\tocount = iov_iter_count(from);\n\n\tXFS_STATS_INC(xs_write_calls);\n\n\tif (ocount == 0)\n\t\treturn 0;\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\tif (unlikely(file->f_flags & O_DIRECT))\n\t\tret = xfs_file_dio_aio_write(iocb, from);\n\telse\n\t\tret = xfs_file_buffered_aio_write(iocb, from);\n\n\tif (ret > 0) {\n\t\tssize_t err;\n\n\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n\n\t\t/* Handle various SYNC-type writes */\n\t\terr = generic_write_sync(file, iocb->ki_pos - ret, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "xfs_file_buffered_aio_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "726-785",
    "snippet": "STATIC ssize_t\nxfs_file_buffered_aio_write(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct address_space\t*mapping = file->f_mapping;\n\tstruct inode\t\t*inode = mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tssize_t\t\t\tret;\n\tint\t\t\tenospc = 0;\n\tint\t\t\tiolock = XFS_IOLOCK_EXCL;\n\tloff_t\t\t\tpos = iocb->ki_pos;\n\tsize_t\t\t\tcount = iov_iter_count(from);\n\n\txfs_rw_ilock(ip, iolock);\n\n\tret = xfs_file_aio_write_checks(file, &pos, &count, &iolock);\n\tif (ret)\n\t\tgoto out;\n\n\tiov_iter_truncate(from, count);\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\nwrite_retry:\n\ttrace_xfs_file_buffered_write(ip, count, iocb->ki_pos, 0);\n\tret = generic_perform_write(file, from, pos);\n\tif (likely(ret >= 0))\n\t\tiocb->ki_pos = pos + ret;\n\n\t/*\n\t * If we hit a space limit, try to free up some lingering preallocated\n\t * space before returning an error. In the case of ENOSPC, first try to\n\t * write back all dirty inodes to free up some of the excess reserved\n\t * metadata space. This reduces the chances that the eofblocks scan\n\t * waits on dirty mappings. Since xfs_flush_inodes() is serialized, this\n\t * also behaves as a filter to prevent too many eofblocks scans from\n\t * running at the same time.\n\t */\n\tif (ret == -EDQUOT && !enospc) {\n\t\tenospc = xfs_inode_free_quota_eofblocks(ip);\n\t\tif (enospc)\n\t\t\tgoto write_retry;\n\t} else if (ret == -ENOSPC && !enospc) {\n\t\tstruct xfs_eofblocks eofb = {0};\n\n\t\tenospc = 1;\n\t\txfs_flush_inodes(ip->i_mount);\n\t\teofb.eof_scan_owner = ip->i_ino; /* for locking */\n\t\teofb.eof_flags = XFS_EOF_FLAGS_SYNC;\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\t\tgoto write_retry;\n\t}\n\n\tcurrent->backing_dev_info = NULL;\nout:\n\txfs_rw_iunlock(ip, iolock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_rw_iunlock",
          "args": [
            "ip",
            "iolock"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rw_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "62-70",
          "snippet": "static inline void\nxfs_rw_iunlock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_iunlock(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_iunlock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_iunlock(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icache_free_eofblocks",
          "args": [
            "ip->i_mount",
            "&eofb"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icache_free_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1291-1303",
          "snippet": "int\nxfs_icache_free_eofblocks(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tint flags = SYNC_TRYLOCK;\n\n\tif (eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC))\n\t\tflags = SYNC_WAIT;\n\n\treturn xfs_inode_ag_iterator_tag(mp, xfs_inode_free_eofblocks, flags,\n\t\t\t\t\t eofb, XFS_ICI_EOFBLOCKS_TAG);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icache_free_eofblocks(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_eofblocks\t*eofb)\n{\n\tint flags = SYNC_TRYLOCK;\n\n\tif (eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC))\n\t\tflags = SYNC_WAIT;\n\n\treturn xfs_inode_ag_iterator_tag(mp, xfs_inode_free_eofblocks, flags,\n\t\t\t\t\t eofb, XFS_ICI_EOFBLOCKS_TAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_flush_inodes",
          "args": [
            "ip->i_mount"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_flush_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "913-923",
          "snippet": "void\nxfs_flush_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct super_block\t*sb = mp->m_super;\n\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tsync_inodes_sb(sb);\n\t\tup_read(&sb->s_umount);\n\t}\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_flush_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct super_block\t*sb = mp->m_super;\n\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tsync_inodes_sb(sb);\n\t\tup_read(&sb->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_free_quota_eofblocks",
          "args": [
            "ip"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_free_quota_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1311-1352",
          "snippet": "int\nxfs_inode_free_quota_eofblocks(\n\tstruct xfs_inode *ip)\n{\n\tint scan = 0;\n\tstruct xfs_eofblocks eofb = {0};\n\tstruct xfs_dquot *dq;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\t/*\n\t * Set the scan owner to avoid a potential livelock. Otherwise, the scan\n\t * can repeatedly trylock on the inode we're currently processing. We\n\t * run a sync scan to increase effectiveness and use the union filter to\n\t * cover all applicable quotas in a single scan.\n\t */\n\teofb.eof_scan_owner = ip->i_ino;\n\teofb.eof_flags = XFS_EOF_FLAGS_UNION|XFS_EOF_FLAGS_SYNC;\n\n\tif (XFS_IS_UQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_USER);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_uid = VFS_I(ip)->i_uid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_UID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (XFS_IS_GQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_GROUP);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_gid = VFS_I(ip)->i_gid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_GID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (scan)\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\n\treturn scan;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_inode_free_quota_eofblocks(\n\tstruct xfs_inode *ip)\n{\n\tint scan = 0;\n\tstruct xfs_eofblocks eofb = {0};\n\tstruct xfs_dquot *dq;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\t/*\n\t * Set the scan owner to avoid a potential livelock. Otherwise, the scan\n\t * can repeatedly trylock on the inode we're currently processing. We\n\t * run a sync scan to increase effectiveness and use the union filter to\n\t * cover all applicable quotas in a single scan.\n\t */\n\teofb.eof_scan_owner = ip->i_ino;\n\teofb.eof_flags = XFS_EOF_FLAGS_UNION|XFS_EOF_FLAGS_SYNC;\n\n\tif (XFS_IS_UQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_USER);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_uid = VFS_I(ip)->i_uid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_UID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (XFS_IS_GQUOTA_ENFORCED(ip->i_mount)) {\n\t\tdq = xfs_inode_dquot(ip, XFS_DQ_GROUP);\n\t\tif (dq && xfs_dquot_lowsp(dq)) {\n\t\t\teofb.eof_gid = VFS_I(ip)->i_gid;\n\t\t\teofb.eof_flags |= XFS_EOF_FLAGS_GID;\n\t\t\tscan = 1;\n\t\t}\n\t}\n\n\tif (scan)\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\n\treturn scan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ret >= 0"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_perform_write",
          "args": [
            "file",
            "from",
            "pos"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_file_buffered_write",
          "args": [
            "ip",
            "count",
            "iocb->ki_pos",
            "0"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "from",
            "count"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_file_aio_write_checks",
          "args": [
            "file",
            "&pos",
            "&count",
            "&iolock"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_file_aio_write_checks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "546-605",
          "snippet": "STATIC ssize_t\nxfs_file_aio_write_checks(\n\tstruct file\t\t*file,\n\tloff_t\t\t\t*pos,\n\tsize_t\t\t\t*count,\n\tint\t\t\t*iolock)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror = 0;\n\nrestart:\n\terror = generic_write_checks(file, pos, count, S_ISBLK(inode->i_mode));\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_break_layouts(inode, iolock);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the offset is beyond the size of the file, we need to zero any\n\t * blocks that fall between the existing EOF and the start of this\n\t * write.  If zeroing is needed and we are currently holding the\n\t * iolock shared, we need to update it to exclusive which implies\n\t * having to redo all checks before.\n\t */\n\tif (*pos > i_size_read(inode)) {\n\t\tbool\tzero = false;\n\n\t\tif (*iolock == XFS_IOLOCK_SHARED) {\n\t\t\txfs_rw_iunlock(ip, *iolock);\n\t\t\t*iolock = XFS_IOLOCK_EXCL;\n\t\t\txfs_rw_ilock(ip, *iolock);\n\t\t\tgoto restart;\n\t\t}\n\t\terror = xfs_zero_eof(ip, *pos, i_size_read(inode), &zero);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Updating the timestamps will grab the ilock again from\n\t * xfs_fs_dirty_inode, so we have to call it after dropping the\n\t * lock above.  Eventually we should look into a way to avoid\n\t * the pointless lock roundtrip.\n\t */\n\tif (likely(!(file->f_mode & FMODE_NOCMTIME))) {\n\t\terror = file_update_time(file);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If we're writing the file then make sure to clear the setuid and\n\t * setgid bits if the process is not being run by root.  This keeps\n\t * people from modifying setuid and setgid binaries.\n\t */\n\treturn file_remove_suid(file);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC ssize_t\nxfs_file_aio_write_checks(\n\tstruct file\t\t*file,\n\tloff_t\t\t\t*pos,\n\tsize_t\t\t\t*count,\n\tint\t\t\t*iolock)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror = 0;\n\nrestart:\n\terror = generic_write_checks(file, pos, count, S_ISBLK(inode->i_mode));\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_break_layouts(inode, iolock);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the offset is beyond the size of the file, we need to zero any\n\t * blocks that fall between the existing EOF and the start of this\n\t * write.  If zeroing is needed and we are currently holding the\n\t * iolock shared, we need to update it to exclusive which implies\n\t * having to redo all checks before.\n\t */\n\tif (*pos > i_size_read(inode)) {\n\t\tbool\tzero = false;\n\n\t\tif (*iolock == XFS_IOLOCK_SHARED) {\n\t\t\txfs_rw_iunlock(ip, *iolock);\n\t\t\t*iolock = XFS_IOLOCK_EXCL;\n\t\t\txfs_rw_ilock(ip, *iolock);\n\t\t\tgoto restart;\n\t\t}\n\t\terror = xfs_zero_eof(ip, *pos, i_size_read(inode), &zero);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Updating the timestamps will grab the ilock again from\n\t * xfs_fs_dirty_inode, so we have to call it after dropping the\n\t * lock above.  Eventually we should look into a way to avoid\n\t * the pointless lock roundtrip.\n\t */\n\tif (likely(!(file->f_mode & FMODE_NOCMTIME))) {\n\t\terror = file_update_time(file);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If we're writing the file then make sure to clear the setuid and\n\t * setgid bits if the process is not being run by root.  This keeps\n\t * people from modifying setuid and setgid binaries.\n\t */\n\treturn file_remove_suid(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rw_ilock",
          "args": [
            "ip",
            "iolock"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rw_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "72-80",
          "snippet": "static inline void\nxfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC ssize_t\nxfs_file_buffered_aio_write(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct address_space\t*mapping = file->f_mapping;\n\tstruct inode\t\t*inode = mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tssize_t\t\t\tret;\n\tint\t\t\tenospc = 0;\n\tint\t\t\tiolock = XFS_IOLOCK_EXCL;\n\tloff_t\t\t\tpos = iocb->ki_pos;\n\tsize_t\t\t\tcount = iov_iter_count(from);\n\n\txfs_rw_ilock(ip, iolock);\n\n\tret = xfs_file_aio_write_checks(file, &pos, &count, &iolock);\n\tif (ret)\n\t\tgoto out;\n\n\tiov_iter_truncate(from, count);\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\nwrite_retry:\n\ttrace_xfs_file_buffered_write(ip, count, iocb->ki_pos, 0);\n\tret = generic_perform_write(file, from, pos);\n\tif (likely(ret >= 0))\n\t\tiocb->ki_pos = pos + ret;\n\n\t/*\n\t * If we hit a space limit, try to free up some lingering preallocated\n\t * space before returning an error. In the case of ENOSPC, first try to\n\t * write back all dirty inodes to free up some of the excess reserved\n\t * metadata space. This reduces the chances that the eofblocks scan\n\t * waits on dirty mappings. Since xfs_flush_inodes() is serialized, this\n\t * also behaves as a filter to prevent too many eofblocks scans from\n\t * running at the same time.\n\t */\n\tif (ret == -EDQUOT && !enospc) {\n\t\tenospc = xfs_inode_free_quota_eofblocks(ip);\n\t\tif (enospc)\n\t\t\tgoto write_retry;\n\t} else if (ret == -ENOSPC && !enospc) {\n\t\tstruct xfs_eofblocks eofb = {0};\n\n\t\tenospc = 1;\n\t\txfs_flush_inodes(ip->i_mount);\n\t\teofb.eof_scan_owner = ip->i_ino; /* for locking */\n\t\teofb.eof_flags = XFS_EOF_FLAGS_SYNC;\n\t\txfs_icache_free_eofblocks(ip->i_mount, &eofb);\n\t\tgoto write_retry;\n\t}\n\n\tcurrent->backing_dev_info = NULL;\nout:\n\txfs_rw_iunlock(ip, iolock);\n\treturn ret;\n}"
  },
  {
    "function_name": "xfs_file_dio_aio_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "632-724",
    "snippet": "STATIC ssize_t\nxfs_file_dio_aio_write(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct address_space\t*mapping = file->f_mapping;\n\tstruct inode\t\t*inode = mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tssize_t\t\t\tret = 0;\n\tint\t\t\tunaligned_io = 0;\n\tint\t\t\tiolock;\n\tsize_t\t\t\tcount = iov_iter_count(from);\n\tloff_t\t\t\tpos = iocb->ki_pos;\n\tstruct xfs_buftarg\t*target = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp;\n\n\t/* DIO must be aligned to device logical sector size */\n\tif ((pos | count) & target->bt_logical_sectormask)\n\t\treturn -EINVAL;\n\n\t/* \"unaligned\" here means not aligned to a filesystem block */\n\tif ((pos & mp->m_blockmask) || ((pos + count) & mp->m_blockmask))\n\t\tunaligned_io = 1;\n\n\t/*\n\t * We don't need to take an exclusive lock unless there page cache needs\n\t * to be invalidated or unaligned IO is being executed. We don't need to\n\t * consider the EOF extension case here because\n\t * xfs_file_aio_write_checks() will relock the inode as necessary for\n\t * EOF zeroing cases and fill out the new inode size as appropriate.\n\t */\n\tif (unaligned_io || mapping->nrpages)\n\t\tiolock = XFS_IOLOCK_EXCL;\n\telse\n\t\tiolock = XFS_IOLOCK_SHARED;\n\txfs_rw_ilock(ip, iolock);\n\n\t/*\n\t * Recheck if there are cached pages that need invalidate after we got\n\t * the iolock to protect against other threads adding new pages while\n\t * we were waiting for the iolock.\n\t */\n\tif (mapping->nrpages && iolock == XFS_IOLOCK_SHARED) {\n\t\txfs_rw_iunlock(ip, iolock);\n\t\tiolock = XFS_IOLOCK_EXCL;\n\t\txfs_rw_ilock(ip, iolock);\n\t}\n\n\tret = xfs_file_aio_write_checks(file, &pos, &count, &iolock);\n\tif (ret)\n\t\tgoto out;\n\tiov_iter_truncate(from, count);\n\n\tif (mapping->nrpages) {\n\t\tret = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t    pos, pos + count - 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Invalidate whole pages. This can return an error if\n\t\t * we fail to invalidate a page, but this should never\n\t\t * happen on XFS. Warn if it does fail.\n\t\t */\n\t\tret = invalidate_inode_pages2_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\tpos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t(pos + count - 1) >> PAGE_CACHE_SHIFT);\n\t\tWARN_ON_ONCE(ret);\n\t\tret = 0;\n\t}\n\n\t/*\n\t * If we are doing unaligned IO, wait for all other IO to drain,\n\t * otherwise demote the lock if we had to flush cached pages\n\t */\n\tif (unaligned_io)\n\t\tinode_dio_wait(inode);\n\telse if (iolock == XFS_IOLOCK_EXCL) {\n\t\txfs_rw_ilock_demote(ip, XFS_IOLOCK_EXCL);\n\t\tiolock = XFS_IOLOCK_SHARED;\n\t}\n\n\ttrace_xfs_file_direct_write(ip, count, iocb->ki_pos, 0);\n\tret = generic_file_direct_write(iocb, from, pos);\n\nout:\n\txfs_rw_iunlock(ip, iolock);\n\n\t/* No fallback to buffered IO on errors for XFS. */\n\tASSERT(ret < 0 || ret == count);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ret < 0 || ret == count"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rw_iunlock",
          "args": [
            "ip",
            "iolock"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rw_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "62-70",
          "snippet": "static inline void\nxfs_rw_iunlock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_iunlock(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_iunlock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_iunlock(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_direct_write",
          "args": [
            "iocb",
            "from",
            "pos"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_file_direct_write",
          "args": [
            "ip",
            "count",
            "iocb->ki_pos",
            "0"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rw_ilock_demote",
          "args": [
            "ip",
            "XFS_IOLOCK_EXCL"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rw_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "72-80",
          "snippet": "static inline void\nxfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "VFS_I(ip)->i_mapping",
            "pos >> PAGE_CACHE_SHIFT",
            "(pos + count - 1) >> PAGE_CACHE_SHIFT"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "VFS_I(ip)->i_mapping",
            "pos",
            "pos + count - 1"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "from",
            "count"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_file_aio_write_checks",
          "args": [
            "file",
            "&pos",
            "&count",
            "&iolock"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_file_aio_write_checks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "546-605",
          "snippet": "STATIC ssize_t\nxfs_file_aio_write_checks(\n\tstruct file\t\t*file,\n\tloff_t\t\t\t*pos,\n\tsize_t\t\t\t*count,\n\tint\t\t\t*iolock)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror = 0;\n\nrestart:\n\terror = generic_write_checks(file, pos, count, S_ISBLK(inode->i_mode));\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_break_layouts(inode, iolock);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the offset is beyond the size of the file, we need to zero any\n\t * blocks that fall between the existing EOF and the start of this\n\t * write.  If zeroing is needed and we are currently holding the\n\t * iolock shared, we need to update it to exclusive which implies\n\t * having to redo all checks before.\n\t */\n\tif (*pos > i_size_read(inode)) {\n\t\tbool\tzero = false;\n\n\t\tif (*iolock == XFS_IOLOCK_SHARED) {\n\t\t\txfs_rw_iunlock(ip, *iolock);\n\t\t\t*iolock = XFS_IOLOCK_EXCL;\n\t\t\txfs_rw_ilock(ip, *iolock);\n\t\t\tgoto restart;\n\t\t}\n\t\terror = xfs_zero_eof(ip, *pos, i_size_read(inode), &zero);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Updating the timestamps will grab the ilock again from\n\t * xfs_fs_dirty_inode, so we have to call it after dropping the\n\t * lock above.  Eventually we should look into a way to avoid\n\t * the pointless lock roundtrip.\n\t */\n\tif (likely(!(file->f_mode & FMODE_NOCMTIME))) {\n\t\terror = file_update_time(file);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If we're writing the file then make sure to clear the setuid and\n\t * setgid bits if the process is not being run by root.  This keeps\n\t * people from modifying setuid and setgid binaries.\n\t */\n\treturn file_remove_suid(file);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC ssize_t\nxfs_file_aio_write_checks(\n\tstruct file\t\t*file,\n\tloff_t\t\t\t*pos,\n\tsize_t\t\t\t*count,\n\tint\t\t\t*iolock)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror = 0;\n\nrestart:\n\terror = generic_write_checks(file, pos, count, S_ISBLK(inode->i_mode));\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_break_layouts(inode, iolock);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the offset is beyond the size of the file, we need to zero any\n\t * blocks that fall between the existing EOF and the start of this\n\t * write.  If zeroing is needed and we are currently holding the\n\t * iolock shared, we need to update it to exclusive which implies\n\t * having to redo all checks before.\n\t */\n\tif (*pos > i_size_read(inode)) {\n\t\tbool\tzero = false;\n\n\t\tif (*iolock == XFS_IOLOCK_SHARED) {\n\t\t\txfs_rw_iunlock(ip, *iolock);\n\t\t\t*iolock = XFS_IOLOCK_EXCL;\n\t\t\txfs_rw_ilock(ip, *iolock);\n\t\t\tgoto restart;\n\t\t}\n\t\terror = xfs_zero_eof(ip, *pos, i_size_read(inode), &zero);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Updating the timestamps will grab the ilock again from\n\t * xfs_fs_dirty_inode, so we have to call it after dropping the\n\t * lock above.  Eventually we should look into a way to avoid\n\t * the pointless lock roundtrip.\n\t */\n\tif (likely(!(file->f_mode & FMODE_NOCMTIME))) {\n\t\terror = file_update_time(file);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If we're writing the file then make sure to clear the setuid and\n\t * setgid bits if the process is not being run by root.  This keeps\n\t * people from modifying setuid and setgid binaries.\n\t */\n\treturn file_remove_suid(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC ssize_t\nxfs_file_dio_aio_write(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*from)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct address_space\t*mapping = file->f_mapping;\n\tstruct inode\t\t*inode = mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tssize_t\t\t\tret = 0;\n\tint\t\t\tunaligned_io = 0;\n\tint\t\t\tiolock;\n\tsize_t\t\t\tcount = iov_iter_count(from);\n\tloff_t\t\t\tpos = iocb->ki_pos;\n\tstruct xfs_buftarg\t*target = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp;\n\n\t/* DIO must be aligned to device logical sector size */\n\tif ((pos | count) & target->bt_logical_sectormask)\n\t\treturn -EINVAL;\n\n\t/* \"unaligned\" here means not aligned to a filesystem block */\n\tif ((pos & mp->m_blockmask) || ((pos + count) & mp->m_blockmask))\n\t\tunaligned_io = 1;\n\n\t/*\n\t * We don't need to take an exclusive lock unless there page cache needs\n\t * to be invalidated or unaligned IO is being executed. We don't need to\n\t * consider the EOF extension case here because\n\t * xfs_file_aio_write_checks() will relock the inode as necessary for\n\t * EOF zeroing cases and fill out the new inode size as appropriate.\n\t */\n\tif (unaligned_io || mapping->nrpages)\n\t\tiolock = XFS_IOLOCK_EXCL;\n\telse\n\t\tiolock = XFS_IOLOCK_SHARED;\n\txfs_rw_ilock(ip, iolock);\n\n\t/*\n\t * Recheck if there are cached pages that need invalidate after we got\n\t * the iolock to protect against other threads adding new pages while\n\t * we were waiting for the iolock.\n\t */\n\tif (mapping->nrpages && iolock == XFS_IOLOCK_SHARED) {\n\t\txfs_rw_iunlock(ip, iolock);\n\t\tiolock = XFS_IOLOCK_EXCL;\n\t\txfs_rw_ilock(ip, iolock);\n\t}\n\n\tret = xfs_file_aio_write_checks(file, &pos, &count, &iolock);\n\tif (ret)\n\t\tgoto out;\n\tiov_iter_truncate(from, count);\n\n\tif (mapping->nrpages) {\n\t\tret = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t    pos, pos + count - 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Invalidate whole pages. This can return an error if\n\t\t * we fail to invalidate a page, but this should never\n\t\t * happen on XFS. Warn if it does fail.\n\t\t */\n\t\tret = invalidate_inode_pages2_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\tpos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t(pos + count - 1) >> PAGE_CACHE_SHIFT);\n\t\tWARN_ON_ONCE(ret);\n\t\tret = 0;\n\t}\n\n\t/*\n\t * If we are doing unaligned IO, wait for all other IO to drain,\n\t * otherwise demote the lock if we had to flush cached pages\n\t */\n\tif (unaligned_io)\n\t\tinode_dio_wait(inode);\n\telse if (iolock == XFS_IOLOCK_EXCL) {\n\t\txfs_rw_ilock_demote(ip, XFS_IOLOCK_EXCL);\n\t\tiolock = XFS_IOLOCK_SHARED;\n\t}\n\n\ttrace_xfs_file_direct_write(ip, count, iocb->ki_pos, 0);\n\tret = generic_file_direct_write(iocb, from, pos);\n\nout:\n\txfs_rw_iunlock(ip, iolock);\n\n\t/* No fallback to buffered IO on errors for XFS. */\n\tASSERT(ret < 0 || ret == count);\n\treturn ret;\n}"
  },
  {
    "function_name": "xfs_file_aio_write_checks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "546-605",
    "snippet": "STATIC ssize_t\nxfs_file_aio_write_checks(\n\tstruct file\t\t*file,\n\tloff_t\t\t\t*pos,\n\tsize_t\t\t\t*count,\n\tint\t\t\t*iolock)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror = 0;\n\nrestart:\n\terror = generic_write_checks(file, pos, count, S_ISBLK(inode->i_mode));\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_break_layouts(inode, iolock);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the offset is beyond the size of the file, we need to zero any\n\t * blocks that fall between the existing EOF and the start of this\n\t * write.  If zeroing is needed and we are currently holding the\n\t * iolock shared, we need to update it to exclusive which implies\n\t * having to redo all checks before.\n\t */\n\tif (*pos > i_size_read(inode)) {\n\t\tbool\tzero = false;\n\n\t\tif (*iolock == XFS_IOLOCK_SHARED) {\n\t\t\txfs_rw_iunlock(ip, *iolock);\n\t\t\t*iolock = XFS_IOLOCK_EXCL;\n\t\t\txfs_rw_ilock(ip, *iolock);\n\t\t\tgoto restart;\n\t\t}\n\t\terror = xfs_zero_eof(ip, *pos, i_size_read(inode), &zero);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Updating the timestamps will grab the ilock again from\n\t * xfs_fs_dirty_inode, so we have to call it after dropping the\n\t * lock above.  Eventually we should look into a way to avoid\n\t * the pointless lock roundtrip.\n\t */\n\tif (likely(!(file->f_mode & FMODE_NOCMTIME))) {\n\t\terror = file_update_time(file);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If we're writing the file then make sure to clear the setuid and\n\t * setgid bits if the process is not being run by root.  This keeps\n\t * people from modifying setuid and setgid binaries.\n\t */\n\treturn file_remove_suid(file);\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_remove_suid",
          "args": [
            "file"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "file_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1675-1700",
          "snippet": "int file_remove_suid(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint killsuid;\n\tint killpriv;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkillsuid = should_remove_suid(dentry);\n\tkillpriv = security_inode_need_killpriv(dentry);\n\n\tif (killpriv < 0)\n\t\treturn killpriv;\n\tif (killpriv)\n\t\terror = security_inode_killpriv(dentry);\n\tif (!error && killsuid)\n\t\terror = __remove_suid(dentry, killsuid);\n\tif (!error && (inode->i_sb->s_flags & MS_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_remove_suid(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint killsuid;\n\tint killpriv;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkillsuid = should_remove_suid(dentry);\n\tkillpriv = security_inode_need_killpriv(dentry);\n\n\tif (killpriv < 0)\n\t\treturn killpriv;\n\tif (killpriv)\n\t\terror = security_inode_killpriv(dentry);\n\tif (!error && killsuid)\n\t\terror = __remove_suid(dentry, killsuid);\n\tif (!error && (inode->i_sb->s_flags & MS_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "file"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(file->f_mode & FMODE_NOCMTIME)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_zero_eof",
          "args": [
            "ip",
            "*pos",
            "i_size_read(inode)",
            "&zero"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_zero_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "444-537",
          "snippet": "int\t\t\t\t\t/* error (positive) */\nxfs_zero_eof(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\t\t/* starting I/O offset */\n\txfs_fsize_t\t\tisize,\t\t/* current inode size */\n\tbool\t\t\t*did_zeroing)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\tstart_zero_fsb;\n\txfs_fileoff_t\t\tend_zero_fsb;\n\txfs_fileoff_t\t\tzero_count_fsb;\n\txfs_fileoff_t\t\tlast_fsb;\n\txfs_fileoff_t\t\tzero_off;\n\txfs_fsize_t\t\tzero_len;\n\tint\t\t\tnimaps;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\timap;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(offset > isize);\n\n\t/*\n\t * First handle zeroing the block on which isize resides.\n\t *\n\t * We only zero a part of that block so it is handled specially.\n\t */\n\tif (XFS_B_FSB_OFFSET(mp, isize) != 0) {\n\t\terror = xfs_zero_last_block(ip, offset, isize, did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Calculate the range between the new size and the old where blocks\n\t * needing to be zeroed may exist.\n\t *\n\t * To get the block where the last byte in the file currently resides,\n\t * we need to subtract one from the size and truncate back to a block\n\t * boundary.  We subtract 1 in case the size is exactly on a block\n\t * boundary.\n\t */\n\tlast_fsb = isize ? XFS_B_TO_FSBT(mp, isize - 1) : (xfs_fileoff_t)-1;\n\tstart_zero_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)isize);\n\tend_zero_fsb = XFS_B_TO_FSBT(mp, offset - 1);\n\tASSERT((xfs_sfiloff_t)last_fsb < (xfs_sfiloff_t)start_zero_fsb);\n\tif (last_fsb == end_zero_fsb) {\n\t\t/*\n\t\t * The size was only incremented on its last block.\n\t\t * We took care of that above, so just return.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tASSERT(start_zero_fsb <= end_zero_fsb);\n\twhile (start_zero_fsb <= end_zero_fsb) {\n\t\tnimaps = 1;\n\t\tzero_count_fsb = end_zero_fsb - start_zero_fsb + 1;\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_bmapi_read(ip, start_zero_fsb, zero_count_fsb,\n\t\t\t\t\t  &imap, &nimaps, 0);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(nimaps > 0);\n\n\t\tif (imap.br_state == XFS_EXT_UNWRITTEN ||\n\t\t    imap.br_startblock == HOLESTARTBLOCK) {\n\t\t\tstart_zero_fsb = imap.br_startoff + imap.br_blockcount;\n\t\t\tASSERT(start_zero_fsb <= (end_zero_fsb + 1));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * There are blocks we need to zero.\n\t\t */\n\t\tzero_off = XFS_FSB_TO_B(mp, start_zero_fsb);\n\t\tzero_len = XFS_FSB_TO_B(mp, imap.br_blockcount);\n\n\t\tif ((zero_off + zero_len) > offset)\n\t\t\tzero_len = offset - zero_off;\n\n\t\terror = xfs_iozero(ip, zero_off, zero_len);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t*did_zeroing = true;\n\t\tstart_zero_fsb = imap.br_startoff + imap.br_blockcount;\n\t\tASSERT(start_zero_fsb <= (end_zero_fsb + 1));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error (positive) */\nxfs_zero_eof(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\t\t/* starting I/O offset */\n\txfs_fsize_t\t\tisize,\t\t/* current inode size */\n\tbool\t\t\t*did_zeroing)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\tstart_zero_fsb;\n\txfs_fileoff_t\t\tend_zero_fsb;\n\txfs_fileoff_t\t\tzero_count_fsb;\n\txfs_fileoff_t\t\tlast_fsb;\n\txfs_fileoff_t\t\tzero_off;\n\txfs_fsize_t\t\tzero_len;\n\tint\t\t\tnimaps;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\timap;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(offset > isize);\n\n\t/*\n\t * First handle zeroing the block on which isize resides.\n\t *\n\t * We only zero a part of that block so it is handled specially.\n\t */\n\tif (XFS_B_FSB_OFFSET(mp, isize) != 0) {\n\t\terror = xfs_zero_last_block(ip, offset, isize, did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Calculate the range between the new size and the old where blocks\n\t * needing to be zeroed may exist.\n\t *\n\t * To get the block where the last byte in the file currently resides,\n\t * we need to subtract one from the size and truncate back to a block\n\t * boundary.  We subtract 1 in case the size is exactly on a block\n\t * boundary.\n\t */\n\tlast_fsb = isize ? XFS_B_TO_FSBT(mp, isize - 1) : (xfs_fileoff_t)-1;\n\tstart_zero_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)isize);\n\tend_zero_fsb = XFS_B_TO_FSBT(mp, offset - 1);\n\tASSERT((xfs_sfiloff_t)last_fsb < (xfs_sfiloff_t)start_zero_fsb);\n\tif (last_fsb == end_zero_fsb) {\n\t\t/*\n\t\t * The size was only incremented on its last block.\n\t\t * We took care of that above, so just return.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tASSERT(start_zero_fsb <= end_zero_fsb);\n\twhile (start_zero_fsb <= end_zero_fsb) {\n\t\tnimaps = 1;\n\t\tzero_count_fsb = end_zero_fsb - start_zero_fsb + 1;\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_bmapi_read(ip, start_zero_fsb, zero_count_fsb,\n\t\t\t\t\t  &imap, &nimaps, 0);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(nimaps > 0);\n\n\t\tif (imap.br_state == XFS_EXT_UNWRITTEN ||\n\t\t    imap.br_startblock == HOLESTARTBLOCK) {\n\t\t\tstart_zero_fsb = imap.br_startoff + imap.br_blockcount;\n\t\t\tASSERT(start_zero_fsb <= (end_zero_fsb + 1));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * There are blocks we need to zero.\n\t\t */\n\t\tzero_off = XFS_FSB_TO_B(mp, start_zero_fsb);\n\t\tzero_len = XFS_FSB_TO_B(mp, imap.br_blockcount);\n\n\t\tif ((zero_off + zero_len) > offset)\n\t\t\tzero_len = offset - zero_off;\n\n\t\terror = xfs_iozero(ip, zero_off, zero_len);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t*did_zeroing = true;\n\t\tstart_zero_fsb = imap.br_startoff + imap.br_blockcount;\n\t\tASSERT(start_zero_fsb <= (end_zero_fsb + 1));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rw_ilock",
          "args": [
            "ip",
            "*iolock"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rw_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "72-80",
          "snippet": "static inline void\nxfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rw_iunlock",
          "args": [
            "ip",
            "*iolock"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rw_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "62-70",
          "snippet": "static inline void\nxfs_rw_iunlock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_iunlock(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_iunlock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_iunlock(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_break_layouts",
          "args": [
            "inode",
            "iolock"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_break_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_pnfs.h",
          "lines": "13-16",
          "snippet": "static inline int xfs_break_layouts(struct inode *inode, uint *iolock)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_break_layouts(struct inode *inode, uint *iolock)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_checks",
          "args": [
            "file",
            "pos",
            "count",
            "S_ISBLK(inode->i_mode)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC ssize_t\nxfs_file_aio_write_checks(\n\tstruct file\t\t*file,\n\tloff_t\t\t\t*pos,\n\tsize_t\t\t\t*count,\n\tint\t\t\t*iolock)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror = 0;\n\nrestart:\n\terror = generic_write_checks(file, pos, count, S_ISBLK(inode->i_mode));\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_break_layouts(inode, iolock);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the offset is beyond the size of the file, we need to zero any\n\t * blocks that fall between the existing EOF and the start of this\n\t * write.  If zeroing is needed and we are currently holding the\n\t * iolock shared, we need to update it to exclusive which implies\n\t * having to redo all checks before.\n\t */\n\tif (*pos > i_size_read(inode)) {\n\t\tbool\tzero = false;\n\n\t\tif (*iolock == XFS_IOLOCK_SHARED) {\n\t\t\txfs_rw_iunlock(ip, *iolock);\n\t\t\t*iolock = XFS_IOLOCK_EXCL;\n\t\t\txfs_rw_ilock(ip, *iolock);\n\t\t\tgoto restart;\n\t\t}\n\t\terror = xfs_zero_eof(ip, *pos, i_size_read(inode), &zero);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Updating the timestamps will grab the ilock again from\n\t * xfs_fs_dirty_inode, so we have to call it after dropping the\n\t * lock above.  Eventually we should look into a way to avoid\n\t * the pointless lock roundtrip.\n\t */\n\tif (likely(!(file->f_mode & FMODE_NOCMTIME))) {\n\t\terror = file_update_time(file);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If we're writing the file then make sure to clear the setuid and\n\t * setgid bits if the process is not being run by root.  This keeps\n\t * people from modifying setuid and setgid binaries.\n\t */\n\treturn file_remove_suid(file);\n}"
  },
  {
    "function_name": "xfs_zero_eof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "444-537",
    "snippet": "int\t\t\t\t\t/* error (positive) */\nxfs_zero_eof(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\t\t/* starting I/O offset */\n\txfs_fsize_t\t\tisize,\t\t/* current inode size */\n\tbool\t\t\t*did_zeroing)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\tstart_zero_fsb;\n\txfs_fileoff_t\t\tend_zero_fsb;\n\txfs_fileoff_t\t\tzero_count_fsb;\n\txfs_fileoff_t\t\tlast_fsb;\n\txfs_fileoff_t\t\tzero_off;\n\txfs_fsize_t\t\tzero_len;\n\tint\t\t\tnimaps;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\timap;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(offset > isize);\n\n\t/*\n\t * First handle zeroing the block on which isize resides.\n\t *\n\t * We only zero a part of that block so it is handled specially.\n\t */\n\tif (XFS_B_FSB_OFFSET(mp, isize) != 0) {\n\t\terror = xfs_zero_last_block(ip, offset, isize, did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Calculate the range between the new size and the old where blocks\n\t * needing to be zeroed may exist.\n\t *\n\t * To get the block where the last byte in the file currently resides,\n\t * we need to subtract one from the size and truncate back to a block\n\t * boundary.  We subtract 1 in case the size is exactly on a block\n\t * boundary.\n\t */\n\tlast_fsb = isize ? XFS_B_TO_FSBT(mp, isize - 1) : (xfs_fileoff_t)-1;\n\tstart_zero_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)isize);\n\tend_zero_fsb = XFS_B_TO_FSBT(mp, offset - 1);\n\tASSERT((xfs_sfiloff_t)last_fsb < (xfs_sfiloff_t)start_zero_fsb);\n\tif (last_fsb == end_zero_fsb) {\n\t\t/*\n\t\t * The size was only incremented on its last block.\n\t\t * We took care of that above, so just return.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tASSERT(start_zero_fsb <= end_zero_fsb);\n\twhile (start_zero_fsb <= end_zero_fsb) {\n\t\tnimaps = 1;\n\t\tzero_count_fsb = end_zero_fsb - start_zero_fsb + 1;\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_bmapi_read(ip, start_zero_fsb, zero_count_fsb,\n\t\t\t\t\t  &imap, &nimaps, 0);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(nimaps > 0);\n\n\t\tif (imap.br_state == XFS_EXT_UNWRITTEN ||\n\t\t    imap.br_startblock == HOLESTARTBLOCK) {\n\t\t\tstart_zero_fsb = imap.br_startoff + imap.br_blockcount;\n\t\t\tASSERT(start_zero_fsb <= (end_zero_fsb + 1));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * There are blocks we need to zero.\n\t\t */\n\t\tzero_off = XFS_FSB_TO_B(mp, start_zero_fsb);\n\t\tzero_len = XFS_FSB_TO_B(mp, imap.br_blockcount);\n\n\t\tif ((zero_off + zero_len) > offset)\n\t\t\tzero_len = offset - zero_off;\n\n\t\terror = xfs_iozero(ip, zero_off, zero_len);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t*did_zeroing = true;\n\t\tstart_zero_fsb = imap.br_startoff + imap.br_blockcount;\n\t\tASSERT(start_zero_fsb <= (end_zero_fsb + 1));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "start_zero_fsb <= (end_zero_fsb + 1)"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iozero",
          "args": [
            "ip",
            "zero_off",
            "zero_len"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iozero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "92-129",
          "snippet": "int\nxfs_iozero(\n\tstruct xfs_inode\t*ip,\t/* inode\t\t\t*/\n\tloff_t\t\t\tpos,\t/* offset in file\t\t*/\n\tsize_t\t\t\tcount)\t/* size of data to zero\t\t*/\n{\n\tstruct page\t\t*page;\n\tstruct address_space\t*mapping;\n\tint\t\t\tstatus;\n\n\tmapping = VFS_I(ip)->i_mapping;\n\tdo {\n\t\tunsigned offset, bytes;\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_CACHE_SIZE -1)); /* Within page */\n\t\tbytes = PAGE_CACHE_SIZE - offset;\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\n\t\tstatus = pagecache_write_begin(NULL, mapping, pos, bytes,\n\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t&page, &fsdata);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tzero_user(page, offset, bytes);\n\n\t\tstatus = pagecache_write_end(NULL, mapping, pos, bytes, bytes,\n\t\t\t\t\tpage, fsdata);\n\t\tWARN_ON(status <= 0); /* can't return less than zero! */\n\t\tpos += bytes;\n\t\tcount -= bytes;\n\t\tstatus = 0;\n\t} while (count);\n\n\treturn (-status);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_iozero(\n\tstruct xfs_inode\t*ip,\t/* inode\t\t\t*/\n\tloff_t\t\t\tpos,\t/* offset in file\t\t*/\n\tsize_t\t\t\tcount)\t/* size of data to zero\t\t*/\n{\n\tstruct page\t\t*page;\n\tstruct address_space\t*mapping;\n\tint\t\t\tstatus;\n\n\tmapping = VFS_I(ip)->i_mapping;\n\tdo {\n\t\tunsigned offset, bytes;\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_CACHE_SIZE -1)); /* Within page */\n\t\tbytes = PAGE_CACHE_SIZE - offset;\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\n\t\tstatus = pagecache_write_begin(NULL, mapping, pos, bytes,\n\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t&page, &fsdata);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tzero_user(page, offset, bytes);\n\n\t\tstatus = pagecache_write_end(NULL, mapping, pos, bytes, bytes,\n\t\t\t\t\tpage, fsdata);\n\t\tWARN_ON(status <= 0); /* can't return less than zero! */\n\t\tpos += bytes;\n\t\tcount -= bytes;\n\t\tstatus = 0;\n\t} while (count);\n\n\treturn (-status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "imap.br_blockcount"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "start_zero_fsb"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "start_zero_fsb <= (end_zero_fsb + 1)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nimaps > 0"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "start_zero_fsb",
            "zero_count_fsb",
            "&imap",
            "&nimaps",
            "0"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "start_zero_fsb <= end_zero_fsb"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(xfs_sfiloff_t)last_fsb < (xfs_sfiloff_t)start_zero_fsb"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "offset - 1"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "(xfs_ufsize_t)isize"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "isize - 1"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_zero_last_block",
          "args": [
            "ip",
            "offset",
            "isize",
            "did_zeroing"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_zero_last_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "396-431",
          "snippet": "STATIC int\t\t\t\t/* error (positive) */\nxfs_zero_last_block(\n\tstruct xfs_inode\t*ip,\n\txfs_fsize_t\t\toffset,\n\txfs_fsize_t\t\tisize,\n\tbool\t\t\t*did_zeroing)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\tlast_fsb = XFS_B_TO_FSBT(mp, isize);\n\tint\t\t\tzero_offset = XFS_B_FSB_OFFSET(mp, isize);\n\tint\t\t\tzero_len;\n\tint\t\t\tnimaps = 1;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\timap;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_bmapi_read(ip, last_fsb, 1, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nimaps > 0);\n\n\t/*\n\t * If the block underlying isize is just a hole, then there\n\t * is nothing to zero.\n\t */\n\tif (imap.br_startblock == HOLESTARTBLOCK)\n\t\treturn 0;\n\n\tzero_len = mp->m_sb.sb_blocksize - zero_offset;\n\tif (isize + zero_len > offset)\n\t\tzero_len = offset - isize;\n\t*did_zeroing = true;\n\treturn xfs_iozero(ip, isize, zero_len);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error (positive) */\nxfs_zero_last_block(\n\tstruct xfs_inode\t*ip,\n\txfs_fsize_t\t\toffset,\n\txfs_fsize_t\t\tisize,\n\tbool\t\t\t*did_zeroing)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\tlast_fsb = XFS_B_TO_FSBT(mp, isize);\n\tint\t\t\tzero_offset = XFS_B_FSB_OFFSET(mp, isize);\n\tint\t\t\tzero_len;\n\tint\t\t\tnimaps = 1;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\timap;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_bmapi_read(ip, last_fsb, 1, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nimaps > 0);\n\n\t/*\n\t * If the block underlying isize is just a hole, then there\n\t * is nothing to zero.\n\t */\n\tif (imap.br_startblock == HOLESTARTBLOCK)\n\t\treturn 0;\n\n\tzero_len = mp->m_sb.sb_blocksize - zero_offset;\n\tif (isize + zero_len > offset)\n\t\tzero_len = offset - isize;\n\t*did_zeroing = true;\n\treturn xfs_iozero(ip, isize, zero_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_FSB_OFFSET",
          "args": [
            "mp",
            "isize"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset > isize"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_IOLOCK_EXCL)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_IOLOCK_EXCL"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error (positive) */\nxfs_zero_eof(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\t\t/* starting I/O offset */\n\txfs_fsize_t\t\tisize,\t\t/* current inode size */\n\tbool\t\t\t*did_zeroing)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\tstart_zero_fsb;\n\txfs_fileoff_t\t\tend_zero_fsb;\n\txfs_fileoff_t\t\tzero_count_fsb;\n\txfs_fileoff_t\t\tlast_fsb;\n\txfs_fileoff_t\t\tzero_off;\n\txfs_fsize_t\t\tzero_len;\n\tint\t\t\tnimaps;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\timap;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(offset > isize);\n\n\t/*\n\t * First handle zeroing the block on which isize resides.\n\t *\n\t * We only zero a part of that block so it is handled specially.\n\t */\n\tif (XFS_B_FSB_OFFSET(mp, isize) != 0) {\n\t\terror = xfs_zero_last_block(ip, offset, isize, did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Calculate the range between the new size and the old where blocks\n\t * needing to be zeroed may exist.\n\t *\n\t * To get the block where the last byte in the file currently resides,\n\t * we need to subtract one from the size and truncate back to a block\n\t * boundary.  We subtract 1 in case the size is exactly on a block\n\t * boundary.\n\t */\n\tlast_fsb = isize ? XFS_B_TO_FSBT(mp, isize - 1) : (xfs_fileoff_t)-1;\n\tstart_zero_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)isize);\n\tend_zero_fsb = XFS_B_TO_FSBT(mp, offset - 1);\n\tASSERT((xfs_sfiloff_t)last_fsb < (xfs_sfiloff_t)start_zero_fsb);\n\tif (last_fsb == end_zero_fsb) {\n\t\t/*\n\t\t * The size was only incremented on its last block.\n\t\t * We took care of that above, so just return.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tASSERT(start_zero_fsb <= end_zero_fsb);\n\twhile (start_zero_fsb <= end_zero_fsb) {\n\t\tnimaps = 1;\n\t\tzero_count_fsb = end_zero_fsb - start_zero_fsb + 1;\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_bmapi_read(ip, start_zero_fsb, zero_count_fsb,\n\t\t\t\t\t  &imap, &nimaps, 0);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(nimaps > 0);\n\n\t\tif (imap.br_state == XFS_EXT_UNWRITTEN ||\n\t\t    imap.br_startblock == HOLESTARTBLOCK) {\n\t\t\tstart_zero_fsb = imap.br_startoff + imap.br_blockcount;\n\t\t\tASSERT(start_zero_fsb <= (end_zero_fsb + 1));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * There are blocks we need to zero.\n\t\t */\n\t\tzero_off = XFS_FSB_TO_B(mp, start_zero_fsb);\n\t\tzero_len = XFS_FSB_TO_B(mp, imap.br_blockcount);\n\n\t\tif ((zero_off + zero_len) > offset)\n\t\t\tzero_len = offset - zero_off;\n\n\t\terror = xfs_iozero(ip, zero_off, zero_len);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t*did_zeroing = true;\n\t\tstart_zero_fsb = imap.br_startoff + imap.br_blockcount;\n\t\tASSERT(start_zero_fsb <= (end_zero_fsb + 1));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_zero_last_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "396-431",
    "snippet": "STATIC int\t\t\t\t/* error (positive) */\nxfs_zero_last_block(\n\tstruct xfs_inode\t*ip,\n\txfs_fsize_t\t\toffset,\n\txfs_fsize_t\t\tisize,\n\tbool\t\t\t*did_zeroing)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\tlast_fsb = XFS_B_TO_FSBT(mp, isize);\n\tint\t\t\tzero_offset = XFS_B_FSB_OFFSET(mp, isize);\n\tint\t\t\tzero_len;\n\tint\t\t\tnimaps = 1;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\timap;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_bmapi_read(ip, last_fsb, 1, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nimaps > 0);\n\n\t/*\n\t * If the block underlying isize is just a hole, then there\n\t * is nothing to zero.\n\t */\n\tif (imap.br_startblock == HOLESTARTBLOCK)\n\t\treturn 0;\n\n\tzero_len = mp->m_sb.sb_blocksize - zero_offset;\n\tif (isize + zero_len > offset)\n\t\tzero_len = offset - isize;\n\t*did_zeroing = true;\n\treturn xfs_iozero(ip, isize, zero_len);\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iozero",
          "args": [
            "ip",
            "isize",
            "zero_len"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iozero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "92-129",
          "snippet": "int\nxfs_iozero(\n\tstruct xfs_inode\t*ip,\t/* inode\t\t\t*/\n\tloff_t\t\t\tpos,\t/* offset in file\t\t*/\n\tsize_t\t\t\tcount)\t/* size of data to zero\t\t*/\n{\n\tstruct page\t\t*page;\n\tstruct address_space\t*mapping;\n\tint\t\t\tstatus;\n\n\tmapping = VFS_I(ip)->i_mapping;\n\tdo {\n\t\tunsigned offset, bytes;\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_CACHE_SIZE -1)); /* Within page */\n\t\tbytes = PAGE_CACHE_SIZE - offset;\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\n\t\tstatus = pagecache_write_begin(NULL, mapping, pos, bytes,\n\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t&page, &fsdata);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tzero_user(page, offset, bytes);\n\n\t\tstatus = pagecache_write_end(NULL, mapping, pos, bytes, bytes,\n\t\t\t\t\tpage, fsdata);\n\t\tWARN_ON(status <= 0); /* can't return less than zero! */\n\t\tpos += bytes;\n\t\tcount -= bytes;\n\t\tstatus = 0;\n\t} while (count);\n\n\treturn (-status);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_iozero(\n\tstruct xfs_inode\t*ip,\t/* inode\t\t\t*/\n\tloff_t\t\t\tpos,\t/* offset in file\t\t*/\n\tsize_t\t\t\tcount)\t/* size of data to zero\t\t*/\n{\n\tstruct page\t\t*page;\n\tstruct address_space\t*mapping;\n\tint\t\t\tstatus;\n\n\tmapping = VFS_I(ip)->i_mapping;\n\tdo {\n\t\tunsigned offset, bytes;\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_CACHE_SIZE -1)); /* Within page */\n\t\tbytes = PAGE_CACHE_SIZE - offset;\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\n\t\tstatus = pagecache_write_begin(NULL, mapping, pos, bytes,\n\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t&page, &fsdata);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tzero_user(page, offset, bytes);\n\n\t\tstatus = pagecache_write_end(NULL, mapping, pos, bytes, bytes,\n\t\t\t\t\tpage, fsdata);\n\t\tWARN_ON(status <= 0); /* can't return less than zero! */\n\t\tpos += bytes;\n\t\tcount -= bytes;\n\t\tstatus = 0;\n\t} while (count);\n\n\treturn (-status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nimaps > 0"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "last_fsb",
            "1",
            "&imap",
            "&nimaps",
            "0"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_FSB_OFFSET",
          "args": [
            "mp",
            "isize"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "isize"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error (positive) */\nxfs_zero_last_block(\n\tstruct xfs_inode\t*ip,\n\txfs_fsize_t\t\toffset,\n\txfs_fsize_t\t\tisize,\n\tbool\t\t\t*did_zeroing)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\tlast_fsb = XFS_B_TO_FSBT(mp, isize);\n\tint\t\t\tzero_offset = XFS_B_FSB_OFFSET(mp, isize);\n\tint\t\t\tzero_len;\n\tint\t\t\tnimaps = 1;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\timap;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_bmapi_read(ip, last_fsb, 1, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nimaps > 0);\n\n\t/*\n\t * If the block underlying isize is just a hole, then there\n\t * is nothing to zero.\n\t */\n\tif (imap.br_startblock == HOLESTARTBLOCK)\n\t\treturn 0;\n\n\tzero_len = mp->m_sb.sb_blocksize - zero_offset;\n\tif (isize + zero_len > offset)\n\t\tzero_len = offset - isize;\n\t*did_zeroing = true;\n\treturn xfs_iozero(ip, isize, zero_len);\n}"
  },
  {
    "function_name": "xfs_file_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "358-388",
    "snippet": "STATIC ssize_t\nxfs_file_splice_read(\n\tstruct file\t\t*infilp,\n\tloff_t\t\t\t*ppos,\n\tstruct pipe_inode_info\t*pipe,\n\tsize_t\t\t\tcount,\n\tunsigned int\t\tflags)\n{\n\tstruct xfs_inode\t*ip = XFS_I(infilp->f_mapping->host);\n\tint\t\t\tioflags = 0;\n\tssize_t\t\t\tret;\n\n\tXFS_STATS_INC(xs_read_calls);\n\n\tif (infilp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= XFS_IO_INVIS;\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\txfs_rw_ilock(ip, XFS_IOLOCK_SHARED);\n\n\ttrace_xfs_file_splice_read(ip, count, *ppos, ioflags);\n\n\tret = generic_file_splice_read(infilp, ppos, pipe, count, flags);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_read_bytes, ret);\n\n\txfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_rw_iunlock",
          "args": [
            "ip",
            "XFS_IOLOCK_SHARED"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rw_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "62-70",
          "snippet": "static inline void\nxfs_rw_iunlock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_iunlock(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_iunlock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_iunlock(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_ADD",
          "args": [
            "xs_read_bytes",
            "ret"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_splice_read",
          "args": [
            "infilp",
            "ppos",
            "pipe",
            "count",
            "flags"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_splice_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "520-542",
          "snippet": "ssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tloff_t isize, left;\n\tint ret;\n\n\tisize = i_size_read(in->f_mapping->host);\n\tif (unlikely(*ppos >= isize))\n\t\treturn 0;\n\n\tleft = isize - *ppos;\n\tif (unlikely(left < len))\n\t\tlen = left;\n\n\tret = __generic_file_splice_read(in, ppos, pipe, len, flags);\n\tif (ret > 0) {\n\t\t*ppos += ret;\n\t\tfile_accessed(in);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tloff_t isize, left;\n\tint ret;\n\n\tisize = i_size_read(in->f_mapping->host);\n\tif (unlikely(*ppos >= isize))\n\t\treturn 0;\n\n\tleft = isize - *ppos;\n\tif (unlikely(left < len))\n\t\tlen = left;\n\n\tret = __generic_file_splice_read(in, ppos, pipe, len, flags);\n\tif (ret > 0) {\n\t\t*ppos += ret;\n\t\tfile_accessed(in);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_file_splice_read",
          "args": [
            "ip",
            "count",
            "*ppos",
            "ioflags"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rw_ilock",
          "args": [
            "ip",
            "XFS_IOLOCK_SHARED"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rw_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "72-80",
          "snippet": "static inline void\nxfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_read_calls"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "infilp->f_mapping->host"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC ssize_t\nxfs_file_splice_read(\n\tstruct file\t\t*infilp,\n\tloff_t\t\t\t*ppos,\n\tstruct pipe_inode_info\t*pipe,\n\tsize_t\t\t\tcount,\n\tunsigned int\t\tflags)\n{\n\tstruct xfs_inode\t*ip = XFS_I(infilp->f_mapping->host);\n\tint\t\t\tioflags = 0;\n\tssize_t\t\t\tret;\n\n\tXFS_STATS_INC(xs_read_calls);\n\n\tif (infilp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= XFS_IO_INVIS;\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\txfs_rw_ilock(ip, XFS_IOLOCK_SHARED);\n\n\ttrace_xfs_file_splice_read(ip, count, *ppos, ioflags);\n\n\tret = generic_file_splice_read(infilp, ppos, pipe, count, flags);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_read_bytes, ret);\n\n\txfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);\n\treturn ret;\n}"
  },
  {
    "function_name": "xfs_file_read_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "266-356",
    "snippet": "STATIC ssize_t\nxfs_file_read_iter(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*to)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tsize_t\t\t\tsize = iov_iter_count(to);\n\tssize_t\t\t\tret = 0;\n\tint\t\t\tioflags = 0;\n\txfs_fsize_t\t\tn;\n\tloff_t\t\t\tpos = iocb->ki_pos;\n\n\tXFS_STATS_INC(xs_read_calls);\n\n\tif (unlikely(file->f_flags & O_DIRECT))\n\t\tioflags |= XFS_IO_ISDIRECT;\n\tif (file->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= XFS_IO_INVIS;\n\n\tif (unlikely(ioflags & XFS_IO_ISDIRECT)) {\n\t\txfs_buftarg_t\t*target =\n\t\t\tXFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp;\n\t\t/* DIO must be aligned to device logical sector size */\n\t\tif ((pos | size) & target->bt_logical_sectormask) {\n\t\t\tif (pos == i_size_read(inode))\n\t\t\t\treturn 0;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tn = mp->m_super->s_maxbytes - pos;\n\tif (n <= 0 || size == 0)\n\t\treturn 0;\n\n\tif (n < size)\n\t\tsize = n;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\t/*\n\t * Locking is a bit tricky here. If we take an exclusive lock\n\t * for direct IO, we effectively serialise all new concurrent\n\t * read IO to this file and block it behind IO that is currently in\n\t * progress because IO in progress holds the IO lock shared. We only\n\t * need to hold the lock exclusive to blow away the page cache, so\n\t * only take lock exclusively if the page cache needs invalidation.\n\t * This allows the normal direct IO case of no page cache pages to\n\t * proceeed concurrently without serialisation.\n\t */\n\txfs_rw_ilock(ip, XFS_IOLOCK_SHARED);\n\tif ((ioflags & XFS_IO_ISDIRECT) && inode->i_mapping->nrpages) {\n\t\txfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);\n\t\txfs_rw_ilock(ip, XFS_IOLOCK_EXCL);\n\n\t\tif (inode->i_mapping->nrpages) {\n\t\t\tret = filemap_write_and_wait_range(\n\t\t\t\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\t\t\t\tpos, pos + size - 1);\n\t\t\tif (ret) {\n\t\t\t\txfs_rw_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Invalidate whole pages. This can return an error if\n\t\t\t * we fail to invalidate a page, but this should never\n\t\t\t * happen on XFS. Warn if it does fail.\n\t\t\t */\n\t\t\tret = invalidate_inode_pages2_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\tpos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t(pos + size - 1) >> PAGE_CACHE_SHIFT);\n\t\t\tWARN_ON_ONCE(ret);\n\t\t\tret = 0;\n\t\t}\n\t\txfs_rw_ilock_demote(ip, XFS_IOLOCK_EXCL);\n\t}\n\n\ttrace_xfs_file_read(ip, size, pos, ioflags);\n\n\tret = generic_file_read_iter(iocb, to);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_read_bytes, ret);\n\n\txfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_rw_iunlock",
          "args": [
            "ip",
            "XFS_IOLOCK_SHARED"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rw_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "62-70",
          "snippet": "static inline void\nxfs_rw_iunlock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_iunlock(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_iunlock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_iunlock(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_ADD",
          "args": [
            "xs_read_bytes",
            "ret"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_read_iter",
          "args": [
            "iocb",
            "to"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_file_read",
          "args": [
            "ip",
            "size",
            "pos",
            "ioflags"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rw_ilock_demote",
          "args": [
            "ip",
            "XFS_IOLOCK_EXCL"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rw_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "72-80",
          "snippet": "static inline void\nxfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "VFS_I(ip)->i_mapping",
            "pos >> PAGE_CACHE_SHIFT",
            "(pos + size - 1) >> PAGE_CACHE_SHIFT"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "VFS_I(ip)->i_mapping",
            "pos",
            "pos + size - 1"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ioflags & XFS_IO_ISDIRECT"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "file->f_flags & O_DIRECT"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_read_calls"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "to"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC ssize_t\nxfs_file_read_iter(\n\tstruct kiocb\t\t*iocb,\n\tstruct iov_iter\t\t*to)\n{\n\tstruct file\t\t*file = iocb->ki_filp;\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tsize_t\t\t\tsize = iov_iter_count(to);\n\tssize_t\t\t\tret = 0;\n\tint\t\t\tioflags = 0;\n\txfs_fsize_t\t\tn;\n\tloff_t\t\t\tpos = iocb->ki_pos;\n\n\tXFS_STATS_INC(xs_read_calls);\n\n\tif (unlikely(file->f_flags & O_DIRECT))\n\t\tioflags |= XFS_IO_ISDIRECT;\n\tif (file->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= XFS_IO_INVIS;\n\n\tif (unlikely(ioflags & XFS_IO_ISDIRECT)) {\n\t\txfs_buftarg_t\t*target =\n\t\t\tXFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp;\n\t\t/* DIO must be aligned to device logical sector size */\n\t\tif ((pos | size) & target->bt_logical_sectormask) {\n\t\t\tif (pos == i_size_read(inode))\n\t\t\t\treturn 0;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tn = mp->m_super->s_maxbytes - pos;\n\tif (n <= 0 || size == 0)\n\t\treturn 0;\n\n\tif (n < size)\n\t\tsize = n;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\t/*\n\t * Locking is a bit tricky here. If we take an exclusive lock\n\t * for direct IO, we effectively serialise all new concurrent\n\t * read IO to this file and block it behind IO that is currently in\n\t * progress because IO in progress holds the IO lock shared. We only\n\t * need to hold the lock exclusive to blow away the page cache, so\n\t * only take lock exclusively if the page cache needs invalidation.\n\t * This allows the normal direct IO case of no page cache pages to\n\t * proceeed concurrently without serialisation.\n\t */\n\txfs_rw_ilock(ip, XFS_IOLOCK_SHARED);\n\tif ((ioflags & XFS_IO_ISDIRECT) && inode->i_mapping->nrpages) {\n\t\txfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);\n\t\txfs_rw_ilock(ip, XFS_IOLOCK_EXCL);\n\n\t\tif (inode->i_mapping->nrpages) {\n\t\t\tret = filemap_write_and_wait_range(\n\t\t\t\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\t\t\t\tpos, pos + size - 1);\n\t\t\tif (ret) {\n\t\t\t\txfs_rw_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Invalidate whole pages. This can return an error if\n\t\t\t * we fail to invalidate a page, but this should never\n\t\t\t * happen on XFS. Warn if it does fail.\n\t\t\t */\n\t\t\tret = invalidate_inode_pages2_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\tpos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t(pos + size - 1) >> PAGE_CACHE_SHIFT);\n\t\t\tWARN_ON_ONCE(ret);\n\t\t\tret = 0;\n\t\t}\n\t\txfs_rw_ilock_demote(ip, XFS_IOLOCK_EXCL);\n\t}\n\n\ttrace_xfs_file_read(ip, size, pos, ioflags);\n\n\tret = generic_file_read_iter(iocb, to);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_read_bytes, ret);\n\n\txfs_rw_iunlock(ip, XFS_IOLOCK_SHARED);\n\treturn ret;\n}"
  },
  {
    "function_name": "xfs_file_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "196-264",
    "snippet": "STATIC int\nxfs_file_fsync(\n\tstruct file\t\t*file,\n\tloff_t\t\t\tstart,\n\tloff_t\t\t\tend,\n\tint\t\t\tdatasync)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flushed = 0;\n\txfs_lsn_t\t\tlsn = 0;\n\n\ttrace_xfs_file_fsync(ip);\n\n\terror = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (error)\n\t\treturn error;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\txfs_iflags_clear(ip, XFS_ITRUNCATED);\n\n\tif (mp->m_flags & XFS_MOUNT_BARRIER) {\n\t\t/*\n\t\t * If we have an RT and/or log subvolume we need to make sure\n\t\t * to flush the write cache the device used for file data\n\t\t * first.  This is to ensure newly written file data make\n\t\t * it to disk before logging the new inode size in case of\n\t\t * an extending write.\n\t\t */\n\t\tif (XFS_IS_REALTIME_INODE(ip))\n\t\t\txfs_blkdev_issue_flush(mp->m_rtdev_targp);\n\t\telse if (mp->m_logdev_targp != mp->m_ddev_targp)\n\t\t\txfs_blkdev_issue_flush(mp->m_ddev_targp);\n\t}\n\n\t/*\n\t * All metadata updates are logged, which means that we just have\n\t * to flush the log up to the latest LSN that touched the inode.\n\t */\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tif (xfs_ipincount(ip)) {\n\t\tif (!datasync ||\n\t\t    (ip->i_itemp->ili_fields & ~XFS_ILOG_TIMESTAMP))\n\t\t\tlsn = ip->i_itemp->ili_last_lsn;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (lsn)\n\t\terror = _xfs_log_force_lsn(mp, lsn, XFS_LOG_SYNC, &log_flushed);\n\n\t/*\n\t * If we only have a single device, and the log force about was\n\t * a no-op we might have to flush the data device cache here.\n\t * This can only happen for fdatasync/O_DSYNC if we were overwriting\n\t * an already allocated file and thus do not have any metadata to\n\t * commit.\n\t */\n\tif ((mp->m_flags & XFS_MOUNT_BARRIER) &&\n\t    mp->m_logdev_targp == mp->m_ddev_targp &&\n\t    !XFS_IS_REALTIME_INODE(ip) &&\n\t    !log_flushed)\n\t\txfs_blkdev_issue_flush(mp->m_ddev_targp);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_blkdev_issue_flush",
          "args": [
            "mp->m_ddev_targp"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_blkdev_issue_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "702-707",
          "snippet": "void\nxfs_blkdev_issue_flush(\n\txfs_buftarg_t\t\t*buftarg)\n{\n\tblkdev_issue_flush(buftarg->bt_bdev, GFP_NOFS, NULL);\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_blkdev_issue_flush(\n\txfs_buftarg_t\t\t*buftarg)\n{\n\tblkdev_issue_flush(buftarg->bt_bdev, GFP_NOFS, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_log_force_lsn",
          "args": [
            "mp",
            "lsn",
            "XFS_LOG_SYNC",
            "&log_flushed"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_log_force_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3332-3445",
          "snippet": "int\n_xfs_log_force_lsn(\n\tstruct xfs_mount\t*mp,\n\txfs_lsn_t\t\tlsn,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\tint\t\t\talready_slept = 0;\n\n\tASSERT(lsn != 0);\n\n\tXFS_STATS_INC(xs_log_force);\n\n\tlsn = xlog_cil_force_lsn(log, lsn);\n\tif (lsn == NULLCOMMITLSN)\n\t\treturn 0;\n\ntry_again:\n\tspin_lock(&log->l_icloglock);\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) != lsn) {\n\t\t\ticlog = iclog->ic_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * We sleep here if we haven't already slept (e.g.\n\t\t\t * this is the first time we've looked at the correct\n\t\t\t * iclog buf) and the buffer before us is going to\n\t\t\t * be sync'ed. The reason for this is that if we\n\t\t\t * are doing sync transactions here, by waiting for\n\t\t\t * the previous I/O to complete, we can allow a few\n\t\t\t * more transactions into this iclog before we close\n\t\t\t * it down.\n\t\t\t *\n\t\t\t * Otherwise, we mark the buffer WANT_SYNC, and bump\n\t\t\t * up the refcnt so we can release the log (which\n\t\t\t * drops the ref count).  The state switch keeps new\n\t\t\t * transaction commits from using this buffer.  When\n\t\t\t * the current commits finish writing into the buffer,\n\t\t\t * the refcount will drop to zero and the buffer will\n\t\t\t * go out then.\n\t\t\t */\n\t\t\tif (!already_slept &&\n\t\t\t    (iclog->ic_prev->ic_state &\n\t\t\t     (XLOG_STATE_WANT_SYNC | XLOG_STATE_SYNCING))) {\n\t\t\t\tASSERT(!(iclog->ic_state & XLOG_STATE_IOERROR));\n\n\t\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\n\t\t\t\txlog_wait(&iclog->ic_prev->ic_write_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\talready_slept = 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\treturn -EIO;\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\tif ((flags & XFS_LOG_SYNC) && /* sleep */\n\t\t    !(iclog->ic_state &\n\t\t      (XLOG_STATE_ACTIVE | XLOG_STATE_DIRTY))) {\n\t\t\t/*\n\t\t\t * Don't wait on completion if we know that we've\n\t\t\t * gotten a log write error.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t\t/*\n\t\t\t * No need to grab the log lock here since we're\n\t\t\t * only deciding whether or not to return EIO\n\t\t\t * and the memory read should be atomic.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t} else {\t\t/* just return */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\n\t\treturn 0;\n\t} while (iclog != log->l_iclog);\n\n\tspin_unlock(&log->l_icloglock);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\n_xfs_log_force_lsn(\n\tstruct xfs_mount\t*mp,\n\txfs_lsn_t\t\tlsn,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\tint\t\t\talready_slept = 0;\n\n\tASSERT(lsn != 0);\n\n\tXFS_STATS_INC(xs_log_force);\n\n\tlsn = xlog_cil_force_lsn(log, lsn);\n\tif (lsn == NULLCOMMITLSN)\n\t\treturn 0;\n\ntry_again:\n\tspin_lock(&log->l_icloglock);\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) != lsn) {\n\t\t\ticlog = iclog->ic_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * We sleep here if we haven't already slept (e.g.\n\t\t\t * this is the first time we've looked at the correct\n\t\t\t * iclog buf) and the buffer before us is going to\n\t\t\t * be sync'ed. The reason for this is that if we\n\t\t\t * are doing sync transactions here, by waiting for\n\t\t\t * the previous I/O to complete, we can allow a few\n\t\t\t * more transactions into this iclog before we close\n\t\t\t * it down.\n\t\t\t *\n\t\t\t * Otherwise, we mark the buffer WANT_SYNC, and bump\n\t\t\t * up the refcnt so we can release the log (which\n\t\t\t * drops the ref count).  The state switch keeps new\n\t\t\t * transaction commits from using this buffer.  When\n\t\t\t * the current commits finish writing into the buffer,\n\t\t\t * the refcount will drop to zero and the buffer will\n\t\t\t * go out then.\n\t\t\t */\n\t\t\tif (!already_slept &&\n\t\t\t    (iclog->ic_prev->ic_state &\n\t\t\t     (XLOG_STATE_WANT_SYNC | XLOG_STATE_SYNCING))) {\n\t\t\t\tASSERT(!(iclog->ic_state & XLOG_STATE_IOERROR));\n\n\t\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\n\t\t\t\txlog_wait(&iclog->ic_prev->ic_write_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\talready_slept = 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\treturn -EIO;\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\tif ((flags & XFS_LOG_SYNC) && /* sleep */\n\t\t    !(iclog->ic_state &\n\t\t      (XLOG_STATE_ACTIVE | XLOG_STATE_DIRTY))) {\n\t\t\t/*\n\t\t\t * Don't wait on completion if we know that we've\n\t\t\t * gotten a log write error.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t\t/*\n\t\t\t * No need to grab the log lock here since we're\n\t\t\t * only deciding whether or not to return EIO\n\t\t\t * and the memory read should be atomic.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t} else {\t\t/* just return */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\n\t\treturn 0;\n\t} while (iclog != log->l_iclog);\n\n\tspin_unlock(&log->l_icloglock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ipincount",
          "args": [
            "ip"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iflags_clear",
          "args": [
            "ip",
            "XFS_ITRUNCATED"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "126-132",
          "snippet": "static inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_file_fsync",
          "args": [
            "ip"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_file_fsync(\n\tstruct file\t\t*file,\n\tloff_t\t\t\tstart,\n\tloff_t\t\t\tend,\n\tint\t\t\tdatasync)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flushed = 0;\n\txfs_lsn_t\t\tlsn = 0;\n\n\ttrace_xfs_file_fsync(ip);\n\n\terror = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (error)\n\t\treturn error;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\txfs_iflags_clear(ip, XFS_ITRUNCATED);\n\n\tif (mp->m_flags & XFS_MOUNT_BARRIER) {\n\t\t/*\n\t\t * If we have an RT and/or log subvolume we need to make sure\n\t\t * to flush the write cache the device used for file data\n\t\t * first.  This is to ensure newly written file data make\n\t\t * it to disk before logging the new inode size in case of\n\t\t * an extending write.\n\t\t */\n\t\tif (XFS_IS_REALTIME_INODE(ip))\n\t\t\txfs_blkdev_issue_flush(mp->m_rtdev_targp);\n\t\telse if (mp->m_logdev_targp != mp->m_ddev_targp)\n\t\t\txfs_blkdev_issue_flush(mp->m_ddev_targp);\n\t}\n\n\t/*\n\t * All metadata updates are logged, which means that we just have\n\t * to flush the log up to the latest LSN that touched the inode.\n\t */\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tif (xfs_ipincount(ip)) {\n\t\tif (!datasync ||\n\t\t    (ip->i_itemp->ili_fields & ~XFS_ILOG_TIMESTAMP))\n\t\t\tlsn = ip->i_itemp->ili_last_lsn;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (lsn)\n\t\terror = _xfs_log_force_lsn(mp, lsn, XFS_LOG_SYNC, &log_flushed);\n\n\t/*\n\t * If we only have a single device, and the log force about was\n\t * a no-op we might have to flush the data device cache here.\n\t * This can only happen for fdatasync/O_DSYNC if we were overwriting\n\t * an already allocated file and thus do not have any metadata to\n\t * commit.\n\t */\n\tif ((mp->m_flags & XFS_MOUNT_BARRIER) &&\n\t    mp->m_logdev_targp == mp->m_ddev_targp &&\n\t    !XFS_IS_REALTIME_INODE(ip) &&\n\t    !log_flushed)\n\t\txfs_blkdev_issue_flush(mp->m_ddev_targp);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dir_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "173-194",
    "snippet": "STATIC int\nxfs_dir_fsync(\n\tstruct file\t\t*file,\n\tloff_t\t\t\tstart,\n\tloff_t\t\t\tend,\n\tint\t\t\tdatasync)\n{\n\tstruct xfs_inode\t*ip = XFS_I(file->f_mapping->host);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_lsn_t\t\tlsn = 0;\n\n\ttrace_xfs_dir_fsync(ip);\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tif (xfs_ipincount(ip))\n\t\tlsn = ip->i_itemp->ili_last_lsn;\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!lsn)\n\t\treturn 0;\n\treturn _xfs_log_force_lsn(mp, lsn, XFS_LOG_SYNC, NULL);\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_xfs_log_force_lsn",
          "args": [
            "mp",
            "lsn",
            "XFS_LOG_SYNC",
            "NULL"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_log_force_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3332-3445",
          "snippet": "int\n_xfs_log_force_lsn(\n\tstruct xfs_mount\t*mp,\n\txfs_lsn_t\t\tlsn,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\tint\t\t\talready_slept = 0;\n\n\tASSERT(lsn != 0);\n\n\tXFS_STATS_INC(xs_log_force);\n\n\tlsn = xlog_cil_force_lsn(log, lsn);\n\tif (lsn == NULLCOMMITLSN)\n\t\treturn 0;\n\ntry_again:\n\tspin_lock(&log->l_icloglock);\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) != lsn) {\n\t\t\ticlog = iclog->ic_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * We sleep here if we haven't already slept (e.g.\n\t\t\t * this is the first time we've looked at the correct\n\t\t\t * iclog buf) and the buffer before us is going to\n\t\t\t * be sync'ed. The reason for this is that if we\n\t\t\t * are doing sync transactions here, by waiting for\n\t\t\t * the previous I/O to complete, we can allow a few\n\t\t\t * more transactions into this iclog before we close\n\t\t\t * it down.\n\t\t\t *\n\t\t\t * Otherwise, we mark the buffer WANT_SYNC, and bump\n\t\t\t * up the refcnt so we can release the log (which\n\t\t\t * drops the ref count).  The state switch keeps new\n\t\t\t * transaction commits from using this buffer.  When\n\t\t\t * the current commits finish writing into the buffer,\n\t\t\t * the refcount will drop to zero and the buffer will\n\t\t\t * go out then.\n\t\t\t */\n\t\t\tif (!already_slept &&\n\t\t\t    (iclog->ic_prev->ic_state &\n\t\t\t     (XLOG_STATE_WANT_SYNC | XLOG_STATE_SYNCING))) {\n\t\t\t\tASSERT(!(iclog->ic_state & XLOG_STATE_IOERROR));\n\n\t\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\n\t\t\t\txlog_wait(&iclog->ic_prev->ic_write_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\talready_slept = 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\treturn -EIO;\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\tif ((flags & XFS_LOG_SYNC) && /* sleep */\n\t\t    !(iclog->ic_state &\n\t\t      (XLOG_STATE_ACTIVE | XLOG_STATE_DIRTY))) {\n\t\t\t/*\n\t\t\t * Don't wait on completion if we know that we've\n\t\t\t * gotten a log write error.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t\t/*\n\t\t\t * No need to grab the log lock here since we're\n\t\t\t * only deciding whether or not to return EIO\n\t\t\t * and the memory read should be atomic.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t} else {\t\t/* just return */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\n\t\treturn 0;\n\t} while (iclog != log->l_iclog);\n\n\tspin_unlock(&log->l_icloglock);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\n_xfs_log_force_lsn(\n\tstruct xfs_mount\t*mp,\n\txfs_lsn_t\t\tlsn,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\tint\t\t\talready_slept = 0;\n\n\tASSERT(lsn != 0);\n\n\tXFS_STATS_INC(xs_log_force);\n\n\tlsn = xlog_cil_force_lsn(log, lsn);\n\tif (lsn == NULLCOMMITLSN)\n\t\treturn 0;\n\ntry_again:\n\tspin_lock(&log->l_icloglock);\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) != lsn) {\n\t\t\ticlog = iclog->ic_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * We sleep here if we haven't already slept (e.g.\n\t\t\t * this is the first time we've looked at the correct\n\t\t\t * iclog buf) and the buffer before us is going to\n\t\t\t * be sync'ed. The reason for this is that if we\n\t\t\t * are doing sync transactions here, by waiting for\n\t\t\t * the previous I/O to complete, we can allow a few\n\t\t\t * more transactions into this iclog before we close\n\t\t\t * it down.\n\t\t\t *\n\t\t\t * Otherwise, we mark the buffer WANT_SYNC, and bump\n\t\t\t * up the refcnt so we can release the log (which\n\t\t\t * drops the ref count).  The state switch keeps new\n\t\t\t * transaction commits from using this buffer.  When\n\t\t\t * the current commits finish writing into the buffer,\n\t\t\t * the refcount will drop to zero and the buffer will\n\t\t\t * go out then.\n\t\t\t */\n\t\t\tif (!already_slept &&\n\t\t\t    (iclog->ic_prev->ic_state &\n\t\t\t     (XLOG_STATE_WANT_SYNC | XLOG_STATE_SYNCING))) {\n\t\t\t\tASSERT(!(iclog->ic_state & XLOG_STATE_IOERROR));\n\n\t\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\n\t\t\t\txlog_wait(&iclog->ic_prev->ic_write_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\talready_slept = 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\treturn -EIO;\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\tif ((flags & XFS_LOG_SYNC) && /* sleep */\n\t\t    !(iclog->ic_state &\n\t\t      (XLOG_STATE_ACTIVE | XLOG_STATE_DIRTY))) {\n\t\t\t/*\n\t\t\t * Don't wait on completion if we know that we've\n\t\t\t * gotten a log write error.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t\t/*\n\t\t\t * No need to grab the log lock here since we're\n\t\t\t * only deciding whether or not to return EIO\n\t\t\t * and the memory read should be atomic.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t} else {\t\t/* just return */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\n\t\treturn 0;\n\t} while (iclog != log->l_iclog);\n\n\tspin_unlock(&log->l_icloglock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ipincount",
          "args": [
            "ip"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir_fsync",
          "args": [
            "ip"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dir_fsync(\n\tstruct file\t\t*file,\n\tloff_t\t\t\tstart,\n\tloff_t\t\t\tend,\n\tint\t\t\tdatasync)\n{\n\tstruct xfs_inode\t*ip = XFS_I(file->f_mapping->host);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_lsn_t\t\tlsn = 0;\n\n\ttrace_xfs_dir_fsync(ip);\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\tif (xfs_ipincount(ip))\n\t\tlsn = ip->i_itemp->ili_last_lsn;\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!lsn)\n\t\treturn 0;\n\treturn _xfs_log_force_lsn(mp, lsn, XFS_LOG_SYNC, NULL);\n}"
  },
  {
    "function_name": "xfs_update_prealloc_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "131-165",
    "snippet": "int\nxfs_update_prealloc_flags(\n\tstruct xfs_inode\t*ip,\n\tenum xfs_prealloc_flags\tflags)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(ip->i_mount, XFS_TRANS_WRITEID);\n\terror = xfs_trans_reserve(tp, &M_RES(ip->i_mount)->tr_writeid, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tif (!(flags & XFS_PREALLOC_INVISIBLE)) {\n\t\tip->i_d.di_mode &= ~S_ISUID;\n\t\tif (ip->i_d.di_mode & S_IXGRP)\n\t\t\tip->i_d.di_mode &= ~S_ISGID;\n\t\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\t}\n\n\tif (flags & XFS_PREALLOC_SET)\n\t\tip->i_d.di_flags |= XFS_DIFLAG_PREALLOC;\n\tif (flags & XFS_PREALLOC_CLEAR)\n\t\tip->i_d.di_flags &= ~XFS_DIFLAG_PREALLOC;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tif (flags & XFS_PREALLOC_SYNC)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "tp",
            "ip",
            "XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(ip->i_mount)->tr_writeid",
            "0",
            "0"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "ip->i_mount"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "ip->i_mount",
            "XFS_TRANS_WRITEID"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_update_prealloc_flags(\n\tstruct xfs_inode\t*ip,\n\tenum xfs_prealloc_flags\tflags)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = xfs_trans_alloc(ip->i_mount, XFS_TRANS_WRITEID);\n\terror = xfs_trans_reserve(tp, &M_RES(ip->i_mount)->tr_writeid, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tif (!(flags & XFS_PREALLOC_INVISIBLE)) {\n\t\tip->i_d.di_mode &= ~S_ISUID;\n\t\tif (ip->i_d.di_mode & S_IXGRP)\n\t\t\tip->i_d.di_mode &= ~S_ISGID;\n\t\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\t}\n\n\tif (flags & XFS_PREALLOC_SET)\n\t\tip->i_d.di_flags |= XFS_DIFLAG_PREALLOC;\n\tif (flags & XFS_PREALLOC_CLEAR)\n\t\tip->i_d.di_flags &= ~XFS_DIFLAG_PREALLOC;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tif (flags & XFS_PREALLOC_SYNC)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
  },
  {
    "function_name": "xfs_iozero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "92-129",
    "snippet": "int\nxfs_iozero(\n\tstruct xfs_inode\t*ip,\t/* inode\t\t\t*/\n\tloff_t\t\t\tpos,\t/* offset in file\t\t*/\n\tsize_t\t\t\tcount)\t/* size of data to zero\t\t*/\n{\n\tstruct page\t\t*page;\n\tstruct address_space\t*mapping;\n\tint\t\t\tstatus;\n\n\tmapping = VFS_I(ip)->i_mapping;\n\tdo {\n\t\tunsigned offset, bytes;\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_CACHE_SIZE -1)); /* Within page */\n\t\tbytes = PAGE_CACHE_SIZE - offset;\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\n\t\tstatus = pagecache_write_begin(NULL, mapping, pos, bytes,\n\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t&page, &fsdata);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tzero_user(page, offset, bytes);\n\n\t\tstatus = pagecache_write_end(NULL, mapping, pos, bytes, bytes,\n\t\t\t\t\tpage, fsdata);\n\t\tWARN_ON(status <= 0); /* can't return less than zero! */\n\t\tpos += bytes;\n\t\tcount -= bytes;\n\t\tstatus = 0;\n\t} while (count);\n\n\treturn (-status);\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "status <= 0"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_end",
          "args": [
            "NULL",
            "mapping",
            "pos",
            "bytes",
            "bytes",
            "page",
            "fsdata"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "offset",
            "bytes"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_begin",
          "args": [
            "NULL",
            "mapping",
            "pos",
            "bytes",
            "AOP_FLAG_UNINTERRUPTIBLE",
            "&page",
            "&fsdata"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_iozero(\n\tstruct xfs_inode\t*ip,\t/* inode\t\t\t*/\n\tloff_t\t\t\tpos,\t/* offset in file\t\t*/\n\tsize_t\t\t\tcount)\t/* size of data to zero\t\t*/\n{\n\tstruct page\t\t*page;\n\tstruct address_space\t*mapping;\n\tint\t\t\tstatus;\n\n\tmapping = VFS_I(ip)->i_mapping;\n\tdo {\n\t\tunsigned offset, bytes;\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_CACHE_SIZE -1)); /* Within page */\n\t\tbytes = PAGE_CACHE_SIZE - offset;\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\n\t\tstatus = pagecache_write_begin(NULL, mapping, pos, bytes,\n\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t&page, &fsdata);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tzero_user(page, offset, bytes);\n\n\t\tstatus = pagecache_write_end(NULL, mapping, pos, bytes, bytes,\n\t\t\t\t\tpage, fsdata);\n\t\tWARN_ON(status <= 0); /* can't return less than zero! */\n\t\tpos += bytes;\n\t\tcount -= bytes;\n\t\tstatus = 0;\n\t} while (count);\n\n\treturn (-status);\n}"
  },
  {
    "function_name": "xfs_rw_ilock_demote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "72-80",
    "snippet": "static inline void\nxfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&VFS_I(ip)->i_mutex"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_demote",
          "args": [
            "ip",
            "type"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}"
  },
  {
    "function_name": "xfs_rw_iunlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "62-70",
    "snippet": "static inline void\nxfs_rw_iunlock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_iunlock(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&VFS_I(ip)->i_mutex"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "type"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_iunlock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_iunlock(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}"
  },
  {
    "function_name": "xfs_rw_ilock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
    "lines": "52-60",
    "snippet": "static inline void\nxfs_rw_ilock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_lock(&VFS_I(ip)->i_mutex);\n\txfs_ilock(ip, type);\n}",
    "includes": [
      "#include <linux/pagevec.h>",
      "#include <linux/falloc.h>",
      "#include <linux/dcache.h>",
      "#include <linux/aio.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "type"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&VFS_I(ip)->i_mutex"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_rw_ilock(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_lock(&VFS_I(ip)->i_mutex);\n\txfs_ilock(ip, type);\n}"
  }
]