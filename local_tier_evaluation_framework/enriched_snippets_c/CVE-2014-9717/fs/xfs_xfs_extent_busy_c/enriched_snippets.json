[
  {
    "function_name": "xfs_extent_busy_ag_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
    "lines": "596-604",
    "snippet": "int\nxfs_extent_busy_ag_cmp(\n\tvoid\t\t\t*priv,\n\tstruct list_head\t*a,\n\tstruct list_head\t*b)\n{\n\treturn container_of(a, struct xfs_extent_busy, list)->agno -\n\t\tcontainer_of(b, struct xfs_extent_busy, list)->agno;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "structxfs_extent_busy",
            "list"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "structxfs_extent_busy",
            "list"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_extent_busy_ag_cmp(\n\tvoid\t\t\t*priv,\n\tstruct list_head\t*a,\n\tstruct list_head\t*b)\n{\n\treturn container_of(a, struct xfs_extent_busy, list)->agno -\n\t\tcontainer_of(b, struct xfs_extent_busy, list)->agno;\n}"
  },
  {
    "function_name": "xfs_extent_busy_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
    "lines": "559-591",
    "snippet": "void\nxfs_extent_busy_clear(\n\tstruct xfs_mount\t*mp,\n\tstruct list_head\t*list,\n\tbool\t\t\tdo_discard)\n{\n\tstruct xfs_extent_busy\t*busyp, *n;\n\tstruct xfs_perag\t*pag = NULL;\n\txfs_agnumber_t\t\tagno = NULLAGNUMBER;\n\n\tlist_for_each_entry_safe(busyp, n, list, list) {\n\t\tif (busyp->agno != agno) {\n\t\t\tif (pag) {\n\t\t\t\tspin_unlock(&pag->pagb_lock);\n\t\t\t\txfs_perag_put(pag);\n\t\t\t}\n\t\t\tpag = xfs_perag_get(mp, busyp->agno);\n\t\t\tspin_lock(&pag->pagb_lock);\n\t\t\tagno = busyp->agno;\n\t\t}\n\n\t\tif (do_discard && busyp->length &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_SKIP_DISCARD))\n\t\t\tbusyp->flags = XFS_EXTENT_BUSY_DISCARDED;\n\t\telse\n\t\t\txfs_extent_busy_clear_one(mp, pag, busyp);\n\t}\n\n\tif (pag) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\txfs_perag_put(pag);\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_clear_one",
          "args": [
            "mp",
            "pag",
            "busyp"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_clear_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "538-552",
          "snippet": "STATIC void\nxfs_extent_busy_clear_one(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_extent_busy\t*busyp)\n{\n\tif (busyp->length) {\n\t\ttrace_xfs_extent_busy_clear(mp, busyp->agno, busyp->bno,\n\t\t\t\t\t\tbusyp->length);\n\t\trb_erase(&busyp->rb_node, &pag->pagb_tree);\n\t}\n\n\tlist_del_init(&busyp->list);\n\tkmem_free(busyp);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_extent_busy_clear_one(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_extent_busy\t*busyp)\n{\n\tif (busyp->length) {\n\t\ttrace_xfs_extent_busy_clear(mp, busyp->agno, busyp->bno,\n\t\t\t\t\t\tbusyp->length);\n\t\trb_erase(&busyp->rb_node, &pag->pagb_tree);\n\t}\n\n\tlist_del_init(&busyp->list);\n\tkmem_free(busyp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "busyp->agno"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "busyp",
            "n",
            "list",
            "list"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_extent_busy_clear(\n\tstruct xfs_mount\t*mp,\n\tstruct list_head\t*list,\n\tbool\t\t\tdo_discard)\n{\n\tstruct xfs_extent_busy\t*busyp, *n;\n\tstruct xfs_perag\t*pag = NULL;\n\txfs_agnumber_t\t\tagno = NULLAGNUMBER;\n\n\tlist_for_each_entry_safe(busyp, n, list, list) {\n\t\tif (busyp->agno != agno) {\n\t\t\tif (pag) {\n\t\t\t\tspin_unlock(&pag->pagb_lock);\n\t\t\t\txfs_perag_put(pag);\n\t\t\t}\n\t\t\tpag = xfs_perag_get(mp, busyp->agno);\n\t\t\tspin_lock(&pag->pagb_lock);\n\t\t\tagno = busyp->agno;\n\t\t}\n\n\t\tif (do_discard && busyp->length &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_SKIP_DISCARD))\n\t\t\tbusyp->flags = XFS_EXTENT_BUSY_DISCARDED;\n\t\telse\n\t\t\txfs_extent_busy_clear_one(mp, pag, busyp);\n\t}\n\n\tif (pag) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\txfs_perag_put(pag);\n\t}\n}"
  },
  {
    "function_name": "xfs_extent_busy_clear_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
    "lines": "538-552",
    "snippet": "STATIC void\nxfs_extent_busy_clear_one(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_extent_busy\t*busyp)\n{\n\tif (busyp->length) {\n\t\ttrace_xfs_extent_busy_clear(mp, busyp->agno, busyp->bno,\n\t\t\t\t\t\tbusyp->length);\n\t\trb_erase(&busyp->rb_node, &pag->pagb_tree);\n\t}\n\n\tlist_del_init(&busyp->list);\n\tkmem_free(busyp);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "busyp"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&busyp->list"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&busyp->rb_node",
            "&pag->pagb_tree"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_extent_busy_clear",
          "args": [
            "mp",
            "busyp->agno",
            "busyp->bno",
            "busyp->length"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_extent_busy_clear_one(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_extent_busy\t*busyp)\n{\n\tif (busyp->length) {\n\t\ttrace_xfs_extent_busy_clear(mp, busyp->agno, busyp->bno,\n\t\t\t\t\t\tbusyp->length);\n\t\trb_erase(&busyp->rb_node, &pag->pagb_tree);\n\t}\n\n\tlist_del_init(&busyp->list);\n\tkmem_free(busyp);\n}"
  },
  {
    "function_name": "xfs_extent_busy_trim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
    "lines": "349-536",
    "snippet": "void\nxfs_extent_busy_trim(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\txfs_agblock_t\t\t*rbno,\n\txfs_extlen_t\t\t*rlen)\n{\n\txfs_agblock_t\t\tfbno;\n\txfs_extlen_t\t\tflen;\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(len > 0);\n\n\tspin_lock(&args->pag->pagb_lock);\nrestart:\n\tfbno = bno;\n\tflen = len;\n\trbp = args->pag->pagb_tree.rb_node;\n\twhile (rbp && flen >= args->minlen) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tfend = fbno + flen;\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fend <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is a metadata allocation, try to reuse the busy\n\t\t * extent instead of trimming the allocation.\n\t\t */\n\t\tif (!args->userdata &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_DISCARDED)) {\n\t\t\tif (!xfs_extent_busy_update_extent(args->mp, args->pag,\n\t\t\t\t\t\t\t  busyp, fbno, flen,\n\t\t\t\t\t\t\t  false))\n\t\t\t\tgoto restart;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bbno <= fbno) {\n\t\t\t/* start overlap */\n\n\t\t\t/*\n\t\t\t * Case 1:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +---------+\n\t\t\t *        fbno   fend\n\t\t\t *\n\t\t\t * Case 2:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-------------+\n\t\t\t *    fbno       fend\n\t\t\t *\n\t\t\t * Case 3:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +-------------+\n\t\t\t *        fbno       fend\n\t\t\t *\n\t\t\t * Case 4:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-----------------+\n\t\t\t *    fbno           fend\n\t\t\t *\n\t\t\t * No unbusy region in extent, return failure.\n\t\t\t */\n\t\t\tif (fend <= bend)\n\t\t\t\tgoto fail;\n\n\t\t\t/*\n\t\t\t * Case 5:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +----------------------+\n\t\t\t *        fbno                fend\n\t\t\t *\n\t\t\t * Case 6:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +--------------------------+\n\t\t\t *    fbno                    fend\n\t\t\t *\n\t\t\t * Needs to be trimmed to:\n\t\t\t *                       +-------+\n\t\t\t *                       fbno fend\n\t\t\t */\n\t\t\tfbno = bend;\n\t\t} else if (bend >= fend) {\n\t\t\t/* end overlap */\n\n\t\t\t/*\n\t\t\t * Case 7:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +------------------+\n\t\t\t *    fbno            fend\n\t\t\t *\n\t\t\t * Case 8:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +--------------------------+\n\t\t\t *    fbno                    fend\n\t\t\t *\n\t\t\t * Needs to be trimmed to:\n\t\t\t *    +-------+\n\t\t\t *    fbno fend\n\t\t\t */\n\t\t\tfend = bbno;\n\t\t} else {\n\t\t\t/* middle overlap */\n\n\t\t\t/*\n\t\t\t * Case 9:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-----------------------------------+\n\t\t\t *    fbno                             fend\n\t\t\t *\n\t\t\t * Can be trimmed to:\n\t\t\t *    +-------+        OR         +-------+\n\t\t\t *    fbno fend                   fbno fend\n\t\t\t *\n\t\t\t * Backward allocation leads to significant\n\t\t\t * fragmentation of directories, which degrades\n\t\t\t * directory performance, therefore we always want to\n\t\t\t * choose the option that produces forward allocation\n\t\t\t * patterns.\n\t\t\t * Preferring the lower bno extent will make the next\n\t\t\t * request use \"fend\" as the start of the next\n\t\t\t * allocation;  if the segment is no longer busy at\n\t\t\t * that point, we'll get a contiguous allocation, but\n\t\t\t * even if it is still busy, we will get a forward\n\t\t\t * allocation.\n\t\t\t * We try to avoid choosing the segment at \"bend\",\n\t\t\t * because that can lead to the next allocation\n\t\t\t * taking the segment at \"fbno\", which would be a\n\t\t\t * backward allocation.  We only use the segment at\n\t\t\t * \"fbno\" if it is much larger than the current\n\t\t\t * requested size, because in that case there's a\n\t\t\t * good chance subsequent allocations will be\n\t\t\t * contiguous.\n\t\t\t */\n\t\t\tif (bbno - fbno >= args->maxlen) {\n\t\t\t\t/* left candidate fits perfect */\n\t\t\t\tfend = bbno;\n\t\t\t} else if (fend - bend >= args->maxlen * 4) {\n\t\t\t\t/* right candidate has enough free space */\n\t\t\t\tfbno = bend;\n\t\t\t} else if (bbno - fbno >= args->minlen) {\n\t\t\t\t/* left candidate fits minimum requirement */\n\t\t\t\tfend = bbno;\n\t\t\t} else {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\tflen = fend - fbno;\n\t}\n\tspin_unlock(&args->pag->pagb_lock);\n\n\tif (fbno != bno || flen != len) {\n\t\ttrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len,\n\t\t\t\t\t  fbno, flen);\n\t}\n\t*rbno = fbno;\n\t*rlen = flen;\n\treturn;\nfail:\n\t/*\n\t * Return a zero extent length as failure indications.  All callers\n\t * re-check if the trimmed extent satisfies the minlen requirement.\n\t */\n\tspin_unlock(&args->pag->pagb_lock);\n\ttrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len, fbno, 0);\n\t*rbno = fbno;\n\t*rlen = 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_extent_busy_trim",
          "args": [
            "args->mp",
            "args->agno",
            "bno",
            "len",
            "fbno",
            "0"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&args->pag->pagb_lock"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_extent_busy_trim",
          "args": [
            "args->mp",
            "args->agno",
            "bno",
            "len",
            "fbno",
            "flen"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_update_extent",
          "args": [
            "args->mp",
            "args->pag",
            "busyp",
            "fbno",
            "flen",
            "false"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_update_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "156-298",
          "snippet": "STATIC bool\nxfs_extent_busy_update_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_extent_busy\t*busyp,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata) __releases(&pag->pagb_lock)\n\t\t\t\t\t  __acquires(&pag->pagb_lock)\n{\n\txfs_agblock_t\t\tfend = fbno + flen;\n\txfs_agblock_t\t\tbbno = busyp->bno;\n\txfs_agblock_t\t\tbend = bbno + busyp->length;\n\n\t/*\n\t * This extent is currently being discarded.  Give the thread\n\t * performing the discard a chance to mark the extent unbusy\n\t * and retry.\n\t */\n\tif (busyp->flags & XFS_EXTENT_BUSY_DISCARDED) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\tdelay(1);\n\t\tspin_lock(&pag->pagb_lock);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If there is a busy extent overlapping a user allocation, we have\n\t * no choice but to force the log and retry the search.\n\t *\n\t * Fortunately this does not happen during normal operation, but\n\t * only if the filesystem is very low on space and has to dip into\n\t * the AGFL for normal allocations.\n\t */\n\tif (userdata)\n\t\tgoto out_force_log;\n\n\tif (bbno < fbno && bend > fend) {\n\t\t/*\n\t\t * Case 1:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +---------+\n\t\t *        fbno   fend\n\t\t */\n\n\t\t/*\n\t\t * We would have to split the busy extent to be able to track\n\t\t * it correct, which we cannot do because we would have to\n\t\t * modify the list of busy extents attached to the transaction\n\t\t * or CIL context, which is immutable.\n\t\t *\n\t\t * Force out the log to clear the busy extent and retry the\n\t\t * search.\n\t\t */\n\t\tgoto out_force_log;\n\t} else if (bbno >= fbno && bend <= fend) {\n\t\t/*\n\t\t * Case 2:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *    +-----------------+\n\t\t *    fbno           fend\n\t\t *\n\t\t * Case 3:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *    +--------------------------+\n\t\t *    fbno                    fend\n\t\t *\n\t\t * Case 4:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +--------------------------+\n\t\t *    fbno                    fend\n\t\t *\n\t\t * Case 5:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +-----------------------------------+\n\t\t *    fbno                             fend\n\t\t *\n\t\t */\n\n\t\t/*\n\t\t * The busy extent is fully covered by the extent we are\n\t\t * allocating, and can simply be removed from the rbtree.\n\t\t * However we cannot remove it from the immutable list\n\t\t * tracking busy extents in the transaction or CIL context,\n\t\t * so set the length to zero to mark it invalid.\n\t\t *\n\t\t * We also need to restart the busy extent search from the\n\t\t * tree root, because erasing the node can rearrange the\n\t\t * tree topology.\n\t\t */\n\t\trb_erase(&busyp->rb_node, &pag->pagb_tree);\n\t\tbusyp->length = 0;\n\t\treturn false;\n\t} else if (fend < bend) {\n\t\t/*\n\t\t * Case 6:\n\t\t *              bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *             +---------+\n\t\t *             fbno   fend\n\t\t *\n\t\t * Case 7:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +------------------+\n\t\t *    fbno            fend\n\t\t *\n\t\t */\n\t\tbusyp->bno = fend;\n\t} else if (bbno < fbno) {\n\t\t/*\n\t\t * Case 8:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +-------------+\n\t\t *        fbno       fend\n\t\t *\n\t\t * Case 9:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +----------------------+\n\t\t *        fbno                fend\n\t\t */\n\t\tbusyp->length = fbno - busyp->bno;\n\t} else {\n\t\tASSERT(0);\n\t}\n\n\ttrace_xfs_extent_busy_reuse(mp, pag->pag_agno, fbno, flen);\n\treturn true;\n\nout_force_log:\n\tspin_unlock(&pag->pagb_lock);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\ttrace_xfs_extent_busy_force(mp, pag->pag_agno, fbno, flen);\n\tspin_lock(&pag->pagb_lock);\n\treturn false;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_extent_busy_update_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_extent_busy\t*busyp,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata) __releases(&pag->pagb_lock)\n\t\t\t\t\t  __acquires(&pag->pagb_lock)\n{\n\txfs_agblock_t\t\tfend = fbno + flen;\n\txfs_agblock_t\t\tbbno = busyp->bno;\n\txfs_agblock_t\t\tbend = bbno + busyp->length;\n\n\t/*\n\t * This extent is currently being discarded.  Give the thread\n\t * performing the discard a chance to mark the extent unbusy\n\t * and retry.\n\t */\n\tif (busyp->flags & XFS_EXTENT_BUSY_DISCARDED) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\tdelay(1);\n\t\tspin_lock(&pag->pagb_lock);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If there is a busy extent overlapping a user allocation, we have\n\t * no choice but to force the log and retry the search.\n\t *\n\t * Fortunately this does not happen during normal operation, but\n\t * only if the filesystem is very low on space and has to dip into\n\t * the AGFL for normal allocations.\n\t */\n\tif (userdata)\n\t\tgoto out_force_log;\n\n\tif (bbno < fbno && bend > fend) {\n\t\t/*\n\t\t * Case 1:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +---------+\n\t\t *        fbno   fend\n\t\t */\n\n\t\t/*\n\t\t * We would have to split the busy extent to be able to track\n\t\t * it correct, which we cannot do because we would have to\n\t\t * modify the list of busy extents attached to the transaction\n\t\t * or CIL context, which is immutable.\n\t\t *\n\t\t * Force out the log to clear the busy extent and retry the\n\t\t * search.\n\t\t */\n\t\tgoto out_force_log;\n\t} else if (bbno >= fbno && bend <= fend) {\n\t\t/*\n\t\t * Case 2:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *    +-----------------+\n\t\t *    fbno           fend\n\t\t *\n\t\t * Case 3:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *    +--------------------------+\n\t\t *    fbno                    fend\n\t\t *\n\t\t * Case 4:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +--------------------------+\n\t\t *    fbno                    fend\n\t\t *\n\t\t * Case 5:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +-----------------------------------+\n\t\t *    fbno                             fend\n\t\t *\n\t\t */\n\n\t\t/*\n\t\t * The busy extent is fully covered by the extent we are\n\t\t * allocating, and can simply be removed from the rbtree.\n\t\t * However we cannot remove it from the immutable list\n\t\t * tracking busy extents in the transaction or CIL context,\n\t\t * so set the length to zero to mark it invalid.\n\t\t *\n\t\t * We also need to restart the busy extent search from the\n\t\t * tree root, because erasing the node can rearrange the\n\t\t * tree topology.\n\t\t */\n\t\trb_erase(&busyp->rb_node, &pag->pagb_tree);\n\t\tbusyp->length = 0;\n\t\treturn false;\n\t} else if (fend < bend) {\n\t\t/*\n\t\t * Case 6:\n\t\t *              bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *             +---------+\n\t\t *             fbno   fend\n\t\t *\n\t\t * Case 7:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +------------------+\n\t\t *    fbno            fend\n\t\t *\n\t\t */\n\t\tbusyp->bno = fend;\n\t} else if (bbno < fbno) {\n\t\t/*\n\t\t * Case 8:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +-------------+\n\t\t *        fbno       fend\n\t\t *\n\t\t * Case 9:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +----------------------+\n\t\t *        fbno                fend\n\t\t */\n\t\tbusyp->length = fbno - busyp->bno;\n\t} else {\n\t\tASSERT(0);\n\t}\n\n\ttrace_xfs_extent_busy_reuse(mp, pag->pag_agno, fbno, flen);\n\treturn true;\n\nout_force_log:\n\tspin_unlock(&pag->pagb_lock);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\ttrace_xfs_extent_busy_force(mp, pag->pag_agno, fbno, flen);\n\tspin_lock(&pag->pagb_lock);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structxfs_extent_busy",
            "rb_node"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&args->pag->pagb_lock"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len > 0"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_extent_busy_trim(\n\tstruct xfs_alloc_arg\t*args,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\txfs_agblock_t\t\t*rbno,\n\txfs_extlen_t\t\t*rlen)\n{\n\txfs_agblock_t\t\tfbno;\n\txfs_extlen_t\t\tflen;\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(len > 0);\n\n\tspin_lock(&args->pag->pagb_lock);\nrestart:\n\tfbno = bno;\n\tflen = len;\n\trbp = args->pag->pagb_tree.rb_node;\n\twhile (rbp && flen >= args->minlen) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tfend = fbno + flen;\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fend <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If this is a metadata allocation, try to reuse the busy\n\t\t * extent instead of trimming the allocation.\n\t\t */\n\t\tif (!args->userdata &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_DISCARDED)) {\n\t\t\tif (!xfs_extent_busy_update_extent(args->mp, args->pag,\n\t\t\t\t\t\t\t  busyp, fbno, flen,\n\t\t\t\t\t\t\t  false))\n\t\t\t\tgoto restart;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bbno <= fbno) {\n\t\t\t/* start overlap */\n\n\t\t\t/*\n\t\t\t * Case 1:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +---------+\n\t\t\t *        fbno   fend\n\t\t\t *\n\t\t\t * Case 2:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-------------+\n\t\t\t *    fbno       fend\n\t\t\t *\n\t\t\t * Case 3:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +-------------+\n\t\t\t *        fbno       fend\n\t\t\t *\n\t\t\t * Case 4:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-----------------+\n\t\t\t *    fbno           fend\n\t\t\t *\n\t\t\t * No unbusy region in extent, return failure.\n\t\t\t */\n\t\t\tif (fend <= bend)\n\t\t\t\tgoto fail;\n\n\t\t\t/*\n\t\t\t * Case 5:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *        +----------------------+\n\t\t\t *        fbno                fend\n\t\t\t *\n\t\t\t * Case 6:\n\t\t\t *    bbno           bend\n\t\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +--------------------------+\n\t\t\t *    fbno                    fend\n\t\t\t *\n\t\t\t * Needs to be trimmed to:\n\t\t\t *                       +-------+\n\t\t\t *                       fbno fend\n\t\t\t */\n\t\t\tfbno = bend;\n\t\t} else if (bend >= fend) {\n\t\t\t/* end overlap */\n\n\t\t\t/*\n\t\t\t * Case 7:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +------------------+\n\t\t\t *    fbno            fend\n\t\t\t *\n\t\t\t * Case 8:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +--------------------------+\n\t\t\t *    fbno                    fend\n\t\t\t *\n\t\t\t * Needs to be trimmed to:\n\t\t\t *    +-------+\n\t\t\t *    fbno fend\n\t\t\t */\n\t\t\tfend = bbno;\n\t\t} else {\n\t\t\t/* middle overlap */\n\n\t\t\t/*\n\t\t\t * Case 9:\n\t\t\t *             bbno           bend\n\t\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t\t *    +-----------------------------------+\n\t\t\t *    fbno                             fend\n\t\t\t *\n\t\t\t * Can be trimmed to:\n\t\t\t *    +-------+        OR         +-------+\n\t\t\t *    fbno fend                   fbno fend\n\t\t\t *\n\t\t\t * Backward allocation leads to significant\n\t\t\t * fragmentation of directories, which degrades\n\t\t\t * directory performance, therefore we always want to\n\t\t\t * choose the option that produces forward allocation\n\t\t\t * patterns.\n\t\t\t * Preferring the lower bno extent will make the next\n\t\t\t * request use \"fend\" as the start of the next\n\t\t\t * allocation;  if the segment is no longer busy at\n\t\t\t * that point, we'll get a contiguous allocation, but\n\t\t\t * even if it is still busy, we will get a forward\n\t\t\t * allocation.\n\t\t\t * We try to avoid choosing the segment at \"bend\",\n\t\t\t * because that can lead to the next allocation\n\t\t\t * taking the segment at \"fbno\", which would be a\n\t\t\t * backward allocation.  We only use the segment at\n\t\t\t * \"fbno\" if it is much larger than the current\n\t\t\t * requested size, because in that case there's a\n\t\t\t * good chance subsequent allocations will be\n\t\t\t * contiguous.\n\t\t\t */\n\t\t\tif (bbno - fbno >= args->maxlen) {\n\t\t\t\t/* left candidate fits perfect */\n\t\t\t\tfend = bbno;\n\t\t\t} else if (fend - bend >= args->maxlen * 4) {\n\t\t\t\t/* right candidate has enough free space */\n\t\t\t\tfbno = bend;\n\t\t\t} else if (bbno - fbno >= args->minlen) {\n\t\t\t\t/* left candidate fits minimum requirement */\n\t\t\t\tfend = bbno;\n\t\t\t} else {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\tflen = fend - fbno;\n\t}\n\tspin_unlock(&args->pag->pagb_lock);\n\n\tif (fbno != bno || flen != len) {\n\t\ttrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len,\n\t\t\t\t\t  fbno, flen);\n\t}\n\t*rbno = fbno;\n\t*rlen = flen;\n\treturn;\nfail:\n\t/*\n\t * Return a zero extent length as failure indications.  All callers\n\t * re-check if the trimmed extent satisfies the minlen requirement.\n\t */\n\tspin_unlock(&args->pag->pagb_lock);\n\ttrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len, fbno, 0);\n\t*rbno = fbno;\n\t*rlen = 0;\n}"
  },
  {
    "function_name": "xfs_extent_busy_reuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
    "lines": "304-341",
    "snippet": "void\nxfs_extent_busy_reuse(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(flen > 0);\n\n\tpag = xfs_perag_get(mp, agno);\n\tspin_lock(&pag->pagb_lock);\nrestart:\n\trbp = pag->pagb_tree.rb_node;\n\twhile (rbp) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fbno + flen <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!xfs_extent_busy_update_extent(mp, pag, busyp, fbno, flen,\n\t\t\t\t\t\t  userdata))\n\t\t\tgoto restart;\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_update_extent",
          "args": [
            "mp",
            "pag",
            "busyp",
            "fbno",
            "flen",
            "userdata"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_update_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "156-298",
          "snippet": "STATIC bool\nxfs_extent_busy_update_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_extent_busy\t*busyp,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata) __releases(&pag->pagb_lock)\n\t\t\t\t\t  __acquires(&pag->pagb_lock)\n{\n\txfs_agblock_t\t\tfend = fbno + flen;\n\txfs_agblock_t\t\tbbno = busyp->bno;\n\txfs_agblock_t\t\tbend = bbno + busyp->length;\n\n\t/*\n\t * This extent is currently being discarded.  Give the thread\n\t * performing the discard a chance to mark the extent unbusy\n\t * and retry.\n\t */\n\tif (busyp->flags & XFS_EXTENT_BUSY_DISCARDED) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\tdelay(1);\n\t\tspin_lock(&pag->pagb_lock);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If there is a busy extent overlapping a user allocation, we have\n\t * no choice but to force the log and retry the search.\n\t *\n\t * Fortunately this does not happen during normal operation, but\n\t * only if the filesystem is very low on space and has to dip into\n\t * the AGFL for normal allocations.\n\t */\n\tif (userdata)\n\t\tgoto out_force_log;\n\n\tif (bbno < fbno && bend > fend) {\n\t\t/*\n\t\t * Case 1:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +---------+\n\t\t *        fbno   fend\n\t\t */\n\n\t\t/*\n\t\t * We would have to split the busy extent to be able to track\n\t\t * it correct, which we cannot do because we would have to\n\t\t * modify the list of busy extents attached to the transaction\n\t\t * or CIL context, which is immutable.\n\t\t *\n\t\t * Force out the log to clear the busy extent and retry the\n\t\t * search.\n\t\t */\n\t\tgoto out_force_log;\n\t} else if (bbno >= fbno && bend <= fend) {\n\t\t/*\n\t\t * Case 2:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *    +-----------------+\n\t\t *    fbno           fend\n\t\t *\n\t\t * Case 3:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *    +--------------------------+\n\t\t *    fbno                    fend\n\t\t *\n\t\t * Case 4:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +--------------------------+\n\t\t *    fbno                    fend\n\t\t *\n\t\t * Case 5:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +-----------------------------------+\n\t\t *    fbno                             fend\n\t\t *\n\t\t */\n\n\t\t/*\n\t\t * The busy extent is fully covered by the extent we are\n\t\t * allocating, and can simply be removed from the rbtree.\n\t\t * However we cannot remove it from the immutable list\n\t\t * tracking busy extents in the transaction or CIL context,\n\t\t * so set the length to zero to mark it invalid.\n\t\t *\n\t\t * We also need to restart the busy extent search from the\n\t\t * tree root, because erasing the node can rearrange the\n\t\t * tree topology.\n\t\t */\n\t\trb_erase(&busyp->rb_node, &pag->pagb_tree);\n\t\tbusyp->length = 0;\n\t\treturn false;\n\t} else if (fend < bend) {\n\t\t/*\n\t\t * Case 6:\n\t\t *              bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *             +---------+\n\t\t *             fbno   fend\n\t\t *\n\t\t * Case 7:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +------------------+\n\t\t *    fbno            fend\n\t\t *\n\t\t */\n\t\tbusyp->bno = fend;\n\t} else if (bbno < fbno) {\n\t\t/*\n\t\t * Case 8:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +-------------+\n\t\t *        fbno       fend\n\t\t *\n\t\t * Case 9:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +----------------------+\n\t\t *        fbno                fend\n\t\t */\n\t\tbusyp->length = fbno - busyp->bno;\n\t} else {\n\t\tASSERT(0);\n\t}\n\n\ttrace_xfs_extent_busy_reuse(mp, pag->pag_agno, fbno, flen);\n\treturn true;\n\nout_force_log:\n\tspin_unlock(&pag->pagb_lock);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\ttrace_xfs_extent_busy_force(mp, pag->pag_agno, fbno, flen);\n\tspin_lock(&pag->pagb_lock);\n\treturn false;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_extent_busy_update_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_extent_busy\t*busyp,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata) __releases(&pag->pagb_lock)\n\t\t\t\t\t  __acquires(&pag->pagb_lock)\n{\n\txfs_agblock_t\t\tfend = fbno + flen;\n\txfs_agblock_t\t\tbbno = busyp->bno;\n\txfs_agblock_t\t\tbend = bbno + busyp->length;\n\n\t/*\n\t * This extent is currently being discarded.  Give the thread\n\t * performing the discard a chance to mark the extent unbusy\n\t * and retry.\n\t */\n\tif (busyp->flags & XFS_EXTENT_BUSY_DISCARDED) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\tdelay(1);\n\t\tspin_lock(&pag->pagb_lock);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If there is a busy extent overlapping a user allocation, we have\n\t * no choice but to force the log and retry the search.\n\t *\n\t * Fortunately this does not happen during normal operation, but\n\t * only if the filesystem is very low on space and has to dip into\n\t * the AGFL for normal allocations.\n\t */\n\tif (userdata)\n\t\tgoto out_force_log;\n\n\tif (bbno < fbno && bend > fend) {\n\t\t/*\n\t\t * Case 1:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +---------+\n\t\t *        fbno   fend\n\t\t */\n\n\t\t/*\n\t\t * We would have to split the busy extent to be able to track\n\t\t * it correct, which we cannot do because we would have to\n\t\t * modify the list of busy extents attached to the transaction\n\t\t * or CIL context, which is immutable.\n\t\t *\n\t\t * Force out the log to clear the busy extent and retry the\n\t\t * search.\n\t\t */\n\t\tgoto out_force_log;\n\t} else if (bbno >= fbno && bend <= fend) {\n\t\t/*\n\t\t * Case 2:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *    +-----------------+\n\t\t *    fbno           fend\n\t\t *\n\t\t * Case 3:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *    +--------------------------+\n\t\t *    fbno                    fend\n\t\t *\n\t\t * Case 4:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +--------------------------+\n\t\t *    fbno                    fend\n\t\t *\n\t\t * Case 5:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +-----------------------------------+\n\t\t *    fbno                             fend\n\t\t *\n\t\t */\n\n\t\t/*\n\t\t * The busy extent is fully covered by the extent we are\n\t\t * allocating, and can simply be removed from the rbtree.\n\t\t * However we cannot remove it from the immutable list\n\t\t * tracking busy extents in the transaction or CIL context,\n\t\t * so set the length to zero to mark it invalid.\n\t\t *\n\t\t * We also need to restart the busy extent search from the\n\t\t * tree root, because erasing the node can rearrange the\n\t\t * tree topology.\n\t\t */\n\t\trb_erase(&busyp->rb_node, &pag->pagb_tree);\n\t\tbusyp->length = 0;\n\t\treturn false;\n\t} else if (fend < bend) {\n\t\t/*\n\t\t * Case 6:\n\t\t *              bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *             +---------+\n\t\t *             fbno   fend\n\t\t *\n\t\t * Case 7:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +------------------+\n\t\t *    fbno            fend\n\t\t *\n\t\t */\n\t\tbusyp->bno = fend;\n\t} else if (bbno < fbno) {\n\t\t/*\n\t\t * Case 8:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +-------------+\n\t\t *        fbno       fend\n\t\t *\n\t\t * Case 9:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +----------------------+\n\t\t *        fbno                fend\n\t\t */\n\t\tbusyp->length = fbno - busyp->bno;\n\t} else {\n\t\tASSERT(0);\n\t}\n\n\ttrace_xfs_extent_busy_reuse(mp, pag->pag_agno, fbno, flen);\n\treturn true;\n\nout_force_log:\n\tspin_unlock(&pag->pagb_lock);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\ttrace_xfs_extent_busy_force(mp, pag->pag_agno, fbno, flen);\n\tspin_lock(&pag->pagb_lock);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structxfs_extent_busy",
            "rb_node"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "flen > 0"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_extent_busy_reuse(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t*rbp;\n\n\tASSERT(flen > 0);\n\n\tpag = xfs_perag_get(mp, agno);\n\tspin_lock(&pag->pagb_lock);\nrestart:\n\trbp = pag->pagb_tree.rb_node;\n\twhile (rbp) {\n\t\tstruct xfs_extent_busy *busyp =\n\t\t\trb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\txfs_agblock_t\tbbno = busyp->bno;\n\t\txfs_agblock_t\tbend = bbno + busyp->length;\n\n\t\tif (fbno + flen <= bbno) {\n\t\t\trbp = rbp->rb_left;\n\t\t\tcontinue;\n\t\t} else if (fbno >= bend) {\n\t\t\trbp = rbp->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!xfs_extent_busy_update_extent(mp, pag, busyp, fbno, flen,\n\t\t\t\t\t\t  userdata))\n\t\t\tgoto restart;\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}"
  },
  {
    "function_name": "xfs_extent_busy_update_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
    "lines": "156-298",
    "snippet": "STATIC bool\nxfs_extent_busy_update_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_extent_busy\t*busyp,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata) __releases(&pag->pagb_lock)\n\t\t\t\t\t  __acquires(&pag->pagb_lock)\n{\n\txfs_agblock_t\t\tfend = fbno + flen;\n\txfs_agblock_t\t\tbbno = busyp->bno;\n\txfs_agblock_t\t\tbend = bbno + busyp->length;\n\n\t/*\n\t * This extent is currently being discarded.  Give the thread\n\t * performing the discard a chance to mark the extent unbusy\n\t * and retry.\n\t */\n\tif (busyp->flags & XFS_EXTENT_BUSY_DISCARDED) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\tdelay(1);\n\t\tspin_lock(&pag->pagb_lock);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If there is a busy extent overlapping a user allocation, we have\n\t * no choice but to force the log and retry the search.\n\t *\n\t * Fortunately this does not happen during normal operation, but\n\t * only if the filesystem is very low on space and has to dip into\n\t * the AGFL for normal allocations.\n\t */\n\tif (userdata)\n\t\tgoto out_force_log;\n\n\tif (bbno < fbno && bend > fend) {\n\t\t/*\n\t\t * Case 1:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +---------+\n\t\t *        fbno   fend\n\t\t */\n\n\t\t/*\n\t\t * We would have to split the busy extent to be able to track\n\t\t * it correct, which we cannot do because we would have to\n\t\t * modify the list of busy extents attached to the transaction\n\t\t * or CIL context, which is immutable.\n\t\t *\n\t\t * Force out the log to clear the busy extent and retry the\n\t\t * search.\n\t\t */\n\t\tgoto out_force_log;\n\t} else if (bbno >= fbno && bend <= fend) {\n\t\t/*\n\t\t * Case 2:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *    +-----------------+\n\t\t *    fbno           fend\n\t\t *\n\t\t * Case 3:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *    +--------------------------+\n\t\t *    fbno                    fend\n\t\t *\n\t\t * Case 4:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +--------------------------+\n\t\t *    fbno                    fend\n\t\t *\n\t\t * Case 5:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +-----------------------------------+\n\t\t *    fbno                             fend\n\t\t *\n\t\t */\n\n\t\t/*\n\t\t * The busy extent is fully covered by the extent we are\n\t\t * allocating, and can simply be removed from the rbtree.\n\t\t * However we cannot remove it from the immutable list\n\t\t * tracking busy extents in the transaction or CIL context,\n\t\t * so set the length to zero to mark it invalid.\n\t\t *\n\t\t * We also need to restart the busy extent search from the\n\t\t * tree root, because erasing the node can rearrange the\n\t\t * tree topology.\n\t\t */\n\t\trb_erase(&busyp->rb_node, &pag->pagb_tree);\n\t\tbusyp->length = 0;\n\t\treturn false;\n\t} else if (fend < bend) {\n\t\t/*\n\t\t * Case 6:\n\t\t *              bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *             +---------+\n\t\t *             fbno   fend\n\t\t *\n\t\t * Case 7:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +------------------+\n\t\t *    fbno            fend\n\t\t *\n\t\t */\n\t\tbusyp->bno = fend;\n\t} else if (bbno < fbno) {\n\t\t/*\n\t\t * Case 8:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +-------------+\n\t\t *        fbno       fend\n\t\t *\n\t\t * Case 9:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +----------------------+\n\t\t *        fbno                fend\n\t\t */\n\t\tbusyp->length = fbno - busyp->bno;\n\t} else {\n\t\tASSERT(0);\n\t}\n\n\ttrace_xfs_extent_busy_reuse(mp, pag->pag_agno, fbno, flen);\n\treturn true;\n\nout_force_log:\n\tspin_unlock(&pag->pagb_lock);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\ttrace_xfs_extent_busy_force(mp, pag->pag_agno, fbno, flen);\n\tspin_lock(&pag->pagb_lock);\n\treturn false;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_extent_busy_force",
          "args": [
            "mp",
            "pag->pag_agno",
            "fbno",
            "flen"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "mp",
            "XFS_LOG_SYNC"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_extent_busy_reuse",
          "args": [
            "mp",
            "pag->pag_agno",
            "fbno",
            "flen"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&busyp->rb_node",
            "&pag->pagb_tree"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "181-184",
          "snippet": "static inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_extent_busy_update_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_extent_busy\t*busyp,\n\txfs_agblock_t\t\tfbno,\n\txfs_extlen_t\t\tflen,\n\tbool\t\t\tuserdata) __releases(&pag->pagb_lock)\n\t\t\t\t\t  __acquires(&pag->pagb_lock)\n{\n\txfs_agblock_t\t\tfend = fbno + flen;\n\txfs_agblock_t\t\tbbno = busyp->bno;\n\txfs_agblock_t\t\tbend = bbno + busyp->length;\n\n\t/*\n\t * This extent is currently being discarded.  Give the thread\n\t * performing the discard a chance to mark the extent unbusy\n\t * and retry.\n\t */\n\tif (busyp->flags & XFS_EXTENT_BUSY_DISCARDED) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\tdelay(1);\n\t\tspin_lock(&pag->pagb_lock);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If there is a busy extent overlapping a user allocation, we have\n\t * no choice but to force the log and retry the search.\n\t *\n\t * Fortunately this does not happen during normal operation, but\n\t * only if the filesystem is very low on space and has to dip into\n\t * the AGFL for normal allocations.\n\t */\n\tif (userdata)\n\t\tgoto out_force_log;\n\n\tif (bbno < fbno && bend > fend) {\n\t\t/*\n\t\t * Case 1:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +---------+\n\t\t *        fbno   fend\n\t\t */\n\n\t\t/*\n\t\t * We would have to split the busy extent to be able to track\n\t\t * it correct, which we cannot do because we would have to\n\t\t * modify the list of busy extents attached to the transaction\n\t\t * or CIL context, which is immutable.\n\t\t *\n\t\t * Force out the log to clear the busy extent and retry the\n\t\t * search.\n\t\t */\n\t\tgoto out_force_log;\n\t} else if (bbno >= fbno && bend <= fend) {\n\t\t/*\n\t\t * Case 2:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *    +-----------------+\n\t\t *    fbno           fend\n\t\t *\n\t\t * Case 3:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *    +--------------------------+\n\t\t *    fbno                    fend\n\t\t *\n\t\t * Case 4:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +--------------------------+\n\t\t *    fbno                    fend\n\t\t *\n\t\t * Case 5:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +-----------------------------------+\n\t\t *    fbno                             fend\n\t\t *\n\t\t */\n\n\t\t/*\n\t\t * The busy extent is fully covered by the extent we are\n\t\t * allocating, and can simply be removed from the rbtree.\n\t\t * However we cannot remove it from the immutable list\n\t\t * tracking busy extents in the transaction or CIL context,\n\t\t * so set the length to zero to mark it invalid.\n\t\t *\n\t\t * We also need to restart the busy extent search from the\n\t\t * tree root, because erasing the node can rearrange the\n\t\t * tree topology.\n\t\t */\n\t\trb_erase(&busyp->rb_node, &pag->pagb_tree);\n\t\tbusyp->length = 0;\n\t\treturn false;\n\t} else if (fend < bend) {\n\t\t/*\n\t\t * Case 6:\n\t\t *              bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *             +---------+\n\t\t *             fbno   fend\n\t\t *\n\t\t * Case 7:\n\t\t *             bbno           bend\n\t\t *             +BBBBBBBBBBBBBBBBB+\n\t\t *    +------------------+\n\t\t *    fbno            fend\n\t\t *\n\t\t */\n\t\tbusyp->bno = fend;\n\t} else if (bbno < fbno) {\n\t\t/*\n\t\t * Case 8:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +-------------+\n\t\t *        fbno       fend\n\t\t *\n\t\t * Case 9:\n\t\t *    bbno           bend\n\t\t *    +BBBBBBBBBBBBBBBBB+\n\t\t *        +----------------------+\n\t\t *        fbno                fend\n\t\t */\n\t\tbusyp->length = fbno - busyp->bno;\n\t} else {\n\t\tASSERT(0);\n\t}\n\n\ttrace_xfs_extent_busy_reuse(mp, pag->pag_agno, fbno, flen);\n\treturn true;\n\nout_force_log:\n\tspin_unlock(&pag->pagb_lock);\n\txfs_log_force(mp, XFS_LOG_SYNC);\n\ttrace_xfs_extent_busy_force(mp, pag->pag_agno, fbno, flen);\n\tspin_lock(&pag->pagb_lock);\n\treturn false;\n}"
  },
  {
    "function_name": "xfs_extent_busy_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
    "lines": "104-143",
    "snippet": "int\nxfs_extent_busy_search(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t*rbp;\n\tstruct xfs_extent_busy\t*busyp;\n\tint\t\t\tmatch = 0;\n\n\tpag = xfs_perag_get(mp, agno);\n\tspin_lock(&pag->pagb_lock);\n\n\trbp = pag->pagb_tree.rb_node;\n\n\t/* find closest start bno overlap */\n\twhile (rbp) {\n\t\tbusyp = rb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\tif (bno < busyp->bno) {\n\t\t\t/* may overlap, but exact start block is lower */\n\t\t\tif (bno + len > busyp->bno)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_left;\n\t\t} else if (bno > busyp->bno) {\n\t\t\t/* may overlap, but exact start block is higher */\n\t\t\tif (bno < busyp->bno + busyp->length)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_right;\n\t\t} else {\n\t\t\t/* bno matches busyp, length determines exact match */\n\t\t\tmatch = (busyp->length == len) ? 1 : -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n\treturn match;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structxfs_extent_busy",
            "rb_node"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_extent_busy_search(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen)\n{\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t*rbp;\n\tstruct xfs_extent_busy\t*busyp;\n\tint\t\t\tmatch = 0;\n\n\tpag = xfs_perag_get(mp, agno);\n\tspin_lock(&pag->pagb_lock);\n\n\trbp = pag->pagb_tree.rb_node;\n\n\t/* find closest start bno overlap */\n\twhile (rbp) {\n\t\tbusyp = rb_entry(rbp, struct xfs_extent_busy, rb_node);\n\t\tif (bno < busyp->bno) {\n\t\t\t/* may overlap, but exact start block is lower */\n\t\t\tif (bno + len > busyp->bno)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_left;\n\t\t} else if (bno > busyp->bno) {\n\t\t\t/* may overlap, but exact start block is higher */\n\t\t\tif (bno < busyp->bno + busyp->length)\n\t\t\t\tmatch = -1;\n\t\t\trbp = rbp->rb_right;\n\t\t} else {\n\t\t\t/* bno matches busyp, length determines exact match */\n\t\t\tmatch = (busyp->length == len) ? 1 : -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n\treturn match;\n}"
  },
  {
    "function_name": "xfs_extent_busy_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
    "lines": "34-93",
    "snippet": "void\nxfs_extent_busy_insert(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tunsigned int\t\tflags)\n{\n\tstruct xfs_extent_busy\t*new;\n\tstruct xfs_extent_busy\t*busyp;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent = NULL;\n\n\tnew = kmem_zalloc(sizeof(struct xfs_extent_busy), KM_MAYFAIL);\n\tif (!new) {\n\t\t/*\n\t\t * No Memory!  Since it is now not possible to track the free\n\t\t * block, make this a synchronous transaction to insure that\n\t\t * the block is not reused before this transaction commits.\n\t\t */\n\t\ttrace_xfs_extent_busy_enomem(tp->t_mountp, agno, bno, len);\n\t\txfs_trans_set_sync(tp);\n\t\treturn;\n\t}\n\n\tnew->agno = agno;\n\tnew->bno = bno;\n\tnew->length = len;\n\tINIT_LIST_HEAD(&new->list);\n\tnew->flags = flags;\n\n\t/* trace before insert to be able to see failed inserts */\n\ttrace_xfs_extent_busy(tp->t_mountp, agno, bno, len);\n\n\tpag = xfs_perag_get(tp->t_mountp, new->agno);\n\tspin_lock(&pag->pagb_lock);\n\trbp = &pag->pagb_tree.rb_node;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbusyp = rb_entry(parent, struct xfs_extent_busy, rb_node);\n\n\t\tif (new->bno < busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_left;\n\t\t\tASSERT(new->bno + new->length <= busyp->bno);\n\t\t} else if (new->bno > busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_right;\n\t\t\tASSERT(bno >= busyp->bno + busyp->length);\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t}\n\t}\n\n\trb_link_node(&new->rb_node, parent, rbp);\n\trb_insert_color(&new->rb_node, &pag->pagb_tree);\n\n\tlist_add(&new->list, &tp->t_busy);\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new->list",
            "&tp->t_busy"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new->rb_node",
            "&pag->pagb_tree"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new->rb_node",
            "parent",
            "rbp"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bno >= busyp->bno + busyp->length"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "new->bno + new->length <= busyp->bno"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structxfs_extent_busy",
            "rb_node"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pag->pagb_lock"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "tp->t_mountp",
            "new->agno"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_extent_busy",
          "args": [
            "tp->t_mountp",
            "agno",
            "bno",
            "len"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->list"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_extent_busy_enomem",
          "args": [
            "tp->t_mountp",
            "agno",
            "bno",
            "len"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(struct xfs_extent_busy)",
            "KM_MAYFAIL"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_extent_busy_insert(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tagno,\n\txfs_agblock_t\t\tbno,\n\txfs_extlen_t\t\tlen,\n\tunsigned int\t\tflags)\n{\n\tstruct xfs_extent_busy\t*new;\n\tstruct xfs_extent_busy\t*busyp;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent = NULL;\n\n\tnew = kmem_zalloc(sizeof(struct xfs_extent_busy), KM_MAYFAIL);\n\tif (!new) {\n\t\t/*\n\t\t * No Memory!  Since it is now not possible to track the free\n\t\t * block, make this a synchronous transaction to insure that\n\t\t * the block is not reused before this transaction commits.\n\t\t */\n\t\ttrace_xfs_extent_busy_enomem(tp->t_mountp, agno, bno, len);\n\t\txfs_trans_set_sync(tp);\n\t\treturn;\n\t}\n\n\tnew->agno = agno;\n\tnew->bno = bno;\n\tnew->length = len;\n\tINIT_LIST_HEAD(&new->list);\n\tnew->flags = flags;\n\n\t/* trace before insert to be able to see failed inserts */\n\ttrace_xfs_extent_busy(tp->t_mountp, agno, bno, len);\n\n\tpag = xfs_perag_get(tp->t_mountp, new->agno);\n\tspin_lock(&pag->pagb_lock);\n\trbp = &pag->pagb_tree.rb_node;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbusyp = rb_entry(parent, struct xfs_extent_busy, rb_node);\n\n\t\tif (new->bno < busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_left;\n\t\t\tASSERT(new->bno + new->length <= busyp->bno);\n\t\t} else if (new->bno > busyp->bno) {\n\t\t\trbp = &(*rbp)->rb_right;\n\t\t\tASSERT(bno >= busyp->bno + busyp->length);\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t}\n\t}\n\n\trb_link_node(&new->rb_node, parent, rbp);\n\trb_insert_color(&new->rb_node, &pag->pagb_tree);\n\n\tlist_add(&new->list, &tp->t_busy);\n\tspin_unlock(&pag->pagb_lock);\n\txfs_perag_put(pag);\n}"
  }
]