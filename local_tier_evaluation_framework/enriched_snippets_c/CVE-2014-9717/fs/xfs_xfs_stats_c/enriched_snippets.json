[
  {
    "function_name": "xfs_cleanup_procfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.c",
    "lines": "189-198",
    "snippet": "void\nxfs_cleanup_procfs(void)\n{\n#ifdef CONFIG_XFS_QUOTA\n\tremove_proc_entry(\"fs/xfs/xqm\", NULL);\n\tremove_proc_entry(\"fs/xfs/xqmstat\", NULL);\n#endif\n\tremove_proc_entry(\"fs/xfs/stat\", NULL);\n\tremove_proc_entry(\"fs/xfs\", NULL);\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"fs/xfs\"",
            "NULL"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include \"xfs.h\"\n\nvoid\nxfs_cleanup_procfs(void)\n{\n#ifdef CONFIG_XFS_QUOTA\n\tremove_proc_entry(\"fs/xfs/xqm\", NULL);\n\tremove_proc_entry(\"fs/xfs/xqmstat\", NULL);\n#endif\n\tremove_proc_entry(\"fs/xfs/stat\", NULL);\n\tremove_proc_entry(\"fs/xfs\", NULL);\n}"
  },
  {
    "function_name": "xfs_init_procfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.c",
    "lines": "158-187",
    "snippet": "int\nxfs_init_procfs(void)\n{\n\tif (!proc_mkdir(\"fs/xfs\", NULL))\n\t\tgoto out;\n\n\tif (!proc_create(\"fs/xfs/stat\", 0, NULL,\n\t\t\t &xfs_stat_proc_fops))\n\t\tgoto out_remove_xfs_dir;\n#ifdef CONFIG_XFS_QUOTA\n\tif (!proc_create(\"fs/xfs/xqmstat\", 0, NULL,\n\t\t\t &xqmstat_proc_fops))\n\t\tgoto out_remove_stat_file;\n\tif (!proc_create(\"fs/xfs/xqm\", 0, NULL,\n\t\t\t &xqm_proc_fops))\n\t\tgoto out_remove_xqmstat_file;\n#endif\n\treturn 0;\n\n#ifdef CONFIG_XFS_QUOTA\n out_remove_xqmstat_file:\n\tremove_proc_entry(\"fs/xfs/xqmstat\", NULL);\n out_remove_stat_file:\n\tremove_proc_entry(\"fs/xfs/stat\", NULL);\n#endif\n out_remove_xfs_dir:\n\tremove_proc_entry(\"fs/xfs\", NULL);\n out:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations xfs_stat_proc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= xfs_stat_proc_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"fs/xfs\"",
            "NULL"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"fs/xfs/xqm\"",
            "0",
            "NULL",
            "&xqm_proc_fops"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "__proc_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "355-391",
          "snippet": "static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"fs/xfs\"",
            "NULL"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include \"xfs.h\"\n\nstatic const struct file_operations xfs_stat_proc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= xfs_stat_proc_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nint\nxfs_init_procfs(void)\n{\n\tif (!proc_mkdir(\"fs/xfs\", NULL))\n\t\tgoto out;\n\n\tif (!proc_create(\"fs/xfs/stat\", 0, NULL,\n\t\t\t &xfs_stat_proc_fops))\n\t\tgoto out_remove_xfs_dir;\n#ifdef CONFIG_XFS_QUOTA\n\tif (!proc_create(\"fs/xfs/xqmstat\", 0, NULL,\n\t\t\t &xqmstat_proc_fops))\n\t\tgoto out_remove_stat_file;\n\tif (!proc_create(\"fs/xfs/xqm\", 0, NULL,\n\t\t\t &xqm_proc_fops))\n\t\tgoto out_remove_xqmstat_file;\n#endif\n\treturn 0;\n\n#ifdef CONFIG_XFS_QUOTA\n out_remove_xqmstat_file:\n\tremove_proc_entry(\"fs/xfs/xqmstat\", NULL);\n out_remove_stat_file:\n\tremove_proc_entry(\"fs/xfs/stat\", NULL);\n#endif\n out_remove_xfs_dir:\n\tremove_proc_entry(\"fs/xfs\", NULL);\n out:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "xqmstat_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.c",
    "lines": "144-147",
    "snippet": "static int xqmstat_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, xqmstat_proc_show, NULL);\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "xqmstat_proc_show",
            "NULL"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include \"xfs.h\"\n\nstatic int xqmstat_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, xqmstat_proc_show, NULL);\n}"
  },
  {
    "function_name": "xqmstat_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.c",
    "lines": "133-142",
    "snippet": "static int xqmstat_proc_show(struct seq_file *m, void *v)\n{\n\tint j;\n\n\tseq_printf(m, \"qm\");\n\tfor (j = XFSSTAT_END_IBT_V2; j < XFSSTAT_END_XQMSTAT; j++)\n\t\tseq_printf(m, \" %u\", counter_val(j));\n\tseq_putc(m, '\\n');\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %u\"",
            "counter_val(j)"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "counter_val",
          "args": [
            "j"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "counter_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.c",
          "lines": "23-30",
          "snippet": "static int counter_val(int idx)\n{\n\tint val = 0, cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tval += *(((__u32 *)&per_cpu(xfsstats, cpu) + idx));\n\treturn val;\n}",
          "includes": [
            "#include <linux/proc_fs.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_fs.h>\n#include \"xfs.h\"\n\nstatic int counter_val(int idx)\n{\n\tint val = 0, cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tval += *(((__u32 *)&per_cpu(xfsstats, cpu) + idx));\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include \"xfs.h\"\n\nstatic int xqmstat_proc_show(struct seq_file *m, void *v)\n{\n\tint j;\n\n\tseq_printf(m, \"qm\");\n\tfor (j = XFSSTAT_END_IBT_V2; j < XFSSTAT_END_XQMSTAT; j++)\n\t\tseq_printf(m, \" %u\", counter_val(j));\n\tseq_putc(m, '\\n');\n\treturn 0;\n}"
  },
  {
    "function_name": "xqm_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.c",
    "lines": "119-122",
    "snippet": "static int xqm_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, xqm_proc_show, NULL);\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "xqm_proc_show",
            "NULL"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include \"xfs.h\"\n\nstatic int xqm_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, xqm_proc_show, NULL);\n}"
  },
  {
    "function_name": "xqm_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.c",
    "lines": "108-117",
    "snippet": "static int xqm_proc_show(struct seq_file *m, void *v)\n{\n\t/* maximum; incore; ratio free to inuse; freelist */\n\tseq_printf(m, \"%d\\t%d\\t%d\\t%u\\n\",\n\t\t\t0,\n\t\t\tcounter_val(XFSSTAT_END_XQMSTAT),\n\t\t\t0,\n\t\t\tcounter_val(XFSSTAT_END_XQMSTAT + 1));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%d\\t%d\\t%d\\t%u\\n\"",
            "0",
            "counter_val(XFSSTAT_END_XQMSTAT)",
            "0",
            "counter_val(XFSSTAT_END_XQMSTAT + 1)"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "counter_val",
          "args": [
            "XFSSTAT_END_XQMSTAT + 1"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "counter_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.c",
          "lines": "23-30",
          "snippet": "static int counter_val(int idx)\n{\n\tint val = 0, cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tval += *(((__u32 *)&per_cpu(xfsstats, cpu) + idx));\n\treturn val;\n}",
          "includes": [
            "#include <linux/proc_fs.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_fs.h>\n#include \"xfs.h\"\n\nstatic int counter_val(int idx)\n{\n\tint val = 0, cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tval += *(((__u32 *)&per_cpu(xfsstats, cpu) + idx));\n\treturn val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include \"xfs.h\"\n\nstatic int xqm_proc_show(struct seq_file *m, void *v)\n{\n\t/* maximum; incore; ratio free to inuse; freelist */\n\tseq_printf(m, \"%d\\t%d\\t%d\\t%u\\n\",\n\t\t\t0,\n\t\t\tcounter_val(XFSSTAT_END_XQMSTAT),\n\t\t\t0,\n\t\t\tcounter_val(XFSSTAT_END_XQMSTAT + 1));\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_stat_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.c",
    "lines": "93-96",
    "snippet": "static int xfs_stat_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, xfs_stat_proc_show, NULL);\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "xfs_stat_proc_show",
            "NULL"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include \"xfs.h\"\n\nstatic int xfs_stat_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, xfs_stat_proc_show, NULL);\n}"
  },
  {
    "function_name": "xfs_stat_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.c",
    "lines": "32-91",
    "snippet": "static int xfs_stat_proc_show(struct seq_file *m, void *v)\n{\n\tint\t\ti, j;\n\t__uint64_t\txs_xstrat_bytes = 0;\n\t__uint64_t\txs_write_bytes = 0;\n\t__uint64_t\txs_read_bytes = 0;\n\n\tstatic const struct xstats_entry {\n\t\tchar\t*desc;\n\t\tint\tendpoint;\n\t} xstats[] = {\n\t\t{ \"extent_alloc\",\tXFSSTAT_END_EXTENT_ALLOC\t},\n\t\t{ \"abt\",\t\tXFSSTAT_END_ALLOC_BTREE\t\t},\n\t\t{ \"blk_map\",\t\tXFSSTAT_END_BLOCK_MAPPING\t},\n\t\t{ \"bmbt\",\t\tXFSSTAT_END_BLOCK_MAP_BTREE\t},\n\t\t{ \"dir\",\t\tXFSSTAT_END_DIRECTORY_OPS\t},\n\t\t{ \"trans\",\t\tXFSSTAT_END_TRANSACTIONS\t},\n\t\t{ \"ig\",\t\t\tXFSSTAT_END_INODE_OPS\t\t},\n\t\t{ \"log\",\t\tXFSSTAT_END_LOG_OPS\t\t},\n\t\t{ \"push_ail\",\t\tXFSSTAT_END_TAIL_PUSHING\t},\n\t\t{ \"xstrat\",\t\tXFSSTAT_END_WRITE_CONVERT\t},\n\t\t{ \"rw\",\t\t\tXFSSTAT_END_READ_WRITE_OPS\t},\n\t\t{ \"attr\",\t\tXFSSTAT_END_ATTRIBUTE_OPS\t},\n\t\t{ \"icluster\",\t\tXFSSTAT_END_INODE_CLUSTER\t},\n\t\t{ \"vnodes\",\t\tXFSSTAT_END_VNODE_OPS\t\t},\n\t\t{ \"buf\",\t\tXFSSTAT_END_BUF\t\t\t},\n\t\t{ \"abtb2\",\t\tXFSSTAT_END_ABTB_V2\t\t},\n\t\t{ \"abtc2\",\t\tXFSSTAT_END_ABTC_V2\t\t},\n\t\t{ \"bmbt2\",\t\tXFSSTAT_END_BMBT_V2\t\t},\n\t\t{ \"ibt2\",\t\tXFSSTAT_END_IBT_V2\t\t},\n\t\t{ \"fibt2\",\t\tXFSSTAT_END_FIBT_V2\t\t},\n\t\t/* we print both series of quota information together */\n\t\t{ \"qm\",\t\t\tXFSSTAT_END_QM\t\t\t},\n\t};\n\n\t/* Loop over all stats groups */\n\tfor (i = j = 0; i < ARRAY_SIZE(xstats); i++) {\n\t\tseq_printf(m, \"%s\", xstats[i].desc);\n\t\t/* inner loop does each group */\n\t\tfor (; j < xstats[i].endpoint; j++)\n\t\t\tseq_printf(m, \" %u\", counter_val(j));\n\t\tseq_putc(m, '\\n');\n\t}\n\t/* extra precision counters */\n\tfor_each_possible_cpu(i) {\n\t\txs_xstrat_bytes += per_cpu(xfsstats, i).xs_xstrat_bytes;\n\t\txs_write_bytes += per_cpu(xfsstats, i).xs_write_bytes;\n\t\txs_read_bytes += per_cpu(xfsstats, i).xs_read_bytes;\n\t}\n\n\tseq_printf(m, \"xpc %Lu %Lu %Lu\\n\",\n\t\t\txs_xstrat_bytes, xs_write_bytes, xs_read_bytes);\n\tseq_printf(m, \"debug %u\\n\",\n#if defined(DEBUG)\n\t\t1);\n#else\n\t\t0);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"debug %u\\n\"",
            "#if defined(DEBUG"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "xfsstats",
            "i"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "xfsstats",
            "i"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "xfsstats",
            "i"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "counter_val",
          "args": [
            "j"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "counter_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.c",
          "lines": "23-30",
          "snippet": "static int counter_val(int idx)\n{\n\tint val = 0, cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tval += *(((__u32 *)&per_cpu(xfsstats, cpu) + idx));\n\treturn val;\n}",
          "includes": [
            "#include <linux/proc_fs.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_fs.h>\n#include \"xfs.h\"\n\nstatic int counter_val(int idx)\n{\n\tint val = 0, cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tval += *(((__u32 *)&per_cpu(xfsstats, cpu) + idx));\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "xstats"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include \"xfs.h\"\n\nstatic int xfs_stat_proc_show(struct seq_file *m, void *v)\n{\n\tint\t\ti, j;\n\t__uint64_t\txs_xstrat_bytes = 0;\n\t__uint64_t\txs_write_bytes = 0;\n\t__uint64_t\txs_read_bytes = 0;\n\n\tstatic const struct xstats_entry {\n\t\tchar\t*desc;\n\t\tint\tendpoint;\n\t} xstats[] = {\n\t\t{ \"extent_alloc\",\tXFSSTAT_END_EXTENT_ALLOC\t},\n\t\t{ \"abt\",\t\tXFSSTAT_END_ALLOC_BTREE\t\t},\n\t\t{ \"blk_map\",\t\tXFSSTAT_END_BLOCK_MAPPING\t},\n\t\t{ \"bmbt\",\t\tXFSSTAT_END_BLOCK_MAP_BTREE\t},\n\t\t{ \"dir\",\t\tXFSSTAT_END_DIRECTORY_OPS\t},\n\t\t{ \"trans\",\t\tXFSSTAT_END_TRANSACTIONS\t},\n\t\t{ \"ig\",\t\t\tXFSSTAT_END_INODE_OPS\t\t},\n\t\t{ \"log\",\t\tXFSSTAT_END_LOG_OPS\t\t},\n\t\t{ \"push_ail\",\t\tXFSSTAT_END_TAIL_PUSHING\t},\n\t\t{ \"xstrat\",\t\tXFSSTAT_END_WRITE_CONVERT\t},\n\t\t{ \"rw\",\t\t\tXFSSTAT_END_READ_WRITE_OPS\t},\n\t\t{ \"attr\",\t\tXFSSTAT_END_ATTRIBUTE_OPS\t},\n\t\t{ \"icluster\",\t\tXFSSTAT_END_INODE_CLUSTER\t},\n\t\t{ \"vnodes\",\t\tXFSSTAT_END_VNODE_OPS\t\t},\n\t\t{ \"buf\",\t\tXFSSTAT_END_BUF\t\t\t},\n\t\t{ \"abtb2\",\t\tXFSSTAT_END_ABTB_V2\t\t},\n\t\t{ \"abtc2\",\t\tXFSSTAT_END_ABTC_V2\t\t},\n\t\t{ \"bmbt2\",\t\tXFSSTAT_END_BMBT_V2\t\t},\n\t\t{ \"ibt2\",\t\tXFSSTAT_END_IBT_V2\t\t},\n\t\t{ \"fibt2\",\t\tXFSSTAT_END_FIBT_V2\t\t},\n\t\t/* we print both series of quota information together */\n\t\t{ \"qm\",\t\t\tXFSSTAT_END_QM\t\t\t},\n\t};\n\n\t/* Loop over all stats groups */\n\tfor (i = j = 0; i < ARRAY_SIZE(xstats); i++) {\n\t\tseq_printf(m, \"%s\", xstats[i].desc);\n\t\t/* inner loop does each group */\n\t\tfor (; j < xstats[i].endpoint; j++)\n\t\t\tseq_printf(m, \" %u\", counter_val(j));\n\t\tseq_putc(m, '\\n');\n\t}\n\t/* extra precision counters */\n\tfor_each_possible_cpu(i) {\n\t\txs_xstrat_bytes += per_cpu(xfsstats, i).xs_xstrat_bytes;\n\t\txs_write_bytes += per_cpu(xfsstats, i).xs_write_bytes;\n\t\txs_read_bytes += per_cpu(xfsstats, i).xs_read_bytes;\n\t}\n\n\tseq_printf(m, \"xpc %Lu %Lu %Lu\\n\",\n\t\t\txs_xstrat_bytes, xs_write_bytes, xs_read_bytes);\n\tseq_printf(m, \"debug %u\\n\",\n#if defined(DEBUG)\n\t\t1);\n#else\n\t\t0);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "counter_val",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_stats.c",
    "lines": "23-30",
    "snippet": "static int counter_val(int idx)\n{\n\tint val = 0, cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tval += *(((__u32 *)&per_cpu(xfsstats, cpu) + idx));\n\treturn val;\n}",
    "includes": [
      "#include <linux/proc_fs.h>",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/proc_fs.h>\n#include \"xfs.h\"\n\nstatic int counter_val(int idx)\n{\n\tint val = 0, cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tval += *(((__u32 *)&per_cpu(xfsstats, cpu) + idx));\n\treturn val;\n}"
  }
]