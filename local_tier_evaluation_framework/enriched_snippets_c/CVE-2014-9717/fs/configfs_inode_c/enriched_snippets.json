[
  {
    "function_name": "configfs_hash_and_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
    "lines": "249-272",
    "snippet": "void configfs_hash_and_remove(struct dentry * dir, const char * name)\n{\n\tstruct configfs_dirent * sd;\n\tstruct configfs_dirent * parent_sd = dir->d_fsdata;\n\n\tif (dir->d_inode == NULL)\n\t\t/* no inode means this hasn't been made visible yet */\n\t\treturn;\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element)\n\t\t\tcontinue;\n\t\tif (!strcmp(configfs_get_name(sd), name)) {\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\tconfigfs_drop_dentry(sd, dir);\n\t\t\tconfigfs_put(sd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_put",
          "args": [
            "sd"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "157-162",
          "snippet": "static inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\n\nstatic inline void configfs_put(struct configfs_dirent * sd)\n{\n\tWARN_ON(!atomic_read(&sd->s_count));\n\tif (atomic_dec_and_test(&sd->s_count))\n\t\trelease_configfs_dirent(sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_drop_dentry",
          "args": [
            "sd",
            "dir"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_drop_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "233-247",
          "snippet": "void configfs_drop_dentry(struct configfs_dirent * sd, struct dentry * parent)\n{\n\tstruct dentry * dentry = sd->s_dentry;\n\n\tif (dentry) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!d_unhashed(dentry) && dentry->d_inode) {\n\t\t\tdget_dlock(dentry);\n\t\t\t__d_drop(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\t} else\n\t\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nvoid configfs_drop_dentry(struct configfs_dirent * sd, struct dentry * parent)\n{\n\tstruct dentry * dentry = sd->s_dentry;\n\n\tif (dentry) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!d_unhashed(dentry) && dentry->d_inode) {\n\t\t\tdget_dlock(dentry);\n\t\t\t__d_drop(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\t} else\n\t\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&sd->s_sibling"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&configfs_dirent_lock"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "configfs_get_name(sd)",
            "name"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_get_name",
          "args": [
            "sd"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "211-226",
          "snippet": "const unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nconst unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sd",
            "&parent_sd->s_children",
            "s_sibling"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nvoid configfs_hash_and_remove(struct dentry * dir, const char * name)\n{\n\tstruct configfs_dirent * sd;\n\tstruct configfs_dirent * parent_sd = dir->d_fsdata;\n\n\tif (dir->d_inode == NULL)\n\t\t/* no inode means this hasn't been made visible yet */\n\t\treturn;\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tlist_for_each_entry(sd, &parent_sd->s_children, s_sibling) {\n\t\tif (!sd->s_element)\n\t\t\tcontinue;\n\t\tif (!strcmp(configfs_get_name(sd), name)) {\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tlist_del_init(&sd->s_sibling);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t\tconfigfs_drop_dentry(sd, dir);\n\t\t\tconfigfs_put(sd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n}"
  },
  {
    "function_name": "configfs_drop_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
    "lines": "233-247",
    "snippet": "void configfs_drop_dentry(struct configfs_dirent * sd, struct dentry * parent)\n{\n\tstruct dentry * dentry = sd->s_dentry;\n\n\tif (dentry) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!d_unhashed(dentry) && dentry->d_inode) {\n\t\t\tdget_dlock(dentry);\n\t\t\t__d_drop(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\t} else\n\t\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_unlink",
          "args": [
            "parent->d_inode",
            "dentry"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "simple_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "305-313",
          "snippet": "int simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_drop",
          "args": [
            "dentry"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__d_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "445-465",
          "snippet": "void __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\tstruct hlist_bl_head *b;\n\t\t/*\n\t\t * Hashed dentries are normally on the dentry hashtable,\n\t\t * with the exception of those newly allocated by\n\t\t * d_obtain_alias, which are always IS_ROOT:\n\t\t */\n\t\tif (unlikely(IS_ROOT(dentry)))\n\t\t\tb = &dentry->d_sb->s_anon;\n\t\telse\n\t\t\tb = d_hash(dentry->d_parent, dentry->d_name.hash);\n\n\t\thlist_bl_lock(b);\n\t\t__hlist_bl_del(&dentry->d_hash);\n\t\tdentry->d_hash.pprev = NULL;\n\t\thlist_bl_unlock(b);\n\t\tdentry_rcuwalk_barrier(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\tstruct hlist_bl_head *b;\n\t\t/*\n\t\t * Hashed dentries are normally on the dentry hashtable,\n\t\t * with the exception of those newly allocated by\n\t\t * d_obtain_alias, which are always IS_ROOT:\n\t\t */\n\t\tif (unlikely(IS_ROOT(dentry)))\n\t\t\tb = &dentry->d_sb->s_anon;\n\t\telse\n\t\t\tb = d_hash(dentry->d_parent, dentry->d_name.hash);\n\n\t\thlist_bl_lock(b);\n\t\t__hlist_bl_del(&dentry->d_hash);\n\t\tdentry->d_hash.pprev = NULL;\n\t\thlist_bl_unlock(b);\n\t\tdentry_rcuwalk_barrier(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_dlock",
          "args": [
            "dentry"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__dget_dlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "767-770",
          "snippet": "static inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nvoid configfs_drop_dentry(struct configfs_dirent * sd, struct dentry * parent)\n{\n\tstruct dentry * dentry = sd->s_dentry;\n\n\tif (dentry) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!d_unhashed(dentry) && dentry->d_inode) {\n\t\t\tdget_dlock(dentry);\n\t\t\t__d_drop(dentry);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\t} else\n\t\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
  },
  {
    "function_name": "configfs_get_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
    "lines": "211-226",
    "snippet": "const unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!sd || !sd->s_element"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nconst unsigned char * configfs_get_name(struct configfs_dirent *sd)\n{\n\tstruct configfs_attribute *attr;\n\n\tBUG_ON(!sd || !sd->s_element);\n\n\t/* These always have a dentry, so use that */\n\tif (sd->s_type & (CONFIGFS_DIR | CONFIGFS_ITEM_LINK))\n\t\treturn sd->s_dentry->d_name.name;\n\n\tif (sd->s_type & CONFIGFS_ITEM_ATTR) {\n\t\tattr = sd->s_element;\n\t\treturn attr->ca_name;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "configfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
    "lines": "179-206",
    "snippet": "int configfs_create(struct dentry * dentry, umode_t mode, void (*init)(struct inode *))\n{\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\tstruct configfs_dirent *sd;\n\tstruct inode *p_inode;\n\n\tif (!dentry)\n\t\treturn -ENOENT;\n\n\tif (dentry->d_inode)\n\t\treturn -EEXIST;\n\n\tsd = dentry->d_fsdata;\n\tinode = configfs_new_inode(mode, sd, dentry->d_sb);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tp_inode = dentry->d_parent->d_inode;\n\tp_inode->i_mtime = p_inode->i_ctime = CURRENT_TIME;\n\tconfigfs_set_inode_lock_class(sd, inode);\n\n\tinit(inode);\n\td_instantiate(dentry, inode);\n\tif (S_ISDIR(mode) || S_ISLNK(mode))\n\t\tdget(dentry);  /* pin link and directory dentries in core */\n\treturn error;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init",
          "args": [
            "inode"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "370-375",
          "snippet": "static void init_once(void *foo)\n{\n\tstruct inode *inode = (struct inode *) foo;\n\n\tinode_init_once(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void init_once(void *foo)\n{\n\tstruct inode *inode = (struct inode *) foo;\n\n\tinode_init_once(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_set_inode_lock_class",
          "args": [
            "sd",
            "inode"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_set_inode_lock_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "172-175",
          "snippet": "static void configfs_set_inode_lock_class(struct configfs_dirent *sd,\n\t\t\t\t\t  struct inode *inode)\n{\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nstatic void configfs_set_inode_lock_class(struct configfs_dirent *sd,\n\t\t\t\t\t  struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_new_inode",
          "args": [
            "mode",
            "sd",
            "dentry->d_sb"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "127-146",
          "snippet": "struct inode *configfs_new_inode(umode_t mode, struct configfs_dirent *sd,\n\t\t\t\t struct super_block *s)\n{\n\tstruct inode * inode = new_inode(s);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mapping->a_ops = &configfs_aops;\n\t\tinode->i_op = &configfs_inode_operations;\n\n\t\tif (sd->s_iattr) {\n\t\t\t/* sysfs_dirent has non-default attributes\n\t\t\t * get them for the new inode from persistent copy\n\t\t\t * in sysfs_dirent\n\t\t\t */\n\t\t\tset_inode_attr(inode, sd->s_iattr);\n\t\t} else\n\t\t\tset_default_inode_attr(inode, mode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations configfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n};",
            "static const struct inode_operations configfs_inode_operations ={\n\t.setattr\t= configfs_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nstatic const struct address_space_operations configfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n};\nstatic const struct inode_operations configfs_inode_operations ={\n\t.setattr\t= configfs_setattr,\n};\n\nstruct inode *configfs_new_inode(umode_t mode, struct configfs_dirent *sd,\n\t\t\t\t struct super_block *s)\n{\n\tstruct inode * inode = new_inode(s);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mapping->a_ops = &configfs_aops;\n\t\tinode->i_op = &configfs_inode_operations;\n\n\t\tif (sd->s_iattr) {\n\t\t\t/* sysfs_dirent has non-default attributes\n\t\t\t * get them for the new inode from persistent copy\n\t\t\t * in sysfs_dirent\n\t\t\t */\n\t\t\tset_inode_attr(inode, sd->s_iattr);\n\t\t} else\n\t\t\tset_default_inode_attr(inode, mode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nint configfs_create(struct dentry * dentry, umode_t mode, void (*init)(struct inode *))\n{\n\tint error = 0;\n\tstruct inode *inode = NULL;\n\tstruct configfs_dirent *sd;\n\tstruct inode *p_inode;\n\n\tif (!dentry)\n\t\treturn -ENOENT;\n\n\tif (dentry->d_inode)\n\t\treturn -EEXIST;\n\n\tsd = dentry->d_fsdata;\n\tinode = configfs_new_inode(mode, sd, dentry->d_sb);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tp_inode = dentry->d_parent->d_inode;\n\tp_inode->i_mtime = p_inode->i_ctime = CURRENT_TIME;\n\tconfigfs_set_inode_lock_class(sd, inode);\n\n\tinit(inode);\n\td_instantiate(dentry, inode);\n\tif (S_ISDIR(mode) || S_ISLNK(mode))\n\t\tdget(dentry);  /* pin link and directory dentries in core */\n\treturn error;\n}"
  },
  {
    "function_name": "configfs_set_inode_lock_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
    "lines": "172-175",
    "snippet": "static void configfs_set_inode_lock_class(struct configfs_dirent *sd,\n\t\t\t\t\t  struct inode *inode)\n{\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nstatic void configfs_set_inode_lock_class(struct configfs_dirent *sd,\n\t\t\t\t\t  struct inode *inode)\n{\n}"
  },
  {
    "function_name": "configfs_set_inode_lock_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
    "lines": "150-168",
    "snippet": "static void configfs_set_inode_lock_class(struct configfs_dirent *sd,\n\t\t\t\t\t  struct inode *inode)\n{\n\tint depth = sd->s_depth;\n\n\tif (depth > 0) {\n\t\tif (depth <= ARRAY_SIZE(default_group_class)) {\n\t\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t\t\t  &default_group_class[depth - 1]);\n\t\t} else {\n\t\t\t/*\n\t\t\t * In practice the maximum level of locking depth is\n\t\t\t * already reached. Just inform about possible reasons.\n\t\t\t */\n\t\t\tpr_info(\"Too many levels of inodes for the locking correctness validator.\\n\");\n\t\t\tpr_info(\"Spurious warnings may appear.\\n\");\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Spurious warnings may appear.\\n\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Too many levels of inodes for the locking correctness validator.\\n\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&inode->i_mutex",
            "&default_group_class[depth - 1]"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "default_group_class"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nstatic void configfs_set_inode_lock_class(struct configfs_dirent *sd,\n\t\t\t\t\t  struct inode *inode)\n{\n\tint depth = sd->s_depth;\n\n\tif (depth > 0) {\n\t\tif (depth <= ARRAY_SIZE(default_group_class)) {\n\t\t\tlockdep_set_class(&inode->i_mutex,\n\t\t\t\t\t  &default_group_class[depth - 1]);\n\t\t} else {\n\t\t\t/*\n\t\t\t * In practice the maximum level of locking depth is\n\t\t\t * already reached. Just inform about possible reasons.\n\t\t\t */\n\t\t\tpr_info(\"Too many levels of inodes for the locking correctness validator.\\n\");\n\t\t\tpr_info(\"Spurious warnings may appear.\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "configfs_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
    "lines": "127-146",
    "snippet": "struct inode *configfs_new_inode(umode_t mode, struct configfs_dirent *sd,\n\t\t\t\t struct super_block *s)\n{\n\tstruct inode * inode = new_inode(s);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mapping->a_ops = &configfs_aops;\n\t\tinode->i_op = &configfs_inode_operations;\n\n\t\tif (sd->s_iattr) {\n\t\t\t/* sysfs_dirent has non-default attributes\n\t\t\t * get them for the new inode from persistent copy\n\t\t\t * in sysfs_dirent\n\t\t\t */\n\t\t\tset_inode_attr(inode, sd->s_iattr);\n\t\t} else\n\t\t\tset_default_inode_attr(inode, mode);\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations configfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n};",
      "static const struct inode_operations configfs_inode_operations ={\n\t.setattr\t= configfs_setattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_default_inode_attr",
          "args": [
            "inode",
            "mode"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "set_default_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "111-115",
          "snippet": "static inline void set_default_inode_attr(struct inode * inode, umode_t mode)\n{\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nstatic inline void set_default_inode_attr(struct inode * inode, umode_t mode)\n{\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_attr",
          "args": [
            "inode",
            "sd->s_iattr"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
          "lines": "117-125",
          "snippet": "static inline void set_inode_attr(struct inode * inode, struct iattr * iattr)\n{\n\tinode->i_mode = iattr->ia_mode;\n\tinode->i_uid = iattr->ia_uid;\n\tinode->i_gid = iattr->ia_gid;\n\tinode->i_atime = iattr->ia_atime;\n\tinode->i_mtime = iattr->ia_mtime;\n\tinode->i_ctime = iattr->ia_ctime;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nstatic inline void set_inode_attr(struct inode * inode, struct iattr * iattr)\n{\n\tinode->i_mode = iattr->ia_mode;\n\tinode->i_uid = iattr->ia_uid;\n\tinode->i_gid = iattr->ia_gid;\n\tinode->i_atime = iattr->ia_atime;\n\tinode->i_mtime = iattr->ia_mtime;\n\tinode->i_ctime = iattr->ia_ctime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "s"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nstatic const struct address_space_operations configfs_aops = {\n\t.readpage\t= simple_readpage,\n\t.write_begin\t= simple_write_begin,\n\t.write_end\t= simple_write_end,\n};\nstatic const struct inode_operations configfs_inode_operations ={\n\t.setattr\t= configfs_setattr,\n};\n\nstruct inode *configfs_new_inode(umode_t mode, struct configfs_dirent *sd,\n\t\t\t\t struct super_block *s)\n{\n\tstruct inode * inode = new_inode(s);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mapping->a_ops = &configfs_aops;\n\t\tinode->i_op = &configfs_inode_operations;\n\n\t\tif (sd->s_iattr) {\n\t\t\t/* sysfs_dirent has non-default attributes\n\t\t\t * get them for the new inode from persistent copy\n\t\t\t * in sysfs_dirent\n\t\t\t */\n\t\t\tset_inode_attr(inode, sd->s_iattr);\n\t\t} else\n\t\t\tset_default_inode_attr(inode, mode);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "set_inode_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
    "lines": "117-125",
    "snippet": "static inline void set_inode_attr(struct inode * inode, struct iattr * iattr)\n{\n\tinode->i_mode = iattr->ia_mode;\n\tinode->i_uid = iattr->ia_uid;\n\tinode->i_gid = iattr->ia_gid;\n\tinode->i_atime = iattr->ia_atime;\n\tinode->i_mtime = iattr->ia_mtime;\n\tinode->i_ctime = iattr->ia_ctime;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nstatic inline void set_inode_attr(struct inode * inode, struct iattr * iattr)\n{\n\tinode->i_mode = iattr->ia_mode;\n\tinode->i_uid = iattr->ia_uid;\n\tinode->i_gid = iattr->ia_gid;\n\tinode->i_atime = iattr->ia_atime;\n\tinode->i_mtime = iattr->ia_mtime;\n\tinode->i_ctime = iattr->ia_ctime;\n}"
  },
  {
    "function_name": "set_default_inode_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
    "lines": "111-115",
    "snippet": "static inline void set_default_inode_attr(struct inode * inode, umode_t mode)\n{\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nstatic inline void set_default_inode_attr(struct inode * inode, umode_t mode)\n{\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n}"
  },
  {
    "function_name": "configfs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/inode.c",
    "lines": "57-109",
    "snippet": "int configfs_setattr(struct dentry * dentry, struct iattr * iattr)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\tstruct iattr * sd_iattr;\n\tunsigned int ia_valid = iattr->ia_valid;\n\tint error;\n\n\tif (!sd)\n\t\treturn -EINVAL;\n\n\tsd_iattr = sd->s_iattr;\n\tif (!sd_iattr) {\n\t\t/* setting attributes for the first time, allocate now */\n\t\tsd_iattr = kzalloc(sizeof(struct iattr), GFP_KERNEL);\n\t\tif (!sd_iattr)\n\t\t\treturn -ENOMEM;\n\t\t/* assign default attributes */\n\t\tsd_iattr->ia_mode = sd->s_mode;\n\t\tsd_iattr->ia_uid = GLOBAL_ROOT_UID;\n\t\tsd_iattr->ia_gid = GLOBAL_ROOT_GID;\n\t\tsd_iattr->ia_atime = sd_iattr->ia_mtime = sd_iattr->ia_ctime = CURRENT_TIME;\n\t\tsd->s_iattr = sd_iattr;\n\t}\n\t/* attributes were changed atleast once in past */\n\n\terror = simple_setattr(dentry, iattr);\n\tif (error)\n\t\treturn error;\n\n\tif (ia_valid & ATTR_UID)\n\t\tsd_iattr->ia_uid = iattr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tsd_iattr->ia_gid = iattr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tsd_iattr->ia_atime = timespec_trunc(iattr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tsd_iattr->ia_mtime = timespec_trunc(iattr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tsd_iattr->ia_ctime = timespec_trunc(iattr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = iattr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tsd_iattr->ia_mode = sd->s_mode = mode;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_FSETID"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "inode->i_gid"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_trunc",
          "args": [
            "iattr->ia_ctime",
            "inode->i_sb->s_time_gran"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_trunc",
          "args": [
            "iattr->ia_mtime",
            "inode->i_sb->s_time_gran"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_trunc",
          "args": [
            "iattr->ia_atime",
            "inode->i_sb->s_time_gran"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_setattr",
          "args": [
            "dentry",
            "iattr"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "simple_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "369-383",
          "snippet": "int simple_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tif (iattr->ia_valid & ATTR_SIZE)\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tif (iattr->ia_valid & ATTR_SIZE)\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct iattr)",
            "GFP_KERNEL"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/lockdep.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n\nint configfs_setattr(struct dentry * dentry, struct iattr * iattr)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\tstruct iattr * sd_iattr;\n\tunsigned int ia_valid = iattr->ia_valid;\n\tint error;\n\n\tif (!sd)\n\t\treturn -EINVAL;\n\n\tsd_iattr = sd->s_iattr;\n\tif (!sd_iattr) {\n\t\t/* setting attributes for the first time, allocate now */\n\t\tsd_iattr = kzalloc(sizeof(struct iattr), GFP_KERNEL);\n\t\tif (!sd_iattr)\n\t\t\treturn -ENOMEM;\n\t\t/* assign default attributes */\n\t\tsd_iattr->ia_mode = sd->s_mode;\n\t\tsd_iattr->ia_uid = GLOBAL_ROOT_UID;\n\t\tsd_iattr->ia_gid = GLOBAL_ROOT_GID;\n\t\tsd_iattr->ia_atime = sd_iattr->ia_mtime = sd_iattr->ia_ctime = CURRENT_TIME;\n\t\tsd->s_iattr = sd_iattr;\n\t}\n\t/* attributes were changed atleast once in past */\n\n\terror = simple_setattr(dentry, iattr);\n\tif (error)\n\t\treturn error;\n\n\tif (ia_valid & ATTR_UID)\n\t\tsd_iattr->ia_uid = iattr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tsd_iattr->ia_gid = iattr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tsd_iattr->ia_atime = timespec_trunc(iattr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tsd_iattr->ia_mtime = timespec_trunc(iattr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tsd_iattr->ia_ctime = timespec_trunc(iattr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = iattr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tsd_iattr->ia_mode = sd->s_mode = mode;\n\t}\n\n\treturn error;\n}"
  }
]