[
  {
    "function_name": "ecryptfs_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "885-898",
    "snippet": "static void __exit ecryptfs_exit(void)\n{\n\tint rc;\n\n\trc = ecryptfs_destroy_crypto();\n\tif (rc)\n\t\tprintk(KERN_ERR \"Failure whilst attempting to destroy crypto; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\tecryptfs_release_messaging();\n\tecryptfs_destroy_kthread();\n\tdo_sysfs_unregistration();\n\tunregister_filesystem(&ecryptfs_fs_type);\n\tecryptfs_free_kmem_caches();\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ecryptfs_fs_type;",
      "static struct file_system_type ecryptfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"ecryptfs\",\n\t.mount = ecryptfs_mount,\n\t.kill_sb = ecryptfs_kill_block_super,\n\t.fs_flags = 0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_free_kmem_caches",
          "args": [],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_free_kmem_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "726-743",
          "snippet": "static void ecryptfs_free_kmem_caches(void)\n{\n\tint i;\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\tif (*(info->cache))\n\t\t\tkmem_cache_destroy(*(info->cache));\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};\n\nstatic void ecryptfs_free_kmem_caches(void)\n{\n\tint i;\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\tif (*(info->cache))\n\t\t\tkmem_cache_destroy(*(info->cache));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&ecryptfs_fs_type"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_sysfs_unregistration",
          "args": [],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "do_sysfs_unregistration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "810-814",
          "snippet": "static void do_sysfs_unregistration(void)\n{\n\tsysfs_remove_group(ecryptfs_kobj, &attr_group);\n\tkobject_put(ecryptfs_kobj);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *ecryptfs_kobj;",
            "static struct attribute_group attr_group = {\n\t.attrs = attributes,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic struct kobject *ecryptfs_kobj;\nstatic struct attribute_group attr_group = {\n\t.attrs = attributes,\n};\n\nstatic void do_sysfs_unregistration(void)\n{\n\tsysfs_remove_group(ecryptfs_kobj, &attr_group);\n\tkobject_put(ecryptfs_kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_destroy_kthread",
          "args": [],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_destroy_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/kthread.c",
          "lines": "103-118",
          "snippet": "void ecryptfs_destroy_kthread(void)\n{\n\tstruct ecryptfs_open_req *req, *tmp;\n\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tecryptfs_kthread_ctl.flags |= ECRYPTFS_KTHREAD_ZOMBIE;\n\tlist_for_each_entry_safe(req, tmp, &ecryptfs_kthread_ctl.req_list,\n\t\t\t\t kthread_ctl_list) {\n\t\tlist_del(&req->kthread_ctl_list);\n\t\t*req->lower_file = ERR_PTR(-EIO);\n\t\tcomplete(&req->done);\n\t}\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\tkthread_stop(ecryptfs_kthread);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/mount.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001"
          ],
          "globals_used": [
            "static struct ecryptfs_kthread_ctl {\n#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001\n\tu32 flags;\n\tstruct mutex mux;\n\tstruct list_head req_list;\n\twait_queue_head_t wait;\n} ecryptfs_kthread_ctl;",
            "static struct task_struct *ecryptfs_kthread;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/mount.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n\n#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001\n\nstatic struct ecryptfs_kthread_ctl {\n#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001\n\tu32 flags;\n\tstruct mutex mux;\n\tstruct list_head req_list;\n\twait_queue_head_t wait;\n} ecryptfs_kthread_ctl;\nstatic struct task_struct *ecryptfs_kthread;\n\nvoid ecryptfs_destroy_kthread(void)\n{\n\tstruct ecryptfs_open_req *req, *tmp;\n\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tecryptfs_kthread_ctl.flags |= ECRYPTFS_KTHREAD_ZOMBIE;\n\tlist_for_each_entry_safe(req, tmp, &ecryptfs_kthread_ctl.req_list,\n\t\t\t\t kthread_ctl_list) {\n\t\tlist_del(&req->kthread_ctl_list);\n\t\t*req->lower_file = ERR_PTR(-EIO);\n\t\tcomplete(&req->done);\n\t}\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\tkthread_stop(ecryptfs_kthread);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_release_messaging",
          "args": [],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_release_messaging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "632-633",
          "snippet": "static inline void ecryptfs_release_messaging(void)\n{ }",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline void ecryptfs_release_messaging(void)\n{ }"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Failure whilst attempting to destroy crypto; \"\n\t\t       \"rc = [%d]\\n\"",
            "rc"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_destroy_crypto",
          "args": [],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_destroy_crypto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1656-1670",
          "snippet": "int ecryptfs_destroy_crypto(void)\n{\n\tstruct ecryptfs_key_tfm *key_tfm, *key_tfm_tmp;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tlist_for_each_entry_safe(key_tfm, key_tfm_tmp, &key_tfm_list,\n\t\t\t\t key_tfm_list) {\n\t\tlist_del(&key_tfm->key_tfm_list);\n\t\tif (key_tfm->key_tfm)\n\t\t\tcrypto_free_blkcipher(key_tfm->key_tfm);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, key_tfm);\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_key_tfm_cache;",
            "static struct list_head key_tfm_list;",
            "struct mutex key_tfm_list_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *ecryptfs_key_tfm_cache;\nstatic struct list_head key_tfm_list;\nstruct mutex key_tfm_list_mutex;\n\nint ecryptfs_destroy_crypto(void)\n{\n\tstruct ecryptfs_key_tfm *key_tfm, *key_tfm_tmp;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tlist_for_each_entry_safe(key_tfm, key_tfm_tmp, &key_tfm_list,\n\t\t\t\t key_tfm_list) {\n\t\tlist_del(&key_tfm->key_tfm_list);\n\t\tif (key_tfm->key_tfm)\n\t\t\tcrypto_free_blkcipher(key_tfm->key_tfm);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, key_tfm);\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic struct file_system_type ecryptfs_fs_type;\nstatic struct file_system_type ecryptfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"ecryptfs\",\n\t.mount = ecryptfs_mount,\n\t.kill_sb = ecryptfs_kill_block_super,\n\t.fs_flags = 0\n};\n\nstatic void __exit ecryptfs_exit(void)\n{\n\tint rc;\n\n\trc = ecryptfs_destroy_crypto();\n\tif (rc)\n\t\tprintk(KERN_ERR \"Failure whilst attempting to destroy crypto; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\tecryptfs_release_messaging();\n\tecryptfs_destroy_kthread();\n\tdo_sysfs_unregistration();\n\tunregister_filesystem(&ecryptfs_fs_type);\n\tecryptfs_free_kmem_caches();\n}"
  },
  {
    "function_name": "ecryptfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "816-883",
    "snippet": "static int __init ecryptfs_init(void)\n{\n\tint rc;\n\n\tif (ECRYPTFS_DEFAULT_EXTENT_SIZE > PAGE_CACHE_SIZE) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"The eCryptfs extent size is \"\n\t\t\t\t\"larger than the host's page size, and so \"\n\t\t\t\t\"eCryptfs cannot run on this system. The \"\n\t\t\t\t\"default eCryptfs extent size is [%u] bytes; \"\n\t\t\t\t\"the page size is [%lu] bytes.\\n\",\n\t\t\t\tECRYPTFS_DEFAULT_EXTENT_SIZE,\n\t\t\t\t(unsigned long)PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_init_kmem_caches();\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"Failed to allocate one or more kmem_cache objects\\n\");\n\t\tgoto out;\n\t}\n\trc = do_sysfs_registration();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"sysfs registration failed\\n\");\n\t\tgoto out_free_kmem_caches;\n\t}\n\trc = ecryptfs_init_kthread();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: kthread initialization failed; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_do_sysfs_unregistration;\n\t}\n\trc = ecryptfs_init_messaging();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failure occurred while attempting to \"\n\t\t\t\t\"initialize the communications channel to \"\n\t\t\t\t\"ecryptfsd\\n\");\n\t\tgoto out_destroy_kthread;\n\t}\n\trc = ecryptfs_init_crypto();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failure whilst attempting to init crypto; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\t\tgoto out_release_messaging;\n\t}\n\trc = register_filesystem(&ecryptfs_fs_type);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to register filesystem\\n\");\n\t\tgoto out_destroy_crypto;\n\t}\n\tif (ecryptfs_verbosity > 0)\n\t\tprintk(KERN_CRIT \"eCryptfs verbosity set to %d. Secret values \"\n\t\t\t\"will be written to the syslog!\\n\", ecryptfs_verbosity);\n\n\tgoto out;\nout_destroy_crypto:\n\tecryptfs_destroy_crypto();\nout_release_messaging:\n\tecryptfs_release_messaging();\nout_destroy_kthread:\n\tecryptfs_destroy_kthread();\nout_do_sysfs_unregistration:\n\tdo_sysfs_unregistration();\nout_free_kmem_caches:\n\tecryptfs_free_kmem_caches();\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ecryptfs_verbosity = 0;",
      "static struct file_system_type ecryptfs_fs_type;",
      "static struct file_system_type ecryptfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"ecryptfs\",\n\t.mount = ecryptfs_mount,\n\t.kill_sb = ecryptfs_kill_block_super,\n\t.fs_flags = 0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_free_kmem_caches",
          "args": [],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_free_kmem_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "726-743",
          "snippet": "static void ecryptfs_free_kmem_caches(void)\n{\n\tint i;\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\tif (*(info->cache))\n\t\t\tkmem_cache_destroy(*(info->cache));\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};\n\nstatic void ecryptfs_free_kmem_caches(void)\n{\n\tint i;\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\tif (*(info->cache))\n\t\t\tkmem_cache_destroy(*(info->cache));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_sysfs_unregistration",
          "args": [],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "do_sysfs_unregistration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "810-814",
          "snippet": "static void do_sysfs_unregistration(void)\n{\n\tsysfs_remove_group(ecryptfs_kobj, &attr_group);\n\tkobject_put(ecryptfs_kobj);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *ecryptfs_kobj;",
            "static struct attribute_group attr_group = {\n\t.attrs = attributes,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic struct kobject *ecryptfs_kobj;\nstatic struct attribute_group attr_group = {\n\t.attrs = attributes,\n};\n\nstatic void do_sysfs_unregistration(void)\n{\n\tsysfs_remove_group(ecryptfs_kobj, &attr_group);\n\tkobject_put(ecryptfs_kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_destroy_kthread",
          "args": [],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_destroy_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/kthread.c",
          "lines": "103-118",
          "snippet": "void ecryptfs_destroy_kthread(void)\n{\n\tstruct ecryptfs_open_req *req, *tmp;\n\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tecryptfs_kthread_ctl.flags |= ECRYPTFS_KTHREAD_ZOMBIE;\n\tlist_for_each_entry_safe(req, tmp, &ecryptfs_kthread_ctl.req_list,\n\t\t\t\t kthread_ctl_list) {\n\t\tlist_del(&req->kthread_ctl_list);\n\t\t*req->lower_file = ERR_PTR(-EIO);\n\t\tcomplete(&req->done);\n\t}\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\tkthread_stop(ecryptfs_kthread);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/mount.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001"
          ],
          "globals_used": [
            "static struct ecryptfs_kthread_ctl {\n#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001\n\tu32 flags;\n\tstruct mutex mux;\n\tstruct list_head req_list;\n\twait_queue_head_t wait;\n} ecryptfs_kthread_ctl;",
            "static struct task_struct *ecryptfs_kthread;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/mount.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n\n#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001\n\nstatic struct ecryptfs_kthread_ctl {\n#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001\n\tu32 flags;\n\tstruct mutex mux;\n\tstruct list_head req_list;\n\twait_queue_head_t wait;\n} ecryptfs_kthread_ctl;\nstatic struct task_struct *ecryptfs_kthread;\n\nvoid ecryptfs_destroy_kthread(void)\n{\n\tstruct ecryptfs_open_req *req, *tmp;\n\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tecryptfs_kthread_ctl.flags |= ECRYPTFS_KTHREAD_ZOMBIE;\n\tlist_for_each_entry_safe(req, tmp, &ecryptfs_kthread_ctl.req_list,\n\t\t\t\t kthread_ctl_list) {\n\t\tlist_del(&req->kthread_ctl_list);\n\t\t*req->lower_file = ERR_PTR(-EIO);\n\t\tcomplete(&req->done);\n\t}\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\tkthread_stop(ecryptfs_kthread);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_release_messaging",
          "args": [],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_release_messaging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "632-633",
          "snippet": "static inline void ecryptfs_release_messaging(void)\n{ }",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline void ecryptfs_release_messaging(void)\n{ }"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_destroy_crypto",
          "args": [],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_destroy_crypto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1656-1670",
          "snippet": "int ecryptfs_destroy_crypto(void)\n{\n\tstruct ecryptfs_key_tfm *key_tfm, *key_tfm_tmp;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tlist_for_each_entry_safe(key_tfm, key_tfm_tmp, &key_tfm_list,\n\t\t\t\t key_tfm_list) {\n\t\tlist_del(&key_tfm->key_tfm_list);\n\t\tif (key_tfm->key_tfm)\n\t\t\tcrypto_free_blkcipher(key_tfm->key_tfm);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, key_tfm);\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_key_tfm_cache;",
            "static struct list_head key_tfm_list;",
            "struct mutex key_tfm_list_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *ecryptfs_key_tfm_cache;\nstatic struct list_head key_tfm_list;\nstruct mutex key_tfm_list_mutex;\n\nint ecryptfs_destroy_crypto(void)\n{\n\tstruct ecryptfs_key_tfm *key_tfm, *key_tfm_tmp;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tlist_for_each_entry_safe(key_tfm, key_tfm_tmp, &key_tfm_list,\n\t\t\t\t key_tfm_list) {\n\t\tlist_del(&key_tfm->key_tfm_list);\n\t\tif (key_tfm->key_tfm)\n\t\t\tcrypto_free_blkcipher(key_tfm->key_tfm);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, key_tfm);\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"eCryptfs verbosity set to %d. Secret values \"\n\t\t\t\"will be written to the syslog!\\n\"",
            "ecryptfs_verbosity"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ecryptfs_fs_type"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_init_crypto",
          "args": [],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_init_crypto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1644-1649",
          "snippet": "int __init ecryptfs_init_crypto(void)\n{\n\tmutex_init(&key_tfm_list_mutex);\n\tINIT_LIST_HEAD(&key_tfm_list);\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head key_tfm_list;",
            "struct mutex key_tfm_list_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct list_head key_tfm_list;\nstruct mutex key_tfm_list_mutex;\n\nint __init ecryptfs_init_crypto(void)\n{\n\tmutex_init(&key_tfm_list_mutex);\n\tINIT_LIST_HEAD(&key_tfm_list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_init_messaging",
          "args": [],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_init_messaging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "628-631",
          "snippet": "static inline int ecryptfs_init_messaging(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline int ecryptfs_init_messaging(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_init_kthread",
          "args": [],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_init_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/kthread.c",
          "lines": "86-101",
          "snippet": "int __init ecryptfs_init_kthread(void)\n{\n\tint rc = 0;\n\n\tmutex_init(&ecryptfs_kthread_ctl.mux);\n\tinit_waitqueue_head(&ecryptfs_kthread_ctl.wait);\n\tINIT_LIST_HEAD(&ecryptfs_kthread_ctl.req_list);\n\tecryptfs_kthread = kthread_run(&ecryptfs_threadfn, NULL,\n\t\t\t\t       \"ecryptfs-kthread\");\n\tif (IS_ERR(ecryptfs_kthread)) {\n\t\trc = PTR_ERR(ecryptfs_kthread);\n\t\tprintk(KERN_ERR \"%s: Failed to create kernel thread; rc = [%d]\"\n\t\t       \"\\n\", __func__, rc);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/mount.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_kthread_ctl {\n#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001\n\tu32 flags;\n\tstruct mutex mux;\n\tstruct list_head req_list;\n\twait_queue_head_t wait;\n} ecryptfs_kthread_ctl;",
            "static struct task_struct *ecryptfs_kthread;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/mount.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n\nstatic struct ecryptfs_kthread_ctl {\n#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001\n\tu32 flags;\n\tstruct mutex mux;\n\tstruct list_head req_list;\n\twait_queue_head_t wait;\n} ecryptfs_kthread_ctl;\nstatic struct task_struct *ecryptfs_kthread;\n\nint __init ecryptfs_init_kthread(void)\n{\n\tint rc = 0;\n\n\tmutex_init(&ecryptfs_kthread_ctl.mux);\n\tinit_waitqueue_head(&ecryptfs_kthread_ctl.wait);\n\tINIT_LIST_HEAD(&ecryptfs_kthread_ctl.req_list);\n\tecryptfs_kthread = kthread_run(&ecryptfs_threadfn, NULL,\n\t\t\t\t       \"ecryptfs-kthread\");\n\tif (IS_ERR(ecryptfs_kthread)) {\n\t\trc = PTR_ERR(ecryptfs_kthread);\n\t\tprintk(KERN_ERR \"%s: Failed to create kernel thread; rc = [%d]\"\n\t\t       \"\\n\", __func__, rc);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_sysfs_registration",
          "args": [],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "do_sysfs_registration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "790-808",
          "snippet": "static int do_sysfs_registration(void)\n{\n\tint rc;\n\n\tecryptfs_kobj = kobject_create_and_add(\"ecryptfs\", fs_kobj);\n\tif (!ecryptfs_kobj) {\n\t\tprintk(KERN_ERR \"Unable to create ecryptfs kset\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = sysfs_create_group(ecryptfs_kobj, &attr_group);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"Unable to create ecryptfs version attributes\\n\");\n\t\tkobject_put(ecryptfs_kobj);\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *ecryptfs_kobj;",
            "static struct attribute *attributes[] = {\n\t&version_attr.attr,\n\tNULL,\n};",
            "static struct attribute_group attr_group = {\n\t.attrs = attributes,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic struct kobject *ecryptfs_kobj;\nstatic struct attribute *attributes[] = {\n\t&version_attr.attr,\n\tNULL,\n};\nstatic struct attribute_group attr_group = {\n\t.attrs = attributes,\n};\n\nstatic int do_sysfs_registration(void)\n{\n\tint rc;\n\n\tecryptfs_kobj = kobject_create_and_add(\"ecryptfs\", fs_kobj);\n\tif (!ecryptfs_kobj) {\n\t\tprintk(KERN_ERR \"Unable to create ecryptfs kset\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = sysfs_create_group(ecryptfs_kobj, &attr_group);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"Unable to create ecryptfs version attributes\\n\");\n\t\tkobject_put(ecryptfs_kobj);\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_init_kmem_caches",
          "args": [],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_init_kmem_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "750-769",
          "snippet": "static int ecryptfs_init_kmem_caches(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\t*(info->cache) = kmem_cache_create(info->name, info->size,\n\t\t\t\t0, SLAB_HWCACHE_ALIGN, info->ctor);\n\t\tif (!*(info->cache)) {\n\t\t\tecryptfs_free_kmem_caches();\n\t\t\tecryptfs_printk(KERN_WARNING, \"%s: \"\n\t\t\t\t\t\"kmem_cache_create failed\\n\",\n\t\t\t\t\tinfo->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};\n\nstatic int ecryptfs_init_kmem_caches(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\t*(info->cache) = kmem_cache_create(info->name, info->size,\n\t\t\t\t0, SLAB_HWCACHE_ALIGN, info->ctor);\n\t\tif (!*(info->cache)) {\n\t\t\tecryptfs_free_kmem_caches();\n\t\t\tecryptfs_printk(KERN_WARNING, \"%s: \"\n\t\t\t\t\t\"kmem_cache_create failed\\n\",\n\t\t\t\t\tinfo->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\nstatic struct file_system_type ecryptfs_fs_type;\nstatic struct file_system_type ecryptfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"ecryptfs\",\n\t.mount = ecryptfs_mount,\n\t.kill_sb = ecryptfs_kill_block_super,\n\t.fs_flags = 0\n};\n\nstatic int __init ecryptfs_init(void)\n{\n\tint rc;\n\n\tif (ECRYPTFS_DEFAULT_EXTENT_SIZE > PAGE_CACHE_SIZE) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"The eCryptfs extent size is \"\n\t\t\t\t\"larger than the host's page size, and so \"\n\t\t\t\t\"eCryptfs cannot run on this system. The \"\n\t\t\t\t\"default eCryptfs extent size is [%u] bytes; \"\n\t\t\t\t\"the page size is [%lu] bytes.\\n\",\n\t\t\t\tECRYPTFS_DEFAULT_EXTENT_SIZE,\n\t\t\t\t(unsigned long)PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_init_kmem_caches();\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"Failed to allocate one or more kmem_cache objects\\n\");\n\t\tgoto out;\n\t}\n\trc = do_sysfs_registration();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"sysfs registration failed\\n\");\n\t\tgoto out_free_kmem_caches;\n\t}\n\trc = ecryptfs_init_kthread();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: kthread initialization failed; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_do_sysfs_unregistration;\n\t}\n\trc = ecryptfs_init_messaging();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failure occurred while attempting to \"\n\t\t\t\t\"initialize the communications channel to \"\n\t\t\t\t\"ecryptfsd\\n\");\n\t\tgoto out_destroy_kthread;\n\t}\n\trc = ecryptfs_init_crypto();\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failure whilst attempting to init crypto; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\t\tgoto out_release_messaging;\n\t}\n\trc = register_filesystem(&ecryptfs_fs_type);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to register filesystem\\n\");\n\t\tgoto out_destroy_crypto;\n\t}\n\tif (ecryptfs_verbosity > 0)\n\t\tprintk(KERN_CRIT \"eCryptfs verbosity set to %d. Secret values \"\n\t\t\t\"will be written to the syslog!\\n\", ecryptfs_verbosity);\n\n\tgoto out;\nout_destroy_crypto:\n\tecryptfs_destroy_crypto();\nout_release_messaging:\n\tecryptfs_release_messaging();\nout_destroy_kthread:\n\tecryptfs_destroy_kthread();\nout_do_sysfs_unregistration:\n\tdo_sysfs_unregistration();\nout_free_kmem_caches:\n\tecryptfs_free_kmem_caches();\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "do_sysfs_unregistration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "810-814",
    "snippet": "static void do_sysfs_unregistration(void)\n{\n\tsysfs_remove_group(ecryptfs_kobj, &attr_group);\n\tkobject_put(ecryptfs_kobj);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobject *ecryptfs_kobj;",
      "static struct attribute_group attr_group = {\n\t.attrs = attributes,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "ecryptfs_kobj"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_remove_group",
          "args": [
            "ecryptfs_kobj",
            "&attr_group"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_remove_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
          "lines": "243-252",
          "snippet": "void sysfs_remove_groups(struct kobject *kobj,\n\t\t\t const struct attribute_group **groups)\n{\n\tint i;\n\n\tif (!groups)\n\t\treturn;\n\tfor (i = 0; groups[i]; i++)\n\t\tsysfs_remove_group(kobj, groups[i]);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/err.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nvoid sysfs_remove_groups(struct kobject *kobj,\n\t\t\t const struct attribute_group **groups)\n{\n\tint i;\n\n\tif (!groups)\n\t\treturn;\n\tfor (i = 0; groups[i]; i++)\n\t\tsysfs_remove_group(kobj, groups[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic struct kobject *ecryptfs_kobj;\nstatic struct attribute_group attr_group = {\n\t.attrs = attributes,\n};\n\nstatic void do_sysfs_unregistration(void)\n{\n\tsysfs_remove_group(ecryptfs_kobj, &attr_group);\n\tkobject_put(ecryptfs_kobj);\n}"
  },
  {
    "function_name": "do_sysfs_registration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "790-808",
    "snippet": "static int do_sysfs_registration(void)\n{\n\tint rc;\n\n\tecryptfs_kobj = kobject_create_and_add(\"ecryptfs\", fs_kobj);\n\tif (!ecryptfs_kobj) {\n\t\tprintk(KERN_ERR \"Unable to create ecryptfs kset\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = sysfs_create_group(ecryptfs_kobj, &attr_group);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"Unable to create ecryptfs version attributes\\n\");\n\t\tkobject_put(ecryptfs_kobj);\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobject *ecryptfs_kobj;",
      "static struct attribute *attributes[] = {\n\t&version_attr.attr,\n\tNULL,\n};",
      "static struct attribute_group attr_group = {\n\t.attrs = attributes,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "ecryptfs_kobj"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"Unable to create ecryptfs version attributes\\n\""
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "ecryptfs_kobj",
            "&attr_group"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_create_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
          "lines": "155-173",
          "snippet": "int sysfs_create_groups(struct kobject *kobj,\n\t\t\tconst struct attribute_group **groups)\n{\n\tint error = 0;\n\tint i;\n\n\tif (!groups)\n\t\treturn 0;\n\n\tfor (i = 0; groups[i]; i++) {\n\t\terror = sysfs_create_group(kobj, groups[i]);\n\t\tif (error) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tsysfs_remove_group(kobj, groups[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/err.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nint sysfs_create_groups(struct kobject *kobj,\n\t\t\tconst struct attribute_group **groups)\n{\n\tint error = 0;\n\tint i;\n\n\tif (!groups)\n\t\treturn 0;\n\n\tfor (i = 0; groups[i]; i++) {\n\t\terror = sysfs_create_group(kobj, groups[i]);\n\t\tif (error) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tsysfs_remove_group(kobj, groups[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"ecryptfs\"",
            "fs_kobj"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic struct kobject *ecryptfs_kobj;\nstatic struct attribute *attributes[] = {\n\t&version_attr.attr,\n\tNULL,\n};\nstatic struct attribute_group attr_group = {\n\t.attrs = attributes,\n};\n\nstatic int do_sysfs_registration(void)\n{\n\tint rc;\n\n\tecryptfs_kobj = kobject_create_and_add(\"ecryptfs\", fs_kobj);\n\tif (!ecryptfs_kobj) {\n\t\tprintk(KERN_ERR \"Unable to create ecryptfs kset\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = sysfs_create_group(ecryptfs_kobj, &attr_group);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"Unable to create ecryptfs version attributes\\n\");\n\t\tkobject_put(ecryptfs_kobj);\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "version_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "773-777",
    "snippet": "static ssize_t version_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buff)\n{\n\treturn snprintf(buff, PAGE_SIZE, \"%d\\n\", ECRYPTFS_VERSIONING_MASK);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buff",
            "PAGE_SIZE",
            "\"%d\\n\"",
            "ECRYPTFS_VERSIONING_MASK"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic ssize_t version_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buff)\n{\n\treturn snprintf(buff, PAGE_SIZE, \"%d\\n\", ECRYPTFS_VERSIONING_MASK);\n}"
  },
  {
    "function_name": "ecryptfs_init_kmem_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "750-769",
    "snippet": "static int ecryptfs_init_kmem_caches(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\t*(info->cache) = kmem_cache_create(info->name, info->size,\n\t\t\t\t0, SLAB_HWCACHE_ALIGN, info->ctor);\n\t\tif (!*(info->cache)) {\n\t\t\tecryptfs_free_kmem_caches();\n\t\t\tecryptfs_printk(KERN_WARNING, \"%s: \"\n\t\t\t\t\t\"kmem_cache_create failed\\n\",\n\t\t\t\t\tinfo->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_WARNING",
            "\"%s: \"\n\t\t\t\t\t\"kmem_cache_create failed\\n\"",
            "info->name"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_free_kmem_caches",
          "args": [],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_free_kmem_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "726-743",
          "snippet": "static void ecryptfs_free_kmem_caches(void)\n{\n\tint i;\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\tif (*(info->cache))\n\t\t\tkmem_cache_destroy(*(info->cache));\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};\n\nstatic void ecryptfs_free_kmem_caches(void)\n{\n\tint i;\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\tif (*(info->cache))\n\t\t\tkmem_cache_destroy(*(info->cache));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "info->name",
            "info->size",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "info->ctor"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ecryptfs_cache_infos"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};\n\nstatic int ecryptfs_init_kmem_caches(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\t*(info->cache) = kmem_cache_create(info->name, info->size,\n\t\t\t\t0, SLAB_HWCACHE_ALIGN, info->ctor);\n\t\tif (!*(info->cache)) {\n\t\t\tecryptfs_free_kmem_caches();\n\t\t\tecryptfs_printk(KERN_WARNING, \"%s: \"\n\t\t\t\t\t\"kmem_cache_create failed\\n\",\n\t\t\t\t\tinfo->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_free_kmem_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "726-743",
    "snippet": "static void ecryptfs_free_kmem_caches(void)\n{\n\tint i;\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\tif (*(info->cache))\n\t\t\tkmem_cache_destroy(*(info->cache));\n\t}\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "*(info->cache)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ecryptfs_cache_infos"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic struct ecryptfs_cache_info {\n\tstruct kmem_cache **cache;\n\tconst char *name;\n\tsize_t size;\n\tvoid (*ctor)(void *obj);\n} ecryptfs_cache_infos[] = {\n\t{\n\t\t.cache = &ecryptfs_auth_tok_list_item_cache,\n\t\t.name = \"ecryptfs_auth_tok_list_item\",\n\t\t.size = sizeof(struct ecryptfs_auth_tok_list_item),\n\t},\n\t{\n\t\t.cache = &ecryptfs_file_info_cache,\n\t\t.name = \"ecryptfs_file_cache\",\n\t\t.size = sizeof(struct ecryptfs_file_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_dentry_info_cache,\n\t\t.name = \"ecryptfs_dentry_info_cache\",\n\t\t.size = sizeof(struct ecryptfs_dentry_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_inode_info_cache,\n\t\t.name = \"ecryptfs_inode_cache\",\n\t\t.size = sizeof(struct ecryptfs_inode_info),\n\t\t.ctor = inode_info_init_once,\n\t},\n\t{\n\t\t.cache = &ecryptfs_sb_info_cache,\n\t\t.name = \"ecryptfs_sb_cache\",\n\t\t.size = sizeof(struct ecryptfs_sb_info),\n\t},\n\t{\n\t\t.cache = &ecryptfs_header_cache,\n\t\t.name = \"ecryptfs_headers\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_xattr_cache,\n\t\t.name = \"ecryptfs_xattr_cache\",\n\t\t.size = PAGE_CACHE_SIZE,\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_record_cache,\n\t\t.name = \"ecryptfs_key_record_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_record),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_sig_cache,\n\t\t.name = \"ecryptfs_key_sig_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_sig),\n\t},\n\t{\n\t\t.cache = &ecryptfs_global_auth_tok_cache,\n\t\t.name = \"ecryptfs_global_auth_tok_cache\",\n\t\t.size = sizeof(struct ecryptfs_global_auth_tok),\n\t},\n\t{\n\t\t.cache = &ecryptfs_key_tfm_cache,\n\t\t.name = \"ecryptfs_key_tfm_cache\",\n\t\t.size = sizeof(struct ecryptfs_key_tfm),\n\t},\n};\n\nstatic void ecryptfs_free_kmem_caches(void)\n{\n\tint i;\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\tif (*(info->cache))\n\t\t\tkmem_cache_destroy(*(info->cache));\n\t}\n}"
  },
  {
    "function_name": "inode_info_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "654-660",
    "snippet": "static void\ninode_info_init_once(void *vptr)\n{\n\tstruct ecryptfs_inode_info *ei = (struct ecryptfs_inode_info *)vptr;\n\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic void\ninode_info_init_once(void *vptr)\n{\n\tstruct ecryptfs_inode_info *ei = (struct ecryptfs_inode_info *)vptr;\n\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "ecryptfs_kill_block_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "629-638",
    "snippet": "static void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_sb_info_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_sb_info_cache",
            "sb_info"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&sb_info->bdi"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_destroy_mount_crypt_stat",
          "args": [
            "&sb_info->mount_crypt_stat"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_destroy_mount_crypt_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "249-268",
          "snippet": "void ecryptfs_destroy_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *auth_tok, *auth_tok_tmp;\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED))\n\t\treturn;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry_safe(auth_tok, auth_tok_tmp,\n\t\t\t\t &mount_crypt_stat->global_auth_tok_list,\n\t\t\t\t mount_crypt_stat_list) {\n\t\tlist_del(&auth_tok->mount_crypt_stat_list);\n\t\tif (auth_tok->global_auth_tok_key\n\t\t    && !(auth_tok->flags & ECRYPTFS_AUTH_TOK_INVALID))\n\t\t\tkey_put(auth_tok->global_auth_tok_key);\n\t\tkmem_cache_free(ecryptfs_global_auth_tok_cache, auth_tok);\n\t}\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmemset(mount_crypt_stat, 0, sizeof(struct ecryptfs_mount_crypt_stat));\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_destroy_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *auth_tok, *auth_tok_tmp;\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED))\n\t\treturn;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry_safe(auth_tok, auth_tok_tmp,\n\t\t\t\t &mount_crypt_stat->global_auth_tok_list,\n\t\t\t\t mount_crypt_stat_list) {\n\t\tlist_del(&auth_tok->mount_crypt_stat_list);\n\t\tif (auth_tok->global_auth_tok_key\n\t\t    && !(auth_tok->flags & ECRYPTFS_AUTH_TOK_INVALID))\n\t\t\tkey_put(auth_tok->global_auth_tok_key);\n\t\tkmem_cache_free(ecryptfs_global_auth_tok_cache, auth_tok);\n\t}\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmemset(mount_crypt_stat, 0, sizeof(struct ecryptfs_mount_crypt_stat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_anon_super",
          "args": [
            "sb"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_private",
          "args": [
            "sb"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "473-477",
          "snippet": "static inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\n\nstatic void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}"
  },
  {
    "function_name": "ecryptfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "491-621",
    "snippet": "static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *dev_name, void *raw_data)\n{\n\tstruct super_block *s;\n\tstruct ecryptfs_sb_info *sbi;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_dentry_info *root_info;\n\tconst char *err = \"Getting sb failed\";\n\tstruct inode *inode;\n\tstruct path path;\n\tuid_t check_ruid;\n\tint rc;\n\n\tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n\tif (!sbi) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);\n\tif (rc) {\n\t\terr = \"Error parsing options\";\n\t\tgoto out;\n\t}\n\tmount_crypt_stat = &sbi->mount_crypt_stat;\n\n\ts = sget(fs_type, NULL, set_anon_super, flags, NULL);\n\tif (IS_ERR(s)) {\n\t\trc = PTR_ERR(s);\n\t\tgoto out;\n\t}\n\n\trc = bdi_setup_and_register(&sbi->bdi, \"ecryptfs\");\n\tif (rc)\n\t\tgoto out1;\n\n\tecryptfs_set_superblock_private(s, sbi);\n\ts->s_bdi = &sbi->bdi;\n\n\t/* ->kill_sb() will take care of sbi after that point */\n\tsbi = NULL;\n\ts->s_op = &ecryptfs_sops;\n\ts->s_d_op = &ecryptfs_dops;\n\n\terr = \"Reading sb failed\";\n\trc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"kern_path() failed\\n\");\n\t\tgoto out1;\n\t}\n\tif (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Mount on filesystem of type \"\n\t\t\t\"eCryptfs explicitly disallowed due to \"\n\t\t\t\"known incompatibilities\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {\n\t\trc = -EPERM;\n\t\tprintk(KERN_ERR \"Mount of device (uid: %d) not owned by \"\n\t\t       \"requested user (uid: %d)\\n\",\n\t\t\ti_uid_read(path.dentry->d_inode),\n\t\t\tfrom_kuid(&init_user_ns, current_uid()));\n\t\tgoto out_free;\n\t}\n\n\tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n\n\t/**\n\t * Set the POSIX ACL flag based on whether they're enabled in the lower\n\t * mount.\n\t */\n\ts->s_flags = flags & ~MS_POSIXACL;\n\ts->s_flags |= path.dentry->d_sb->s_flags & MS_POSIXACL;\n\n\t/**\n\t * Force a read-only eCryptfs mount when:\n\t *   1) The lower mount is ro\n\t *   2) The ecryptfs_encrypted_view mount option is specified\n\t */\n\tif (path.dentry->d_sb->s_flags & MS_RDONLY ||\n\t    mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t\ts->s_flags |= MS_RDONLY;\n\n\ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n\ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n\ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n\n\trc = -EINVAL;\n\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n\t\tpr_err(\"eCryptfs: maximum fs stacking depth exceeded\\n\");\n\t\tgoto out_free;\n\t}\n\n\tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n\trc = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_free;\n\n\ts->s_root = d_make_root(inode);\n\tif (!s->s_root) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\trc = -ENOMEM;\n\troot_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!root_info)\n\t\tgoto out_free;\n\n\t/* ->kill_sb() will take care of root_info */\n\tecryptfs_set_dentry_private(s->s_root, root_info);\n\troot_info->lower_path = path;\n\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nout_free:\n\tpath_put(&path);\nout1:\n\tdeactivate_locked_super(s);\nout:\n\tif (sbi) {\n\t\tecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);\n\t\tkmem_cache_free(ecryptfs_sb_info_cache, sbi);\n\t}\n\tprintk(KERN_ERR \"%s; rc = [%d]\\n\", err, rc);\n\treturn ERR_PTR(rc);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_sb_info_cache;",
      "static struct file_system_type ecryptfs_fs_type;",
      "static struct file_system_type ecryptfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"ecryptfs\",\n\t.mount = ecryptfs_mount,\n\t.kill_sb = ecryptfs_kill_block_super,\n\t.fs_flags = 0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s; rc = [%d]\\n\"",
            "err",
            "rc"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_sb_info_cache",
            "sbi"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_destroy_mount_crypt_stat",
          "args": [
            "&sbi->mount_crypt_stat"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_destroy_mount_crypt_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "249-268",
          "snippet": "void ecryptfs_destroy_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *auth_tok, *auth_tok_tmp;\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED))\n\t\treturn;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry_safe(auth_tok, auth_tok_tmp,\n\t\t\t\t &mount_crypt_stat->global_auth_tok_list,\n\t\t\t\t mount_crypt_stat_list) {\n\t\tlist_del(&auth_tok->mount_crypt_stat_list);\n\t\tif (auth_tok->global_auth_tok_key\n\t\t    && !(auth_tok->flags & ECRYPTFS_AUTH_TOK_INVALID))\n\t\t\tkey_put(auth_tok->global_auth_tok_key);\n\t\tkmem_cache_free(ecryptfs_global_auth_tok_cache, auth_tok);\n\t}\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmemset(mount_crypt_stat, 0, sizeof(struct ecryptfs_mount_crypt_stat));\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_destroy_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *auth_tok, *auth_tok_tmp;\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED))\n\t\treturn;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry_safe(auth_tok, auth_tok_tmp,\n\t\t\t\t &mount_crypt_stat->global_auth_tok_list,\n\t\t\t\t mount_crypt_stat_list) {\n\t\tlist_del(&auth_tok->mount_crypt_stat_list);\n\t\tif (auth_tok->global_auth_tok_key\n\t\t    && !(auth_tok->flags & ECRYPTFS_AUTH_TOK_INVALID))\n\t\t\tkey_put(auth_tok->global_auth_tok_key);\n\t\tkmem_cache_free(ecryptfs_global_auth_tok_cache, auth_tok);\n\t}\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmemset(mount_crypt_stat, 0, sizeof(struct ecryptfs_mount_crypt_stat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "s->s_root"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_set_dentry_private",
          "args": [
            "s->s_root",
            "root_info"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_set_dentry_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "505-510",
          "snippet": "static inline void\necryptfs_set_dentry_private(struct dentry *dentry,\n\t\t\t    struct ecryptfs_dentry_info *dentry_info)\n{\n\tdentry->d_fsdata = dentry_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline void\necryptfs_set_dentry_private(struct dentry *dentry,\n\t\t\t    struct ecryptfs_dentry_info *dentry_info)\n{\n\tdentry->d_fsdata = dentry_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "ecryptfs_dentry_info_cache",
            "GFP_KERNEL"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_inode",
          "args": [
            "path.dentry->d_inode",
            "s"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "110-119",
          "snippet": "struct inode *ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t struct super_block *sb)\n{\n\tstruct inode *inode = __ecryptfs_get_inode(lower_inode, sb);\n\n\tif (!IS_ERR(inode) && (inode->i_state & I_NEW))\n\t\tunlock_new_inode(inode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstruct inode *ecryptfs_get_inode(struct inode *lower_inode,\n\t\t\t\t struct super_block *sb)\n{\n\tstruct inode *inode = __ecryptfs_get_inode(lower_inode, sb);\n\n\tif (!IS_ERR(inode) && (inode->i_state & I_NEW))\n\t\tunlock_new_inode(inode);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"eCryptfs: maximum fs stacking depth exceeded\\n\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_set_superblock_lower",
          "args": [
            "s",
            "path.dentry->d_sb"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_set_superblock_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "492-497",
          "snippet": "static inline void\necryptfs_set_superblock_lower(struct super_block *sb,\n\t\t\t      struct super_block *lower_sb)\n{\n\t((struct ecryptfs_sb_info *)sb->s_fs_info)->wsi_sb = lower_sb;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline void\necryptfs_set_superblock_lower(struct super_block *sb,\n\t\t\t      struct super_block *lower_sb)\n{\n\t((struct ecryptfs_sb_info *)sb->s_fs_info)->wsi_sb = lower_sb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "current_uid()"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "path.dentry->d_inode"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "path.dentry->d_inode->i_uid",
            "current_uid()"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "dev_name",
            "LOOKUP_FOLLOW | LOOKUP_DIRECTORY",
            "&path"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_set_superblock_private",
          "args": [
            "s",
            "sbi"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_set_superblock_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "479-484",
          "snippet": "static inline void\necryptfs_set_superblock_private(struct super_block *sb,\n\t\t\t\tstruct ecryptfs_sb_info *sb_info)\n{\n\tsb->s_fs_info = sb_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline void\necryptfs_set_superblock_private(struct super_block *sb,\n\t\t\t\tstruct ecryptfs_sb_info *sb_info)\n{\n\tsb->s_fs_info = sb_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_setup_and_register",
          "args": [
            "&sbi->bdi",
            "\"ecryptfs\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "s"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "NULL",
            "set_anon_super",
            "flags",
            "NULL"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_parse_options",
          "args": [
            "sbi",
            "raw_data",
            "&check_ruid"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "257-479",
          "snippet": "static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,\n\t\t\t\t  uid_t *check_ruid)\n{\n\tchar *p;\n\tint rc = 0;\n\tint sig_set = 0;\n\tint cipher_name_set = 0;\n\tint fn_cipher_name_set = 0;\n\tint cipher_key_bytes;\n\tint cipher_key_bytes_set = 0;\n\tint fn_cipher_key_bytes;\n\tint fn_cipher_key_bytes_set = 0;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&sbi->mount_crypt_stat;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tchar *sig_src;\n\tchar *cipher_name_dst;\n\tchar *cipher_name_src;\n\tchar *fn_cipher_name_dst;\n\tchar *fn_cipher_name_src;\n\tchar *fnek_dst;\n\tchar *fnek_src;\n\tchar *cipher_key_bytes_src;\n\tchar *fn_cipher_key_bytes_src;\n\tu8 cipher_code;\n\n\t*check_ruid = 0;\n\n\tif (!options) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tecryptfs_init_mount_crypt_stat(mount_crypt_stat);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase ecryptfs_opt_sig:\n\t\tcase ecryptfs_opt_ecryptfs_sig:\n\t\t\tsig_src = args[0].from;\n\t\t\trc = ecryptfs_add_global_auth_tok(mount_crypt_stat,\n\t\t\t\t\t\t\t  sig_src, 0);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global sig; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsig_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_cipher:\n\t\tcase ecryptfs_opt_ecryptfs_cipher:\n\t\t\tcipher_name_src = args[0].from;\n\t\t\tcipher_name_dst =\n\t\t\t\tmount_crypt_stat->\n\t\t\t\tglobal_default_cipher_name;\n\t\t\tstrncpy(cipher_name_dst, cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tcipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tcipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_ecryptfs_key_bytes:\n\t\t\tcipher_key_bytes_src = args[0].from;\n\t\t\tcipher_key_bytes =\n\t\t\t\t(int)simple_strtol(cipher_key_bytes_src,\n\t\t\t\t\t\t   &cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\t\tcipher_key_bytes;\n\t\t\tcipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_passthrough:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_xattr_metadata:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_encrypted_view:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_ENCRYPTED_VIEW_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fnek_sig:\n\t\t\tfnek_src = args[0].from;\n\t\t\tfnek_dst =\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig;\n\t\t\tstrncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);\n\t\t\tmount_crypt_stat->global_default_fnek_sig[\n\t\t\t\tECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\t\trc = ecryptfs_add_global_auth_tok(\n\t\t\t\tmount_crypt_stat,\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig,\n\t\t\t\tECRYPTFS_AUTH_TOK_FNEK);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global fnek sig [%s]; rc = [%d]\\n\",\n\t\t\t\t       mount_crypt_stat->global_default_fnek_sig,\n\t\t\t\t       rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\t(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES\n\t\t\t\t | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher:\n\t\t\tfn_cipher_name_src = args[0].from;\n\t\t\tfn_cipher_name_dst =\n\t\t\t\tmount_crypt_stat->global_default_fn_cipher_name;\n\t\t\tstrncpy(fn_cipher_name_dst, fn_cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name[\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tfn_cipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher_key_bytes:\n\t\t\tfn_cipher_key_bytes_src = args[0].from;\n\t\t\tfn_cipher_key_bytes =\n\t\t\t\t(int)simple_strtol(fn_cipher_key_bytes_src,\n\t\t\t\t\t\t   &fn_cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\t\tfn_cipher_key_bytes;\n\t\t\tfn_cipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_unlink_sigs:\n\t\t\tmount_crypt_stat->flags |= ECRYPTFS_UNLINK_SIGS;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_mount_auth_tok_only:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_check_dev_ruid:\n\t\t\t*check_ruid = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_err:\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: eCryptfs: unrecognized option [%s]\\n\",\n\t\t\t       __func__, p);\n\t\t}\n\t}\n\tif (!sig_set) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"You must supply at least one valid \"\n\t\t\t\t\"auth tok signature as a mount \"\n\t\t\t\t\"parameter; see the eCryptfs README\\n\");\n\t\tgoto out;\n\t}\n\tif (!cipher_name_set) {\n\t\tint cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);\n\n\t\tBUG_ON(cipher_name_len > ECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\tstrcpy(mount_crypt_stat->global_default_cipher_name,\n\t\t       ECRYPTFS_DEFAULT_CIPHER);\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_name_set)\n\t\tstrcpy(mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_cipher_name);\n\tif (!cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_cipher_key_size = 0;\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\n\tcipher_code = ecryptfs_code_for_cipher_string(\n\t\tmount_crypt_stat->global_default_cipher_name,\n\t\tmount_crypt_stat->global_default_cipher_key_size);\n\tif (!cipher_code) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"eCryptfs doesn't support cipher: %s\",\n\t\t\t\tmount_crypt_stat->global_default_cipher_name);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name,\n\t\t\t\t NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_cipher_name,\n\t\t\tmount_crypt_stat->global_default_cipher_key_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_cipher_key_size,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !ecryptfs_tfm_exists(\n\t\t    mount_crypt_stat->global_default_fn_cipher_name, NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\trc = ecryptfs_init_global_auth_toks(mount_crypt_stat);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{ecryptfs_opt_sig, \"sig=%s\"},\n\t{ecryptfs_opt_ecryptfs_sig, \"ecryptfs_sig=%s\"},\n\t{ecryptfs_opt_cipher, \"cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_cipher, \"ecryptfs_cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_key_bytes, \"ecryptfs_key_bytes=%u\"},\n\t{ecryptfs_opt_passthrough, \"ecryptfs_passthrough\"},\n\t{ecryptfs_opt_xattr_metadata, \"ecryptfs_xattr_metadata\"},\n\t{ecryptfs_opt_encrypted_view, \"ecryptfs_encrypted_view\"},\n\t{ecryptfs_opt_fnek_sig, \"ecryptfs_fnek_sig=%s\"},\n\t{ecryptfs_opt_fn_cipher, \"ecryptfs_fn_cipher=%s\"},\n\t{ecryptfs_opt_fn_cipher_key_bytes, \"ecryptfs_fn_key_bytes=%u\"},\n\t{ecryptfs_opt_unlink_sigs, \"ecryptfs_unlink_sigs\"},\n\t{ecryptfs_opt_mount_auth_tok_only, \"ecryptfs_mount_auth_tok_only\"},\n\t{ecryptfs_opt_check_dev_ruid, \"ecryptfs_check_dev_ruid\"},\n\t{ecryptfs_opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic const match_table_t tokens = {\n\t{ecryptfs_opt_sig, \"sig=%s\"},\n\t{ecryptfs_opt_ecryptfs_sig, \"ecryptfs_sig=%s\"},\n\t{ecryptfs_opt_cipher, \"cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_cipher, \"ecryptfs_cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_key_bytes, \"ecryptfs_key_bytes=%u\"},\n\t{ecryptfs_opt_passthrough, \"ecryptfs_passthrough\"},\n\t{ecryptfs_opt_xattr_metadata, \"ecryptfs_xattr_metadata\"},\n\t{ecryptfs_opt_encrypted_view, \"ecryptfs_encrypted_view\"},\n\t{ecryptfs_opt_fnek_sig, \"ecryptfs_fnek_sig=%s\"},\n\t{ecryptfs_opt_fn_cipher, \"ecryptfs_fn_cipher=%s\"},\n\t{ecryptfs_opt_fn_cipher_key_bytes, \"ecryptfs_fn_key_bytes=%u\"},\n\t{ecryptfs_opt_unlink_sigs, \"ecryptfs_unlink_sigs\"},\n\t{ecryptfs_opt_mount_auth_tok_only, \"ecryptfs_mount_auth_tok_only\"},\n\t{ecryptfs_opt_check_dev_ruid, \"ecryptfs_check_dev_ruid\"},\n\t{ecryptfs_opt_err, NULL}\n};\n\nstatic int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,\n\t\t\t\t  uid_t *check_ruid)\n{\n\tchar *p;\n\tint rc = 0;\n\tint sig_set = 0;\n\tint cipher_name_set = 0;\n\tint fn_cipher_name_set = 0;\n\tint cipher_key_bytes;\n\tint cipher_key_bytes_set = 0;\n\tint fn_cipher_key_bytes;\n\tint fn_cipher_key_bytes_set = 0;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&sbi->mount_crypt_stat;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tchar *sig_src;\n\tchar *cipher_name_dst;\n\tchar *cipher_name_src;\n\tchar *fn_cipher_name_dst;\n\tchar *fn_cipher_name_src;\n\tchar *fnek_dst;\n\tchar *fnek_src;\n\tchar *cipher_key_bytes_src;\n\tchar *fn_cipher_key_bytes_src;\n\tu8 cipher_code;\n\n\t*check_ruid = 0;\n\n\tif (!options) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tecryptfs_init_mount_crypt_stat(mount_crypt_stat);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase ecryptfs_opt_sig:\n\t\tcase ecryptfs_opt_ecryptfs_sig:\n\t\t\tsig_src = args[0].from;\n\t\t\trc = ecryptfs_add_global_auth_tok(mount_crypt_stat,\n\t\t\t\t\t\t\t  sig_src, 0);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global sig; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsig_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_cipher:\n\t\tcase ecryptfs_opt_ecryptfs_cipher:\n\t\t\tcipher_name_src = args[0].from;\n\t\t\tcipher_name_dst =\n\t\t\t\tmount_crypt_stat->\n\t\t\t\tglobal_default_cipher_name;\n\t\t\tstrncpy(cipher_name_dst, cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tcipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tcipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_ecryptfs_key_bytes:\n\t\t\tcipher_key_bytes_src = args[0].from;\n\t\t\tcipher_key_bytes =\n\t\t\t\t(int)simple_strtol(cipher_key_bytes_src,\n\t\t\t\t\t\t   &cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\t\tcipher_key_bytes;\n\t\t\tcipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_passthrough:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_xattr_metadata:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_encrypted_view:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_ENCRYPTED_VIEW_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fnek_sig:\n\t\t\tfnek_src = args[0].from;\n\t\t\tfnek_dst =\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig;\n\t\t\tstrncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);\n\t\t\tmount_crypt_stat->global_default_fnek_sig[\n\t\t\t\tECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\t\trc = ecryptfs_add_global_auth_tok(\n\t\t\t\tmount_crypt_stat,\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig,\n\t\t\t\tECRYPTFS_AUTH_TOK_FNEK);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global fnek sig [%s]; rc = [%d]\\n\",\n\t\t\t\t       mount_crypt_stat->global_default_fnek_sig,\n\t\t\t\t       rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\t(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES\n\t\t\t\t | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher:\n\t\t\tfn_cipher_name_src = args[0].from;\n\t\t\tfn_cipher_name_dst =\n\t\t\t\tmount_crypt_stat->global_default_fn_cipher_name;\n\t\t\tstrncpy(fn_cipher_name_dst, fn_cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name[\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tfn_cipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher_key_bytes:\n\t\t\tfn_cipher_key_bytes_src = args[0].from;\n\t\t\tfn_cipher_key_bytes =\n\t\t\t\t(int)simple_strtol(fn_cipher_key_bytes_src,\n\t\t\t\t\t\t   &fn_cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\t\tfn_cipher_key_bytes;\n\t\t\tfn_cipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_unlink_sigs:\n\t\t\tmount_crypt_stat->flags |= ECRYPTFS_UNLINK_SIGS;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_mount_auth_tok_only:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_check_dev_ruid:\n\t\t\t*check_ruid = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_err:\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: eCryptfs: unrecognized option [%s]\\n\",\n\t\t\t       __func__, p);\n\t\t}\n\t}\n\tif (!sig_set) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"You must supply at least one valid \"\n\t\t\t\t\"auth tok signature as a mount \"\n\t\t\t\t\"parameter; see the eCryptfs README\\n\");\n\t\tgoto out;\n\t}\n\tif (!cipher_name_set) {\n\t\tint cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);\n\n\t\tBUG_ON(cipher_name_len > ECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\tstrcpy(mount_crypt_stat->global_default_cipher_name,\n\t\t       ECRYPTFS_DEFAULT_CIPHER);\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_name_set)\n\t\tstrcpy(mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_cipher_name);\n\tif (!cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_cipher_key_size = 0;\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\n\tcipher_code = ecryptfs_code_for_cipher_string(\n\t\tmount_crypt_stat->global_default_cipher_name,\n\t\tmount_crypt_stat->global_default_cipher_key_size);\n\tif (!cipher_code) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"eCryptfs doesn't support cipher: %s\",\n\t\t\t\tmount_crypt_stat->global_default_cipher_name);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name,\n\t\t\t\t NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_cipher_name,\n\t\t\tmount_crypt_stat->global_default_cipher_key_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_cipher_key_size,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !ecryptfs_tfm_exists(\n\t\t    mount_crypt_stat->global_default_fn_cipher_name, NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\trc = ecryptfs_init_global_auth_toks(mount_crypt_stat);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "ecryptfs_sb_info_cache",
            "GFP_KERNEL"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\nstatic struct file_system_type ecryptfs_fs_type;\nstatic struct file_system_type ecryptfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"ecryptfs\",\n\t.mount = ecryptfs_mount,\n\t.kill_sb = ecryptfs_kill_block_super,\n\t.fs_flags = 0\n};\n\nstatic struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *dev_name, void *raw_data)\n{\n\tstruct super_block *s;\n\tstruct ecryptfs_sb_info *sbi;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_dentry_info *root_info;\n\tconst char *err = \"Getting sb failed\";\n\tstruct inode *inode;\n\tstruct path path;\n\tuid_t check_ruid;\n\tint rc;\n\n\tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n\tif (!sbi) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);\n\tif (rc) {\n\t\terr = \"Error parsing options\";\n\t\tgoto out;\n\t}\n\tmount_crypt_stat = &sbi->mount_crypt_stat;\n\n\ts = sget(fs_type, NULL, set_anon_super, flags, NULL);\n\tif (IS_ERR(s)) {\n\t\trc = PTR_ERR(s);\n\t\tgoto out;\n\t}\n\n\trc = bdi_setup_and_register(&sbi->bdi, \"ecryptfs\");\n\tif (rc)\n\t\tgoto out1;\n\n\tecryptfs_set_superblock_private(s, sbi);\n\ts->s_bdi = &sbi->bdi;\n\n\t/* ->kill_sb() will take care of sbi after that point */\n\tsbi = NULL;\n\ts->s_op = &ecryptfs_sops;\n\ts->s_d_op = &ecryptfs_dops;\n\n\terr = \"Reading sb failed\";\n\trc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"kern_path() failed\\n\");\n\t\tgoto out1;\n\t}\n\tif (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Mount on filesystem of type \"\n\t\t\t\"eCryptfs explicitly disallowed due to \"\n\t\t\t\"known incompatibilities\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {\n\t\trc = -EPERM;\n\t\tprintk(KERN_ERR \"Mount of device (uid: %d) not owned by \"\n\t\t       \"requested user (uid: %d)\\n\",\n\t\t\ti_uid_read(path.dentry->d_inode),\n\t\t\tfrom_kuid(&init_user_ns, current_uid()));\n\t\tgoto out_free;\n\t}\n\n\tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n\n\t/**\n\t * Set the POSIX ACL flag based on whether they're enabled in the lower\n\t * mount.\n\t */\n\ts->s_flags = flags & ~MS_POSIXACL;\n\ts->s_flags |= path.dentry->d_sb->s_flags & MS_POSIXACL;\n\n\t/**\n\t * Force a read-only eCryptfs mount when:\n\t *   1) The lower mount is ro\n\t *   2) The ecryptfs_encrypted_view mount option is specified\n\t */\n\tif (path.dentry->d_sb->s_flags & MS_RDONLY ||\n\t    mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t\ts->s_flags |= MS_RDONLY;\n\n\ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n\ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n\ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n\n\trc = -EINVAL;\n\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n\t\tpr_err(\"eCryptfs: maximum fs stacking depth exceeded\\n\");\n\t\tgoto out_free;\n\t}\n\n\tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n\trc = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_free;\n\n\ts->s_root = d_make_root(inode);\n\tif (!s->s_root) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\trc = -ENOMEM;\n\troot_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!root_info)\n\t\tgoto out_free;\n\n\t/* ->kill_sb() will take care of root_info */\n\tecryptfs_set_dentry_private(s->s_root, root_info);\n\troot_info->lower_path = path;\n\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nout_free:\n\tpath_put(&path);\nout1:\n\tdeactivate_locked_super(s);\nout:\n\tif (sbi) {\n\t\tecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);\n\t\tkmem_cache_free(ecryptfs_sb_info_cache, sbi);\n\t}\n\tprintk(KERN_ERR \"%s; rc = [%d]\\n\", err, rc);\n\treturn ERR_PTR(rc);\n}"
  },
  {
    "function_name": "ecryptfs_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "257-479",
    "snippet": "static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,\n\t\t\t\t  uid_t *check_ruid)\n{\n\tchar *p;\n\tint rc = 0;\n\tint sig_set = 0;\n\tint cipher_name_set = 0;\n\tint fn_cipher_name_set = 0;\n\tint cipher_key_bytes;\n\tint cipher_key_bytes_set = 0;\n\tint fn_cipher_key_bytes;\n\tint fn_cipher_key_bytes_set = 0;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&sbi->mount_crypt_stat;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tchar *sig_src;\n\tchar *cipher_name_dst;\n\tchar *cipher_name_src;\n\tchar *fn_cipher_name_dst;\n\tchar *fn_cipher_name_src;\n\tchar *fnek_dst;\n\tchar *fnek_src;\n\tchar *cipher_key_bytes_src;\n\tchar *fn_cipher_key_bytes_src;\n\tu8 cipher_code;\n\n\t*check_ruid = 0;\n\n\tif (!options) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tecryptfs_init_mount_crypt_stat(mount_crypt_stat);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase ecryptfs_opt_sig:\n\t\tcase ecryptfs_opt_ecryptfs_sig:\n\t\t\tsig_src = args[0].from;\n\t\t\trc = ecryptfs_add_global_auth_tok(mount_crypt_stat,\n\t\t\t\t\t\t\t  sig_src, 0);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global sig; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsig_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_cipher:\n\t\tcase ecryptfs_opt_ecryptfs_cipher:\n\t\t\tcipher_name_src = args[0].from;\n\t\t\tcipher_name_dst =\n\t\t\t\tmount_crypt_stat->\n\t\t\t\tglobal_default_cipher_name;\n\t\t\tstrncpy(cipher_name_dst, cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tcipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tcipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_ecryptfs_key_bytes:\n\t\t\tcipher_key_bytes_src = args[0].from;\n\t\t\tcipher_key_bytes =\n\t\t\t\t(int)simple_strtol(cipher_key_bytes_src,\n\t\t\t\t\t\t   &cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\t\tcipher_key_bytes;\n\t\t\tcipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_passthrough:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_xattr_metadata:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_encrypted_view:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_ENCRYPTED_VIEW_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fnek_sig:\n\t\t\tfnek_src = args[0].from;\n\t\t\tfnek_dst =\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig;\n\t\t\tstrncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);\n\t\t\tmount_crypt_stat->global_default_fnek_sig[\n\t\t\t\tECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\t\trc = ecryptfs_add_global_auth_tok(\n\t\t\t\tmount_crypt_stat,\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig,\n\t\t\t\tECRYPTFS_AUTH_TOK_FNEK);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global fnek sig [%s]; rc = [%d]\\n\",\n\t\t\t\t       mount_crypt_stat->global_default_fnek_sig,\n\t\t\t\t       rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\t(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES\n\t\t\t\t | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher:\n\t\t\tfn_cipher_name_src = args[0].from;\n\t\t\tfn_cipher_name_dst =\n\t\t\t\tmount_crypt_stat->global_default_fn_cipher_name;\n\t\t\tstrncpy(fn_cipher_name_dst, fn_cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name[\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tfn_cipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher_key_bytes:\n\t\t\tfn_cipher_key_bytes_src = args[0].from;\n\t\t\tfn_cipher_key_bytes =\n\t\t\t\t(int)simple_strtol(fn_cipher_key_bytes_src,\n\t\t\t\t\t\t   &fn_cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\t\tfn_cipher_key_bytes;\n\t\t\tfn_cipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_unlink_sigs:\n\t\t\tmount_crypt_stat->flags |= ECRYPTFS_UNLINK_SIGS;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_mount_auth_tok_only:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_check_dev_ruid:\n\t\t\t*check_ruid = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_err:\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: eCryptfs: unrecognized option [%s]\\n\",\n\t\t\t       __func__, p);\n\t\t}\n\t}\n\tif (!sig_set) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"You must supply at least one valid \"\n\t\t\t\t\"auth tok signature as a mount \"\n\t\t\t\t\"parameter; see the eCryptfs README\\n\");\n\t\tgoto out;\n\t}\n\tif (!cipher_name_set) {\n\t\tint cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);\n\n\t\tBUG_ON(cipher_name_len > ECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\tstrcpy(mount_crypt_stat->global_default_cipher_name,\n\t\t       ECRYPTFS_DEFAULT_CIPHER);\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_name_set)\n\t\tstrcpy(mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_cipher_name);\n\tif (!cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_cipher_key_size = 0;\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\n\tcipher_code = ecryptfs_code_for_cipher_string(\n\t\tmount_crypt_stat->global_default_cipher_name,\n\t\tmount_crypt_stat->global_default_cipher_key_size);\n\tif (!cipher_code) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"eCryptfs doesn't support cipher: %s\",\n\t\t\t\tmount_crypt_stat->global_default_cipher_name);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name,\n\t\t\t\t NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_cipher_name,\n\t\t\tmount_crypt_stat->global_default_cipher_key_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_cipher_key_size,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !ecryptfs_tfm_exists(\n\t\t    mount_crypt_stat->global_default_fn_cipher_name, NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\trc = ecryptfs_init_global_auth_toks(mount_crypt_stat);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{ecryptfs_opt_sig, \"sig=%s\"},\n\t{ecryptfs_opt_ecryptfs_sig, \"ecryptfs_sig=%s\"},\n\t{ecryptfs_opt_cipher, \"cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_cipher, \"ecryptfs_cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_key_bytes, \"ecryptfs_key_bytes=%u\"},\n\t{ecryptfs_opt_passthrough, \"ecryptfs_passthrough\"},\n\t{ecryptfs_opt_xattr_metadata, \"ecryptfs_xattr_metadata\"},\n\t{ecryptfs_opt_encrypted_view, \"ecryptfs_encrypted_view\"},\n\t{ecryptfs_opt_fnek_sig, \"ecryptfs_fnek_sig=%s\"},\n\t{ecryptfs_opt_fn_cipher, \"ecryptfs_fn_cipher=%s\"},\n\t{ecryptfs_opt_fn_cipher_key_bytes, \"ecryptfs_fn_key_bytes=%u\"},\n\t{ecryptfs_opt_unlink_sigs, \"ecryptfs_unlink_sigs\"},\n\t{ecryptfs_opt_mount_auth_tok_only, \"ecryptfs_mount_auth_tok_only\"},\n\t{ecryptfs_opt_check_dev_ruid, \"ecryptfs_check_dev_ruid\"},\n\t{ecryptfs_opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\"",
            "rc"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_init_global_auth_toks",
          "args": [
            "mount_crypt_stat"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_init_global_auth_toks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "199-225",
          "snippet": "static int ecryptfs_init_global_auth_toks(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tint rc = 0;\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(\n\t\t\t&global_auth_tok->global_auth_tok_key, &auth_tok,\n\t\t\tglobal_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Could not find valid key in user \"\n\t\t\t       \"session keyring for sig specified in mount \"\n\t\t\t       \"option: [%s]\\n\", global_auth_tok->sig);\n\t\t\tglobal_auth_tok->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tglobal_auth_tok->flags &= ~ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tup_write(&(global_auth_tok->global_auth_tok_key)->sem);\n\t\t}\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic int ecryptfs_init_global_auth_toks(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tint rc = 0;\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(\n\t\t\t&global_auth_tok->global_auth_tok_key, &auth_tok,\n\t\t\tglobal_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Could not find valid key in user \"\n\t\t\t       \"session keyring for sig specified in mount \"\n\t\t\t       \"option: [%s]\\n\", global_auth_tok->sig);\n\t\t\tglobal_auth_tok->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tglobal_auth_tok->flags &= ~ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tup_write(&(global_auth_tok->global_auth_tok_key)->sem);\n\t\t}\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&key_tfm_list_mutex"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&key_tfm_list_mutex"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_add_new_key_tfm",
          "args": [
            "NULL",
            "mount_crypt_stat->global_default_fn_cipher_name",
            "mount_crypt_stat->global_default_fn_cipher_key_bytes"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_add_new_key_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1672-1710",
          "snippet": "int\necryptfs_add_new_key_tfm(struct ecryptfs_key_tfm **key_tfm, char *cipher_name,\n\t\t\t size_t key_size)\n{\n\tstruct ecryptfs_key_tfm *tmp_tfm;\n\tint rc = 0;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\ttmp_tfm = kmem_cache_alloc(ecryptfs_key_tfm_cache, GFP_KERNEL);\n\tif (key_tfm != NULL)\n\t\t(*key_tfm) = tmp_tfm;\n\tif (!tmp_tfm) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"Error attempting to allocate from \"\n\t\t       \"ecryptfs_key_tfm_cache\\n\");\n\t\tgoto out;\n\t}\n\tmutex_init(&tmp_tfm->key_tfm_mutex);\n\tstrncpy(tmp_tfm->cipher_name, cipher_name,\n\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\ttmp_tfm->cipher_name[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\ttmp_tfm->key_size = key_size;\n\trc = ecryptfs_process_key_cipher(&tmp_tfm->key_tfm,\n\t\t\t\t\t tmp_tfm->cipher_name,\n\t\t\t\t\t &tmp_tfm->key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to initialize key TFM \"\n\t\t       \"cipher with name = [%s]; rc = [%d]\\n\",\n\t\t       tmp_tfm->cipher_name, rc);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, tmp_tfm);\n\t\tif (key_tfm != NULL)\n\t\t\t(*key_tfm) = NULL;\n\t\tgoto out;\n\t}\n\tlist_add(&tmp_tfm->key_tfm_list, &key_tfm_list);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_key_tfm_cache;",
            "static struct list_head key_tfm_list;",
            "struct mutex key_tfm_list_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *ecryptfs_key_tfm_cache;\nstatic struct list_head key_tfm_list;\nstruct mutex key_tfm_list_mutex;\n\nint\necryptfs_add_new_key_tfm(struct ecryptfs_key_tfm **key_tfm, char *cipher_name,\n\t\t\t size_t key_size)\n{\n\tstruct ecryptfs_key_tfm *tmp_tfm;\n\tint rc = 0;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\ttmp_tfm = kmem_cache_alloc(ecryptfs_key_tfm_cache, GFP_KERNEL);\n\tif (key_tfm != NULL)\n\t\t(*key_tfm) = tmp_tfm;\n\tif (!tmp_tfm) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"Error attempting to allocate from \"\n\t\t       \"ecryptfs_key_tfm_cache\\n\");\n\t\tgoto out;\n\t}\n\tmutex_init(&tmp_tfm->key_tfm_mutex);\n\tstrncpy(tmp_tfm->cipher_name, cipher_name,\n\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\ttmp_tfm->cipher_name[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\ttmp_tfm->key_size = key_size;\n\trc = ecryptfs_process_key_cipher(&tmp_tfm->key_tfm,\n\t\t\t\t\t tmp_tfm->cipher_name,\n\t\t\t\t\t &tmp_tfm->key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to initialize key TFM \"\n\t\t       \"cipher with name = [%s]; rc = [%d]\\n\",\n\t\t       tmp_tfm->cipher_name, rc);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, tmp_tfm);\n\t\tif (key_tfm != NULL)\n\t\t\t(*key_tfm) = NULL;\n\t\tgoto out;\n\t}\n\tlist_add(&tmp_tfm->key_tfm_list, &key_tfm_list);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_tfm_exists",
          "args": [
            "mount_crypt_stat->global_default_fn_cipher_name",
            "NULL"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_tfm_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1722-1738",
          "snippet": "int ecryptfs_tfm_exists(char *cipher_name, struct ecryptfs_key_tfm **key_tfm)\n{\n\tstruct ecryptfs_key_tfm *tmp_key_tfm;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\tlist_for_each_entry(tmp_key_tfm, &key_tfm_list, key_tfm_list) {\n\t\tif (strcmp(tmp_key_tfm->cipher_name, cipher_name) == 0) {\n\t\t\tif (key_tfm)\n\t\t\t\t(*key_tfm) = tmp_key_tfm;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (key_tfm)\n\t\t(*key_tfm) = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head key_tfm_list;",
            "struct mutex key_tfm_list_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct list_head key_tfm_list;\nstruct mutex key_tfm_list_mutex;\n\nint ecryptfs_tfm_exists(char *cipher_name, struct ecryptfs_key_tfm **key_tfm)\n{\n\tstruct ecryptfs_key_tfm *tmp_key_tfm;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\tlist_for_each_entry(tmp_key_tfm, &key_tfm_list, key_tfm_list) {\n\t\tif (strcmp(tmp_key_tfm->cipher_name, cipher_name) == 0) {\n\t\t\tif (key_tfm)\n\t\t\t\t(*key_tfm) = tmp_key_tfm;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (key_tfm)\n\t\t(*key_tfm) = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&key_tfm_list_mutex"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&key_tfm_list_mutex"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_code_for_cipher_string",
          "args": [
            "mount_crypt_stat->global_default_cipher_name",
            "mount_crypt_stat->global_default_cipher_key_size"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_code_for_cipher_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "985-1011",
          "snippet": "u8 ecryptfs_code_for_cipher_string(char *cipher_name, size_t key_bytes)\n{\n\tint i;\n\tu8 code = 0;\n\tstruct ecryptfs_cipher_code_str_map_elem *map =\n\t\tecryptfs_cipher_code_str_map;\n\n\tif (strcmp(cipher_name, \"aes\") == 0) {\n\t\tswitch (key_bytes) {\n\t\tcase 16:\n\t\t\tcode = RFC2440_CIPHER_AES_128;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tcode = RFC2440_CIPHER_AES_192;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcode = RFC2440_CIPHER_AES_256;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\t\tif (strcmp(cipher_name, map[i].cipher_str) == 0) {\n\t\t\t\tcode = map[i].cipher_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn code;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};\n\nu8 ecryptfs_code_for_cipher_string(char *cipher_name, size_t key_bytes)\n{\n\tint i;\n\tu8 code = 0;\n\tstruct ecryptfs_cipher_code_str_map_elem *map =\n\t\tecryptfs_cipher_code_str_map;\n\n\tif (strcmp(cipher_name, \"aes\") == 0) {\n\t\tswitch (key_bytes) {\n\t\tcase 16:\n\t\t\tcode = RFC2440_CIPHER_AES_128;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tcode = RFC2440_CIPHER_AES_192;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcode = RFC2440_CIPHER_AES_256;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\t\tif (strcmp(cipher_name, map[i].cipher_str) == 0) {\n\t\t\t\tcode = map[i].cipher_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "mount_crypt_stat->global_default_fn_cipher_name",
            "mount_crypt_stat->global_default_cipher_name"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "mount_crypt_stat->global_default_cipher_name",
            "ECRYPTFS_DEFAULT_CIPHER"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cipher_name_len > ECRYPTFS_MAX_CIPHER_NAME_SIZE"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ECRYPTFS_DEFAULT_CIPHER"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "fn_cipher_key_bytes_src",
            "&fn_cipher_key_bytes_src",
            "0"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "fn_cipher_name_dst",
            "fn_cipher_name_src",
            "ECRYPTFS_MAX_CIPHER_NAME_SIZE"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_add_global_auth_tok",
          "args": [
            "mount_crypt_stat",
            "mount_crypt_stat->global_default_fnek_sig",
            "ECRYPTFS_AUTH_TOK_FNEK"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_add_global_auth_tok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "2504-2528",
          "snippet": "int\necryptfs_add_global_auth_tok(struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *sig, u32 global_auth_tok_flags)\n{\n\tstruct ecryptfs_global_auth_tok *new_auth_tok;\n\tint rc = 0;\n\n\tnew_auth_tok = kmem_cache_zalloc(ecryptfs_global_auth_tok_cache,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!new_auth_tok) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"Error allocating from \"\n\t\t       \"ecryptfs_global_auth_tok_cache\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(new_auth_tok->sig, sig, ECRYPTFS_SIG_SIZE_HEX);\n\tnew_auth_tok->flags = global_auth_tok_flags;\n\tnew_auth_tok->sig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_add(&new_auth_tok->mount_crypt_stat_list,\n\t\t &mount_crypt_stat->global_auth_tok_list);\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_global_auth_tok_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_global_auth_tok_cache;\n\nint\necryptfs_add_global_auth_tok(struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *sig, u32 global_auth_tok_flags)\n{\n\tstruct ecryptfs_global_auth_tok *new_auth_tok;\n\tint rc = 0;\n\n\tnew_auth_tok = kmem_cache_zalloc(ecryptfs_global_auth_tok_cache,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!new_auth_tok) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"Error allocating from \"\n\t\t       \"ecryptfs_global_auth_tok_cache\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(new_auth_tok->sig, sig, ECRYPTFS_SIG_SIZE_HEX);\n\tnew_auth_tok->flags = global_auth_tok_flags;\n\tnew_auth_tok->sig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_add(&new_auth_tok->mount_crypt_stat_list,\n\t\t &mount_crypt_stat->global_auth_tok_list);\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "fnek_dst",
            "fnek_src",
            "ECRYPTFS_SIG_SIZE_HEX"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "cipher_key_bytes_src",
            "&cipher_key_bytes_src",
            "0"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cipher_name_dst",
            "cipher_name_src",
            "ECRYPTFS_MAX_CIPHER_NAME_SIZE"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_init_mount_crypt_stat",
          "args": [
            "mount_crypt_stat"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_init_mount_crypt_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "227-235",
          "snippet": "static void ecryptfs_init_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tmemset((void *)mount_crypt_stat, 0,\n\t       sizeof(struct ecryptfs_mount_crypt_stat));\n\tINIT_LIST_HEAD(&mount_crypt_stat->global_auth_tok_list);\n\tmutex_init(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmount_crypt_stat->flags |= ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic void ecryptfs_init_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tmemset((void *)mount_crypt_stat, 0,\n\t       sizeof(struct ecryptfs_mount_crypt_stat));\n\tINIT_LIST_HEAD(&mount_crypt_stat->global_auth_tok_list);\n\tmutex_init(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmount_crypt_stat->flags |= ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic const match_table_t tokens = {\n\t{ecryptfs_opt_sig, \"sig=%s\"},\n\t{ecryptfs_opt_ecryptfs_sig, \"ecryptfs_sig=%s\"},\n\t{ecryptfs_opt_cipher, \"cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_cipher, \"ecryptfs_cipher=%s\"},\n\t{ecryptfs_opt_ecryptfs_key_bytes, \"ecryptfs_key_bytes=%u\"},\n\t{ecryptfs_opt_passthrough, \"ecryptfs_passthrough\"},\n\t{ecryptfs_opt_xattr_metadata, \"ecryptfs_xattr_metadata\"},\n\t{ecryptfs_opt_encrypted_view, \"ecryptfs_encrypted_view\"},\n\t{ecryptfs_opt_fnek_sig, \"ecryptfs_fnek_sig=%s\"},\n\t{ecryptfs_opt_fn_cipher, \"ecryptfs_fn_cipher=%s\"},\n\t{ecryptfs_opt_fn_cipher_key_bytes, \"ecryptfs_fn_key_bytes=%u\"},\n\t{ecryptfs_opt_unlink_sigs, \"ecryptfs_unlink_sigs\"},\n\t{ecryptfs_opt_mount_auth_tok_only, \"ecryptfs_mount_auth_tok_only\"},\n\t{ecryptfs_opt_check_dev_ruid, \"ecryptfs_check_dev_ruid\"},\n\t{ecryptfs_opt_err, NULL}\n};\n\nstatic int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,\n\t\t\t\t  uid_t *check_ruid)\n{\n\tchar *p;\n\tint rc = 0;\n\tint sig_set = 0;\n\tint cipher_name_set = 0;\n\tint fn_cipher_name_set = 0;\n\tint cipher_key_bytes;\n\tint cipher_key_bytes_set = 0;\n\tint fn_cipher_key_bytes;\n\tint fn_cipher_key_bytes_set = 0;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&sbi->mount_crypt_stat;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tchar *sig_src;\n\tchar *cipher_name_dst;\n\tchar *cipher_name_src;\n\tchar *fn_cipher_name_dst;\n\tchar *fn_cipher_name_src;\n\tchar *fnek_dst;\n\tchar *fnek_src;\n\tchar *cipher_key_bytes_src;\n\tchar *fn_cipher_key_bytes_src;\n\tu8 cipher_code;\n\n\t*check_ruid = 0;\n\n\tif (!options) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tecryptfs_init_mount_crypt_stat(mount_crypt_stat);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase ecryptfs_opt_sig:\n\t\tcase ecryptfs_opt_ecryptfs_sig:\n\t\t\tsig_src = args[0].from;\n\t\t\trc = ecryptfs_add_global_auth_tok(mount_crypt_stat,\n\t\t\t\t\t\t\t  sig_src, 0);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global sig; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsig_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_cipher:\n\t\tcase ecryptfs_opt_ecryptfs_cipher:\n\t\t\tcipher_name_src = args[0].from;\n\t\t\tcipher_name_dst =\n\t\t\t\tmount_crypt_stat->\n\t\t\t\tglobal_default_cipher_name;\n\t\t\tstrncpy(cipher_name_dst, cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tcipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tcipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_ecryptfs_key_bytes:\n\t\t\tcipher_key_bytes_src = args[0].from;\n\t\t\tcipher_key_bytes =\n\t\t\t\t(int)simple_strtol(cipher_key_bytes_src,\n\t\t\t\t\t\t   &cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\t\tcipher_key_bytes;\n\t\t\tcipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_passthrough:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_xattr_metadata:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_encrypted_view:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_ENCRYPTED_VIEW_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fnek_sig:\n\t\t\tfnek_src = args[0].from;\n\t\t\tfnek_dst =\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig;\n\t\t\tstrncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);\n\t\t\tmount_crypt_stat->global_default_fnek_sig[\n\t\t\t\tECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\t\trc = ecryptfs_add_global_auth_tok(\n\t\t\t\tmount_crypt_stat,\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig,\n\t\t\t\tECRYPTFS_AUTH_TOK_FNEK);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global fnek sig [%s]; rc = [%d]\\n\",\n\t\t\t\t       mount_crypt_stat->global_default_fnek_sig,\n\t\t\t\t       rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\t(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES\n\t\t\t\t | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher:\n\t\t\tfn_cipher_name_src = args[0].from;\n\t\t\tfn_cipher_name_dst =\n\t\t\t\tmount_crypt_stat->global_default_fn_cipher_name;\n\t\t\tstrncpy(fn_cipher_name_dst, fn_cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name[\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tfn_cipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher_key_bytes:\n\t\t\tfn_cipher_key_bytes_src = args[0].from;\n\t\t\tfn_cipher_key_bytes =\n\t\t\t\t(int)simple_strtol(fn_cipher_key_bytes_src,\n\t\t\t\t\t\t   &fn_cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\t\tfn_cipher_key_bytes;\n\t\t\tfn_cipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_unlink_sigs:\n\t\t\tmount_crypt_stat->flags |= ECRYPTFS_UNLINK_SIGS;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_mount_auth_tok_only:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_check_dev_ruid:\n\t\t\t*check_ruid = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_err:\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: eCryptfs: unrecognized option [%s]\\n\",\n\t\t\t       __func__, p);\n\t\t}\n\t}\n\tif (!sig_set) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"You must supply at least one valid \"\n\t\t\t\t\"auth tok signature as a mount \"\n\t\t\t\t\"parameter; see the eCryptfs README\\n\");\n\t\tgoto out;\n\t}\n\tif (!cipher_name_set) {\n\t\tint cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);\n\n\t\tBUG_ON(cipher_name_len > ECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\tstrcpy(mount_crypt_stat->global_default_cipher_name,\n\t\t       ECRYPTFS_DEFAULT_CIPHER);\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_name_set)\n\t\tstrcpy(mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_cipher_name);\n\tif (!cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_cipher_key_size = 0;\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\n\tcipher_code = ecryptfs_code_for_cipher_string(\n\t\tmount_crypt_stat->global_default_cipher_name,\n\t\tmount_crypt_stat->global_default_cipher_key_size);\n\tif (!cipher_code) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"eCryptfs doesn't support cipher: %s\",\n\t\t\t\tmount_crypt_stat->global_default_cipher_name);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name,\n\t\t\t\t NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_cipher_name,\n\t\t\tmount_crypt_stat->global_default_cipher_key_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_cipher_key_size,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !ecryptfs_tfm_exists(\n\t\t    mount_crypt_stat->global_default_fn_cipher_name, NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\trc = ecryptfs_init_global_auth_toks(mount_crypt_stat);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_init_mount_crypt_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "227-235",
    "snippet": "static void ecryptfs_init_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tmemset((void *)mount_crypt_stat, 0,\n\t       sizeof(struct ecryptfs_mount_crypt_stat));\n\tINIT_LIST_HEAD(&mount_crypt_stat->global_auth_tok_list);\n\tmutex_init(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmount_crypt_stat->flags |= ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&mount_crypt_stat->global_auth_tok_list_mutex"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mount_crypt_stat->global_auth_tok_list"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)mount_crypt_stat",
            "0",
            "sizeof(struct ecryptfs_mount_crypt_stat)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic void ecryptfs_init_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tmemset((void *)mount_crypt_stat, 0,\n\t       sizeof(struct ecryptfs_mount_crypt_stat));\n\tINIT_LIST_HEAD(&mount_crypt_stat->global_auth_tok_list);\n\tmutex_init(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmount_crypt_stat->flags |= ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED;\n}"
  },
  {
    "function_name": "ecryptfs_init_global_auth_toks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "199-225",
    "snippet": "static int ecryptfs_init_global_auth_toks(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tint rc = 0;\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(\n\t\t\t&global_auth_tok->global_auth_tok_key, &auth_tok,\n\t\t\tglobal_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Could not find valid key in user \"\n\t\t\t       \"session keyring for sig specified in mount \"\n\t\t\t       \"option: [%s]\\n\", global_auth_tok->sig);\n\t\t\tglobal_auth_tok->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tglobal_auth_tok->flags &= ~ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tup_write(&(global_auth_tok->global_auth_tok_key)->sem);\n\t\t}\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&(global_auth_tok->global_auth_tok_key)->sem"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Could not find valid key in user \"\n\t\t\t       \"session keyring for sig specified in mount \"\n\t\t\t       \"option: [%s]\\n\"",
            "global_auth_tok->sig"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_keyring_auth_tok_for_sig",
          "args": [
            "&global_auth_tok->global_auth_tok_key",
            "&auth_tok",
            "global_auth_tok->sig"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_keyring_auth_tok_for_sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "1627-1654",
          "snippet": "int ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key,\n\t\t\t\t      struct ecryptfs_auth_tok **auth_tok,\n\t\t\t\t      char *sig)\n{\n\tint rc = 0;\n\n\t(*auth_tok_key) = request_key(&key_type_user, sig, NULL);\n\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t(*auth_tok_key) = ecryptfs_get_encrypted_key(sig);\n\t\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t\tprintk(KERN_ERR \"Could not find key with description: [%s]\\n\",\n\t\t\t      sig);\n\t\t\trc = process_request_key_err(PTR_ERR(*auth_tok_key));\n\t\t\t(*auth_tok_key) = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdown_write(&(*auth_tok_key)->sem);\n\trc = ecryptfs_verify_auth_tok_from_key(*auth_tok_key, auth_tok);\n\tif (rc) {\n\t\tup_write(&(*auth_tok_key)->sem);\n\t\tkey_put(*auth_tok_key);\n\t\t(*auth_tok_key) = NULL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key,\n\t\t\t\t      struct ecryptfs_auth_tok **auth_tok,\n\t\t\t\t      char *sig)\n{\n\tint rc = 0;\n\n\t(*auth_tok_key) = request_key(&key_type_user, sig, NULL);\n\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t(*auth_tok_key) = ecryptfs_get_encrypted_key(sig);\n\t\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t\tprintk(KERN_ERR \"Could not find key with description: [%s]\\n\",\n\t\t\t      sig);\n\t\t\trc = process_request_key_err(PTR_ERR(*auth_tok_key));\n\t\t\t(*auth_tok_key) = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdown_write(&(*auth_tok_key)->sem);\n\trc = ecryptfs_verify_auth_tok_from_key(*auth_tok_key, auth_tok);\n\tif (rc) {\n\t\tup_write(&(*auth_tok_key)->sem);\n\t\tkey_put(*auth_tok_key);\n\t\t(*auth_tok_key) = NULL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "global_auth_tok",
            "&mount_crypt_stat->global_auth_tok_list",
            "mount_crypt_stat_list"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic int ecryptfs_init_global_auth_toks(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tint rc = 0;\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(\n\t\t\t&global_auth_tok->global_auth_tok_key, &auth_tok,\n\t\t\tglobal_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Could not find valid key in user \"\n\t\t\t       \"session keyring for sig specified in mount \"\n\t\t\t       \"option: [%s]\\n\", global_auth_tok->sig);\n\t\t\tglobal_auth_tok->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tglobal_auth_tok->flags &= ~ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tup_write(&(global_auth_tok->global_auth_tok_key)->sem);\n\t\t}\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_put_lower_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "157-169",
    "snippet": "void ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode_info->lower_file_mutex"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "inode_info->lower_file"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_mutex_lock",
          "args": [
            "&inode_info->lower_file_count",
            "&inode_info->lower_file_mutex"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nvoid ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}"
  },
  {
    "function_name": "ecryptfs_get_lower_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "137-155",
    "snippet": "int ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode_info->lower_file_mutex"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&inode_info->lower_file_count",
            "0"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_init_lower_file",
          "args": [
            "dentry",
            "&inode_info->lower_file"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_init_lower_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "119-135",
          "snippet": "static int ecryptfs_init_lower_file(struct dentry *dentry,\n\t\t\t\t    struct file **lower_file)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct path *path = ecryptfs_dentry_to_lower_path(dentry);\n\tint rc;\n\n\trc = ecryptfs_privileged_open(lower_file, path->dentry, path->mnt,\n\t\t\t\t      cred);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error opening lower file \"\n\t\t       \"for lower_dentry [0x%p] and lower_mnt [0x%p]; \"\n\t\t       \"rc = [%d]\\n\", path->dentry, path->mnt, rc);\n\t\t(*lower_file) = NULL;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic int ecryptfs_init_lower_file(struct dentry *dentry,\n\t\t\t\t    struct file **lower_file)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct path *path = ecryptfs_dentry_to_lower_path(dentry);\n\tint rc;\n\n\trc = ecryptfs_privileged_open(lower_file, path->dentry, path->mnt,\n\t\t\t\t      cred);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error opening lower file \"\n\t\t       \"for lower_dentry [0x%p] and lower_mnt [0x%p]; \"\n\t\t       \"rc = [%d]\\n\", path->dentry, path->mnt, rc);\n\t\t(*lower_file) = NULL;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "count < 1"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&inode_info->lower_file_count"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode_info->lower_file_mutex"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "inode"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\tint count, rc = 0;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tmutex_lock(&inode_info->lower_file_mutex);\n\tcount = atomic_inc_return(&inode_info->lower_file_count);\n\tif (WARN_ON_ONCE(count < 1))\n\t\trc = -EINVAL;\n\telse if (count == 1) {\n\t\trc = ecryptfs_init_lower_file(dentry,\n\t\t\t\t\t      &inode_info->lower_file);\n\t\tif (rc)\n\t\t\tatomic_set(&inode_info->lower_file_count, 0);\n\t}\n\tmutex_unlock(&inode_info->lower_file_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_init_lower_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "119-135",
    "snippet": "static int ecryptfs_init_lower_file(struct dentry *dentry,\n\t\t\t\t    struct file **lower_file)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct path *path = ecryptfs_dentry_to_lower_path(dentry);\n\tint rc;\n\n\trc = ecryptfs_privileged_open(lower_file, path->dentry, path->mnt,\n\t\t\t\t      cred);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error opening lower file \"\n\t\t       \"for lower_dentry [0x%p] and lower_mnt [0x%p]; \"\n\t\t       \"rc = [%d]\\n\", path->dentry, path->mnt, rc);\n\t\t(*lower_file) = NULL;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error opening lower file \"\n\t\t       \"for lower_dentry [0x%p] and lower_mnt [0x%p]; \"\n\t\t       \"rc = [%d]\\n\"",
            "path->dentry",
            "path->mnt",
            "rc"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_privileged_open",
          "args": [
            "lower_file",
            "path->dentry",
            "path->mnt",
            "cred"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_privileged_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/kthread.c",
          "lines": "130-172",
          "snippet": "int ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\n\t/* Corresponding dput() and mntput() are done when the\n\t * lower file is fput() when all eCryptfs files for the inode are\n\t * released. */\n\tflags |= IS_RDONLY(lower_dentry->d_inode) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n\t\trc = PTR_ERR(*lower_file);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/mount.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001"
          ],
          "globals_used": [
            "static struct ecryptfs_kthread_ctl {\n#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001\n\tu32 flags;\n\tstruct mutex mux;\n\tstruct list_head req_list;\n\twait_queue_head_t wait;\n} ecryptfs_kthread_ctl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/mount.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n\n#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001\n\nstatic struct ecryptfs_kthread_ctl {\n#define ECRYPTFS_KTHREAD_ZOMBIE 0x00000001\n\tu32 flags;\n\tstruct mutex mux;\n\tstruct list_head req_list;\n\twait_queue_head_t wait;\n} ecryptfs_kthread_ctl;\n\nint ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\n\t/* Corresponding dput() and mntput() are done when the\n\t * lower file is fput() when all eCryptfs files for the inode are\n\t * released. */\n\tflags |= IS_RDONLY(lower_dentry->d_inode) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n\t\trc = PTR_ERR(*lower_file);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower_path",
          "args": [
            "dentry"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstatic int ecryptfs_init_lower_file(struct dentry *dentry,\n\t\t\t\t    struct file **lower_file)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct path *path = ecryptfs_dentry_to_lower_path(dentry);\n\tint rc;\n\n\trc = ecryptfs_privileged_open(lower_file, path->dentry, path->mnt,\n\t\t\t\t      cred);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error opening lower file \"\n\t\t       \"for lower_dentry [0x%p] and lower_mnt [0x%p]; \"\n\t\t       \"rc = [%d]\\n\", path->dentry, path->mnt, rc);\n\t\t(*lower_file) = NULL;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "__ecryptfs_printk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
    "lines": "86-96",
    "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/magic.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_stack.h>",
      "#include <linux/parser.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/crypto.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ecryptfs_verbosity = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vprintk",
          "args": [
            "fmt",
            "args"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vprintk",
          "args": [
            "fmt",
            "args"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
  }
]