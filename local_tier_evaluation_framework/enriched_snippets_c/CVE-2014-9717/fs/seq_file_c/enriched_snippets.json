[
  {
    "function_name": "seq_hlist_next_percpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "948-967",
    "snippet": "struct hlist_node *\nseq_hlist_next_percpu(void *v, struct hlist_head __percpu *head,\n\t\t\tint *cpu, loff_t *pos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*pos;\n\n\tif (node->next)\n\t\treturn node->next;\n\n\tfor (*cpu = cpumask_next(*cpu, cpu_possible_mask); *cpu < nr_cpu_ids;\n\t     *cpu = cpumask_next(*cpu, cpu_possible_mask)) {\n\t\tstruct hlist_head *bucket = per_cpu_ptr(head, *cpu);\n\n\t\tif (!hlist_empty(bucket))\n\t\t\treturn bucket->first;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "bucket"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "head",
            "*cpu"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "*cpu",
            "cpu_possible_mask"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "*cpu",
            "cpu_possible_mask"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct hlist_node *\nseq_hlist_next_percpu(void *v, struct hlist_head __percpu *head,\n\t\t\tint *cpu, loff_t *pos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*pos;\n\n\tif (node->next)\n\t\treturn node->next;\n\n\tfor (*cpu = cpumask_next(*cpu, cpu_possible_mask); *cpu < nr_cpu_ids;\n\t     *cpu = cpumask_next(*cpu, cpu_possible_mask)) {\n\t\tstruct hlist_head *bucket = per_cpu_ptr(head, *cpu);\n\n\t\tif (!hlist_empty(bucket))\n\t\t\treturn bucket->first;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "seq_hlist_start_percpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "924-936",
    "snippet": "struct hlist_node *\nseq_hlist_start_percpu(struct hlist_head __percpu *head, int *cpu, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\tfor_each_possible_cpu(*cpu) {\n\t\thlist_for_each(node, per_cpu_ptr(head, *cpu)) {\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn node;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each",
          "args": [
            "node",
            "per_cpu_ptr(head, *cpu)"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "head",
            "*cpu"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct hlist_node *\nseq_hlist_start_percpu(struct hlist_head __percpu *head, int *cpu, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\tfor_each_possible_cpu(*cpu) {\n\t\thlist_for_each(node, per_cpu_ptr(head, *cpu)) {\n\t\t\tif (pos-- == 0)\n\t\t\t\treturn node;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "seq_hlist_next_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "902-913",
    "snippet": "struct hlist_node *seq_hlist_next_rcu(void *v,\n\t\t\t\t      struct hlist_head *head,\n\t\t\t\t      loff_t *ppos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*ppos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn rcu_dereference(head->first);\n\telse\n\t\treturn rcu_dereference(node->next);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "node->next"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "head->first"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct hlist_node *seq_hlist_next_rcu(void *v,\n\t\t\t\t      struct hlist_head *head,\n\t\t\t\t      loff_t *ppos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*ppos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn rcu_dereference(head->first);\n\telse\n\t\treturn rcu_dereference(node->next);\n}"
  },
  {
    "function_name": "seq_hlist_start_head_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "880-887",
    "snippet": "struct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *head,\n\t\t\t\t\t    loff_t pos)\n{\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start_rcu(head, pos - 1);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_hlist_start_rcu",
          "args": [
            "head",
            "pos - 1"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "seq_hlist_start_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "856-865",
          "snippet": "struct hlist_node *seq_hlist_start_rcu(struct hlist_head *head,\n\t\t\t\t       loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\t__hlist_for_each_rcu(node, head)\n\t\tif (pos-- == 0)\n\t\t\treturn node;\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct hlist_node *seq_hlist_start_rcu(struct hlist_head *head,\n\t\t\t\t       loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\t__hlist_for_each_rcu(node, head)\n\t\tif (pos-- == 0)\n\t\t\treturn node;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *head,\n\t\t\t\t\t    loff_t pos)\n{\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start_rcu(head, pos - 1);\n}"
  },
  {
    "function_name": "seq_hlist_start_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "856-865",
    "snippet": "struct hlist_node *seq_hlist_start_rcu(struct hlist_head *head,\n\t\t\t\t       loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\t__hlist_for_each_rcu(node, head)\n\t\tif (pos-- == 0)\n\t\t\treturn node;\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hlist_for_each_rcu",
          "args": [
            "node",
            "head"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct hlist_node *seq_hlist_start_rcu(struct hlist_head *head,\n\t\t\t\t       loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\t__hlist_for_each_rcu(node, head)\n\t\tif (pos-- == 0)\n\t\t\treturn node;\n\treturn NULL;\n}"
  },
  {
    "function_name": "seq_hlist_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "832-842",
    "snippet": "struct hlist_node *seq_hlist_next(void *v, struct hlist_head *head,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*ppos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn head->first;\n\telse\n\t\treturn node->next;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct hlist_node *seq_hlist_next(void *v, struct hlist_head *head,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct hlist_node *node = v;\n\n\t++*ppos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn head->first;\n\telse\n\t\treturn node->next;\n}"
  },
  {
    "function_name": "seq_hlist_start_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "815-821",
    "snippet": "struct hlist_node *seq_hlist_start_head(struct hlist_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start(head, pos - 1);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_hlist_start",
          "args": [
            "head",
            "pos - 1"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "seq_hlist_start_head_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "880-887",
          "snippet": "struct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *head,\n\t\t\t\t\t    loff_t pos)\n{\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start_rcu(head, pos - 1);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct hlist_node *seq_hlist_start_head_rcu(struct hlist_head *head,\n\t\t\t\t\t    loff_t pos)\n{\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start_rcu(head, pos - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct hlist_node *seq_hlist_start_head(struct hlist_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start(head, pos - 1);\n}"
  },
  {
    "function_name": "seq_hlist_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "796-804",
    "snippet": "struct hlist_node *seq_hlist_start(struct hlist_head *head, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\thlist_for_each(node, head)\n\t\tif (pos-- == 0)\n\t\t\treturn node;\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each",
          "args": [
            "node",
            "head"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct hlist_node *seq_hlist_start(struct hlist_head *head, loff_t pos)\n{\n\tstruct hlist_node *node;\n\n\thlist_for_each(node, head)\n\t\tif (pos-- == 0)\n\t\t\treturn node;\n\treturn NULL;\n}"
  },
  {
    "function_name": "seq_list_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "779-786",
    "snippet": "struct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}"
  },
  {
    "function_name": "seq_list_start_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "770-776",
    "snippet": "struct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "head",
            "pos - 1"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_start_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "770-776",
          "snippet": "struct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}"
  },
  {
    "function_name": "seq_list_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "758-767",
    "snippet": "struct list_head *seq_list_start(struct list_head *head, loff_t pos)\n{\n\tstruct list_head *lh;\n\n\tlist_for_each(lh, head)\n\t\tif (pos-- == 0)\n\t\t\treturn lh;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "lh",
            "head"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_start(struct list_head *head, loff_t pos)\n{\n\tstruct list_head *lh;\n\n\tlist_for_each(lh, head)\n\t\tif (pos-- == 0)\n\t\t\treturn lh;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "seq_pad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "748-755",
    "snippet": "void seq_pad(struct seq_file *m, char c)\n{\n\tint size = m->pad_until - m->count;\n\tif (size > 0)\n\t\tseq_printf(m, \"%*s\", size, \"\");\n\tif (c)\n\t\tseq_putc(m, c);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "c"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*s\"",
            "size",
            "\"\""
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid seq_pad(struct seq_file *m, char c)\n{\n\tint size = m->pad_until - m->count;\n\tif (size > 0)\n\t\tseq_printf(m, \"%*s\", size, \"\");\n\tif (c)\n\t\tseq_putc(m, c);\n}"
  },
  {
    "function_name": "seq_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "731-740",
    "snippet": "int seq_write(struct seq_file *seq, const void *data, size_t len)\n{\n\tif (seq->count + len < seq->size) {\n\t\tmemcpy(seq->buf + seq->count, data, len);\n\t\tseq->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(seq);\n\treturn -1;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_set_overflow",
          "args": [
            "seq"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "seq_set_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "19-22",
          "snippet": "static void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "seq->buf + seq->count",
            "data",
            "len"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_write(struct seq_file *seq, const void *data, size_t len)\n{\n\tif (seq->count + len < seq->size) {\n\t\tmemcpy(seq->buf + seq->count, data, len);\n\t\tseq->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(seq);\n\treturn -1;\n}"
  },
  {
    "function_name": "seq_put_decimal_ll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "705-720",
    "snippet": "int seq_put_decimal_ll(struct seq_file *m, char delimiter,\n\t\t\tlong long num)\n{\n\tif (num < 0) {\n\t\tif (m->count + 3 >= m->size) {\n\t\t\tseq_set_overflow(m);\n\t\t\treturn -1;\n\t\t}\n\t\tif (delimiter)\n\t\t\tm->buf[m->count++] = delimiter;\n\t\tnum = -num;\n\t\tdelimiter = '-';\n\t}\n\treturn seq_put_decimal_ull(m, delimiter, num);\n\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_put_decimal_ull",
          "args": [
            "m",
            "delimiter",
            "num"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "seq_put_decimal_ull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "678-702",
          "snippet": "int seq_put_decimal_ull(struct seq_file *m, char delimiter,\n\t\t\tunsigned long long num)\n{\n\tint len;\n\n\tif (m->count + 2 >= m->size) /* we'll write 2 bytes at least */\n\t\tgoto overflow;\n\n\tif (delimiter)\n\t\tm->buf[m->count++] = delimiter;\n\n\tif (num < 10) {\n\t\tm->buf[m->count++] = num + '0';\n\t\treturn 0;\n\t}\n\n\tlen = num_to_str(m->buf + m->count, m->size - m->count, num);\n\tif (!len)\n\t\tgoto overflow;\n\tm->count += len;\n\treturn 0;\noverflow:\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_put_decimal_ull(struct seq_file *m, char delimiter,\n\t\t\tunsigned long long num)\n{\n\tint len;\n\n\tif (m->count + 2 >= m->size) /* we'll write 2 bytes at least */\n\t\tgoto overflow;\n\n\tif (delimiter)\n\t\tm->buf[m->count++] = delimiter;\n\n\tif (num < 10) {\n\t\tm->buf[m->count++] = num + '0';\n\t\treturn 0;\n\t}\n\n\tlen = num_to_str(m->buf + m->count, m->size - m->count, num);\n\tif (!len)\n\t\tgoto overflow;\n\tm->count += len;\n\treturn 0;\noverflow:\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_set_overflow",
          "args": [
            "m"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "seq_set_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "19-22",
          "snippet": "static void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_put_decimal_ll(struct seq_file *m, char delimiter,\n\t\t\tlong long num)\n{\n\tif (num < 0) {\n\t\tif (m->count + 3 >= m->size) {\n\t\t\tseq_set_overflow(m);\n\t\t\treturn -1;\n\t\t}\n\t\tif (delimiter)\n\t\t\tm->buf[m->count++] = delimiter;\n\t\tnum = -num;\n\t\tdelimiter = '-';\n\t}\n\treturn seq_put_decimal_ull(m, delimiter, num);\n\n}"
  },
  {
    "function_name": "seq_put_decimal_ull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "678-702",
    "snippet": "int seq_put_decimal_ull(struct seq_file *m, char delimiter,\n\t\t\tunsigned long long num)\n{\n\tint len;\n\n\tif (m->count + 2 >= m->size) /* we'll write 2 bytes at least */\n\t\tgoto overflow;\n\n\tif (delimiter)\n\t\tm->buf[m->count++] = delimiter;\n\n\tif (num < 10) {\n\t\tm->buf[m->count++] = num + '0';\n\t\treturn 0;\n\t}\n\n\tlen = num_to_str(m->buf + m->count, m->size - m->count, num);\n\tif (!len)\n\t\tgoto overflow;\n\tm->count += len;\n\treturn 0;\noverflow:\n\tseq_set_overflow(m);\n\treturn -1;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_set_overflow",
          "args": [
            "m"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "seq_set_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "19-22",
          "snippet": "static void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_to_str",
          "args": [
            "m->buf + m->count",
            "m->size - m->count",
            "num"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_put_decimal_ull(struct seq_file *m, char delimiter,\n\t\t\tunsigned long long num)\n{\n\tint len;\n\n\tif (m->count + 2 >= m->size) /* we'll write 2 bytes at least */\n\t\tgoto overflow;\n\n\tif (delimiter)\n\t\tm->buf[m->count++] = delimiter;\n\n\tif (num < 10) {\n\t\tm->buf[m->count++] = num + '0';\n\t\treturn 0;\n\t}\n\n\tlen = num_to_str(m->buf + m->count, m->size - m->count, num);\n\tif (!len)\n\t\tgoto overflow;\n\tm->count += len;\n\treturn 0;\noverflow:\n\tseq_set_overflow(m);\n\treturn -1;\n}"
  },
  {
    "function_name": "seq_puts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "658-668",
    "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_set_overflow",
          "args": [
            "m"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "seq_set_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "19-22",
          "snippet": "static void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m->buf + m->count",
            "s",
            "len"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
  },
  {
    "function_name": "seq_putc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "648-655",
    "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "seq_open_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "641-645",
    "snippet": "int seq_open_private(struct file *filp, const struct seq_operations *ops,\n\t\tint psize)\n{\n\treturn __seq_open_private(filp, ops, psize) ? 0 : -ENOMEM;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "filp",
            "ops",
            "psize"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "__seq_open_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "615-638",
          "snippet": "void *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open_private(struct file *filp, const struct seq_operations *ops,\n\t\tint psize)\n{\n\treturn __seq_open_private(filp, ops, psize) ? 0 : -ENOMEM;\n}"
  },
  {
    "function_name": "__seq_open_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "615-638",
    "snippet": "void *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "private"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "f",
            "ops"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "psize",
            "GFP_KERNEL"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "seq_release_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "605-612",
    "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "seq->private"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
  },
  {
    "function_name": "single_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "596-602",
    "snippet": "int single_release(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *op = ((struct seq_file *)file->private_data)->op;\n\tint res = seq_release(inode, file);\n\tkfree(op);\n\treturn res;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_release(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *op = ((struct seq_file *)file->private_data)->op;\n\tint res = seq_release(inode, file);\n\tkfree(op);\n\treturn res;\n}"
  },
  {
    "function_name": "single_open_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "578-593",
    "snippet": "int single_open_size(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data, size_t size)\n{\n\tchar *buf = seq_buf_alloc(size);\n\tint ret;\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = single_open(file, show, data);\n\tif (ret) {\n\t\tkvfree(buf);\n\t\treturn ret;\n\t}\n\t((struct seq_file *)file->private_data)->buf = buf;\n\t((struct seq_file *)file->private_data)->size = size;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "buf"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "show",
            "data"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_buf_alloc",
          "args": [
            "size"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "seq_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "24-36",
          "snippet": "static void *seq_buf_alloc(unsigned long size)\n{\n\tvoid *buf;\n\n\t/*\n\t * __GFP_NORETRY to avoid oom-killings with high-order allocations -\n\t * it's better to fall back to vmalloc() than to kill things.\n\t */\n\tbuf = kmalloc(size, GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tif (!buf && size > PAGE_SIZE)\n\t\tbuf = vmalloc(size);\n\treturn buf;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void *seq_buf_alloc(unsigned long size)\n{\n\tvoid *buf;\n\n\t/*\n\t * __GFP_NORETRY to avoid oom-killings with high-order allocations -\n\t * it's better to fall back to vmalloc() than to kill things.\n\t */\n\tbuf = kmalloc(size, GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tif (!buf && size > PAGE_SIZE)\n\t\tbuf = vmalloc(size);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open_size(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data, size_t size)\n{\n\tchar *buf = seq_buf_alloc(size);\n\tint ret;\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = single_open(file, show, data);\n\tif (ret) {\n\t\tkvfree(buf);\n\t\treturn ret;\n\t}\n\t((struct seq_file *)file->private_data)->buf = buf;\n\t((struct seq_file *)file->private_data)->size = size;\n\treturn 0;\n}"
  },
  {
    "function_name": "single_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "557-575",
    "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "op"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*op)",
            "GFP_KERNEL"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "single_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "553-555",
    "snippet": "static void single_stop(struct seq_file *p, void *v)\n{\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void single_stop(struct seq_file *p, void *v)\n{\n}"
  },
  {
    "function_name": "single_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "547-551",
    "snippet": "static void *single_next(struct seq_file *p, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void *single_next(struct seq_file *p, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn NULL;\n}"
  },
  {
    "function_name": "single_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "542-545",
    "snippet": "static void *single_start(struct seq_file *p, loff_t *pos)\n{\n\treturn NULL + (*pos == 0);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void *single_start(struct seq_file *p, loff_t *pos)\n{\n\treturn NULL + (*pos == 0);\n}"
  },
  {
    "function_name": "seq_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "523-540",
    "snippet": "int seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = dentry_path(dentry, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_commit",
          "args": [
            "m",
            "res"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mangle_path",
          "args": [
            "buf",
            "p",
            "esc"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "mangle_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "440-458",
          "snippet": "char *mangle_path(char *s, const char *p, const char *esc)\n{\n\twhile (s <= p) {\n\t\tchar c = *p++;\n\t\tif (!c) {\n\t\t\treturn s;\n\t\t} else if (!strchr(esc, c)) {\n\t\t\t*s++ = c;\n\t\t} else if (s + 4 > p) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '0' + ((c & 0300) >> 6);\n\t\t\t*s++ = '0' + ((c & 070) >> 3);\n\t\t\t*s++ = '0' + (c & 07);\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nchar *mangle_path(char *s, const char *p, const char *esc)\n{\n\twhile (s <= p) {\n\t\tchar c = *p++;\n\t\tif (!c) {\n\t\t\treturn s;\n\t\t} else if (!strchr(esc, c)) {\n\t\t\t*s++ = c;\n\t\t} else if (s + 4 > p) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '0' + ((c & 0300) >> 6);\n\t\t\t*s++ = '0' + ((c & 070) >> 3);\n\t\t\t*s++ = '0' + (c & 07);\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_path",
          "args": [
            "dentry",
            "buf",
            "size"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3166-3183",
          "snippet": "char *dentry_path(struct dentry *dentry, char *buf, int buflen)\n{\n\tchar *p = NULL;\n\tchar *retval;\n\n\tif (d_unlinked(dentry)) {\n\t\tp = buf + buflen;\n\t\tif (prepend(&p, &buflen, \"//deleted\", 10) != 0)\n\t\t\tgoto Elong;\n\t\tbuflen++;\n\t}\n\tretval = __dentry_path(dentry, buf, buflen);\n\tif (!IS_ERR(retval) && p)\n\t\t*p = '/';\t/* restore '/' overriden with '\\0' */\n\treturn retval;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nchar *dentry_path(struct dentry *dentry, char *buf, int buflen)\n{\n\tchar *p = NULL;\n\tchar *retval;\n\n\tif (d_unlinked(dentry)) {\n\t\tp = buf + buflen;\n\t\tif (prepend(&p, &buflen, \"//deleted\", 10) != 0)\n\t\t\tgoto Elong;\n\t\tbuflen++;\n\t}\n\tretval = __dentry_path(dentry, buf, buflen);\n\tif (!IS_ERR(retval) && p)\n\t\t*p = '/';\t/* restore '/' overriden with '\\0' */\n\treturn retval;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_get_buf",
          "args": [
            "m",
            "&buf"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = dentry_path(dentry, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}"
  },
  {
    "function_name": "seq_path_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "493-518",
    "snippet": "int seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_commit",
          "args": [
            "m",
            "res"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mangle_path",
          "args": [
            "buf",
            "p",
            "esc"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "mangle_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "440-458",
          "snippet": "char *mangle_path(char *s, const char *p, const char *esc)\n{\n\twhile (s <= p) {\n\t\tchar c = *p++;\n\t\tif (!c) {\n\t\t\treturn s;\n\t\t} else if (!strchr(esc, c)) {\n\t\t\t*s++ = c;\n\t\t} else if (s + 4 > p) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '0' + ((c & 0300) >> 6);\n\t\t\t*s++ = '0' + ((c & 070) >> 3);\n\t\t\t*s++ = '0' + (c & 07);\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nchar *mangle_path(char *s, const char *p, const char *esc)\n{\n\twhile (s <= p) {\n\t\tchar c = *p++;\n\t\tif (!c) {\n\t\t\treturn s;\n\t\t} else if (!strchr(esc, c)) {\n\t\t\t*s++ = c;\n\t\t} else if (s + 4 > p) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '0' + ((c & 0300) >> 6);\n\t\t\t*s++ = '0' + ((c & 070) >> 3);\n\t\t\t*s++ = '0' + (c & 07);\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "p"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_path",
          "args": [
            "path",
            "root",
            "buf",
            "size"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2965-2980",
          "snippet": "char *__d_path(const struct path *path,\n\t       const struct path *root,\n\t       char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tint error;\n\n\tprepend(&res, &buflen, \"\\0\", 1);\n\terror = prepend_path(path, root, &res, &buflen);\n\n\tif (error < 0)\n\t\treturn ERR_PTR(error);\n\tif (error > 0)\n\t\treturn NULL;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nchar *__d_path(const struct path *path,\n\t       const struct path *root,\n\t       char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tint error;\n\n\tprepend(&res, &buflen, \"\\0\", 1);\n\terror = prepend_path(path, root, &res, &buflen);\n\n\tif (error < 0)\n\t\treturn ERR_PTR(error);\n\tif (error > 0)\n\t\treturn NULL;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_get_buf",
          "args": [
            "m",
            "&buf"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}"
  },
  {
    "function_name": "seq_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "470-487",
    "snippet": "int seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_commit",
          "args": [
            "m",
            "res"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mangle_path",
          "args": [
            "buf",
            "p",
            "esc"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "mangle_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "440-458",
          "snippet": "char *mangle_path(char *s, const char *p, const char *esc)\n{\n\twhile (s <= p) {\n\t\tchar c = *p++;\n\t\tif (!c) {\n\t\t\treturn s;\n\t\t} else if (!strchr(esc, c)) {\n\t\t\t*s++ = c;\n\t\t} else if (s + 4 > p) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '0' + ((c & 0300) >> 6);\n\t\t\t*s++ = '0' + ((c & 070) >> 3);\n\t\t\t*s++ = '0' + (c & 07);\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nchar *mangle_path(char *s, const char *p, const char *esc)\n{\n\twhile (s <= p) {\n\t\tchar c = *p++;\n\t\tif (!c) {\n\t\t\treturn s;\n\t\t} else if (!strchr(esc, c)) {\n\t\t\t*s++ = c;\n\t\t} else if (s + 4 > p) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '0' + ((c & 0300) >> 6);\n\t\t\t*s++ = '0' + ((c & 070) >> 3);\n\t\t\t*s++ = '0' + (c & 07);\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_path",
          "args": [
            "path",
            "buf",
            "size"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3047-3076",
          "snippet": "char *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nchar *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_get_buf",
          "args": [
            "m",
            "&buf"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}"
  },
  {
    "function_name": "mangle_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "440-458",
    "snippet": "char *mangle_path(char *s, const char *p, const char *esc)\n{\n\twhile (s <= p) {\n\t\tchar c = *p++;\n\t\tif (!c) {\n\t\t\treturn s;\n\t\t} else if (!strchr(esc, c)) {\n\t\t\t*s++ = c;\n\t\t} else if (s + 4 > p) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '0' + ((c & 0300) >> 6);\n\t\t\t*s++ = '0' + ((c & 070) >> 3);\n\t\t\t*s++ = '0' + (c & 07);\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "esc",
            "c"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nchar *mangle_path(char *s, const char *p, const char *esc)\n{\n\twhile (s <= p) {\n\t\tchar c = *p++;\n\t\tif (!c) {\n\t\t\treturn s;\n\t\t} else if (!strchr(esc, c)) {\n\t\t\t*s++ = c;\n\t\t} else if (s + 4 > p) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*s++ = '\\\\';\n\t\t\t*s++ = '0' + ((c & 0300) >> 6);\n\t\t\t*s++ = '0' + ((c & 070) >> 3);\n\t\t\t*s++ = '0' + (c & 07);\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "seq_printf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "416-426",
    "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_vprintf",
          "args": [
            "m",
            "f",
            "args"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "seq_vprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "400-413",
          "snippet": "int seq_vprintf(struct seq_file *m, const char *f, va_list args)\n{\n\tint len;\n\n\tif (m->count < m->size) {\n\t\tlen = vsnprintf(m->buf + m->count, m->size - m->count, f, args);\n\t\tif (m->count + len < m->size) {\n\t\t\tm->count += len;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_vprintf(struct seq_file *m, const char *f, va_list args)\n{\n\tint len;\n\n\tif (m->count < m->size) {\n\t\tlen = vsnprintf(m->buf + m->count, m->size - m->count, f, args);\n\t\tif (m->count + len < m->size) {\n\t\t\tm->count += len;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "f"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "seq_vprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "400-413",
    "snippet": "int seq_vprintf(struct seq_file *m, const char *f, va_list args)\n{\n\tint len;\n\n\tif (m->count < m->size) {\n\t\tlen = vsnprintf(m->buf + m->count, m->size - m->count, f, args);\n\t\tif (m->count + len < m->size) {\n\t\t\tm->count += len;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_set_overflow",
          "args": [
            "m"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "seq_set_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "19-22",
          "snippet": "static void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "m->buf + m->count",
            "m->size - m->count",
            "f",
            "args"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_vprintf(struct seq_file *m, const char *f, va_list args)\n{\n\tint len;\n\n\tif (m->count < m->size) {\n\t\tlen = vsnprintf(m->buf + m->count, m->size - m->count, f, args);\n\t\tif (m->count + len < m->size) {\n\t\t\tm->count += len;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
  },
  {
    "function_name": "seq_escape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "374-397",
    "snippet": "int seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *end = m->buf + m->size;\n        char *p;\n\tchar c;\n\n        for (p = m->buf + m->count; (c = *s) != '\\0' && p < end; s++) {\n\t\tif (!strchr(esc, c)) {\n\t\t\t*p++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p + 3 < end) {\n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = '0' + ((c & 0300) >> 6);\n\t\t\t*p++ = '0' + ((c & 070) >> 3);\n\t\t\t*p++ = '0' + (c & 07);\n\t\t\tcontinue;\n\t\t}\n\t\tseq_set_overflow(m);\n\t\treturn -1;\n        }\n\tm->count = p - m->buf;\n        return 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_set_overflow",
          "args": [
            "m"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "seq_set_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "19-22",
          "snippet": "static void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "esc",
            "c"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *end = m->buf + m->size;\n        char *p;\n\tchar c;\n\n        for (p = m->buf + m->count; (c = *s) != '\\0' && p < end; s++) {\n\t\tif (!strchr(esc, c)) {\n\t\t\t*p++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p + 3 < end) {\n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = '0' + ((c & 0300) >> 6);\n\t\t\t*p++ = '0' + ((c & 070) >> 3);\n\t\t\t*p++ = '0' + (c & 07);\n\t\t\tcontinue;\n\t\t}\n\t\tseq_set_overflow(m);\n\t\treturn -1;\n        }\n\tm->count = p - m->buf;\n        return 0;\n}"
  },
  {
    "function_name": "seq_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "355-361",
    "snippet": "int seq_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tkvfree(m->buf);\n\tkfree(m);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "m"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "m->buf"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tkvfree(m->buf);\n\tkfree(m);\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_lseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "309-344",
    "snippet": "loff_t seq_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct seq_file *m = file->private_data;\n\tloff_t retval = -EINVAL;\n\n\tmutex_lock(&m->lock);\n\tm->version = file->f_version;\n\tswitch (whence) {\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\tcase SEEK_SET:\n\t\tif (offset < 0)\n\t\t\tbreak;\n\t\tretval = offset;\n\t\tif (offset != m->read_pos) {\n\t\t\twhile ((retval = traverse(m, offset)) == -EAGAIN)\n\t\t\t\t;\n\t\t\tif (retval) {\n\t\t\t\t/* with extreme prejudice... */\n\t\t\t\tfile->f_pos = 0;\n\t\t\t\tm->read_pos = 0;\n\t\t\t\tm->version = 0;\n\t\t\t\tm->index = 0;\n\t\t\t\tm->count = 0;\n\t\t\t} else {\n\t\t\t\tm->read_pos = offset;\n\t\t\t\tretval = file->f_pos = offset;\n\t\t\t}\n\t\t} else {\n\t\t\tfile->f_pos = offset;\n\t\t}\n\t}\n\tfile->f_version = m->version;\n\tmutex_unlock(&m->lock);\n\treturn retval;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&m->lock"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traverse",
          "args": [
            "m",
            "offset"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "90-147",
          "snippet": "static int traverse(struct seq_file *m, loff_t offset)\n{\n\tloff_t pos = 0, index;\n\tint error = 0;\n\tvoid *p;\n\n\tm->version = 0;\n\tindex = 0;\n\tm->count = m->from = 0;\n\tif (!offset) {\n\t\tm->index = index;\n\t\treturn 0;\n\t}\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tp = m->op->start(m, &index);\n\twhile (p) {\n\t\terror = PTR_ERR(p);\n\t\tif (IS_ERR(p))\n\t\t\tbreak;\n\t\terror = m->op->show(m, p);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (unlikely(error)) {\n\t\t\terror = 0;\n\t\t\tm->count = 0;\n\t\t}\n\t\tif (seq_has_overflowed(m))\n\t\t\tgoto Eoverflow;\n\t\tif (pos + m->count > offset) {\n\t\t\tm->from = offset - pos;\n\t\t\tm->count -= m->from;\n\t\t\tm->index = index;\n\t\t\tbreak;\n\t\t}\n\t\tpos += m->count;\n\t\tm->count = 0;\n\t\tif (pos == offset) {\n\t\t\tindex++;\n\t\t\tm->index = index;\n\t\t\tbreak;\n\t\t}\n\t\tp = m->op->next(m, p, &index);\n\t}\n\tm->op->stop(m, p);\n\tm->index = index;\n\treturn error;\n\nEoverflow:\n\tm->op->stop(m, p);\n\tkvfree(m->buf);\n\tm->count = 0;\n\tm->buf = seq_buf_alloc(m->size <<= 1);\n\treturn !m->buf ? -ENOMEM : -EAGAIN;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic int traverse(struct seq_file *m, loff_t offset)\n{\n\tloff_t pos = 0, index;\n\tint error = 0;\n\tvoid *p;\n\n\tm->version = 0;\n\tindex = 0;\n\tm->count = m->from = 0;\n\tif (!offset) {\n\t\tm->index = index;\n\t\treturn 0;\n\t}\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tp = m->op->start(m, &index);\n\twhile (p) {\n\t\terror = PTR_ERR(p);\n\t\tif (IS_ERR(p))\n\t\t\tbreak;\n\t\terror = m->op->show(m, p);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (unlikely(error)) {\n\t\t\terror = 0;\n\t\t\tm->count = 0;\n\t\t}\n\t\tif (seq_has_overflowed(m))\n\t\t\tgoto Eoverflow;\n\t\tif (pos + m->count > offset) {\n\t\t\tm->from = offset - pos;\n\t\t\tm->count -= m->from;\n\t\t\tm->index = index;\n\t\t\tbreak;\n\t\t}\n\t\tpos += m->count;\n\t\tm->count = 0;\n\t\tif (pos == offset) {\n\t\t\tindex++;\n\t\t\tm->index = index;\n\t\t\tbreak;\n\t\t}\n\t\tp = m->op->next(m, p, &index);\n\t}\n\tm->op->stop(m, p);\n\tm->index = index;\n\treturn error;\n\nEoverflow:\n\tm->op->stop(m, p);\n\tkvfree(m->buf);\n\tm->count = 0;\n\tm->buf = seq_buf_alloc(m->size <<= 1);\n\treturn !m->buf ? -ENOMEM : -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&m->lock"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nloff_t seq_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct seq_file *m = file->private_data;\n\tloff_t retval = -EINVAL;\n\n\tmutex_lock(&m->lock);\n\tm->version = file->f_version;\n\tswitch (whence) {\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\tcase SEEK_SET:\n\t\tif (offset < 0)\n\t\t\tbreak;\n\t\tretval = offset;\n\t\tif (offset != m->read_pos) {\n\t\t\twhile ((retval = traverse(m, offset)) == -EAGAIN)\n\t\t\t\t;\n\t\t\tif (retval) {\n\t\t\t\t/* with extreme prejudice... */\n\t\t\t\tfile->f_pos = 0;\n\t\t\t\tm->read_pos = 0;\n\t\t\t\tm->version = 0;\n\t\t\t\tm->index = 0;\n\t\t\t\tm->count = 0;\n\t\t\t} else {\n\t\t\t\tm->read_pos = offset;\n\t\t\t\tretval = file->f_pos = offset;\n\t\t\t}\n\t\t} else {\n\t\t\tfile->f_pos = offset;\n\t\t}\n\t}\n\tfile->f_version = m->version;\n\tmutex_unlock(&m->lock);\n\treturn retval;\n}"
  },
  {
    "function_name": "seq_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "158-298",
    "snippet": "ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)\n{\n\tstruct seq_file *m = file->private_data;\n\tsize_t copied = 0;\n\tloff_t pos;\n\tsize_t n;\n\tvoid *p;\n\tint err = 0;\n\n\tmutex_lock(&m->lock);\n\n\t/*\n\t * seq_file->op->..m_start/m_stop/m_next may do special actions\n\t * or optimisations based on the file->f_version, so we want to\n\t * pass the file->f_version to those methods.\n\t *\n\t * seq_file->version is just copy of f_version, and seq_file\n\t * methods can treat it simply as file version.\n\t * It is copied in first and copied out after all operations.\n\t * It is convenient to have it as  part of structure to avoid the\n\t * need of passing another argument to all the seq_file methods.\n\t */\n\tm->version = file->f_version;\n\n\t/* Don't assume *ppos is where we left it */\n\tif (unlikely(*ppos != m->read_pos)) {\n\t\twhile ((err = traverse(m, *ppos)) == -EAGAIN)\n\t\t\t;\n\t\tif (err) {\n\t\t\t/* With prejudice... */\n\t\t\tm->read_pos = 0;\n\t\t\tm->version = 0;\n\t\t\tm->index = 0;\n\t\t\tm->count = 0;\n\t\t\tgoto Done;\n\t\t} else {\n\t\t\tm->read_pos = *ppos;\n\t\t}\n\t}\n\n\t/* grab buffer if we didn't have one */\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t}\n\t/* if not empty - flush it first */\n\tif (m->count) {\n\t\tn = min(m->count, size);\n\t\terr = copy_to_user(buf, m->buf + m->from, n);\n\t\tif (err)\n\t\t\tgoto Efault;\n\t\tm->count -= n;\n\t\tm->from += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t\tcopied += n;\n\t\tif (!m->count)\n\t\t\tm->index++;\n\t\tif (!size)\n\t\t\tgoto Done;\n\t}\n\t/* we need at least one record in buffer */\n\tpos = m->index;\n\tp = m->op->start(m, &pos);\n\twhile (1) {\n\t\terr = PTR_ERR(p);\n\t\tif (!p || IS_ERR(p))\n\t\t\tbreak;\n\t\terr = m->op->show(m, p);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (unlikely(err))\n\t\t\tm->count = 0;\n\t\tif (unlikely(!m->count)) {\n\t\t\tp = m->op->next(m, p, &pos);\n\t\t\tm->index = pos;\n\t\t\tcontinue;\n\t\t}\n\t\tif (m->count < m->size)\n\t\t\tgoto Fill;\n\t\tm->op->stop(m, p);\n\t\tkvfree(m->buf);\n\t\tm->count = 0;\n\t\tm->buf = seq_buf_alloc(m->size <<= 1);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t\tm->version = 0;\n\t\tpos = m->index;\n\t\tp = m->op->start(m, &pos);\n\t}\n\tm->op->stop(m, p);\n\tm->count = 0;\n\tgoto Done;\nFill:\n\t/* they want more? let's try to get some more */\n\twhile (m->count < size) {\n\t\tsize_t offs = m->count;\n\t\tloff_t next = pos;\n\t\tp = m->op->next(m, p, &next);\n\t\tif (!p || IS_ERR(p)) {\n\t\t\terr = PTR_ERR(p);\n\t\t\tbreak;\n\t\t}\n\t\terr = m->op->show(m, p);\n\t\tif (seq_has_overflowed(m) || err) {\n\t\t\tm->count = offs;\n\t\t\tif (likely(err <= 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tpos = next;\n\t}\n\tm->op->stop(m, p);\n\tn = min(m->count, size);\n\terr = copy_to_user(buf, m->buf, n);\n\tif (err)\n\t\tgoto Efault;\n\tcopied += n;\n\tm->count -= n;\n\tif (m->count)\n\t\tm->from = n;\n\telse\n\t\tpos++;\n\tm->index = pos;\nDone:\n\tif (!copied)\n\t\tcopied = err;\n\telse {\n\t\t*ppos += copied;\n\t\tm->read_pos += copied;\n\t}\n\tfile->f_version = m->version;\n\tmutex_unlock(&m->lock);\n\treturn copied;\nEnomem:\n\terr = -ENOMEM;\n\tgoto Done;\nEfault:\n\terr = -EFAULT;\n\tgoto Done;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&m->lock"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "m->buf",
            "n"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "m->count",
            "size"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->op->stop",
          "args": [
            "m",
            "p"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "err <= 0"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "m"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->show",
          "args": [
            "m",
            "p"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "p"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->next",
          "args": [
            "m",
            "p",
            "&next"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->stop",
          "args": [
            "m",
            "p"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->start",
          "args": [
            "m",
            "&pos"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_alloc",
          "args": [
            "m->size <<= 1"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "seq_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "24-36",
          "snippet": "static void *seq_buf_alloc(unsigned long size)\n{\n\tvoid *buf;\n\n\t/*\n\t * __GFP_NORETRY to avoid oom-killings with high-order allocations -\n\t * it's better to fall back to vmalloc() than to kill things.\n\t */\n\tbuf = kmalloc(size, GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tif (!buf && size > PAGE_SIZE)\n\t\tbuf = vmalloc(size);\n\treturn buf;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void *seq_buf_alloc(unsigned long size)\n{\n\tvoid *buf;\n\n\t/*\n\t * __GFP_NORETRY to avoid oom-killings with high-order allocations -\n\t * it's better to fall back to vmalloc() than to kill things.\n\t */\n\tbuf = kmalloc(size, GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tif (!buf && size > PAGE_SIZE)\n\t\tbuf = vmalloc(size);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "m->buf"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->stop",
          "args": [
            "m",
            "p"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->next",
          "args": [
            "m",
            "p",
            "&pos"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!m->count"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->show",
          "args": [
            "m",
            "p"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "p"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->start",
          "args": [
            "m",
            "&pos"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "m->buf + m->from",
            "n"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traverse",
          "args": [
            "m",
            "*ppos"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "90-147",
          "snippet": "static int traverse(struct seq_file *m, loff_t offset)\n{\n\tloff_t pos = 0, index;\n\tint error = 0;\n\tvoid *p;\n\n\tm->version = 0;\n\tindex = 0;\n\tm->count = m->from = 0;\n\tif (!offset) {\n\t\tm->index = index;\n\t\treturn 0;\n\t}\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tp = m->op->start(m, &index);\n\twhile (p) {\n\t\terror = PTR_ERR(p);\n\t\tif (IS_ERR(p))\n\t\t\tbreak;\n\t\terror = m->op->show(m, p);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (unlikely(error)) {\n\t\t\terror = 0;\n\t\t\tm->count = 0;\n\t\t}\n\t\tif (seq_has_overflowed(m))\n\t\t\tgoto Eoverflow;\n\t\tif (pos + m->count > offset) {\n\t\t\tm->from = offset - pos;\n\t\t\tm->count -= m->from;\n\t\t\tm->index = index;\n\t\t\tbreak;\n\t\t}\n\t\tpos += m->count;\n\t\tm->count = 0;\n\t\tif (pos == offset) {\n\t\t\tindex++;\n\t\t\tm->index = index;\n\t\t\tbreak;\n\t\t}\n\t\tp = m->op->next(m, p, &index);\n\t}\n\tm->op->stop(m, p);\n\tm->index = index;\n\treturn error;\n\nEoverflow:\n\tm->op->stop(m, p);\n\tkvfree(m->buf);\n\tm->count = 0;\n\tm->buf = seq_buf_alloc(m->size <<= 1);\n\treturn !m->buf ? -ENOMEM : -EAGAIN;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic int traverse(struct seq_file *m, loff_t offset)\n{\n\tloff_t pos = 0, index;\n\tint error = 0;\n\tvoid *p;\n\n\tm->version = 0;\n\tindex = 0;\n\tm->count = m->from = 0;\n\tif (!offset) {\n\t\tm->index = index;\n\t\treturn 0;\n\t}\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tp = m->op->start(m, &index);\n\twhile (p) {\n\t\terror = PTR_ERR(p);\n\t\tif (IS_ERR(p))\n\t\t\tbreak;\n\t\terror = m->op->show(m, p);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (unlikely(error)) {\n\t\t\terror = 0;\n\t\t\tm->count = 0;\n\t\t}\n\t\tif (seq_has_overflowed(m))\n\t\t\tgoto Eoverflow;\n\t\tif (pos + m->count > offset) {\n\t\t\tm->from = offset - pos;\n\t\t\tm->count -= m->from;\n\t\t\tm->index = index;\n\t\t\tbreak;\n\t\t}\n\t\tpos += m->count;\n\t\tm->count = 0;\n\t\tif (pos == offset) {\n\t\t\tindex++;\n\t\t\tm->index = index;\n\t\t\tbreak;\n\t\t}\n\t\tp = m->op->next(m, p, &index);\n\t}\n\tm->op->stop(m, p);\n\tm->index = index;\n\treturn error;\n\nEoverflow:\n\tm->op->stop(m, p);\n\tkvfree(m->buf);\n\tm->count = 0;\n\tm->buf = seq_buf_alloc(m->size <<= 1);\n\treturn !m->buf ? -ENOMEM : -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*ppos != m->read_pos"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&m->lock"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)\n{\n\tstruct seq_file *m = file->private_data;\n\tsize_t copied = 0;\n\tloff_t pos;\n\tsize_t n;\n\tvoid *p;\n\tint err = 0;\n\n\tmutex_lock(&m->lock);\n\n\t/*\n\t * seq_file->op->..m_start/m_stop/m_next may do special actions\n\t * or optimisations based on the file->f_version, so we want to\n\t * pass the file->f_version to those methods.\n\t *\n\t * seq_file->version is just copy of f_version, and seq_file\n\t * methods can treat it simply as file version.\n\t * It is copied in first and copied out after all operations.\n\t * It is convenient to have it as  part of structure to avoid the\n\t * need of passing another argument to all the seq_file methods.\n\t */\n\tm->version = file->f_version;\n\n\t/* Don't assume *ppos is where we left it */\n\tif (unlikely(*ppos != m->read_pos)) {\n\t\twhile ((err = traverse(m, *ppos)) == -EAGAIN)\n\t\t\t;\n\t\tif (err) {\n\t\t\t/* With prejudice... */\n\t\t\tm->read_pos = 0;\n\t\t\tm->version = 0;\n\t\t\tm->index = 0;\n\t\t\tm->count = 0;\n\t\t\tgoto Done;\n\t\t} else {\n\t\t\tm->read_pos = *ppos;\n\t\t}\n\t}\n\n\t/* grab buffer if we didn't have one */\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t}\n\t/* if not empty - flush it first */\n\tif (m->count) {\n\t\tn = min(m->count, size);\n\t\terr = copy_to_user(buf, m->buf + m->from, n);\n\t\tif (err)\n\t\t\tgoto Efault;\n\t\tm->count -= n;\n\t\tm->from += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t\tcopied += n;\n\t\tif (!m->count)\n\t\t\tm->index++;\n\t\tif (!size)\n\t\t\tgoto Done;\n\t}\n\t/* we need at least one record in buffer */\n\tpos = m->index;\n\tp = m->op->start(m, &pos);\n\twhile (1) {\n\t\terr = PTR_ERR(p);\n\t\tif (!p || IS_ERR(p))\n\t\t\tbreak;\n\t\terr = m->op->show(m, p);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (unlikely(err))\n\t\t\tm->count = 0;\n\t\tif (unlikely(!m->count)) {\n\t\t\tp = m->op->next(m, p, &pos);\n\t\t\tm->index = pos;\n\t\t\tcontinue;\n\t\t}\n\t\tif (m->count < m->size)\n\t\t\tgoto Fill;\n\t\tm->op->stop(m, p);\n\t\tkvfree(m->buf);\n\t\tm->count = 0;\n\t\tm->buf = seq_buf_alloc(m->size <<= 1);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t\tm->version = 0;\n\t\tpos = m->index;\n\t\tp = m->op->start(m, &pos);\n\t}\n\tm->op->stop(m, p);\n\tm->count = 0;\n\tgoto Done;\nFill:\n\t/* they want more? let's try to get some more */\n\twhile (m->count < size) {\n\t\tsize_t offs = m->count;\n\t\tloff_t next = pos;\n\t\tp = m->op->next(m, p, &next);\n\t\tif (!p || IS_ERR(p)) {\n\t\t\terr = PTR_ERR(p);\n\t\t\tbreak;\n\t\t}\n\t\terr = m->op->show(m, p);\n\t\tif (seq_has_overflowed(m) || err) {\n\t\t\tm->count = offs;\n\t\t\tif (likely(err <= 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tpos = next;\n\t}\n\tm->op->stop(m, p);\n\tn = min(m->count, size);\n\terr = copy_to_user(buf, m->buf, n);\n\tif (err)\n\t\tgoto Efault;\n\tcopied += n;\n\tm->count -= n;\n\tif (m->count)\n\t\tm->from = n;\n\telse\n\t\tpos++;\n\tm->index = pos;\nDone:\n\tif (!copied)\n\t\tcopied = err;\n\telse {\n\t\t*ppos += copied;\n\t\tm->read_pos += copied;\n\t}\n\tfile->f_version = m->version;\n\tmutex_unlock(&m->lock);\n\treturn copied;\nEnomem:\n\terr = -ENOMEM;\n\tgoto Done;\nEfault:\n\terr = -EFAULT;\n\tgoto Done;\n}"
  },
  {
    "function_name": "traverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "90-147",
    "snippet": "static int traverse(struct seq_file *m, loff_t offset)\n{\n\tloff_t pos = 0, index;\n\tint error = 0;\n\tvoid *p;\n\n\tm->version = 0;\n\tindex = 0;\n\tm->count = m->from = 0;\n\tif (!offset) {\n\t\tm->index = index;\n\t\treturn 0;\n\t}\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tp = m->op->start(m, &index);\n\twhile (p) {\n\t\terror = PTR_ERR(p);\n\t\tif (IS_ERR(p))\n\t\t\tbreak;\n\t\terror = m->op->show(m, p);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (unlikely(error)) {\n\t\t\terror = 0;\n\t\t\tm->count = 0;\n\t\t}\n\t\tif (seq_has_overflowed(m))\n\t\t\tgoto Eoverflow;\n\t\tif (pos + m->count > offset) {\n\t\t\tm->from = offset - pos;\n\t\t\tm->count -= m->from;\n\t\t\tm->index = index;\n\t\t\tbreak;\n\t\t}\n\t\tpos += m->count;\n\t\tm->count = 0;\n\t\tif (pos == offset) {\n\t\t\tindex++;\n\t\t\tm->index = index;\n\t\t\tbreak;\n\t\t}\n\t\tp = m->op->next(m, p, &index);\n\t}\n\tm->op->stop(m, p);\n\tm->index = index;\n\treturn error;\n\nEoverflow:\n\tm->op->stop(m, p);\n\tkvfree(m->buf);\n\tm->count = 0;\n\tm->buf = seq_buf_alloc(m->size <<= 1);\n\treturn !m->buf ? -ENOMEM : -EAGAIN;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_buf_alloc",
          "args": [
            "m->size <<= 1"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "seq_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "24-36",
          "snippet": "static void *seq_buf_alloc(unsigned long size)\n{\n\tvoid *buf;\n\n\t/*\n\t * __GFP_NORETRY to avoid oom-killings with high-order allocations -\n\t * it's better to fall back to vmalloc() than to kill things.\n\t */\n\tbuf = kmalloc(size, GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tif (!buf && size > PAGE_SIZE)\n\t\tbuf = vmalloc(size);\n\treturn buf;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void *seq_buf_alloc(unsigned long size)\n{\n\tvoid *buf;\n\n\t/*\n\t * __GFP_NORETRY to avoid oom-killings with high-order allocations -\n\t * it's better to fall back to vmalloc() than to kill things.\n\t */\n\tbuf = kmalloc(size, GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tif (!buf && size > PAGE_SIZE)\n\t\tbuf = vmalloc(size);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "m->buf"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->stop",
          "args": [
            "m",
            "p"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->stop",
          "args": [
            "m",
            "p"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->next",
          "args": [
            "m",
            "p",
            "&index"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "m"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->show",
          "args": [
            "m",
            "p"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "p"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->op->start",
          "args": [
            "m",
            "&index"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic int traverse(struct seq_file *m, loff_t offset)\n{\n\tloff_t pos = 0, index;\n\tint error = 0;\n\tvoid *p;\n\n\tm->version = 0;\n\tindex = 0;\n\tm->count = m->from = 0;\n\tif (!offset) {\n\t\tm->index = index;\n\t\treturn 0;\n\t}\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tp = m->op->start(m, &index);\n\twhile (p) {\n\t\terror = PTR_ERR(p);\n\t\tif (IS_ERR(p))\n\t\t\tbreak;\n\t\terror = m->op->show(m, p);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t\tif (unlikely(error)) {\n\t\t\terror = 0;\n\t\t\tm->count = 0;\n\t\t}\n\t\tif (seq_has_overflowed(m))\n\t\t\tgoto Eoverflow;\n\t\tif (pos + m->count > offset) {\n\t\t\tm->from = offset - pos;\n\t\t\tm->count -= m->from;\n\t\t\tm->index = index;\n\t\t\tbreak;\n\t\t}\n\t\tpos += m->count;\n\t\tm->count = 0;\n\t\tif (pos == offset) {\n\t\t\tindex++;\n\t\t\tm->index = index;\n\t\t\tbreak;\n\t\t}\n\t\tp = m->op->next(m, p, &index);\n\t}\n\tm->op->stop(m, p);\n\tm->index = index;\n\treturn error;\n\nEoverflow:\n\tm->op->stop(m, p);\n\tkvfree(m->buf);\n\tm->count = 0;\n\tm->buf = seq_buf_alloc(m->size <<= 1);\n\treturn !m->buf ? -ENOMEM : -EAGAIN;\n}"
  },
  {
    "function_name": "seq_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "52-87",
    "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&p->lock"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "0",
            "sizeof(*p)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*p)",
            "GFP_KERNEL"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_buf_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "24-36",
    "snippet": "static void *seq_buf_alloc(unsigned long size)\n{\n\tvoid *buf;\n\n\t/*\n\t * __GFP_NORETRY to avoid oom-killings with high-order allocations -\n\t * it's better to fall back to vmalloc() than to kill things.\n\t */\n\tbuf = kmalloc(size, GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tif (!buf && size > PAGE_SIZE)\n\t\tbuf = vmalloc(size);\n\treturn buf;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "size"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void *seq_buf_alloc(unsigned long size)\n{\n\tvoid *buf;\n\n\t/*\n\t * __GFP_NORETRY to avoid oom-killings with high-order allocations -\n\t * it's better to fall back to vmalloc() than to kill things.\n\t */\n\tbuf = kmalloc(size, GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tif (!buf && size > PAGE_SIZE)\n\t\tbuf = vmalloc(size);\n\treturn buf;\n}"
  },
  {
    "function_name": "seq_set_overflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
    "lines": "19-22",
    "snippet": "static void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mm.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/export.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic void seq_set_overflow(struct seq_file *m)\n{\n\tm->count = m->size;\n}"
  }
]