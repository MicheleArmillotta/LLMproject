[
  {
    "function_name": "enable_debug_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
    "lines": "376-381",
    "snippet": "void __init enable_debug_cgroup(void)\n{\n\tdebug_cgrp_subsys.dfl_cftypes = debug_files;\n\tdebug_cgrp_subsys.implicit_on_dfl = true;\n\tdebug_cgrp_subsys.threaded = true;\n}",
    "includes": [
      "#include \"cgroup-internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cftype debug_files[] =  {\n\t{\n\t\t.name = \"taskcount\",\n\t\t.read_u64 = debug_taskcount_read,\n\t},\n\n\t{\n\t\t.name = \"current_css_set\",\n\t\t.seq_show = current_css_set_read,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\n\t{\n\t\t.name = \"current_css_set_refcount\",\n\t\t.read_u64 = current_css_set_refcount_read,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\n\t{\n\t\t.name = \"current_css_set_cg_links\",\n\t\t.seq_show = current_css_set_cg_links_read,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\n\t{\n\t\t.name = \"css_links\",\n\t\t.seq_show = cgroup_css_links_read,\n\t},\n\n\t{\n\t\t.name = \"csses\",\n\t\t.seq_show = cgroup_subsys_states_read,\n\t},\n\n\t{\n\t\t.name = \"masks\",\n\t\t.seq_show = cgroup_masks_read,\n\t},\n\n\t{ }\t/* terminate */\n};",
      "struct cgroup_subsys debug_cgrp_subsys = {\n\t.css_alloc\t= debug_css_alloc,\n\t.css_free\t= debug_css_free,\n\t.legacy_cftypes\t= debug_legacy_files,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nstatic struct cftype debug_files[] =  {\n\t{\n\t\t.name = \"taskcount\",\n\t\t.read_u64 = debug_taskcount_read,\n\t},\n\n\t{\n\t\t.name = \"current_css_set\",\n\t\t.seq_show = current_css_set_read,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\n\t{\n\t\t.name = \"current_css_set_refcount\",\n\t\t.read_u64 = current_css_set_refcount_read,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\n\t{\n\t\t.name = \"current_css_set_cg_links\",\n\t\t.seq_show = current_css_set_cg_links_read,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\n\t{\n\t\t.name = \"css_links\",\n\t\t.seq_show = cgroup_css_links_read,\n\t},\n\n\t{\n\t\t.name = \"csses\",\n\t\t.seq_show = cgroup_subsys_states_read,\n\t},\n\n\t{\n\t\t.name = \"masks\",\n\t\t.seq_show = cgroup_masks_read,\n\t},\n\n\t{ }\t/* terminate */\n};\nstruct cgroup_subsys debug_cgrp_subsys = {\n\t.css_alloc\t= debug_css_alloc,\n\t.css_free\t= debug_css_free,\n\t.legacy_cftypes\t= debug_legacy_files,\n};\n\nvoid __init enable_debug_cgroup(void)\n{\n\tdebug_cgrp_subsys.dfl_cftypes = debug_files;\n\tdebug_cgrp_subsys.implicit_on_dfl = true;\n\tdebug_cgrp_subsys.threaded = true;\n}"
  },
  {
    "function_name": "releasable_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
    "lines": "271-275",
    "snippet": "static u64 releasable_read(struct cgroup_subsys_state *css, struct cftype *cft)\n{\n\treturn (!cgroup_is_populated(css->cgroup) &&\n\t\t!css_has_online_children(&css->cgroup->self));\n}",
    "includes": [
      "#include \"cgroup-internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_has_online_children",
          "args": [
            "&css->cgroup->self"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "css->cgroup"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nstatic u64 releasable_read(struct cgroup_subsys_state *css, struct cftype *cft)\n{\n\treturn (!cgroup_is_populated(css->cgroup) &&\n\t\t!css_has_online_children(&css->cgroup->self));\n}"
  },
  {
    "function_name": "cgroup_masks_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
    "lines": "255-269",
    "snippet": "static int cgroup_masks_read(struct seq_file *seq, void *v)\n{\n\tstruct kernfs_open_file *of = seq->private;\n\tstruct cgroup *cgrp;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tcgroup_masks_read_one(seq, \"subtree_control\", cgrp->subtree_control);\n\tcgroup_masks_read_one(seq, \"subtree_ss_mask\", cgrp->subtree_ss_mask);\n\n\tcgroup_kn_unlock(of->kn);\n\treturn 0;\n}",
    "includes": [
      "#include \"cgroup-internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_kn_unlock",
          "args": [
            "of->kn"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1583-1596",
          "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_masks_read_one",
          "args": [
            "seq",
            "\"subtree_ss_mask\"",
            "cgrp->subtree_ss_mask"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_masks_read_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
          "lines": "236-253",
          "snippet": "static void cgroup_masks_read_one(struct seq_file *seq, const char *name,\n\t\t\t\t  u16 mask)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\tbool first = true;\n\n\tseq_printf(seq, \"%-17s: \", name);\n\tfor_each_subsys(ss, ssid) {\n\t\tif (!(mask & (1 << ssid)))\n\t\t\tcontinue;\n\t\tif (!first)\n\t\t\tseq_puts(seq, \", \");\n\t\tseq_puts(seq, ss->name);\n\t\tfirst = false;\n\t}\n\tseq_putc(seq, '\\n');\n}",
          "includes": [
            "#include \"cgroup-internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nstatic void cgroup_masks_read_one(struct seq_file *seq, const char *name,\n\t\t\t\t  u16 mask)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\tbool first = true;\n\n\tseq_printf(seq, \"%-17s: \", name);\n\tfor_each_subsys(ss, ssid) {\n\t\tif (!(mask & (1 << ssid)))\n\t\t\tcontinue;\n\t\tif (!first)\n\t\t\tseq_puts(seq, \", \");\n\t\tseq_puts(seq, ss->name);\n\t\tfirst = false;\n\t}\n\tseq_putc(seq, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_kn_lock_live",
          "args": [
            "of->kn",
            "false"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_lock_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1615-1644",
          "snippet": "struct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nstatic int cgroup_masks_read(struct seq_file *seq, void *v)\n{\n\tstruct kernfs_open_file *of = seq->private;\n\tstruct cgroup *cgrp;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tcgroup_masks_read_one(seq, \"subtree_control\", cgrp->subtree_control);\n\tcgroup_masks_read_one(seq, \"subtree_ss_mask\", cgrp->subtree_ss_mask);\n\n\tcgroup_kn_unlock(of->kn);\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_masks_read_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
    "lines": "236-253",
    "snippet": "static void cgroup_masks_read_one(struct seq_file *seq, const char *name,\n\t\t\t\t  u16 mask)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\tbool first = true;\n\n\tseq_printf(seq, \"%-17s: \", name);\n\tfor_each_subsys(ss, ssid) {\n\t\tif (!(mask & (1 << ssid)))\n\t\t\tcontinue;\n\t\tif (!first)\n\t\t\tseq_puts(seq, \", \");\n\t\tseq_puts(seq, ss->name);\n\t\tfirst = false;\n\t}\n\tseq_putc(seq, '\\n');\n}",
    "includes": [
      "#include \"cgroup-internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "seq",
            "'\\n'"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "ss->name"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\", \""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%-17s: \"",
            "name"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nstatic void cgroup_masks_read_one(struct seq_file *seq, const char *name,\n\t\t\t\t  u16 mask)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\tbool first = true;\n\n\tseq_printf(seq, \"%-17s: \", name);\n\tfor_each_subsys(ss, ssid) {\n\t\tif (!(mask & (1 << ssid)))\n\t\t\tcontinue;\n\t\tif (!first)\n\t\t\tseq_puts(seq, \", \");\n\t\tseq_puts(seq, ss->name);\n\t\tfirst = false;\n\t}\n\tseq_putc(seq, '\\n');\n}"
  },
  {
    "function_name": "cgroup_subsys_states_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
    "lines": "203-234",
    "snippet": "static int cgroup_subsys_states_read(struct seq_file *seq, void *v)\n{\n\tstruct kernfs_open_file *of = seq->private;\n\tstruct cgroup *cgrp;\n\tstruct cgroup_subsys *ss;\n\tstruct cgroup_subsys_state *css;\n\tchar pbuf[16];\n\tint i;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tfor_each_subsys(ss, i) {\n\t\tcss = rcu_dereference_check(cgrp->subsys[ss->id], true);\n\t\tif (!css)\n\t\t\tcontinue;\n\n\t\tpbuf[0] = '\\0';\n\n\t\t/* Show the parent CSS if applicable*/\n\t\tif (css->parent)\n\t\t\tsnprintf(pbuf, sizeof(pbuf) - 1, \" P=%d\",\n\t\t\t\t css->parent->id);\n\t\tseq_printf(seq, \"%2d: %-4s\\t- %p[%d] %d%s\\n\", ss->id, ss->name,\n\t\t\t  css, css->id,\n\t\t\t  atomic_read(&css->online_cnt), pbuf);\n\t}\n\n\tcgroup_kn_unlock(of->kn);\n\treturn 0;\n}",
    "includes": [
      "#include \"cgroup-internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_kn_unlock",
          "args": [
            "of->kn"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1583-1596",
          "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%2d: %-4s\\t- %p[%d] %d%s\\n\"",
            "ss->id",
            "ss->name",
            "css",
            "css->id",
            "atomic_read(&css->online_cnt)",
            "pbuf"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&css->online_cnt"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "pbuf",
            "sizeof(pbuf) - 1",
            "\" P=%d\"",
            "css->parent->id"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "cgrp->subsys[ss->id]",
            "true"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "i"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_kn_lock_live",
          "args": [
            "of->kn",
            "false"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_lock_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1615-1644",
          "snippet": "struct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nstatic int cgroup_subsys_states_read(struct seq_file *seq, void *v)\n{\n\tstruct kernfs_open_file *of = seq->private;\n\tstruct cgroup *cgrp;\n\tstruct cgroup_subsys *ss;\n\tstruct cgroup_subsys_state *css;\n\tchar pbuf[16];\n\tint i;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tfor_each_subsys(ss, i) {\n\t\tcss = rcu_dereference_check(cgrp->subsys[ss->id], true);\n\t\tif (!css)\n\t\t\tcontinue;\n\n\t\tpbuf[0] = '\\0';\n\n\t\t/* Show the parent CSS if applicable*/\n\t\tif (css->parent)\n\t\t\tsnprintf(pbuf, sizeof(pbuf) - 1, \" P=%d\",\n\t\t\t\t css->parent->id);\n\t\tseq_printf(seq, \"%2d: %-4s\\t- %p[%d] %d%s\\n\", ss->id, ss->name,\n\t\t\t  css, css->id,\n\t\t\t  atomic_read(&css->online_cnt), pbuf);\n\t}\n\n\tcgroup_kn_unlock(of->kn);\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_css_links_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
    "lines": "114-201",
    "snippet": "static int cgroup_css_links_read(struct seq_file *seq, void *v)\n{\n\tstruct cgroup_subsys_state *css = seq_css(seq);\n\tstruct cgrp_cset_link *link;\n\tint dead_cnt = 0, extra_refs = 0, threaded_csets = 0;\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_for_each_entry(link, &css->cgroup->cset_links, cset_link) {\n\t\tstruct css_set *cset = link->cset;\n\t\tstruct task_struct *task;\n\t\tint count = 0;\n\t\tint refcnt = refcount_read(&cset->refcount);\n\n\t\t/*\n\t\t * Print out the proc_cset and threaded_cset relationship\n\t\t * and highlight difference between refcount and task_count.\n\t\t */\n\t\tseq_printf(seq, \"css_set %pK\", cset);\n\t\tif (rcu_dereference_protected(cset->dom_cset, 1) != cset) {\n\t\t\tthreaded_csets++;\n\t\t\tseq_printf(seq, \"=>%pK\", cset->dom_cset);\n\t\t}\n\t\tif (!list_empty(&cset->threaded_csets)) {\n\t\t\tstruct css_set *tcset;\n\t\t\tint idx = 0;\n\n\t\t\tlist_for_each_entry(tcset, &cset->threaded_csets,\n\t\t\t\t\t    threaded_csets_node) {\n\t\t\t\tseq_puts(seq, idx ? \",\" : \"<=\");\n\t\t\t\tseq_printf(seq, \"%pK\", tcset);\n\t\t\t\tidx++;\n\t\t\t}\n\t\t} else {\n\t\t\tseq_printf(seq, \" %d\", refcnt);\n\t\t\tif (refcnt - cset->nr_tasks > 0) {\n\t\t\t\tint extra = refcnt - cset->nr_tasks;\n\n\t\t\t\tseq_printf(seq, \" +%d\", extra);\n\t\t\t\t/*\n\t\t\t\t * Take out the one additional reference in\n\t\t\t\t * init_css_set.\n\t\t\t\t */\n\t\t\t\tif (cset == &init_css_set)\n\t\t\t\t\textra--;\n\t\t\t\textra_refs += extra;\n\t\t\t}\n\t\t}\n\t\tseq_puts(seq, \"\\n\");\n\n\t\tlist_for_each_entry(task, &cset->tasks, cg_list) {\n\t\t\tif (count++ <= MAX_TASKS_SHOWN_PER_CSS)\n\t\t\t\tseq_printf(seq, \"  task %d\\n\",\n\t\t\t\t\t   task_pid_vnr(task));\n\t\t}\n\n\t\tlist_for_each_entry(task, &cset->mg_tasks, cg_list) {\n\t\t\tif (count++ <= MAX_TASKS_SHOWN_PER_CSS)\n\t\t\t\tseq_printf(seq, \"  task %d\\n\",\n\t\t\t\t\t   task_pid_vnr(task));\n\t\t}\n\t\t/* show # of overflowed tasks */\n\t\tif (count > MAX_TASKS_SHOWN_PER_CSS)\n\t\t\tseq_printf(seq, \"  ... (%d)\\n\",\n\t\t\t\t   count - MAX_TASKS_SHOWN_PER_CSS);\n\n\t\tif (cset->dead) {\n\t\t\tseq_puts(seq, \"    [dead]\\n\");\n\t\t\tdead_cnt++;\n\t\t}\n\n\t\tWARN_ON(count != cset->nr_tasks);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!dead_cnt && !extra_refs && !threaded_csets)\n\t\treturn 0;\n\n\tseq_puts(seq, \"\\n\");\n\tif (threaded_csets)\n\t\tseq_printf(seq, \"threaded css_sets = %d\\n\", threaded_csets);\n\tif (extra_refs)\n\t\tseq_printf(seq, \"extra references = %d\\n\", extra_refs);\n\tif (dead_cnt)\n\t\tseq_printf(seq, \"dead css_sets = %d\\n\", dead_cnt);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cgroup-internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define MAX_TASKS_SHOWN_PER_CSS 25"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"dead css_sets = %d\\n\"",
            "dead_cnt"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"extra references = %d\\n\"",
            "extra_refs"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"threaded css_sets = %d\\n\"",
            "threaded_csets"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"\\n\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "count != cset->nr_tasks"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"    [dead]\\n\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"  ... (%d)\\n\"",
            "count - MAX_TASKS_SHOWN_PER_CSS"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"  task %d\\n\"",
            "task_pid_vnr(task)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "task"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "task",
            "&cset->mg_tasks",
            "cg_list"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"  task %d\\n\"",
            "task_pid_vnr(task)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "task"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "task",
            "&cset->tasks",
            "cg_list"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"\\n\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\" +%d\"",
            "extra"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\" %d\"",
            "refcnt"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%pK\"",
            "tcset"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "idx ? \",\" : \"<=\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tcset",
            "&cset->threaded_csets",
            "threaded_csets_node"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cset->threaded_csets"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"=>%pK\"",
            "cset->dom_cset"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "cset->dom_cset",
            "1"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"css_set %pK\"",
            "cset"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&cset->refcount"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&css->cgroup->cset_links",
            "cset_link"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\n#define MAX_TASKS_SHOWN_PER_CSS 25\n\nstatic int cgroup_css_links_read(struct seq_file *seq, void *v)\n{\n\tstruct cgroup_subsys_state *css = seq_css(seq);\n\tstruct cgrp_cset_link *link;\n\tint dead_cnt = 0, extra_refs = 0, threaded_csets = 0;\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_for_each_entry(link, &css->cgroup->cset_links, cset_link) {\n\t\tstruct css_set *cset = link->cset;\n\t\tstruct task_struct *task;\n\t\tint count = 0;\n\t\tint refcnt = refcount_read(&cset->refcount);\n\n\t\t/*\n\t\t * Print out the proc_cset and threaded_cset relationship\n\t\t * and highlight difference between refcount and task_count.\n\t\t */\n\t\tseq_printf(seq, \"css_set %pK\", cset);\n\t\tif (rcu_dereference_protected(cset->dom_cset, 1) != cset) {\n\t\t\tthreaded_csets++;\n\t\t\tseq_printf(seq, \"=>%pK\", cset->dom_cset);\n\t\t}\n\t\tif (!list_empty(&cset->threaded_csets)) {\n\t\t\tstruct css_set *tcset;\n\t\t\tint idx = 0;\n\n\t\t\tlist_for_each_entry(tcset, &cset->threaded_csets,\n\t\t\t\t\t    threaded_csets_node) {\n\t\t\t\tseq_puts(seq, idx ? \",\" : \"<=\");\n\t\t\t\tseq_printf(seq, \"%pK\", tcset);\n\t\t\t\tidx++;\n\t\t\t}\n\t\t} else {\n\t\t\tseq_printf(seq, \" %d\", refcnt);\n\t\t\tif (refcnt - cset->nr_tasks > 0) {\n\t\t\t\tint extra = refcnt - cset->nr_tasks;\n\n\t\t\t\tseq_printf(seq, \" +%d\", extra);\n\t\t\t\t/*\n\t\t\t\t * Take out the one additional reference in\n\t\t\t\t * init_css_set.\n\t\t\t\t */\n\t\t\t\tif (cset == &init_css_set)\n\t\t\t\t\textra--;\n\t\t\t\textra_refs += extra;\n\t\t\t}\n\t\t}\n\t\tseq_puts(seq, \"\\n\");\n\n\t\tlist_for_each_entry(task, &cset->tasks, cg_list) {\n\t\t\tif (count++ <= MAX_TASKS_SHOWN_PER_CSS)\n\t\t\t\tseq_printf(seq, \"  task %d\\n\",\n\t\t\t\t\t   task_pid_vnr(task));\n\t\t}\n\n\t\tlist_for_each_entry(task, &cset->mg_tasks, cg_list) {\n\t\t\tif (count++ <= MAX_TASKS_SHOWN_PER_CSS)\n\t\t\t\tseq_printf(seq, \"  task %d\\n\",\n\t\t\t\t\t   task_pid_vnr(task));\n\t\t}\n\t\t/* show # of overflowed tasks */\n\t\tif (count > MAX_TASKS_SHOWN_PER_CSS)\n\t\t\tseq_printf(seq, \"  ... (%d)\\n\",\n\t\t\t\t   count - MAX_TASKS_SHOWN_PER_CSS);\n\n\t\tif (cset->dead) {\n\t\t\tseq_puts(seq, \"    [dead]\\n\");\n\t\t\tdead_cnt++;\n\t\t}\n\n\t\tWARN_ON(count != cset->nr_tasks);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!dead_cnt && !extra_refs && !threaded_csets)\n\t\treturn 0;\n\n\tseq_puts(seq, \"\\n\");\n\tif (threaded_csets)\n\t\tseq_printf(seq, \"threaded css_sets = %d\\n\", threaded_csets);\n\tif (extra_refs)\n\t\tseq_printf(seq, \"extra references = %d\\n\", extra_refs);\n\tif (dead_cnt)\n\t\tseq_printf(seq, \"dead css_sets = %d\\n\", dead_cnt);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "current_css_set_cg_links_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
    "lines": "87-111",
    "snippet": "static int current_css_set_cg_links_read(struct seq_file *seq, void *v)\n{\n\tstruct cgrp_cset_link *link;\n\tstruct css_set *cset;\n\tchar *name_buf;\n\n\tname_buf = kmalloc(NAME_MAX + 1, GFP_KERNEL);\n\tif (!name_buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\tcset = task_css_set(current);\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tcgroup_name(c, name_buf, NAME_MAX + 1);\n\t\tseq_printf(seq, \"Root %d group %s\\n\",\n\t\t\t   c->root->hierarchy_id, name_buf);\n\t}\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\tkfree(name_buf);\n\treturn 0;\n}",
    "includes": [
      "#include \"cgroup-internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name_buf"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"Root %d group %s\\n\"",
            "c->root->hierarchy_id",
            "name_buf"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_name",
          "args": [
            "c",
            "name_buf",
            "NAME_MAX + 1"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&cset->cgrp_links",
            "cgrp_link"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "current"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NAME_MAX + 1",
            "GFP_KERNEL"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nstatic int current_css_set_cg_links_read(struct seq_file *seq, void *v)\n{\n\tstruct cgrp_cset_link *link;\n\tstruct css_set *cset;\n\tchar *name_buf;\n\n\tname_buf = kmalloc(NAME_MAX + 1, GFP_KERNEL);\n\tif (!name_buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\tcset = task_css_set(current);\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tcgroup_name(c, name_buf, NAME_MAX + 1);\n\t\tseq_printf(seq, \"Root %d group %s\\n\",\n\t\t\t   c->root->hierarchy_id, name_buf);\n\t}\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\tkfree(name_buf);\n\treturn 0;\n}"
  },
  {
    "function_name": "current_css_set_refcount_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
    "lines": "76-85",
    "snippet": "static u64 current_css_set_refcount_read(struct cgroup_subsys_state *css,\n\t\t\t\t\t struct cftype *cft)\n{\n\tu64 count;\n\n\trcu_read_lock();\n\tcount = refcount_read(&task_css_set(current)->refcount);\n\trcu_read_unlock();\n\treturn count;\n}",
    "includes": [
      "#include \"cgroup-internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&task_css_set(current)->refcount"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "current"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nstatic u64 current_css_set_refcount_read(struct cgroup_subsys_state *css,\n\t\t\t\t\t struct cftype *cft)\n{\n\tu64 count;\n\n\trcu_read_lock();\n\tcount = refcount_read(&task_css_set(current)->refcount);\n\trcu_read_unlock();\n\treturn count;\n}"
  },
  {
    "function_name": "current_css_set_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
    "lines": "40-74",
    "snippet": "static int current_css_set_read(struct seq_file *seq, void *v)\n{\n\tstruct kernfs_open_file *of = seq->private;\n\tstruct css_set *cset;\n\tstruct cgroup_subsys *ss;\n\tstruct cgroup_subsys_state *css;\n\tint i, refcnt;\n\n\tif (!cgroup_kn_lock_live(of->kn, false))\n\t\treturn -ENODEV;\n\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\tcset = task_css_set(current);\n\trefcnt = refcount_read(&cset->refcount);\n\tseq_printf(seq, \"css_set %pK %d\", cset, refcnt);\n\tif (refcnt > cset->nr_tasks)\n\t\tseq_printf(seq, \" +%d\", refcnt - cset->nr_tasks);\n\tseq_puts(seq, \"\\n\");\n\n\t/*\n\t * Print the css'es stored in the current css_set.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tcss = cset->subsys[ss->id];\n\t\tif (!css)\n\t\t\tcontinue;\n\t\tseq_printf(seq, \"%2d: %-4s\\t- %p[%d]\\n\", ss->id, ss->name,\n\t\t\t  css, css->id);\n\t}\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn 0;\n}",
    "includes": [
      "#include \"cgroup-internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_kn_unlock",
          "args": [
            "of->kn"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1583-1596",
          "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%2d: %-4s\\t- %p[%d]\\n\"",
            "ss->id",
            "ss->name",
            "css",
            "css->id"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "i"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"\\n\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\" +%d\"",
            "refcnt - cset->nr_tasks"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"css_set %pK %d\"",
            "cset",
            "refcnt"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&cset->refcount"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "current"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_kn_lock_live",
          "args": [
            "of->kn",
            "false"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_lock_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1615-1644",
          "snippet": "struct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nstatic int current_css_set_read(struct seq_file *seq, void *v)\n{\n\tstruct kernfs_open_file *of = seq->private;\n\tstruct css_set *cset;\n\tstruct cgroup_subsys *ss;\n\tstruct cgroup_subsys_state *css;\n\tint i, refcnt;\n\n\tif (!cgroup_kn_lock_live(of->kn, false))\n\t\treturn -ENODEV;\n\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\tcset = task_css_set(current);\n\trefcnt = refcount_read(&cset->refcount);\n\tseq_printf(seq, \"css_set %pK %d\", cset, refcnt);\n\tif (refcnt > cset->nr_tasks)\n\t\tseq_printf(seq, \" +%d\", refcnt - cset->nr_tasks);\n\tseq_puts(seq, \"\\n\");\n\n\t/*\n\t * Print the css'es stored in the current css_set.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tcss = cset->subsys[ss->id];\n\t\tif (!css)\n\t\t\tcontinue;\n\t\tseq_printf(seq, \"%2d: %-4s\\t- %p[%d]\\n\", ss->id, ss->name,\n\t\t\t  css, css->id);\n\t}\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn 0;\n}"
  },
  {
    "function_name": "debug_taskcount_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
    "lines": "34-38",
    "snippet": "static u64 debug_taskcount_read(struct cgroup_subsys_state *css,\n\t\t\t\tstruct cftype *cft)\n{\n\treturn cgroup_task_count(css->cgroup);\n}",
    "includes": [
      "#include \"cgroup-internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_task_count",
          "args": [
            "css->cgroup"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_task_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "641-650",
          "snippet": "int cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count;\n\n\tspin_lock_irq(&css_set_lock);\n\tcount = __cgroup_task_count(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count;\n\n\tspin_lock_irq(&css_set_lock);\n\tcount = __cgroup_task_count(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nstatic u64 debug_taskcount_read(struct cgroup_subsys_state *css,\n\t\t\t\tstruct cftype *cft)\n{\n\treturn cgroup_task_count(css->cgroup);\n}"
  },
  {
    "function_name": "debug_css_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
    "lines": "25-28",
    "snippet": "static void debug_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css);\n}",
    "includes": [
      "#include \"cgroup-internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "css"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nstatic void debug_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css);\n}"
  },
  {
    "function_name": "debug_css_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/debug.c",
    "lines": "14-23",
    "snippet": "static struct cgroup_subsys_state *\ndebug_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct cgroup_subsys_state *css = kzalloc(sizeof(*css), GFP_KERNEL);\n\n\tif (!css)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn css;\n}",
    "includes": [
      "#include \"cgroup-internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*css)",
            "GFP_KERNEL"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cgroup-internal.h\"\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nstatic struct cgroup_subsys_state *\ndebug_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct cgroup_subsys_state *css = kzalloc(sizeof(*css), GFP_KERNEL);\n\n\tif (!css)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn css;\n}"
  }
]