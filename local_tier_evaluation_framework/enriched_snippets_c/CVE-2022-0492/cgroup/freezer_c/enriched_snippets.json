[
  {
    "function_name": "cgroup_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
    "lines": "260-323",
    "snippet": "void cgroup_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *dsct;\n\tbool applied = false;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Nothing changed? Just exit.\n\t */\n\tif (cgrp->freezer.freeze == freeze)\n\t\treturn;\n\n\tcgrp->freezer.freeze = freeze;\n\n\t/*\n\t * Propagate changes downwards the cgroup tree.\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tdsct = css->cgroup;\n\n\t\tif (cgroup_is_dead(dsct))\n\t\t\tcontinue;\n\n\t\tif (freeze) {\n\t\t\tdsct->freezer.e_freeze++;\n\t\t\t/*\n\t\t\t * Already frozen because of ancestor's settings?\n\t\t\t */\n\t\t\tif (dsct->freezer.e_freeze > 1)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tdsct->freezer.e_freeze--;\n\t\t\t/*\n\t\t\t * Still frozen because of ancestor's settings?\n\t\t\t */\n\t\t\tif (dsct->freezer.e_freeze > 0)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(dsct->freezer.e_freeze < 0);\n\t\t}\n\n\t\t/*\n\t\t * Do change actual state: freeze or unfreeze.\n\t\t */\n\t\tcgroup_do_freeze(dsct, freeze);\n\t\tapplied = true;\n\t}\n\n\t/*\n\t * Even if the actual state hasn't changed, let's notify a user.\n\t * The state can be enforced by an ancestor cgroup: the cgroup\n\t * can already be in the desired state or it can be locked in the\n\t * opposite state, so that the transition will never happen.\n\t * In both cases it's better to notify a user, that there is\n\t * nothing to wait for.\n\t */\n\tif (!applied) {\n\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp,\n\t\t\t\t  test_bit(CGRP_FROZEN, &cgrp->flags));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\t}\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&cgrp->events_file"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "notify_frozen",
            "cgrp",
            "test_bit(CGRP_FROZEN, &cgrp->flags)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_do_freeze",
          "args": [
            "dsct",
            "freeze"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_do_freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "177-216",
          "snippet": "static void cgroup_do_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tif (freeze)\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\telse\n\t\tclear_bit(CGRP_FREEZE, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (freeze)\n\t\tTRACE_CGROUP_PATH(freeze, cgrp);\n\telse\n\t\tTRACE_CGROUP_PATH(unfreeze, cgrp);\n\n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t/*\n\t\t * Ignore kernel threads here. Freezing cgroups containing\n\t\t * kthreads isn't supported.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tcgroup_freeze_task(task, freeze);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * Cgroup state should be revisited here to cover empty leaf cgroups\n\t * and cgroups which descendants are already in the desired state.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tif (cgrp->nr_descendants == cgrp->freezer.nr_frozen_descendants)\n\t\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_do_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tif (freeze)\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\telse\n\t\tclear_bit(CGRP_FREEZE, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (freeze)\n\t\tTRACE_CGROUP_PATH(freeze, cgrp);\n\telse\n\t\tTRACE_CGROUP_PATH(unfreeze, cgrp);\n\n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t/*\n\t\t * Ignore kernel threads here. Freezing cgroups containing\n\t\t * kthreads isn't supported.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tcgroup_freeze_task(task, freeze);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * Cgroup state should be revisited here to cover empty leaf cgroups\n\t * and cgroups which descendants are already in the desired state.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tif (cgrp->nr_descendants == cgrp->freezer.nr_frozen_descendants)\n\t\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dsct->freezer.e_freeze < 0"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_dead",
          "args": [
            "dsct"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "187-190",
          "snippet": "static inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "css",
            "&cgrp->self"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *dsct;\n\tbool applied = false;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Nothing changed? Just exit.\n\t */\n\tif (cgrp->freezer.freeze == freeze)\n\t\treturn;\n\n\tcgrp->freezer.freeze = freeze;\n\n\t/*\n\t * Propagate changes downwards the cgroup tree.\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tdsct = css->cgroup;\n\n\t\tif (cgroup_is_dead(dsct))\n\t\t\tcontinue;\n\n\t\tif (freeze) {\n\t\t\tdsct->freezer.e_freeze++;\n\t\t\t/*\n\t\t\t * Already frozen because of ancestor's settings?\n\t\t\t */\n\t\t\tif (dsct->freezer.e_freeze > 1)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tdsct->freezer.e_freeze--;\n\t\t\t/*\n\t\t\t * Still frozen because of ancestor's settings?\n\t\t\t */\n\t\t\tif (dsct->freezer.e_freeze > 0)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(dsct->freezer.e_freeze < 0);\n\t\t}\n\n\t\t/*\n\t\t * Do change actual state: freeze or unfreeze.\n\t\t */\n\t\tcgroup_do_freeze(dsct, freeze);\n\t\tapplied = true;\n\t}\n\n\t/*\n\t * Even if the actual state hasn't changed, let's notify a user.\n\t * The state can be enforced by an ancestor cgroup: the cgroup\n\t * can already be in the desired state or it can be locked in the\n\t * opposite state, so that the transition will never happen.\n\t * In both cases it's better to notify a user, that there is\n\t * nothing to wait for.\n\t */\n\tif (!applied) {\n\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp,\n\t\t\t\t  test_bit(CGRP_FROZEN, &cgrp->flags));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\t}\n}"
  },
  {
    "function_name": "cgroup_freezer_migrate_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
    "lines": "222-258",
    "snippet": "void cgroup_freezer_migrate_task(struct task_struct *task,\n\t\t\t\t struct cgroup *src, struct cgroup *dst)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * Kernel threads are not supposed to be frozen at all.\n\t */\n\tif (task->flags & PF_KTHREAD)\n\t\treturn;\n\n\t/*\n\t * It's not necessary to do changes if both of the src and dst cgroups\n\t * are not freezing and task is not frozen.\n\t */\n\tif (!test_bit(CGRP_FREEZE, &src->flags) &&\n\t    !test_bit(CGRP_FREEZE, &dst->flags) &&\n\t    !task->frozen)\n\t\treturn;\n\n\t/*\n\t * Adjust counters of freezing and frozen tasks.\n\t * Note, that if the task is frozen, but the destination cgroup is not\n\t * frozen, we bump both counters to keep them balanced.\n\t */\n\tif (task->frozen) {\n\t\tcgroup_inc_frozen_cnt(dst);\n\t\tcgroup_dec_frozen_cnt(src);\n\t}\n\tcgroup_update_frozen(dst);\n\tcgroup_update_frozen(src);\n\n\t/*\n\t * Force the task to the desired state.\n\t */\n\tcgroup_freeze_task(task, test_bit(CGRP_FREEZE, &dst->flags));\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_freeze_task",
          "args": [
            "task",
            "test_bit(CGRP_FREEZE, &dst->flags)"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_freeze_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "155-172",
          "snippet": "static void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t/* If the task is about to die, don't bother with freezing it. */\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t/* If the task is about to die, don't bother with freezing it. */\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FREEZE",
            "&dst->flags"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_update_frozen",
          "args": [
            "src"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_frozen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "52-84",
          "snippet": "void cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_dec_frozen_cnt",
          "args": [
            "src"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_dec_frozen_cnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "97-101",
          "snippet": "static void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_inc_frozen_cnt",
          "args": [
            "dst"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_inc_frozen_cnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "89-92",
          "snippet": "static void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FREEZE",
            "&dst->flags"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FREEZE",
            "&src->flags"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_freezer_migrate_task(struct task_struct *task,\n\t\t\t\t struct cgroup *src, struct cgroup *dst)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * Kernel threads are not supposed to be frozen at all.\n\t */\n\tif (task->flags & PF_KTHREAD)\n\t\treturn;\n\n\t/*\n\t * It's not necessary to do changes if both of the src and dst cgroups\n\t * are not freezing and task is not frozen.\n\t */\n\tif (!test_bit(CGRP_FREEZE, &src->flags) &&\n\t    !test_bit(CGRP_FREEZE, &dst->flags) &&\n\t    !task->frozen)\n\t\treturn;\n\n\t/*\n\t * Adjust counters of freezing and frozen tasks.\n\t * Note, that if the task is frozen, but the destination cgroup is not\n\t * frozen, we bump both counters to keep them balanced.\n\t */\n\tif (task->frozen) {\n\t\tcgroup_inc_frozen_cnt(dst);\n\t\tcgroup_dec_frozen_cnt(src);\n\t}\n\tcgroup_update_frozen(dst);\n\tcgroup_update_frozen(src);\n\n\t/*\n\t * Force the task to the desired state.\n\t */\n\tcgroup_freeze_task(task, test_bit(CGRP_FREEZE, &dst->flags));\n}"
  },
  {
    "function_name": "cgroup_do_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
    "lines": "177-216",
    "snippet": "static void cgroup_do_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tif (freeze)\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\telse\n\t\tclear_bit(CGRP_FREEZE, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (freeze)\n\t\tTRACE_CGROUP_PATH(freeze, cgrp);\n\telse\n\t\tTRACE_CGROUP_PATH(unfreeze, cgrp);\n\n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t/*\n\t\t * Ignore kernel threads here. Freezing cgroups containing\n\t\t * kthreads isn't supported.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tcgroup_freeze_task(task, freeze);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * Cgroup state should be revisited here to cover empty leaf cgroups\n\t * and cgroups which descendants are already in the desired state.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tif (cgrp->nr_descendants == cgrp->freezer.nr_frozen_descendants)\n\t\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_update_frozen",
          "args": [
            "cgrp"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_frozen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "52-84",
          "snippet": "void cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "&it"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4761-4775",
          "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_freeze_task",
          "args": [
            "task",
            "freeze"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_freeze_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "155-172",
          "snippet": "static void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t/* If the task is about to die, don't bother with freezing it. */\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t/* If the task is about to die, don't bother with freezing it. */\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "&it"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4730-4753",
          "snippet": "struct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&cgrp->self",
            "0",
            "&it"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4700-4720",
          "snippet": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "unfreeze",
            "cgrp"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "freeze",
            "cgrp"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CGRP_FREEZE",
            "&cgrp->flags"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_FREEZE",
            "&cgrp->flags"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_do_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tif (freeze)\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\telse\n\t\tclear_bit(CGRP_FREEZE, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (freeze)\n\t\tTRACE_CGROUP_PATH(freeze, cgrp);\n\telse\n\t\tTRACE_CGROUP_PATH(unfreeze, cgrp);\n\n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t/*\n\t\t * Ignore kernel threads here. Freezing cgroups containing\n\t\t * kthreads isn't supported.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tcgroup_freeze_task(task, freeze);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * Cgroup state should be revisited here to cover empty leaf cgroups\n\t * and cgroups which descendants are already in the desired state.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tif (cgrp->nr_descendants == cgrp->freezer.nr_frozen_descendants)\n\t\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}"
  },
  {
    "function_name": "cgroup_freeze_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
    "lines": "155-172",
    "snippet": "static void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t/* If the task is about to die, don't bother with freezing it. */\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "task"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "task",
            "false"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t/* If the task is about to die, don't bother with freezing it. */\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}"
  },
  {
    "function_name": "cgroup_leave_frozen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
    "lines": "131-149",
    "snippet": "void cgroup_leave_frozen(bool always_leave)\n{\n\tstruct cgroup *cgrp;\n\n\tspin_lock_irq(&css_set_lock);\n\tcgrp = task_dfl_cgroup(current);\n\tif (always_leave || !test_bit(CGRP_FREEZE, &cgrp->flags)) {\n\t\tcgroup_dec_frozen_cnt(cgrp);\n\t\tcgroup_update_frozen(cgrp);\n\t\tWARN_ON_ONCE(!current->frozen);\n\t\tcurrent->frozen = false;\n\t} else if (!(current->jobctl & JOBCTL_TRAP_FREEZE)) {\n\t\tspin_lock(&current->sighand->siglock);\n\t\tcurrent->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\tspin_unlock(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_SIGPENDING"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!current->frozen"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_update_frozen",
          "args": [
            "cgrp"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_frozen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "52-84",
          "snippet": "void cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_dec_frozen_cnt",
          "args": [
            "cgrp"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_dec_frozen_cnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "97-101",
          "snippet": "static void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FREEZE",
            "&cgrp->flags"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_dfl_cgroup",
          "args": [
            "current"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_leave_frozen(bool always_leave)\n{\n\tstruct cgroup *cgrp;\n\n\tspin_lock_irq(&css_set_lock);\n\tcgrp = task_dfl_cgroup(current);\n\tif (always_leave || !test_bit(CGRP_FREEZE, &cgrp->flags)) {\n\t\tcgroup_dec_frozen_cnt(cgrp);\n\t\tcgroup_update_frozen(cgrp);\n\t\tWARN_ON_ONCE(!current->frozen);\n\t\tcurrent->frozen = false;\n\t} else if (!(current->jobctl & JOBCTL_TRAP_FREEZE)) {\n\t\tspin_lock(&current->sighand->siglock);\n\t\tcurrent->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\tspin_unlock(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n}"
  },
  {
    "function_name": "cgroup_enter_frozen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
    "lines": "107-120",
    "snippet": "void cgroup_enter_frozen(void)\n{\n\tstruct cgroup *cgrp;\n\n\tif (current->frozen)\n\t\treturn;\n\n\tspin_lock_irq(&css_set_lock);\n\tcurrent->frozen = true;\n\tcgrp = task_dfl_cgroup(current);\n\tcgroup_inc_frozen_cnt(cgrp);\n\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_update_frozen",
          "args": [
            "cgrp"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_frozen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "52-84",
          "snippet": "void cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_inc_frozen_cnt",
          "args": [
            "cgrp"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_inc_frozen_cnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "89-92",
          "snippet": "static void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_dfl_cgroup",
          "args": [
            "current"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_enter_frozen(void)\n{\n\tstruct cgroup *cgrp;\n\n\tif (current->frozen)\n\t\treturn;\n\n\tspin_lock_irq(&css_set_lock);\n\tcurrent->frozen = true;\n\tcgrp = task_dfl_cgroup(current);\n\tcgroup_inc_frozen_cnt(cgrp);\n\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}"
  },
  {
    "function_name": "cgroup_dec_frozen_cnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
    "lines": "97-101",
    "snippet": "static void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cgrp->freezer.nr_frozen_tasks < 0"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}"
  },
  {
    "function_name": "cgroup_inc_frozen_cnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
    "lines": "89-92",
    "snippet": "static void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}"
  },
  {
    "function_name": "cgroup_update_frozen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
    "lines": "52-84",
    "snippet": "void cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_propagate_frozen",
          "args": [
            "cgrp",
            "frozen"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_propagate_frozen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "14-46",
          "snippet": "static void cgroup_propagate_frozen(struct cgroup *cgrp, bool frozen)\n{\n\tint desc = 1;\n\n\t/*\n\t * If the new state is frozen, some freezing ancestor cgroups may change\n\t * their state too, depending on if all their descendants are frozen.\n\t *\n\t * Otherwise, all ancestor cgroups are forced into the non-frozen state.\n\t */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (frozen) {\n\t\t\tcgrp->freezer.nr_frozen_descendants += desc;\n\t\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags) &&\n\t\t\t    test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\t\t    cgrp->freezer.nr_frozen_descendants ==\n\t\t\t    cgrp->nr_descendants) {\n\t\t\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 1);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t} else {\n\t\t\tcgrp->freezer.nr_frozen_descendants -= desc;\n\t\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags)) {\n\t\t\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 0);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_propagate_frozen(struct cgroup *cgrp, bool frozen)\n{\n\tint desc = 1;\n\n\t/*\n\t * If the new state is frozen, some freezing ancestor cgroups may change\n\t * their state too, depending on if all their descendants are frozen.\n\t *\n\t * Otherwise, all ancestor cgroups are forced into the non-frozen state.\n\t */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (frozen) {\n\t\t\tcgrp->freezer.nr_frozen_descendants += desc;\n\t\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags) &&\n\t\t\t    test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\t\t    cgrp->freezer.nr_frozen_descendants ==\n\t\t\t    cgrp->nr_descendants) {\n\t\t\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 1);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t} else {\n\t\t\tcgrp->freezer.nr_frozen_descendants -= desc;\n\t\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags)) {\n\t\t\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 0);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "notify_frozen",
            "cgrp",
            "frozen"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&cgrp->events_file"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cgroup_task_count",
          "args": [
            "cgrp"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_task_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "624-635",
          "snippet": "int __cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count = 0;\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tcount += link->cset->nr_tasks;\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint __cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count = 0;\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tcount += link->cset->nr_tasks;\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FREEZE",
            "&cgrp->flags"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}"
  },
  {
    "function_name": "cgroup_propagate_frozen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
    "lines": "14-46",
    "snippet": "static void cgroup_propagate_frozen(struct cgroup *cgrp, bool frozen)\n{\n\tint desc = 1;\n\n\t/*\n\t * If the new state is frozen, some freezing ancestor cgroups may change\n\t * their state too, depending on if all their descendants are frozen.\n\t *\n\t * Otherwise, all ancestor cgroups are forced into the non-frozen state.\n\t */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (frozen) {\n\t\t\tcgrp->freezer.nr_frozen_descendants += desc;\n\t\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags) &&\n\t\t\t    test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\t\t    cgrp->freezer.nr_frozen_descendants ==\n\t\t\t    cgrp->nr_descendants) {\n\t\t\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 1);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t} else {\n\t\t\tcgrp->freezer.nr_frozen_descendants -= desc;\n\t\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags)) {\n\t\t\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 0);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/cgroup.h>",
      "#include \"cgroup-internal.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "notify_frozen",
            "cgrp",
            "0"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&cgrp->events_file"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "notify_frozen",
            "cgrp",
            "1"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&cgrp->events_file"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FREEZE",
            "&cgrp->flags"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nstatic void cgroup_propagate_frozen(struct cgroup *cgrp, bool frozen)\n{\n\tint desc = 1;\n\n\t/*\n\t * If the new state is frozen, some freezing ancestor cgroups may change\n\t * their state too, depending on if all their descendants are frozen.\n\t *\n\t * Otherwise, all ancestor cgroups are forced into the non-frozen state.\n\t */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (frozen) {\n\t\t\tcgrp->freezer.nr_frozen_descendants += desc;\n\t\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags) &&\n\t\t\t    test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\t\t    cgrp->freezer.nr_frozen_descendants ==\n\t\t\t    cgrp->nr_descendants) {\n\t\t\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 1);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t} else {\n\t\t\tcgrp->freezer.nr_frozen_descendants -= desc;\n\t\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags)) {\n\t\t\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 0);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t}\n\t}\n}"
  }
]