[
  {
    "function_name": "cgroup_namespaces_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
    "lines": "153-156",
    "snippet": "static __init int cgroup_namespaces_init(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic __init int cgroup_namespaces_init(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroupns_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
    "lines": "139-142",
    "snippet": "static struct user_namespace *cgroupns_owner(struct ns_common *ns)\n{\n\treturn to_cg_ns(ns)->user_ns;\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_cg_ns",
          "args": [
            "ns"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "to_cg_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
          "lines": "93-96",
          "snippet": "static inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic struct user_namespace *cgroupns_owner(struct ns_common *ns)\n{\n\treturn to_cg_ns(ns)->user_ns;\n}"
  },
  {
    "function_name": "cgroupns_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
    "lines": "134-137",
    "snippet": "static void cgroupns_put(struct ns_common *ns)\n{\n\tput_cgroup_ns(to_cg_ns(ns));\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "to_cg_ns(ns)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_cg_ns",
          "args": [
            "ns"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "to_cg_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
          "lines": "93-96",
          "snippet": "static inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroupns_put(struct ns_common *ns)\n{\n\tput_cgroup_ns(to_cg_ns(ns));\n}"
  },
  {
    "function_name": "cgroupns_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
    "lines": "118-132",
    "snippet": "static struct ns_common *cgroupns_get(struct task_struct *task)\n{\n\tstruct cgroup_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = nsproxy->cgroup_ns;\n\t\tget_cgroup_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\treturn ns ? &ns->ns : NULL;\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cgroup_ns",
          "args": [
            "ns"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic struct ns_common *cgroupns_get(struct task_struct *task)\n{\n\tstruct cgroup_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = nsproxy->cgroup_ns;\n\t\tget_cgroup_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\treturn ns ? &ns->ns : NULL;\n}"
  },
  {
    "function_name": "cgroupns_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
    "lines": "98-116",
    "snippet": "static int cgroupns_install(struct nsset *nsset, struct ns_common *ns)\n{\n\tstruct nsproxy *nsproxy = nsset->nsproxy;\n\tstruct cgroup_namespace *cgroup_ns = to_cg_ns(ns);\n\n\tif (!ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(cgroup_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* Don't need to do anything if we are attaching to our own cgroupns. */\n\tif (cgroup_ns == nsproxy->cgroup_ns)\n\t\treturn 0;\n\n\tget_cgroup_ns(cgroup_ns);\n\tput_cgroup_ns(nsproxy->cgroup_ns);\n\tnsproxy->cgroup_ns = cgroup_ns;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "nsproxy->cgroup_ns"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cgroup_ns",
          "args": [
            "cgroup_ns"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "cgroup_ns->user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "nsset->cred->user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_cg_ns",
          "args": [
            "ns"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "to_cg_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
          "lines": "93-96",
          "snippet": "static inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroupns_install(struct nsset *nsset, struct ns_common *ns)\n{\n\tstruct nsproxy *nsproxy = nsset->nsproxy;\n\tstruct cgroup_namespace *cgroup_ns = to_cg_ns(ns);\n\n\tif (!ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(cgroup_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* Don't need to do anything if we are attaching to our own cgroupns. */\n\tif (cgroup_ns == nsproxy->cgroup_ns)\n\t\treturn 0;\n\n\tget_cgroup_ns(cgroup_ns);\n\tput_cgroup_ns(nsproxy->cgroup_ns);\n\tnsproxy->cgroup_ns = cgroup_ns;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "to_cg_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
    "lines": "93-96",
    "snippet": "static inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ns",
            "structcgroup_namespace",
            "ns"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}"
  },
  {
    "function_name": "copy_cgroup_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
    "lines": "50-91",
    "snippet": "struct cgroup_namespace *copy_cgroup_ns(unsigned long flags,\n\t\t\t\t\tstruct user_namespace *user_ns,\n\t\t\t\t\tstruct cgroup_namespace *old_ns)\n{\n\tstruct cgroup_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tstruct css_set *cset;\n\n\tBUG_ON(!old_ns);\n\n\tif (!(flags & CLONE_NEWCGROUP)) {\n\t\tget_cgroup_ns(old_ns);\n\t\treturn old_ns;\n\t}\n\n\t/* Allow only sysadmin to create cgroup namespace. */\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tucounts = inc_cgroup_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* It is not safe to take cgroup_mutex here */\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tnew_ns = alloc_cgroup_ns();\n\tif (IS_ERR(new_ns)) {\n\t\tput_css_set(cset);\n\t\tdec_cgroup_namespaces(ucounts);\n\t\treturn new_ns;\n\t}\n\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->root_cset = cset;\n\n\treturn new_ns;\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "user_ns"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_cgroup_namespaces",
          "args": [
            "ucounts"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "dec_cgroup_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
          "lines": "17-20",
          "snippet": "static void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "cset"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "199-214",
          "snippet": "static inline void put_css_set(struct css_set *cset)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Ensure that the refcount doesn't hit zero while any readers\n\t * can see it. Similar to atomic_dec_and_lock(), but for an\n\t * rwlock\n\t */\n\tif (refcount_dec_not_one(&cset->refcount))\n\t\treturn;\n\n\tspin_lock_irqsave(&css_set_lock, flags);\n\tput_css_set_locked(cset);\n\tspin_unlock_irqrestore(&css_set_lock, flags);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void put_css_set(struct css_set *cset)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Ensure that the refcount doesn't hit zero while any readers\n\t * can see it. Similar to atomic_dec_and_lock(), but for an\n\t * rwlock\n\t */\n\tif (refcount_dec_not_one(&cset->refcount))\n\t\treturn;\n\n\tspin_lock_irqsave(&css_set_lock, flags);\n\tput_css_set_locked(cset);\n\tspin_unlock_irqrestore(&css_set_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_ns"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cgroup_ns",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cgroup_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
          "lines": "22-38",
          "snippet": "static struct cgroup_namespace *alloc_cgroup_ns(void)\n{\n\tstruct cgroup_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kzalloc(sizeof(struct cgroup_namespace), GFP_KERNEL_ACCOUNT);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\trefcount_set(&new_ns->ns.count, 1);\n\tnew_ns->ns.ops = &cgroupns_operations;\n\treturn new_ns;\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct proc_ns_operations cgroupns_operations = {\n\t.name\t\t= \"cgroup\",\n\t.type\t\t= CLONE_NEWCGROUP,\n\t.get\t\t= cgroupns_get,\n\t.put\t\t= cgroupns_put,\n\t.install\t= cgroupns_install,\n\t.owner\t\t= cgroupns_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nconst struct proc_ns_operations cgroupns_operations = {\n\t.name\t\t= \"cgroup\",\n\t.type\t\t= CLONE_NEWCGROUP,\n\t.get\t\t= cgroupns_get,\n\t.put\t\t= cgroupns_put,\n\t.install\t= cgroupns_install,\n\t.owner\t\t= cgroupns_owner,\n};\n\nstatic struct cgroup_namespace *alloc_cgroup_ns(void)\n{\n\tstruct cgroup_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kzalloc(sizeof(struct cgroup_namespace), GFP_KERNEL_ACCOUNT);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\trefcount_set(&new_ns->ns.count, 1);\n\tnew_ns->ns.ops = &cgroupns_operations;\n\treturn new_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "cset"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "219-222",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "current"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_cgroup_namespaces",
          "args": [
            "user_ns"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "inc_cgroup_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
          "lines": "12-15",
          "snippet": "static struct ucounts *inc_cgroup_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_CGROUP_NAMESPACES);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic struct ucounts *inc_cgroup_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_CGROUP_NAMESPACES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cgroup_ns",
          "args": [
            "old_ns"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!old_ns"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_namespace *copy_cgroup_ns(unsigned long flags,\n\t\t\t\t\tstruct user_namespace *user_ns,\n\t\t\t\t\tstruct cgroup_namespace *old_ns)\n{\n\tstruct cgroup_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tstruct css_set *cset;\n\n\tBUG_ON(!old_ns);\n\n\tif (!(flags & CLONE_NEWCGROUP)) {\n\t\tget_cgroup_ns(old_ns);\n\t\treturn old_ns;\n\t}\n\n\t/* Allow only sysadmin to create cgroup namespace. */\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tucounts = inc_cgroup_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* It is not safe to take cgroup_mutex here */\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tnew_ns = alloc_cgroup_ns();\n\tif (IS_ERR(new_ns)) {\n\t\tput_css_set(cset);\n\t\tdec_cgroup_namespaces(ucounts);\n\t\treturn new_ns;\n\t}\n\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->root_cset = cset;\n\n\treturn new_ns;\n}"
  },
  {
    "function_name": "free_cgroup_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
    "lines": "40-47",
    "snippet": "void free_cgroup_ns(struct cgroup_namespace *ns)\n{\n\tput_css_set(ns->root_cset);\n\tdec_cgroup_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\tns_free_inum(&ns->ns);\n\tkfree(ns);\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ns"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_free_inum",
          "args": [
            "&ns->ns"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "ns->user_ns"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_cgroup_namespaces",
          "args": [
            "ns->ucounts"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "dec_cgroup_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
          "lines": "17-20",
          "snippet": "static void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "ns->root_cset"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "199-214",
          "snippet": "static inline void put_css_set(struct css_set *cset)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Ensure that the refcount doesn't hit zero while any readers\n\t * can see it. Similar to atomic_dec_and_lock(), but for an\n\t * rwlock\n\t */\n\tif (refcount_dec_not_one(&cset->refcount))\n\t\treturn;\n\n\tspin_lock_irqsave(&css_set_lock, flags);\n\tput_css_set_locked(cset);\n\tspin_unlock_irqrestore(&css_set_lock, flags);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void put_css_set(struct css_set *cset)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Ensure that the refcount doesn't hit zero while any readers\n\t * can see it. Similar to atomic_dec_and_lock(), but for an\n\t * rwlock\n\t */\n\tif (refcount_dec_not_one(&cset->refcount))\n\t\treturn;\n\n\tspin_lock_irqsave(&css_set_lock, flags);\n\tput_css_set_locked(cset);\n\tspin_unlock_irqrestore(&css_set_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nvoid free_cgroup_ns(struct cgroup_namespace *ns)\n{\n\tput_css_set(ns->root_cset);\n\tdec_cgroup_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\tns_free_inum(&ns->ns);\n\tkfree(ns);\n}"
  },
  {
    "function_name": "alloc_cgroup_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
    "lines": "22-38",
    "snippet": "static struct cgroup_namespace *alloc_cgroup_ns(void)\n{\n\tstruct cgroup_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kzalloc(sizeof(struct cgroup_namespace), GFP_KERNEL_ACCOUNT);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\trefcount_set(&new_ns->ns.count, 1);\n\tnew_ns->ns.ops = &cgroupns_operations;\n\treturn new_ns;\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct proc_ns_operations cgroupns_operations = {\n\t.name\t\t= \"cgroup\",\n\t.type\t\t= CLONE_NEWCGROUP,\n\t.get\t\t= cgroupns_get,\n\t.put\t\t= cgroupns_put,\n\t.install\t= cgroupns_install,\n\t.owner\t\t= cgroupns_owner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&new_ns->ns.count",
            "1"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_ns"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_alloc_inum",
          "args": [
            "&new_ns->ns"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cgroup_namespace)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nconst struct proc_ns_operations cgroupns_operations = {\n\t.name\t\t= \"cgroup\",\n\t.type\t\t= CLONE_NEWCGROUP,\n\t.get\t\t= cgroupns_get,\n\t.put\t\t= cgroupns_put,\n\t.install\t= cgroupns_install,\n\t.owner\t\t= cgroupns_owner,\n};\n\nstatic struct cgroup_namespace *alloc_cgroup_ns(void)\n{\n\tstruct cgroup_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kzalloc(sizeof(struct cgroup_namespace), GFP_KERNEL_ACCOUNT);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\trefcount_set(&new_ns->ns.count, 1);\n\tnew_ns->ns.ops = &cgroupns_operations;\n\treturn new_ns;\n}"
  },
  {
    "function_name": "dec_cgroup_namespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
    "lines": "17-20",
    "snippet": "static void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_ucount",
          "args": [
            "ucounts",
            "UCOUNT_CGROUP_NAMESPACES"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}"
  },
  {
    "function_name": "inc_cgroup_namespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/namespace.c",
    "lines": "12-15",
    "snippet": "static struct ucounts *inc_cgroup_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_CGROUP_NAMESPACES);\n}",
    "includes": [
      "#include <linux/proc_ns.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_ucount",
          "args": [
            "ns",
            "current_euid()",
            "UCOUNT_CGROUP_NAMESPACES"
          ],
          "line": 14
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 14
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstatic struct ucounts *inc_cgroup_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_CGROUP_NAMESPACES);\n}"
  }
]