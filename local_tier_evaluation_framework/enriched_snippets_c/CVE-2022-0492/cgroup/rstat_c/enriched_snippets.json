[
  {
    "function_name": "cgroup_base_stat_cputime_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "436-463",
    "snippet": "void cgroup_base_stat_cputime_show(struct seq_file *seq)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tu64 usage, utime, stime;\n\tstruct task_cputime cputime;\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcgroup_rstat_flush_hold(cgrp);\n\t\tusage = cgrp->bstat.cputime.sum_exec_runtime;\n\t\tcputime_adjust(&cgrp->bstat.cputime, &cgrp->prev_cputime,\n\t\t\t       &utime, &stime);\n\t\tcgroup_rstat_flush_release();\n\t} else {\n\t\troot_cgroup_cputime(&cputime);\n\t\tusage = cputime.sum_exec_runtime;\n\t\tutime = cputime.utime;\n\t\tstime = cputime.stime;\n\t}\n\n\tdo_div(usage, NSEC_PER_USEC);\n\tdo_div(utime, NSEC_PER_USEC);\n\tdo_div(stime, NSEC_PER_USEC);\n\n\tseq_printf(seq, \"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\",\n\t\t   usage, utime, stime);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\"",
            "usage",
            "utime",
            "stime"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stime",
            "NSEC_PER_USEC"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "utime",
            "NSEC_PER_USEC"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "usage",
            "NSEC_PER_USEC"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "root_cgroup_cputime",
          "args": [
            "&cputime"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "root_cgroup_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "406-434",
          "snippet": "static void root_cgroup_cputime(struct task_cputime *cputime)\n{\n\tint i;\n\n\tcputime->stime = 0;\n\tcputime->utime = 0;\n\tcputime->sum_exec_runtime = 0;\n\tfor_each_possible_cpu(i) {\n\t\tstruct kernel_cpustat kcpustat;\n\t\tu64 *cpustat = kcpustat.cpustat;\n\t\tu64 user = 0;\n\t\tu64 sys = 0;\n\n\t\tkcpustat_cpu_fetch(&kcpustat, i);\n\n\t\tuser += cpustat[CPUTIME_USER];\n\t\tuser += cpustat[CPUTIME_NICE];\n\t\tcputime->utime += user;\n\n\t\tsys += cpustat[CPUTIME_SYSTEM];\n\t\tsys += cpustat[CPUTIME_IRQ];\n\t\tsys += cpustat[CPUTIME_SOFTIRQ];\n\t\tcputime->stime += sys;\n\n\t\tcputime->sum_exec_runtime += user;\n\t\tcputime->sum_exec_runtime += sys;\n\t\tcputime->sum_exec_runtime += cpustat[CPUTIME_STEAL];\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void root_cgroup_cputime(struct task_cputime *cputime)\n{\n\tint i;\n\n\tcputime->stime = 0;\n\tcputime->utime = 0;\n\tcputime->sum_exec_runtime = 0;\n\tfor_each_possible_cpu(i) {\n\t\tstruct kernel_cpustat kcpustat;\n\t\tu64 *cpustat = kcpustat.cpustat;\n\t\tu64 user = 0;\n\t\tu64 sys = 0;\n\n\t\tkcpustat_cpu_fetch(&kcpustat, i);\n\n\t\tuser += cpustat[CPUTIME_USER];\n\t\tuser += cpustat[CPUTIME_NICE];\n\t\tcputime->utime += user;\n\n\t\tsys += cpustat[CPUTIME_SYSTEM];\n\t\tsys += cpustat[CPUTIME_IRQ];\n\t\tsys += cpustat[CPUTIME_SOFTIRQ];\n\t\tcputime->stime += sys;\n\n\t\tcputime->sum_exec_runtime += user;\n\t\tcputime->sum_exec_runtime += sys;\n\t\tcputime->sum_exec_runtime += cpustat[CPUTIME_STEAL];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_release",
          "args": [],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "239-243",
          "snippet": "void cgroup_rstat_flush_release(void)\n\t__releases(&cgroup_rstat_lock)\n{\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_release(void)\n\t__releases(&cgroup_rstat_lock)\n{\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cputime_adjust",
          "args": [
            "&cgrp->bstat.cputime",
            "&cgrp->prev_cputime",
            "&utime",
            "&stime"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_hold",
          "args": [
            "cgrp"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "228-234",
          "snippet": "void cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_base_stat_cputime_show(struct seq_file *seq)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tu64 usage, utime, stime;\n\tstruct task_cputime cputime;\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcgroup_rstat_flush_hold(cgrp);\n\t\tusage = cgrp->bstat.cputime.sum_exec_runtime;\n\t\tcputime_adjust(&cgrp->bstat.cputime, &cgrp->prev_cputime,\n\t\t\t       &utime, &stime);\n\t\tcgroup_rstat_flush_release();\n\t} else {\n\t\troot_cgroup_cputime(&cputime);\n\t\tusage = cputime.sum_exec_runtime;\n\t\tutime = cputime.utime;\n\t\tstime = cputime.stime;\n\t}\n\n\tdo_div(usage, NSEC_PER_USEC);\n\tdo_div(utime, NSEC_PER_USEC);\n\tdo_div(stime, NSEC_PER_USEC);\n\n\tseq_printf(seq, \"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\",\n\t\t   usage, utime, stime);\n}"
  },
  {
    "function_name": "root_cgroup_cputime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "406-434",
    "snippet": "static void root_cgroup_cputime(struct task_cputime *cputime)\n{\n\tint i;\n\n\tcputime->stime = 0;\n\tcputime->utime = 0;\n\tcputime->sum_exec_runtime = 0;\n\tfor_each_possible_cpu(i) {\n\t\tstruct kernel_cpustat kcpustat;\n\t\tu64 *cpustat = kcpustat.cpustat;\n\t\tu64 user = 0;\n\t\tu64 sys = 0;\n\n\t\tkcpustat_cpu_fetch(&kcpustat, i);\n\n\t\tuser += cpustat[CPUTIME_USER];\n\t\tuser += cpustat[CPUTIME_NICE];\n\t\tcputime->utime += user;\n\n\t\tsys += cpustat[CPUTIME_SYSTEM];\n\t\tsys += cpustat[CPUTIME_IRQ];\n\t\tsys += cpustat[CPUTIME_SOFTIRQ];\n\t\tcputime->stime += sys;\n\n\t\tcputime->sum_exec_runtime += user;\n\t\tcputime->sum_exec_runtime += sys;\n\t\tcputime->sum_exec_runtime += cpustat[CPUTIME_STEAL];\n\t}\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcpustat_cpu_fetch",
          "args": [
            "&kcpustat",
            "i"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void root_cgroup_cputime(struct task_cputime *cputime)\n{\n\tint i;\n\n\tcputime->stime = 0;\n\tcputime->utime = 0;\n\tcputime->sum_exec_runtime = 0;\n\tfor_each_possible_cpu(i) {\n\t\tstruct kernel_cpustat kcpustat;\n\t\tu64 *cpustat = kcpustat.cpustat;\n\t\tu64 user = 0;\n\t\tu64 sys = 0;\n\n\t\tkcpustat_cpu_fetch(&kcpustat, i);\n\n\t\tuser += cpustat[CPUTIME_USER];\n\t\tuser += cpustat[CPUTIME_NICE];\n\t\tcputime->utime += user;\n\n\t\tsys += cpustat[CPUTIME_SYSTEM];\n\t\tsys += cpustat[CPUTIME_IRQ];\n\t\tsys += cpustat[CPUTIME_SOFTIRQ];\n\t\tcputime->stime += sys;\n\n\t\tcputime->sum_exec_runtime += user;\n\t\tcputime->sum_exec_runtime += sys;\n\t\tcputime->sum_exec_runtime += cpustat[CPUTIME_STEAL];\n\t}\n}"
  },
  {
    "function_name": "__cgroup_account_cputime_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "375-398",
    "snippet": "void __cgroup_account_cputime_field(struct cgroup *cgrp,\n\t\t\t\t    enum cpu_usage_stat index, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tunsigned long flags;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp, &flags);\n\n\tswitch (index) {\n\tcase CPUTIME_USER:\n\tcase CPUTIME_NICE:\n\t\trstatc->bstat.cputime.utime += delta_exec;\n\t\tbreak;\n\tcase CPUTIME_SYSTEM:\n\tcase CPUTIME_IRQ:\n\tcase CPUTIME_SOFTIRQ:\n\t\trstatc->bstat.cputime.stime += delta_exec;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc, flags);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_account_end",
          "args": [
            "cgrp",
            "rstatc",
            "flags"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_account_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "356-363",
          "snippet": "static void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc,\n\t\t\t\t\t\t unsigned long flags)\n{\n\tu64_stats_update_end_irqrestore(&rstatc->bsync, flags);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc,\n\t\t\t\t\t\t unsigned long flags)\n{\n\tu64_stats_update_end_irqrestore(&rstatc->bsync, flags);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_account_begin",
          "args": [
            "cgrp",
            "&flags"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_account_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "346-354",
          "snippet": "static struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp, unsigned long *flags)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\t*flags = u64_stats_update_begin_irqsave(&rstatc->bsync);\n\treturn rstatc;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp, unsigned long *flags)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\t*flags = u64_stats_update_begin_irqsave(&rstatc->bsync);\n\treturn rstatc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid __cgroup_account_cputime_field(struct cgroup *cgrp,\n\t\t\t\t    enum cpu_usage_stat index, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tunsigned long flags;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp, &flags);\n\n\tswitch (index) {\n\tcase CPUTIME_USER:\n\tcase CPUTIME_NICE:\n\t\trstatc->bstat.cputime.utime += delta_exec;\n\t\tbreak;\n\tcase CPUTIME_SYSTEM:\n\tcase CPUTIME_IRQ:\n\tcase CPUTIME_SOFTIRQ:\n\t\trstatc->bstat.cputime.stime += delta_exec;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc, flags);\n}"
  },
  {
    "function_name": "__cgroup_account_cputime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "365-373",
    "snippet": "void __cgroup_account_cputime(struct cgroup *cgrp, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tunsigned long flags;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp, &flags);\n\trstatc->bstat.cputime.sum_exec_runtime += delta_exec;\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc, flags);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_account_end",
          "args": [
            "cgrp",
            "rstatc",
            "flags"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_account_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "356-363",
          "snippet": "static void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc,\n\t\t\t\t\t\t unsigned long flags)\n{\n\tu64_stats_update_end_irqrestore(&rstatc->bsync, flags);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc,\n\t\t\t\t\t\t unsigned long flags)\n{\n\tu64_stats_update_end_irqrestore(&rstatc->bsync, flags);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_account_begin",
          "args": [
            "cgrp",
            "&flags"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_account_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "346-354",
          "snippet": "static struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp, unsigned long *flags)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\t*flags = u64_stats_update_begin_irqsave(&rstatc->bsync);\n\treturn rstatc;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp, unsigned long *flags)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\t*flags = u64_stats_update_begin_irqsave(&rstatc->bsync);\n\treturn rstatc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid __cgroup_account_cputime(struct cgroup *cgrp, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tunsigned long flags;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp, &flags);\n\trstatc->bstat.cputime.sum_exec_runtime += delta_exec;\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc, flags);\n}"
  },
  {
    "function_name": "cgroup_base_stat_cputime_account_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "356-363",
    "snippet": "static void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc,\n\t\t\t\t\t\t unsigned long flags)\n{\n\tu64_stats_update_end_irqrestore(&rstatc->bsync, flags);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_ptr",
          "args": [
            "rstatc"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_updated",
          "args": [
            "cgrp",
            "smp_processor_id()"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_updated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "25-70",
          "snippet": "void cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n{\n\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu);\n\tunsigned long flags;\n\n\t/*\n\t * Speculative already-on-list test. This may race leading to\n\t * temporary inaccuracies, which is fine.\n\t *\n\t * Because @parent's updated_children is terminated with @parent\n\t * instead of NULL, we can tell whether @cgrp is on the list by\n\t * testing the next pointer for NULL.\n\t */\n\tif (data_race(cgroup_rstat_cpu(cgrp, cpu)->updated_next))\n\t\treturn;\n\n\traw_spin_lock_irqsave(cpu_lock, flags);\n\n\t/* put @cgrp and all ancestors on the corresponding updated lists */\n\twhile (true) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\t\tstruct cgroup *parent = cgroup_parent(cgrp);\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\n\t\t/*\n\t\t * Both additions and removals are bottom-up.  If a cgroup\n\t\t * is already in the tree, all ancestors are.\n\t\t */\n\t\tif (rstatc->updated_next)\n\t\t\tbreak;\n\n\t\t/* Root has no parent to link it to, but mark it busy */\n\t\tif (!parent) {\n\t\t\trstatc->updated_next = cgrp;\n\t\t\tbreak;\n\t\t}\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\trstatc->updated_next = prstatc->updated_children;\n\t\tprstatc->updated_children = cgrp;\n\n\t\tcgrp = parent;\n\t}\n\n\traw_spin_unlock_irqrestore(cpu_lock, flags);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n{\n\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu);\n\tunsigned long flags;\n\n\t/*\n\t * Speculative already-on-list test. This may race leading to\n\t * temporary inaccuracies, which is fine.\n\t *\n\t * Because @parent's updated_children is terminated with @parent\n\t * instead of NULL, we can tell whether @cgrp is on the list by\n\t * testing the next pointer for NULL.\n\t */\n\tif (data_race(cgroup_rstat_cpu(cgrp, cpu)->updated_next))\n\t\treturn;\n\n\traw_spin_lock_irqsave(cpu_lock, flags);\n\n\t/* put @cgrp and all ancestors on the corresponding updated lists */\n\twhile (true) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\t\tstruct cgroup *parent = cgroup_parent(cgrp);\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\n\t\t/*\n\t\t * Both additions and removals are bottom-up.  If a cgroup\n\t\t * is already in the tree, all ancestors are.\n\t\t */\n\t\tif (rstatc->updated_next)\n\t\t\tbreak;\n\n\t\t/* Root has no parent to link it to, but mark it busy */\n\t\tif (!parent) {\n\t\t\trstatc->updated_next = cgrp;\n\t\t\tbreak;\n\t\t}\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\trstatc->updated_next = prstatc->updated_children;\n\t\tprstatc->updated_children = cgrp;\n\n\t\tcgrp = parent;\n\t}\n\n\traw_spin_unlock_irqrestore(cpu_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_stats_update_end_irqrestore",
          "args": [
            "&rstatc->bsync",
            "flags"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_cputime_account_end(struct cgroup *cgrp,\n\t\t\t\t\t\t struct cgroup_rstat_cpu *rstatc,\n\t\t\t\t\t\t unsigned long flags)\n{\n\tu64_stats_update_end_irqrestore(&rstatc->bsync, flags);\n\tcgroup_rstat_updated(cgrp, smp_processor_id());\n\tput_cpu_ptr(rstatc);\n}"
  },
  {
    "function_name": "cgroup_base_stat_cputime_account_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "346-354",
    "snippet": "static struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp, unsigned long *flags)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\t*flags = u64_stats_update_begin_irqsave(&rstatc->bsync);\n\treturn rstatc;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "u64_stats_update_begin_irqsave",
          "args": [
            "&rstatc->bsync"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_ptr",
          "args": [
            "cgrp->rstat_cpu"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_rstat_cpu *\ncgroup_base_stat_cputime_account_begin(struct cgroup *cgrp, unsigned long *flags)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = get_cpu_ptr(cgrp->rstat_cpu);\n\t*flags = u64_stats_update_begin_irqsave(&rstatc->bsync);\n\treturn rstatc;\n}"
  },
  {
    "function_name": "cgroup_base_stat_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "314-344",
    "snippet": "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_base_stat cur, delta;\n\tunsigned seq;\n\n\t/* Root-level stats are sourced from system-wide CPU stats */\n\tif (!parent)\n\t\treturn;\n\n\t/* fetch the current per-cpu values */\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&rstatc->bsync);\n\t\tcur.cputime = rstatc->bstat.cputime;\n\t} while (__u64_stats_fetch_retry(&rstatc->bsync, seq));\n\n\t/* propagate percpu delta to global */\n\tdelta = cur;\n\tcgroup_base_stat_sub(&delta, &rstatc->last_bstat);\n\tcgroup_base_stat_add(&cgrp->bstat, &delta);\n\tcgroup_base_stat_add(&rstatc->last_bstat, &delta);\n\n\t/* propagate global delta to parent (unless that's root) */\n\tif (cgroup_parent(parent)) {\n\t\tdelta = cgrp->bstat;\n\t\tcgroup_base_stat_sub(&delta, &cgrp->last_bstat);\n\t\tcgroup_base_stat_add(&parent->bstat, &delta);\n\t\tcgroup_base_stat_add(&cgrp->last_bstat, &delta);\n\t}\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_base_stat_add",
          "args": [
            "&cgrp->last_bstat",
            "&delta"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "298-304",
          "snippet": "static void cgroup_base_stat_add(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime += src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime += src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime += src_bstat->cputime.sum_exec_runtime;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_add(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime += src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime += src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime += src_bstat->cputime.sum_exec_runtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_sub",
          "args": [
            "&delta",
            "&cgrp->last_bstat"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "306-312",
          "snippet": "static void cgroup_base_stat_sub(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime -= src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime -= src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime -= src_bstat->cputime.sum_exec_runtime;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_sub(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime -= src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime -= src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime -= src_bstat->cputime.sum_exec_runtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "parent"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__u64_stats_fetch_retry",
          "args": [
            "&rstatc->bsync",
            "seq"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__u64_stats_fetch_begin",
          "args": [
            "&rstatc->bsync"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "cgrp",
            "cpu"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "11-14",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_base_stat cur, delta;\n\tunsigned seq;\n\n\t/* Root-level stats are sourced from system-wide CPU stats */\n\tif (!parent)\n\t\treturn;\n\n\t/* fetch the current per-cpu values */\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&rstatc->bsync);\n\t\tcur.cputime = rstatc->bstat.cputime;\n\t} while (__u64_stats_fetch_retry(&rstatc->bsync, seq));\n\n\t/* propagate percpu delta to global */\n\tdelta = cur;\n\tcgroup_base_stat_sub(&delta, &rstatc->last_bstat);\n\tcgroup_base_stat_add(&cgrp->bstat, &delta);\n\tcgroup_base_stat_add(&rstatc->last_bstat, &delta);\n\n\t/* propagate global delta to parent (unless that's root) */\n\tif (cgroup_parent(parent)) {\n\t\tdelta = cgrp->bstat;\n\t\tcgroup_base_stat_sub(&delta, &cgrp->last_bstat);\n\t\tcgroup_base_stat_add(&parent->bstat, &delta);\n\t\tcgroup_base_stat_add(&cgrp->last_bstat, &delta);\n\t}\n}"
  },
  {
    "function_name": "cgroup_base_stat_sub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "306-312",
    "snippet": "static void cgroup_base_stat_sub(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime -= src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime -= src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime -= src_bstat->cputime.sum_exec_runtime;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_sub(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime -= src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime -= src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime -= src_bstat->cputime.sum_exec_runtime;\n}"
  },
  {
    "function_name": "cgroup_base_stat_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "298-304",
    "snippet": "static void cgroup_base_stat_add(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime += src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime += src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime += src_bstat->cputime.sum_exec_runtime;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_add(struct cgroup_base_stat *dst_bstat,\n\t\t\t\t struct cgroup_base_stat *src_bstat)\n{\n\tdst_bstat->cputime.utime += src_bstat->cputime.utime;\n\tdst_bstat->cputime.stime += src_bstat->cputime.stime;\n\tdst_bstat->cputime.sum_exec_runtime += src_bstat->cputime.sum_exec_runtime;\n}"
  },
  {
    "function_name": "cgroup_rstat_boot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "286-292",
    "snippet": "void __init cgroup_rstat_boot(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\traw_spin_lock_init(per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu));\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid __init cgroup_rstat_boot(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\traw_spin_lock_init(per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu));\n}"
  },
  {
    "function_name": "cgroup_rstat_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "267-284",
    "snippet": "void cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "cgrp->rstat_cpu"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rstatc->updated_next"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rstatc->updated_children != cgrp"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "cgrp",
            "cpu"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "11-14",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush",
          "args": [
            "cgrp"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "228-234",
          "snippet": "void cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}"
  },
  {
    "function_name": "cgroup_rstat_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "245-265",
    "snippet": "int cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "u64_stats_init",
          "args": [
            "&rstatc->bsync"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "cgrp",
            "cpu"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "11-14",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structcgroup_rstat_cpu"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nint cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_rstat_flush_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "239-243",
    "snippet": "void cgroup_rstat_flush_release(void)\n\t__releases(&cgroup_rstat_lock)\n{\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_release(void)\n\t__releases(&cgroup_rstat_lock)\n{\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}"
  },
  {
    "function_name": "cgroup_rstat_flush_hold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "228-234",
    "snippet": "void cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_locked",
          "args": [
            "cgrp",
            "true"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "145-180",
          "snippet": "static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);",
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}"
  },
  {
    "function_name": "cgroup_rstat_flush_irqsafe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "210-217",
    "snippet": "void cgroup_rstat_flush_irqsafe(struct cgroup *cgrp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_rstat_lock, flags);\n\tcgroup_rstat_flush_locked(cgrp, false);\n\tspin_unlock_irqrestore(&cgroup_rstat_lock, flags);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&cgroup_rstat_lock",
            "flags"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_locked",
          "args": [
            "cgrp",
            "false"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "145-180",
          "snippet": "static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);",
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&cgroup_rstat_lock",
            "flags"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_irqsafe(struct cgroup *cgrp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_rstat_lock, flags);\n\tcgroup_rstat_flush_locked(cgrp, false);\n\tspin_unlock_irqrestore(&cgroup_rstat_lock, flags);\n}"
  },
  {
    "function_name": "cgroup_rstat_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "195-202",
    "snippet": "void cgroup_rstat_flush(struct cgroup *cgrp)\n{\n\tmight_sleep();\n\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush_locked",
          "args": [
            "cgrp",
            "true"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "145-180",
          "snippet": "static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);",
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush(struct cgroup *cgrp)\n{\n\tmight_sleep();\n\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n\tspin_unlock_irq(&cgroup_rstat_lock);\n}"
  },
  {
    "function_name": "cgroup_rstat_flush_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "145-180",
    "snippet": "static void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_rstat_lock);",
      "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "cpu_lock"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "css",
            "cpu"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "css",
            "&pos->rstat_css_list",
            "rstat_css_node"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_flush",
          "args": [
            "pos",
            "cpu"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "314-344",
          "snippet": "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_base_stat cur, delta;\n\tunsigned seq;\n\n\t/* Root-level stats are sourced from system-wide CPU stats */\n\tif (!parent)\n\t\treturn;\n\n\t/* fetch the current per-cpu values */\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&rstatc->bsync);\n\t\tcur.cputime = rstatc->bstat.cputime;\n\t} while (__u64_stats_fetch_retry(&rstatc->bsync, seq));\n\n\t/* propagate percpu delta to global */\n\tdelta = cur;\n\tcgroup_base_stat_sub(&delta, &rstatc->last_bstat);\n\tcgroup_base_stat_add(&cgrp->bstat, &delta);\n\tcgroup_base_stat_add(&rstatc->last_bstat, &delta);\n\n\t/* propagate global delta to parent (unless that's root) */\n\tif (cgroup_parent(parent)) {\n\t\tdelta = cgrp->bstat;\n\t\tcgroup_base_stat_sub(&delta, &cgrp->last_bstat);\n\t\tcgroup_base_stat_add(&parent->bstat, &delta);\n\t\tcgroup_base_stat_add(&cgrp->last_bstat, &delta);\n\t}\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_base_stat cur, delta;\n\tunsigned seq;\n\n\t/* Root-level stats are sourced from system-wide CPU stats */\n\tif (!parent)\n\t\treturn;\n\n\t/* fetch the current per-cpu values */\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&rstatc->bsync);\n\t\tcur.cputime = rstatc->bstat.cputime;\n\t} while (__u64_stats_fetch_retry(&rstatc->bsync, seq));\n\n\t/* propagate percpu delta to global */\n\tdelta = cur;\n\tcgroup_base_stat_sub(&delta, &rstatc->last_bstat);\n\tcgroup_base_stat_add(&cgrp->bstat, &delta);\n\tcgroup_base_stat_add(&rstatc->last_bstat, &delta);\n\n\t/* propagate global delta to parent (unless that's root) */\n\tif (cgroup_parent(parent)) {\n\t\tdelta = cgrp->bstat;\n\t\tcgroup_base_stat_sub(&delta, &cgrp->last_bstat);\n\t\tcgroup_base_stat_add(&parent->bstat, &delta);\n\t\tcgroup_base_stat_add(&cgrp->last_bstat, &delta);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu_pop_updated",
          "args": [
            "pos",
            "cgrp",
            "cpu"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu_pop_updated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "87-142",
          "snippet": "static struct cgroup *cgroup_rstat_cpu_pop_updated(struct cgroup *pos,\n\t\t\t\t\t\t   struct cgroup *root, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tstruct cgroup *parent;\n\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/*\n\t * We're gonna walk down to the first leaf and visit/remove it.  We\n\t * can pick whatever unvisited node as the starting point.\n\t */\n\tif (!pos) {\n\t\tpos = root;\n\t\t/* return NULL if this subtree is not on-list */\n\t\tif (!cgroup_rstat_cpu(pos, cpu)->updated_next)\n\t\t\treturn NULL;\n\t} else {\n\t\tpos = cgroup_parent(pos);\n\t}\n\n\t/* walk down to the first leaf */\n\twhile (true) {\n\t\trstatc = cgroup_rstat_cpu(pos, cpu);\n\t\tif (rstatc->updated_children == pos)\n\t\t\tbreak;\n\t\tpos = rstatc->updated_children;\n\t}\n\n\t/*\n\t * Unlink @pos from the tree.  As the updated_children list is\n\t * singly linked, we have to walk it to find the removal point.\n\t * However, due to the way we traverse, @pos will be the first\n\t * child in most cases. The only exception is @root.\n\t */\n\tparent = cgroup_parent(pos);\n\tif (parent) {\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\t\tstruct cgroup **nextp;\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\tnextp = &prstatc->updated_children;\n\t\twhile (*nextp != pos) {\n\t\t\tstruct cgroup_rstat_cpu *nrstatc;\n\n\t\t\tnrstatc = cgroup_rstat_cpu(*nextp, cpu);\n\t\t\tWARN_ON_ONCE(*nextp == parent);\n\t\t\tnextp = &nrstatc->updated_next;\n\t\t}\n\t\t*nextp = rstatc->updated_next;\n\t}\n\n\trstatc->updated_next = NULL;\n\treturn pos;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup *cgroup_rstat_cpu_pop_updated(struct cgroup *pos,\n\t\t\t\t\t\t   struct cgroup *root, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tstruct cgroup *parent;\n\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/*\n\t * We're gonna walk down to the first leaf and visit/remove it.  We\n\t * can pick whatever unvisited node as the starting point.\n\t */\n\tif (!pos) {\n\t\tpos = root;\n\t\t/* return NULL if this subtree is not on-list */\n\t\tif (!cgroup_rstat_cpu(pos, cpu)->updated_next)\n\t\t\treturn NULL;\n\t} else {\n\t\tpos = cgroup_parent(pos);\n\t}\n\n\t/* walk down to the first leaf */\n\twhile (true) {\n\t\trstatc = cgroup_rstat_cpu(pos, cpu);\n\t\tif (rstatc->updated_children == pos)\n\t\t\tbreak;\n\t\tpos = rstatc->updated_children;\n\t}\n\n\t/*\n\t * Unlink @pos from the tree.  As the updated_children list is\n\t * singly linked, we have to walk it to find the removal point.\n\t * However, due to the way we traverse, @pos will be the first\n\t * child in most cases. The only exception is @root.\n\t */\n\tparent = cgroup_parent(pos);\n\tif (parent) {\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\t\tstruct cgroup **nextp;\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\tnextp = &prstatc->updated_children;\n\t\twhile (*nextp != pos) {\n\t\t\tstruct cgroup_rstat_cpu *nrstatc;\n\n\t\t\tnrstatc = cgroup_rstat_cpu(*nextp, cpu);\n\t\t\tWARN_ON_ONCE(*nextp == parent);\n\t\t\tnextp = &nrstatc->updated_next;\n\t\t}\n\t\t*nextp = rstatc->updated_next;\n\t}\n\n\trstatc->updated_next = NULL;\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "cpu_lock"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cgroup_rstat_cpu_lock",
            "cpu"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&cgroup_rstat_lock"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic void cgroup_rstat_flush_locked(struct cgroup *cgrp, bool may_sleep)\n\t__releases(&cgroup_rstat_lock) __acquires(&cgroup_rstat_lock)\n{\n\tint cpu;\n\n\tlockdep_assert_held(&cgroup_rstat_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock,\n\t\t\t\t\t\t       cpu);\n\t\tstruct cgroup *pos = NULL;\n\n\t\traw_spin_lock(cpu_lock);\n\t\twhile ((pos = cgroup_rstat_cpu_pop_updated(pos, cgrp, cpu))) {\n\t\t\tstruct cgroup_subsys_state *css;\n\n\t\t\tcgroup_base_stat_flush(pos, cpu);\n\n\t\t\trcu_read_lock();\n\t\t\tlist_for_each_entry_rcu(css, &pos->rstat_css_list,\n\t\t\t\t\t\trstat_css_node)\n\t\t\t\tcss->ss->css_rstat_flush(css, cpu);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\traw_spin_unlock(cpu_lock);\n\n\t\t/* if @may_sleep, play nice and yield if necessary */\n\t\tif (may_sleep && (need_resched() ||\n\t\t\t\t  spin_needbreak(&cgroup_rstat_lock))) {\n\t\t\tspin_unlock_irq(&cgroup_rstat_lock);\n\t\t\tif (!cond_resched())\n\t\t\t\tcpu_relax();\n\t\t\tspin_lock_irq(&cgroup_rstat_lock);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "cgroup_rstat_cpu_pop_updated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "87-142",
    "snippet": "static struct cgroup *cgroup_rstat_cpu_pop_updated(struct cgroup *pos,\n\t\t\t\t\t\t   struct cgroup *root, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tstruct cgroup *parent;\n\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/*\n\t * We're gonna walk down to the first leaf and visit/remove it.  We\n\t * can pick whatever unvisited node as the starting point.\n\t */\n\tif (!pos) {\n\t\tpos = root;\n\t\t/* return NULL if this subtree is not on-list */\n\t\tif (!cgroup_rstat_cpu(pos, cpu)->updated_next)\n\t\t\treturn NULL;\n\t} else {\n\t\tpos = cgroup_parent(pos);\n\t}\n\n\t/* walk down to the first leaf */\n\twhile (true) {\n\t\trstatc = cgroup_rstat_cpu(pos, cpu);\n\t\tif (rstatc->updated_children == pos)\n\t\t\tbreak;\n\t\tpos = rstatc->updated_children;\n\t}\n\n\t/*\n\t * Unlink @pos from the tree.  As the updated_children list is\n\t * singly linked, we have to walk it to find the removal point.\n\t * However, due to the way we traverse, @pos will be the first\n\t * child in most cases. The only exception is @root.\n\t */\n\tparent = cgroup_parent(pos);\n\tif (parent) {\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\t\tstruct cgroup **nextp;\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\tnextp = &prstatc->updated_children;\n\t\twhile (*nextp != pos) {\n\t\t\tstruct cgroup_rstat_cpu *nrstatc;\n\n\t\t\tnrstatc = cgroup_rstat_cpu(*nextp, cpu);\n\t\t\tWARN_ON_ONCE(*nextp == parent);\n\t\t\tnextp = &nrstatc->updated_next;\n\t\t}\n\t\t*nextp = rstatc->updated_next;\n\t}\n\n\trstatc->updated_next = NULL;\n\treturn pos;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "*nextp == parent"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "*nextp",
            "cpu"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "11-14",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "pos"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "pos"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup *cgroup_rstat_cpu_pop_updated(struct cgroup *pos,\n\t\t\t\t\t\t   struct cgroup *root, int cpu)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tstruct cgroup *parent;\n\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/*\n\t * We're gonna walk down to the first leaf and visit/remove it.  We\n\t * can pick whatever unvisited node as the starting point.\n\t */\n\tif (!pos) {\n\t\tpos = root;\n\t\t/* return NULL if this subtree is not on-list */\n\t\tif (!cgroup_rstat_cpu(pos, cpu)->updated_next)\n\t\t\treturn NULL;\n\t} else {\n\t\tpos = cgroup_parent(pos);\n\t}\n\n\t/* walk down to the first leaf */\n\twhile (true) {\n\t\trstatc = cgroup_rstat_cpu(pos, cpu);\n\t\tif (rstatc->updated_children == pos)\n\t\t\tbreak;\n\t\tpos = rstatc->updated_children;\n\t}\n\n\t/*\n\t * Unlink @pos from the tree.  As the updated_children list is\n\t * singly linked, we have to walk it to find the removal point.\n\t * However, due to the way we traverse, @pos will be the first\n\t * child in most cases. The only exception is @root.\n\t */\n\tparent = cgroup_parent(pos);\n\tif (parent) {\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\t\tstruct cgroup **nextp;\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\tnextp = &prstatc->updated_children;\n\t\twhile (*nextp != pos) {\n\t\t\tstruct cgroup_rstat_cpu *nrstatc;\n\n\t\t\tnrstatc = cgroup_rstat_cpu(*nextp, cpu);\n\t\t\tWARN_ON_ONCE(*nextp == parent);\n\t\t\tnextp = &nrstatc->updated_next;\n\t\t}\n\t\t*nextp = rstatc->updated_next;\n\t}\n\n\trstatc->updated_next = NULL;\n\treturn pos;\n}"
  },
  {
    "function_name": "cgroup_rstat_updated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "25-70",
    "snippet": "void cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n{\n\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu);\n\tunsigned long flags;\n\n\t/*\n\t * Speculative already-on-list test. This may race leading to\n\t * temporary inaccuracies, which is fine.\n\t *\n\t * Because @parent's updated_children is terminated with @parent\n\t * instead of NULL, we can tell whether @cgrp is on the list by\n\t * testing the next pointer for NULL.\n\t */\n\tif (data_race(cgroup_rstat_cpu(cgrp, cpu)->updated_next))\n\t\treturn;\n\n\traw_spin_lock_irqsave(cpu_lock, flags);\n\n\t/* put @cgrp and all ancestors on the corresponding updated lists */\n\twhile (true) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\t\tstruct cgroup *parent = cgroup_parent(cgrp);\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\n\t\t/*\n\t\t * Both additions and removals are bottom-up.  If a cgroup\n\t\t * is already in the tree, all ancestors are.\n\t\t */\n\t\tif (rstatc->updated_next)\n\t\t\tbreak;\n\n\t\t/* Root has no parent to link it to, but mark it busy */\n\t\tif (!parent) {\n\t\t\trstatc->updated_next = cgrp;\n\t\t\tbreak;\n\t\t}\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\trstatc->updated_next = prstatc->updated_children;\n\t\tprstatc->updated_children = cgrp;\n\n\t\tcgrp = parent;\n\t}\n\n\traw_spin_unlock_irqrestore(cpu_lock, flags);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "cpu_lock",
            "flags"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_cpu",
          "args": [
            "parent",
            "cpu"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "11-14",
          "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "cpu_lock",
            "flags"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "cgroup_rstat_cpu(cgrp, cpu)->updated_next"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cgroup_rstat_cpu_lock",
            "cpu"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_updated(struct cgroup *cgrp, int cpu)\n{\n\traw_spinlock_t *cpu_lock = per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu);\n\tunsigned long flags;\n\n\t/*\n\t * Speculative already-on-list test. This may race leading to\n\t * temporary inaccuracies, which is fine.\n\t *\n\t * Because @parent's updated_children is terminated with @parent\n\t * instead of NULL, we can tell whether @cgrp is on the list by\n\t * testing the next pointer for NULL.\n\t */\n\tif (data_race(cgroup_rstat_cpu(cgrp, cpu)->updated_next))\n\t\treturn;\n\n\traw_spin_lock_irqsave(cpu_lock, flags);\n\n\t/* put @cgrp and all ancestors on the corresponding updated lists */\n\twhile (true) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\t\tstruct cgroup *parent = cgroup_parent(cgrp);\n\t\tstruct cgroup_rstat_cpu *prstatc;\n\n\t\t/*\n\t\t * Both additions and removals are bottom-up.  If a cgroup\n\t\t * is already in the tree, all ancestors are.\n\t\t */\n\t\tif (rstatc->updated_next)\n\t\t\tbreak;\n\n\t\t/* Root has no parent to link it to, but mark it busy */\n\t\tif (!parent) {\n\t\t\trstatc->updated_next = cgrp;\n\t\t\tbreak;\n\t\t}\n\n\t\tprstatc = cgroup_rstat_cpu(parent, cpu);\n\t\trstatc->updated_next = prstatc->updated_children;\n\t\tprstatc->updated_children = cgrp;\n\n\t\tcgrp = parent;\n\t}\n\n\traw_spin_unlock_irqrestore(cpu_lock, flags);\n}"
  },
  {
    "function_name": "cgroup_rstat_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
    "lines": "11-14",
    "snippet": "static struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cgrp->rstat_cpu",
            "cpu"
          ],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nstatic struct cgroup_rstat_cpu *cgroup_rstat_cpu(struct cgroup *cgrp, int cpu)\n{\n\treturn per_cpu_ptr(cgrp->rstat_cpu, cpu);\n}"
  }
]