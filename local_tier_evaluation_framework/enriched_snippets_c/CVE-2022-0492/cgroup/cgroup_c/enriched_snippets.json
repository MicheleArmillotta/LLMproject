[
  {
    "function_name": "cgroup_sysfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6757-6760",
    "snippet": "static int __init cgroup_sysfs_init(void)\n{\n\treturn sysfs_create_group(kernel_kobj, &cgroup_sysfs_attr_group);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "kernel_kobj",
            "&cgroup_sysfs_attr_group"
          ],
          "line": 6759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid __init;\n\nstatic int __init cgroup_sysfs_init(void)\n{\n\treturn sysfs_create_group(kernel_kobj, &cgroup_sysfs_attr_group);\n}"
  },
  {
    "function_name": "features_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6736-6743",
    "snippet": "static ssize_t features_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"nsdelegate\\n\"\n\t\t\t\"memory_localevents\\n\"\n\t\t\t\"memory_recursiveprot\\n\");\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"nsdelegate\\n\"\n\t\t\t\"memory_localevents\\n\"\n\t\t\t\"memory_recursiveprot\\n\""
          ],
          "line": 6739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic ssize_t features_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"nsdelegate\\n\"\n\t\t\t\"memory_localevents\\n\"\n\t\t\t\"memory_recursiveprot\\n\");\n}"
  },
  {
    "function_name": "delegate_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6717-6733",
    "snippet": "static ssize_t delegate_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\tssize_t ret = 0;\n\n\tret = show_delegatable_files(cgroup_base_files, buf, PAGE_SIZE - ret,\n\t\t\t\t     NULL);\n\n\tfor_each_subsys(ss, ssid)\n\t\tret += show_delegatable_files(ss->dfl_cftypes, buf + ret,\n\t\t\t\t\t      PAGE_SIZE - ret,\n\t\t\t\t\t      cgroup_subsys_name[ssid]);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *cgroup_subsys_name[] = {\n#include <linux/cgroup_subsys.h>\n};",
      "static struct cftype cgroup_base_files[];",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_delegatable_files",
          "args": [
            "ss->dfl_cftypes",
            "buf + ret",
            "PAGE_SIZE - ret",
            "cgroup_subsys_name[ssid]"
          ],
          "line": 6728
        },
        "resolved": true,
        "details": {
          "function_name": "show_delegatable_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6692-6715",
          "snippet": "static ssize_t show_delegatable_files(struct cftype *files, char *buf,\n\t\t\t\t      ssize_t size, const char *prefix)\n{\n\tstruct cftype *cft;\n\tssize_t ret = 0;\n\n\tfor (cft = files; cft && cft->name[0] != '\\0'; cft++) {\n\t\tif (!(cft->flags & CFTYPE_NS_DELEGATABLE))\n\t\t\tcontinue;\n\n\t\tif ((cft->flags & CFTYPE_PRESSURE) && !cgroup_psi_enabled())\n\t\t\tcontinue;\n\n\t\tif (prefix)\n\t\t\tret += snprintf(buf + ret, size - ret, \"%s.\", prefix);\n\n\t\tret += snprintf(buf + ret, size - ret, \"%s\\n\", cft->name);\n\n\t\tif (WARN_ON(ret >= size))\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic ssize_t show_delegatable_files(struct cftype *files, char *buf,\n\t\t\t\t      ssize_t size, const char *prefix)\n{\n\tstruct cftype *cft;\n\tssize_t ret = 0;\n\n\tfor (cft = files; cft && cft->name[0] != '\\0'; cft++) {\n\t\tif (!(cft->flags & CFTYPE_NS_DELEGATABLE))\n\t\t\tcontinue;\n\n\t\tif ((cft->flags & CFTYPE_PRESSURE) && !cgroup_psi_enabled())\n\t\t\tcontinue;\n\n\t\tif (prefix)\n\t\t\tret += snprintf(buf + ret, size - ret, \"%s.\", prefix);\n\n\t\tret += snprintf(buf + ret, size - ret, \"%s\\n\", cft->name);\n\n\t\tif (WARN_ON(ret >= size))\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 6727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic const char *cgroup_subsys_name[] = {\n#include <linux/cgroup_subsys.h>\n};\nstatic struct cftype cgroup_base_files[];\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};\n\nstatic ssize_t delegate_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\tssize_t ret = 0;\n\n\tret = show_delegatable_files(cgroup_base_files, buf, PAGE_SIZE - ret,\n\t\t\t\t     NULL);\n\n\tfor_each_subsys(ss, ssid)\n\t\tret += show_delegatable_files(ss->dfl_cftypes, buf + ret,\n\t\t\t\t\t      PAGE_SIZE - ret,\n\t\t\t\t\t      cgroup_subsys_name[ssid]);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "show_delegatable_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6692-6715",
    "snippet": "static ssize_t show_delegatable_files(struct cftype *files, char *buf,\n\t\t\t\t      ssize_t size, const char *prefix)\n{\n\tstruct cftype *cft;\n\tssize_t ret = 0;\n\n\tfor (cft = files; cft && cft->name[0] != '\\0'; cft++) {\n\t\tif (!(cft->flags & CFTYPE_NS_DELEGATABLE))\n\t\t\tcontinue;\n\n\t\tif ((cft->flags & CFTYPE_PRESSURE) && !cgroup_psi_enabled())\n\t\t\tcontinue;\n\n\t\tif (prefix)\n\t\t\tret += snprintf(buf + ret, size - ret, \"%s.\", prefix);\n\n\t\tret += snprintf(buf + ret, size - ret, \"%s\\n\", cft->name);\n\n\t\tif (WARN_ON(ret >= size))\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret >= size"
          ],
          "line": 6710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + ret",
            "size - ret",
            "\"%s\\n\"",
            "cft->name"
          ],
          "line": 6708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + ret",
            "size - ret",
            "\"%s.\"",
            "prefix"
          ],
          "line": 6706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_psi_enabled",
          "args": [],
          "line": 6702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic ssize_t show_delegatable_files(struct cftype *files, char *buf,\n\t\t\t\t      ssize_t size, const char *prefix)\n{\n\tstruct cftype *cft;\n\tssize_t ret = 0;\n\n\tfor (cft = files; cft && cft->name[0] != '\\0'; cft++) {\n\t\tif (!(cft->flags & CFTYPE_NS_DELEGATABLE))\n\t\t\tcontinue;\n\n\t\tif ((cft->flags & CFTYPE_PRESSURE) && !cgroup_psi_enabled())\n\t\t\tcontinue;\n\n\t\tif (prefix)\n\t\t\tret += snprintf(buf + ret, size - ret, \"%s.\", prefix);\n\n\t\tret += snprintf(buf + ret, size - ret, \"%s\\n\", cft->name);\n\n\t\tif (WARN_ON(ret >= size))\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_sk_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6681-6687",
    "snippet": "void cgroup_sk_free(struct sock_cgroup_data *skcd)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(skcd);\n\n\tcgroup_bpf_put(cgrp);\n\tcgroup_put(cgrp);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 6686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_put",
          "args": [
            "cgrp"
          ],
          "line": 6685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "skcd"
          ],
          "line": 6683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_sk_free(struct sock_cgroup_data *skcd)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(skcd);\n\n\tcgroup_bpf_put(cgrp);\n\tcgroup_put(cgrp);\n}"
  },
  {
    "function_name": "cgroup_sk_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6668-6679",
    "snippet": "void cgroup_sk_clone(struct sock_cgroup_data *skcd)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(skcd);\n\n\t/*\n\t * We might be cloning a socket which is left in an empty\n\t * cgroup and the cgroup might have already been rmdir'd.\n\t * Don't use cgroup_get_live().\n\t */\n\tcgroup_get(cgrp);\n\tcgroup_bpf_get(cgrp);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_bpf_get",
          "args": [
            "cgrp"
          ],
          "line": 6678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get",
          "args": [
            "cgrp"
          ],
          "line": 6677
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6577-6589",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_cgroup_ptr",
          "args": [
            "skcd"
          ],
          "line": 6670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_sk_clone(struct sock_cgroup_data *skcd)\n{\n\tstruct cgroup *cgrp = sock_cgroup_ptr(skcd);\n\n\t/*\n\t * We might be cloning a socket which is left in an empty\n\t * cgroup and the cgroup might have already been rmdir'd.\n\t * Don't use cgroup_get_live().\n\t */\n\tcgroup_get(cgrp);\n\tcgroup_bpf_get(cgrp);\n}"
  },
  {
    "function_name": "cgroup_sk_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6640-6666",
    "snippet": "void cgroup_sk_alloc(struct sock_cgroup_data *skcd)\n{\n\tstruct cgroup *cgroup;\n\n\trcu_read_lock();\n\t/* Don't associate the sock with unrelated interrupted task's cgroup. */\n\tif (in_interrupt()) {\n\t\tcgroup = &cgrp_dfl_root.cgrp;\n\t\tcgroup_get(cgroup);\n\t\tgoto out;\n\t}\n\n\twhile (true) {\n\t\tstruct css_set *cset;\n\n\t\tcset = task_css_set(current);\n\t\tif (likely(cgroup_tryget(cset->dfl_cgrp))) {\n\t\t\tcgroup = cset->dfl_cgrp;\n\t\t\tbreak;\n\t\t}\n\t\tcpu_relax();\n\t}\nout:\n\tskcd->cgroup = cgroup;\n\tcgroup_bpf_get(cgroup);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 6665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_get",
          "args": [
            "cgroup"
          ],
          "line": 6664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 6660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "cgroup_tryget(cset->dfl_cgrp)"
          ],
          "line": 6656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_tryget",
          "args": [
            "cset->dfl_cgrp"
          ],
          "line": 6656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "current"
          ],
          "line": 6655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get",
          "args": [
            "cgroup"
          ],
          "line": 6648
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6577-6589",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 6646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 6644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_sk_alloc(struct sock_cgroup_data *skcd)\n{\n\tstruct cgroup *cgroup;\n\n\trcu_read_lock();\n\t/* Don't associate the sock with unrelated interrupted task's cgroup. */\n\tif (in_interrupt()) {\n\t\tcgroup = &cgrp_dfl_root.cgrp;\n\t\tcgroup_get(cgroup);\n\t\tgoto out;\n\t}\n\n\twhile (true) {\n\t\tstruct css_set *cset;\n\n\t\tcset = task_css_set(current);\n\t\tif (likely(cgroup_tryget(cset->dfl_cgrp))) {\n\t\t\tcgroup = cset->dfl_cgrp;\n\t\t\tbreak;\n\t\t}\n\t\tcpu_relax();\n\t}\nout:\n\tskcd->cgroup = cgroup;\n\tcgroup_bpf_get(cgroup);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "cgroup_parse_float",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6614-6632",
    "snippet": "int cgroup_parse_float(const char *input, unsigned dec_shift, s64 *v)\n{\n\ts64 whole, frac = 0;\n\tint fstart = 0, fend = 0, flen;\n\n\tif (!sscanf(input, \"%lld.%n%lld%n\", &whole, &fstart, &frac, &fend))\n\t\treturn -EINVAL;\n\tif (frac < 0)\n\t\treturn -EINVAL;\n\n\tflen = fend > fstart ? fend - fstart : 0;\n\tif (flen < dec_shift)\n\t\tfrac *= power_of_ten(dec_shift - flen);\n\telse\n\t\tfrac = DIV_ROUND_CLOSEST_ULL(frac, power_of_ten(flen - dec_shift));\n\n\t*v = whole * power_of_ten(dec_shift) + frac;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "power_of_ten",
          "args": [
            "dec_shift"
          ],
          "line": 6630
        },
        "resolved": true,
        "details": {
          "function_name": "power_of_ten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6592-6598",
          "snippet": "static u64 power_of_ten(int power)\n{\n\tu64 v = 1;\n\twhile (power--)\n\t\tv *= 10;\n\treturn v;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u64 power_of_ten(int power)\n{\n\tu64 v = 1;\n\twhile (power--)\n\t\tv *= 10;\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_CLOSEST_ULL",
          "args": [
            "frac",
            "power_of_ten(flen - dec_shift)"
          ],
          "line": 6628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "input",
            "\"%lld.%n%lld%n\"",
            "&whole",
            "&fstart",
            "&frac",
            "&fend"
          ],
          "line": 6619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nint cgroup_parse_float(const char *input, unsigned dec_shift, s64 *v)\n{\n\ts64 whole, frac = 0;\n\tint fstart = 0, fend = 0, flen;\n\n\tif (!sscanf(input, \"%lld.%n%lld%n\", &whole, &fstart, &frac, &fend))\n\t\treturn -EINVAL;\n\tif (frac < 0)\n\t\treturn -EINVAL;\n\n\tflen = fend > fstart ? fend - fstart : 0;\n\tif (flen < dec_shift)\n\t\tfrac *= power_of_ten(dec_shift - flen);\n\telse\n\t\tfrac = DIV_ROUND_CLOSEST_ULL(frac, power_of_ten(flen - dec_shift));\n\n\t*v = whole * power_of_ten(dec_shift) + frac;\n\treturn 0;\n}"
  },
  {
    "function_name": "power_of_ten",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6592-6598",
    "snippet": "static u64 power_of_ten(int power)\n{\n\tu64 v = 1;\n\twhile (power--)\n\t\tv *= 10;\n\treturn v;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u64 power_of_ten(int power)\n{\n\tu64 v = 1;\n\twhile (power--)\n\t\tv *= 10;\n\treturn v;\n}"
  },
  {
    "function_name": "cgroup_get_from_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6577-6589",
    "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f"
          ],
          "line": 6587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_from_file",
          "args": [
            "f"
          ],
          "line": 6586
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6078-6094",
          "snippet": "static struct cgroup *cgroup_get_from_file(struct file *f)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup *cgroup_get_from_file(struct file *f)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 6584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fget_raw",
          "args": [
            "fd"
          ],
          "line": 6582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}"
  },
  {
    "function_name": "cgroup_get_from_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6539-6565",
    "snippet": "struct cgroup *cgroup_get_from_path(const char *path)\n{\n\tstruct kernfs_node *kn;\n\tstruct cgroup *cgrp = ERR_PTR(-ENOENT);\n\n\tkn = kernfs_walk_and_get(cgrp_dfl_root.cgrp.kn, path);\n\tif (!kn)\n\t\tgoto out;\n\n\tif (kernfs_type(kn) != KERNFS_DIR) {\n\t\tcgrp = ERR_PTR(-ENOTDIR);\n\t\tgoto out_kernfs;\n\t}\n\n\trcu_read_lock();\n\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (!cgrp || !cgroup_tryget(cgrp))\n\t\tcgrp = ERR_PTR(-ENOENT);\n\n\trcu_read_unlock();\n\nout_kernfs:\n\tkernfs_put(kn);\nout:\n\treturn cgrp;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 6562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 6559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 6557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_tryget",
          "args": [
            "cgrp"
          ],
          "line": 6556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "*(void __rcu __force **)&kn->priv"
          ],
          "line": 6555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 6553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTDIR"
          ],
          "line": 6549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 6548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_walk_and_get",
          "args": [
            "cgrp_dfl_root.cgrp.kn",
            "path"
          ],
          "line": 6544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 6542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_path(const char *path)\n{\n\tstruct kernfs_node *kn;\n\tstruct cgroup *cgrp = ERR_PTR(-ENOENT);\n\n\tkn = kernfs_walk_and_get(cgrp_dfl_root.cgrp.kn, path);\n\tif (!kn)\n\t\tgoto out;\n\n\tif (kernfs_type(kn) != KERNFS_DIR) {\n\t\tcgrp = ERR_PTR(-ENOTDIR);\n\t\tgoto out_kernfs;\n\t}\n\n\trcu_read_lock();\n\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (!cgrp || !cgroup_tryget(cgrp))\n\t\tcgrp = ERR_PTR(-ENOENT);\n\n\trcu_read_unlock();\n\nout_kernfs:\n\tkernfs_put(kn);\nout:\n\treturn cgrp;\n}"
  },
  {
    "function_name": "css_from_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6524-6528",
    "snippet": "struct cgroup_subsys_state *css_from_id(int id, struct cgroup_subsys *ss)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&ss->css_idr, id);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&ss->css_idr",
            "id"
          ],
          "line": 6527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 6526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 6526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstruct cgroup_subsys_state *css_from_id(int id, struct cgroup_subsys *ss)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&ss->css_idr, id);\n}"
  },
  {
    "function_name": "css_tryget_online_from_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6485-6514",
    "snippet": "struct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,\n\t\t\t\t\t\t       struct cgroup_subsys *ss)\n{\n\tstruct kernfs_node *kn = kernfs_node_from_dentry(dentry);\n\tstruct file_system_type *s_type = dentry->d_sb->s_type;\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct cgroup *cgrp;\n\n\t/* is @dentry a cgroup dir? */\n\tif ((s_type != &cgroup_fs_type && s_type != &cgroup2_fs_type) ||\n\t    !kn || kernfs_type(kn) != KERNFS_DIR)\n\t\treturn ERR_PTR(-EBADF);\n\n\trcu_read_lock();\n\n\t/*\n\t * This path doesn't originate from kernfs and @kn could already\n\t * have been or be removed at any point.  @kn->priv is RCU\n\t * protected for this access.  See css_release_work_fn() for details.\n\t */\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (cgrp)\n\t\tcss = cgroup_css(cgrp, ss);\n\n\tif (!css || !css_tryget_online(css))\n\t\tcss = ERR_PTR(-ENOENT);\n\n\trcu_read_unlock();\n\treturn css;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type cgroup2_fs_type;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "struct file_system_type cgroup_fs_type = {\n\t.name\t\t\t= \"cgroup\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup1_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};",
      "static struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 6512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 6510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "css"
          ],
          "line": 6509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 6507
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "481-489",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "*(void __rcu __force **)&kn->priv"
          ],
          "line": 6505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 6498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 6496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 6495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_node_from_dentry",
          "args": [
            "dentry"
          ],
          "line": 6488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct file_system_type cgroup2_fs_type;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstruct file_system_type cgroup_fs_type = {\n\t.name\t\t\t= \"cgroup\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup1_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\nstatic struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\n\nstruct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,\n\t\t\t\t\t\t       struct cgroup_subsys *ss)\n{\n\tstruct kernfs_node *kn = kernfs_node_from_dentry(dentry);\n\tstruct file_system_type *s_type = dentry->d_sb->s_type;\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct cgroup *cgrp;\n\n\t/* is @dentry a cgroup dir? */\n\tif ((s_type != &cgroup_fs_type && s_type != &cgroup2_fs_type) ||\n\t    !kn || kernfs_type(kn) != KERNFS_DIR)\n\t\treturn ERR_PTR(-EBADF);\n\n\trcu_read_lock();\n\n\t/*\n\t * This path doesn't originate from kernfs and @kn could already\n\t * have been or be removed at any point.  @kn->priv is RCU\n\t * protected for this access.  See css_release_work_fn() for details.\n\t */\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (cgrp)\n\t\tcss = cgroup_css(cgrp, ss);\n\n\tif (!css || !css_tryget_online(css))\n\t\tcss = ERR_PTR(-ENOENT);\n\n\trcu_read_unlock();\n\treturn css;\n}"
  },
  {
    "function_name": "enable_cgroup_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6468-6473",
    "snippet": "static int __init enable_cgroup_debug(char *str)\n{\n\tcgroup_debug = true;\n\tenable_debug_cgroup();\n\treturn 1;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool cgroup_debug",
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_debug_cgroup",
          "args": [],
          "line": 6471
        },
        "resolved": true,
        "details": {
          "function_name": "enable_debug_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6466-6466",
          "snippet": "__weak enable_debug_cgroup(void) { }",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n__weak enable_debug_cgroup(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nbool cgroup_debug;\nvoid __init;\n\nstatic int __init enable_cgroup_debug(char *str)\n{\n\tcgroup_debug = true;\n\tenable_debug_cgroup();\n\treturn 1;\n}"
  },
  {
    "function_name": "enable_debug_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6466-6466",
    "snippet": "__weak enable_debug_cgroup(void) { }",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n__weak enable_debug_cgroup(void) { }"
  },
  {
    "function_name": "cgroup_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6433-6463",
    "snippet": "static int __init cgroup_disable(char *str)\n{\n\tstruct cgroup_subsys *ss;\n\tchar *token;\n\tint i;\n\n\twhile ((token = strsep(&str, \",\")) != NULL) {\n\t\tif (!*token)\n\t\t\tcontinue;\n\n\t\tfor_each_subsys(ss, i) {\n\t\t\tif (strcmp(token, ss->name) &&\n\t\t\t    strcmp(token, ss->legacy_name))\n\t\t\t\tcontinue;\n\n\t\t\tstatic_branch_disable(cgroup_subsys_enabled_key[i]);\n\t\t\tpr_info(\"Disabling %s control group subsystem\\n\",\n\t\t\t\tss->name);\n\t\t}\n\n\t\tfor (i = 0; i < OPT_FEATURE_COUNT; i++) {\n\t\t\tif (strcmp(token, cgroup_opt_feature_names[i]))\n\t\t\t\tcontinue;\n\t\t\tcgroup_feature_disable_mask |= 1 << i;\n\t\t\tpr_info(\"Disabling %s control group feature\\n\",\n\t\t\t\tcgroup_opt_feature_names[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};",
      "static const char *cgroup_opt_feature_names[OPT_FEATURE_COUNT] = {\n#ifdef CONFIG_PSI\n\t\"pressure\",\n#endif\n};",
      "static u16 cgroup_feature_disable_mask",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Disabling %s control group feature\\n\"",
            "cgroup_opt_feature_names[i]"
          ],
          "line": 6457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "token",
            "cgroup_opt_feature_names[i]"
          ],
          "line": 6454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Disabling %s control group subsystem\\n\"",
            "ss->name"
          ],
          "line": 6449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "cgroup_subsys_enabled_key[i]"
          ],
          "line": 6448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "token",
            "ss->legacy_name"
          ],
          "line": 6445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "token",
            "ss->name"
          ],
          "line": 6444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "i"
          ],
          "line": 6443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\",\""
          ],
          "line": 6439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};\nstatic const char *cgroup_opt_feature_names[OPT_FEATURE_COUNT] = {\n#ifdef CONFIG_PSI\n\t\"pressure\",\n#endif\n};\nstatic u16 cgroup_feature_disable_mask;\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nvoid __init;\n\nstatic int __init cgroup_disable(char *str)\n{\n\tstruct cgroup_subsys *ss;\n\tchar *token;\n\tint i;\n\n\twhile ((token = strsep(&str, \",\")) != NULL) {\n\t\tif (!*token)\n\t\t\tcontinue;\n\n\t\tfor_each_subsys(ss, i) {\n\t\t\tif (strcmp(token, ss->name) &&\n\t\t\t    strcmp(token, ss->legacy_name))\n\t\t\t\tcontinue;\n\n\t\t\tstatic_branch_disable(cgroup_subsys_enabled_key[i]);\n\t\t\tpr_info(\"Disabling %s control group subsystem\\n\",\n\t\t\t\tss->name);\n\t\t}\n\n\t\tfor (i = 0; i < OPT_FEATURE_COUNT; i++) {\n\t\t\tif (strcmp(token, cgroup_opt_feature_names[i]))\n\t\t\t\tcontinue;\n\t\t\tcgroup_feature_disable_mask |= 1 << i;\n\t\t\tpr_info(\"Disabling %s control group feature\\n\",\n\t\t\t\tcgroup_opt_feature_names[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "cgroup_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6427-6431",
    "snippet": "void cgroup_free(struct task_struct *task)\n{\n\tstruct css_set *cset = task_css_set(task);\n\tput_css_set(cset);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "cset"
          ],
          "line": 6430
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "955-990",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int css_set_count\t= 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "task"
          ],
          "line": 6429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nvoid cgroup_free(struct task_struct *task)\n{\n\tstruct css_set *cset = task_css_set(task);\n\tput_css_set(cset);\n}"
  },
  {
    "function_name": "cgroup_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6412-6425",
    "snippet": "void cgroup_release(struct task_struct *task)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, have_release_callback) {\n\t\tss->release(task);\n\t} while_each_subsys_mask();\n\n\tspin_lock_irq(&css_set_lock);\n\tcss_set_skip_task_iters(task_css_set(task), task);\n\tlist_del_init(&task->cg_list);\n\tspin_unlock_irq(&css_set_lock);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 have_release_callback",
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 6424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&task->cg_list"
          ],
          "line": 6423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_skip_task_iters",
          "args": [
            "task_css_set(task)",
            "task"
          ],
          "line": 6422
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_skip_task_iters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "876-883",
          "snippet": "static void css_set_skip_task_iters(struct css_set *cset,\n\t\t\t\t    struct task_struct *task)\n{\n\tstruct css_task_iter *it, *pos;\n\n\tlist_for_each_entry_safe(it, pos, &cset->task_iters, iters_node)\n\t\tcss_task_iter_skip(it, task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void css_set_skip_task_iters(struct css_set *cset,\n\t\t\t\t    struct task_struct *task)\n{\n\tstruct css_task_iter *it, *pos;\n\n\tlist_for_each_entry_safe(it, pos, &cset->task_iters, iters_node)\n\t\tcss_task_iter_skip(it, task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "task"
          ],
          "line": 6422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 6421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 6419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->release",
          "args": [
            "task"
          ],
          "line": 6418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "have_release_callback"
          ],
          "line": 6417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 have_release_callback;\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nvoid cgroup_release(struct task_struct *task)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, have_release_callback) {\n\t\tss->release(task);\n\t} while_each_subsys_mask();\n\n\tspin_lock_irq(&css_set_lock);\n\tcss_set_skip_task_iters(task_css_set(task), task);\n\tlist_del_init(&task->cg_list);\n\tspin_unlock_irq(&css_set_lock);\n}"
  },
  {
    "function_name": "cgroup_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6385-6410",
    "snippet": "void cgroup_exit(struct task_struct *tsk)\n{\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tint i;\n\n\tspin_lock_irq(&css_set_lock);\n\n\tWARN_ON_ONCE(list_empty(&tsk->cg_list));\n\tcset = task_css_set(tsk);\n\tcss_set_move_task(tsk, cset, NULL, false);\n\tlist_add_tail(&tsk->cg_list, &cset->dying_tasks);\n\tcset->nr_tasks--;\n\n\tWARN_ON_ONCE(cgroup_task_frozen(tsk));\n\tif (unlikely(!(tsk->flags & PF_KTHREAD) &&\n\t\t     test_bit(CGRP_FREEZE, &task_dfl_cgroup(tsk)->flags)))\n\t\tcgroup_update_frozen(task_dfl_cgroup(tsk));\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* see cgroup_post_fork() for details */\n\tdo_each_subsys_mask(ss, i, have_exit_callback) {\n\t\tss->exit(tsk);\n\t} while_each_subsys_mask();\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 have_exit_callback",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 6409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->exit",
          "args": [
            "tsk"
          ],
          "line": 6408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "i",
            "have_exit_callback"
          ],
          "line": 6407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 6404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_update_frozen",
          "args": [
            "task_dfl_cgroup(tsk)"
          ],
          "line": 6402
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_frozen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "52-84",
          "snippet": "void cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If the cgroup has to be frozen (CGRP_FREEZE bit set),\n\t * and all tasks are frozen and/or stopped, let's consider\n\t * the cgroup frozen. Otherwise it's not frozen.\n\t */\n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t/* Already there? */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t/* Already there? */\n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t/* Update the state of ancestor cgroups. */\n\tcgroup_propagate_frozen(cgrp, frozen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_dfl_cgroup",
          "args": [
            "tsk"
          ],
          "line": 6402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(tsk->flags & PF_KTHREAD) &&\n\t\t     test_bit(CGRP_FREEZE, &task_dfl_cgroup(tsk)->flags)"
          ],
          "line": 6400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FREEZE",
            "&task_dfl_cgroup(tsk)->flags"
          ],
          "line": 6401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_dfl_cgroup",
          "args": [
            "tsk"
          ],
          "line": 6401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cgroup_task_frozen(tsk)"
          ],
          "line": 6399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_task_frozen",
          "args": [
            "tsk"
          ],
          "line": 6399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tsk->cg_list",
            "&cset->dying_tasks"
          ],
          "line": 6396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_move_task",
          "args": [
            "tsk",
            "cset",
            "NULL",
            "false"
          ],
          "line": 6395
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_move_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "900-932",
          "snippet": "static void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\tcss_set_skip_task_iters(from_cset, task);\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit()/cgroup_free() dropping the css_set.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\tcss_set_skip_task_iters(from_cset, task);\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit()/cgroup_free() dropping the css_set.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "tsk"
          ],
          "line": 6394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "list_empty(&tsk->cg_list)"
          ],
          "line": 6393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tsk->cg_list"
          ],
          "line": 6393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 6391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 have_exit_callback;\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nvoid cgroup_exit(struct task_struct *tsk)\n{\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tint i;\n\n\tspin_lock_irq(&css_set_lock);\n\n\tWARN_ON_ONCE(list_empty(&tsk->cg_list));\n\tcset = task_css_set(tsk);\n\tcss_set_move_task(tsk, cset, NULL, false);\n\tlist_add_tail(&tsk->cg_list, &cset->dying_tasks);\n\tcset->nr_tasks--;\n\n\tWARN_ON_ONCE(cgroup_task_frozen(tsk));\n\tif (unlikely(!(tsk->flags & PF_KTHREAD) &&\n\t\t     test_bit(CGRP_FREEZE, &task_dfl_cgroup(tsk)->flags)))\n\t\tcgroup_update_frozen(task_dfl_cgroup(tsk));\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* see cgroup_post_fork() for details */\n\tdo_each_subsys_mask(ss, i, have_exit_callback) {\n\t\tss->exit(tsk);\n\t} while_each_subsys_mask();\n}"
  },
  {
    "function_name": "cgroup_post_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6293-6376",
    "snippet": "void cgroup_post_fork(struct task_struct *child,\n\t\t      struct kernel_clone_args *kargs)\n\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)\n{\n\tunsigned long cgrp_flags = 0;\n\tbool kill = false;\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tint i;\n\n\tcset = kargs->cset;\n\tkargs->cset = NULL;\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* init tasks are special, only link regular threads */\n\tif (likely(child->pid)) {\n\t\tif (kargs->cgrp)\n\t\t\tcgrp_flags = kargs->cgrp->flags;\n\t\telse\n\t\t\tcgrp_flags = cset->dfl_cgrp->flags;\n\n\t\tWARN_ON_ONCE(!list_empty(&child->cg_list));\n\t\tcset->nr_tasks++;\n\t\tcss_set_move_task(child, NULL, cset, false);\n\t} else {\n\t\tput_css_set(cset);\n\t\tcset = NULL;\n\t}\n\n\tif (!(child->flags & PF_KTHREAD)) {\n\t\tif (unlikely(test_bit(CGRP_FREEZE, &cgrp_flags))) {\n\t\t\t/*\n\t\t\t * If the cgroup has to be frozen, the new task has\n\t\t\t * too. Let's set the JOBCTL_TRAP_FREEZE jobctl bit to\n\t\t\t * get the task into the frozen state.\n\t\t\t */\n\t\t\tspin_lock(&child->sighand->siglock);\n\t\t\tWARN_ON_ONCE(child->frozen);\n\t\t\tchild->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\t\tspin_unlock(&child->sighand->siglock);\n\n\t\t\t/*\n\t\t\t * Calling cgroup_update_frozen() isn't required here,\n\t\t\t * because it will be called anyway a bit later from\n\t\t\t * do_freezer_trap(). So we avoid cgroup's transient\n\t\t\t * switch from the frozen state and back.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * If the cgroup is to be killed notice it now and take the\n\t\t * child down right after we finished preparing it for\n\t\t * userspace.\n\t\t */\n\t\tkill = test_bit(CGRP_KILL, &cgrp_flags);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Call ss->fork().  This must happen after @child is linked on\n\t * css_set; otherwise, @child might change state between ->fork()\n\t * and addition to css_set.\n\t */\n\tdo_each_subsys_mask(ss, i, have_fork_callback) {\n\t\tss->fork(child);\n\t} while_each_subsys_mask();\n\n\t/* Make the new cset the root_cset of the new cgroup namespace. */\n\tif (kargs->flags & CLONE_NEWCGROUP) {\n\t\tstruct css_set *rcset = child->nsproxy->cgroup_ns->root_cset;\n\n\t\tget_css_set(cset);\n\t\tchild->nsproxy->cgroup_ns->root_cset = cset;\n\t\tput_css_set(rcset);\n\t}\n\n\t/* Cgroup has to be killed so take down child immediately. */\n\tif (unlikely(kill))\n\t\tdo_send_sig_info(SIGKILL, SEND_SIG_NOINFO, child, PIDTYPE_TGID);\n\n\tcgroup_css_set_put_fork(kargs);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 have_fork_callback",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_css_set_put_fork",
          "args": [
            "kargs"
          ],
          "line": 6375
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css_set_put_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6201-6222",
          "snippet": "static void cgroup_css_set_put_fork(struct kernel_clone_args *kargs)\n\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)\n{\n\tcgroup_threadgroup_change_end(current);\n\n\tif (kargs->flags & CLONE_INTO_CGROUP) {\n\t\tstruct cgroup *cgrp = kargs->cgrp;\n\t\tstruct css_set *cset = kargs->cset;\n\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tif (cset) {\n\t\t\tput_css_set(cset);\n\t\t\tkargs->cset = NULL;\n\t\t}\n\n\t\tif (cgrp) {\n\t\t\tcgroup_put(cgrp);\n\t\t\tkargs->cgrp = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_css_set_put_fork(struct kernel_clone_args *kargs)\n\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)\n{\n\tcgroup_threadgroup_change_end(current);\n\n\tif (kargs->flags & CLONE_INTO_CGROUP) {\n\t\tstruct cgroup *cgrp = kargs->cgrp;\n\t\tstruct css_set *cset = kargs->cset;\n\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tif (cset) {\n\t\t\tput_css_set(cset);\n\t\t\tkargs->cset = NULL;\n\t\t}\n\n\t\tif (cgrp) {\n\t\t\tcgroup_put(cgrp);\n\t\t\tkargs->cgrp = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_send_sig_info",
          "args": [
            "SIGKILL",
            "SEND_SIG_NOINFO",
            "child",
            "PIDTYPE_TGID"
          ],
          "line": 6373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kill"
          ],
          "line": 6372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "rcset"
          ],
          "line": 6368
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "955-990",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int css_set_count\t= 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "cset"
          ],
          "line": 6366
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "219-222",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 6360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->fork",
          "args": [
            "child"
          ],
          "line": 6359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "i",
            "have_fork_callback"
          ],
          "line": 6358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 6351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_KILL",
            "&cgrp_flags"
          ],
          "line": 6348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&child->sighand->siglock"
          ],
          "line": 6333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "child->frozen"
          ],
          "line": 6331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&child->sighand->siglock"
          ],
          "line": 6330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(CGRP_FREEZE, &cgrp_flags)"
          ],
          "line": 6324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FREEZE",
            "&cgrp_flags"
          ],
          "line": 6324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_move_task",
          "args": [
            "child",
            "NULL",
            "cset",
            "false"
          ],
          "line": 6317
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_move_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "900-932",
          "snippet": "static void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\tcss_set_skip_task_iters(from_cset, task);\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit()/cgroup_free() dropping the css_set.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\tcss_set_skip_task_iters(from_cset, task);\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit()/cgroup_free() dropping the css_set.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&child->cg_list)"
          ],
          "line": 6315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&child->cg_list"
          ],
          "line": 6315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "child->pid"
          ],
          "line": 6309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 6306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 6295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 6295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 have_fork_callback;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nvoid cgroup_post_fork(struct task_struct *child,\n\t\t      struct kernel_clone_args *kargs)\n\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)\n{\n\tunsigned long cgrp_flags = 0;\n\tbool kill = false;\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tint i;\n\n\tcset = kargs->cset;\n\tkargs->cset = NULL;\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* init tasks are special, only link regular threads */\n\tif (likely(child->pid)) {\n\t\tif (kargs->cgrp)\n\t\t\tcgrp_flags = kargs->cgrp->flags;\n\t\telse\n\t\t\tcgrp_flags = cset->dfl_cgrp->flags;\n\n\t\tWARN_ON_ONCE(!list_empty(&child->cg_list));\n\t\tcset->nr_tasks++;\n\t\tcss_set_move_task(child, NULL, cset, false);\n\t} else {\n\t\tput_css_set(cset);\n\t\tcset = NULL;\n\t}\n\n\tif (!(child->flags & PF_KTHREAD)) {\n\t\tif (unlikely(test_bit(CGRP_FREEZE, &cgrp_flags))) {\n\t\t\t/*\n\t\t\t * If the cgroup has to be frozen, the new task has\n\t\t\t * too. Let's set the JOBCTL_TRAP_FREEZE jobctl bit to\n\t\t\t * get the task into the frozen state.\n\t\t\t */\n\t\t\tspin_lock(&child->sighand->siglock);\n\t\t\tWARN_ON_ONCE(child->frozen);\n\t\t\tchild->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\t\tspin_unlock(&child->sighand->siglock);\n\n\t\t\t/*\n\t\t\t * Calling cgroup_update_frozen() isn't required here,\n\t\t\t * because it will be called anyway a bit later from\n\t\t\t * do_freezer_trap(). So we avoid cgroup's transient\n\t\t\t * switch from the frozen state and back.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * If the cgroup is to be killed notice it now and take the\n\t\t * child down right after we finished preparing it for\n\t\t * userspace.\n\t\t */\n\t\tkill = test_bit(CGRP_KILL, &cgrp_flags);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Call ss->fork().  This must happen after @child is linked on\n\t * css_set; otherwise, @child might change state between ->fork()\n\t * and addition to css_set.\n\t */\n\tdo_each_subsys_mask(ss, i, have_fork_callback) {\n\t\tss->fork(child);\n\t} while_each_subsys_mask();\n\n\t/* Make the new cset the root_cset of the new cgroup namespace. */\n\tif (kargs->flags & CLONE_NEWCGROUP) {\n\t\tstruct css_set *rcset = child->nsproxy->cgroup_ns->root_cset;\n\n\t\tget_css_set(cset);\n\t\tchild->nsproxy->cgroup_ns->root_cset = cset;\n\t\tput_css_set(rcset);\n\t}\n\n\t/* Cgroup has to be killed so take down child immediately. */\n\tif (unlikely(kill))\n\t\tdo_send_sig_info(SIGKILL, SEND_SIG_NOINFO, child, PIDTYPE_TGID);\n\n\tcgroup_css_set_put_fork(kargs);\n}"
  },
  {
    "function_name": "cgroup_cancel_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6273-6284",
    "snippet": "void cgroup_cancel_fork(struct task_struct *child,\n\t\t\tstruct kernel_clone_args *kargs)\n{\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tif (ss->cancel_fork)\n\t\t\tss->cancel_fork(child, kargs->cset);\n\n\tcgroup_css_set_put_fork(kargs);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_css_set_put_fork",
          "args": [
            "kargs"
          ],
          "line": 6283
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css_set_put_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6201-6222",
          "snippet": "static void cgroup_css_set_put_fork(struct kernel_clone_args *kargs)\n\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)\n{\n\tcgroup_threadgroup_change_end(current);\n\n\tif (kargs->flags & CLONE_INTO_CGROUP) {\n\t\tstruct cgroup *cgrp = kargs->cgrp;\n\t\tstruct css_set *cset = kargs->cset;\n\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tif (cset) {\n\t\t\tput_css_set(cset);\n\t\t\tkargs->cset = NULL;\n\t\t}\n\n\t\tif (cgrp) {\n\t\t\tcgroup_put(cgrp);\n\t\t\tkargs->cgrp = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_css_set_put_fork(struct kernel_clone_args *kargs)\n\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)\n{\n\tcgroup_threadgroup_change_end(current);\n\n\tif (kargs->flags & CLONE_INTO_CGROUP) {\n\t\tstruct cgroup *cgrp = kargs->cgrp;\n\t\tstruct css_set *cset = kargs->cset;\n\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tif (cset) {\n\t\t\tput_css_set(cset);\n\t\t\tkargs->cset = NULL;\n\t\t}\n\n\t\tif (cgrp) {\n\t\t\tcgroup_put(cgrp);\n\t\t\tkargs->cgrp = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss->cancel_fork",
          "args": [
            "child",
            "kargs->cset"
          ],
          "line": 6281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "i"
          ],
          "line": 6279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nvoid cgroup_cancel_fork(struct task_struct *child,\n\t\t\tstruct kernel_clone_args *kargs)\n{\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tif (ss->cancel_fork)\n\t\t\tss->cancel_fork(child, kargs->cset);\n\n\tcgroup_css_set_put_fork(kargs);\n}"
  },
  {
    "function_name": "cgroup_can_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6234-6262",
    "snippet": "int cgroup_can_fork(struct task_struct *child, struct kernel_clone_args *kargs)\n{\n\tstruct cgroup_subsys *ss;\n\tint i, j, ret;\n\n\tret = cgroup_css_set_fork(kargs);\n\tif (ret)\n\t\treturn ret;\n\n\tdo_each_subsys_mask(ss, i, have_canfork_callback) {\n\t\tret = ss->can_fork(child, kargs->cset);\n\t\tif (ret)\n\t\t\tgoto out_revert;\n\t} while_each_subsys_mask();\n\n\treturn 0;\n\nout_revert:\n\tfor_each_subsys(ss, j) {\n\t\tif (j >= i)\n\t\t\tbreak;\n\t\tif (ss->cancel_fork)\n\t\t\tss->cancel_fork(child, kargs->cset);\n\t}\n\n\tcgroup_css_set_put_fork(kargs);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 have_canfork_callback",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_css_set_put_fork",
          "args": [
            "kargs"
          ],
          "line": 6259
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css_set_put_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6201-6222",
          "snippet": "static void cgroup_css_set_put_fork(struct kernel_clone_args *kargs)\n\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)\n{\n\tcgroup_threadgroup_change_end(current);\n\n\tif (kargs->flags & CLONE_INTO_CGROUP) {\n\t\tstruct cgroup *cgrp = kargs->cgrp;\n\t\tstruct css_set *cset = kargs->cset;\n\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tif (cset) {\n\t\t\tput_css_set(cset);\n\t\t\tkargs->cset = NULL;\n\t\t}\n\n\t\tif (cgrp) {\n\t\t\tcgroup_put(cgrp);\n\t\t\tkargs->cgrp = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_css_set_put_fork(struct kernel_clone_args *kargs)\n\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)\n{\n\tcgroup_threadgroup_change_end(current);\n\n\tif (kargs->flags & CLONE_INTO_CGROUP) {\n\t\tstruct cgroup *cgrp = kargs->cgrp;\n\t\tstruct css_set *cset = kargs->cset;\n\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tif (cset) {\n\t\t\tput_css_set(cset);\n\t\t\tkargs->cset = NULL;\n\t\t}\n\n\t\tif (cgrp) {\n\t\t\tcgroup_put(cgrp);\n\t\t\tkargs->cgrp = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss->cancel_fork",
          "args": [
            "child",
            "kargs->cset"
          ],
          "line": 6256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "j"
          ],
          "line": 6252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 6247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->can_fork",
          "args": [
            "child",
            "kargs->cset"
          ],
          "line": 6244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "i",
            "have_canfork_callback"
          ],
          "line": 6243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css_set_fork",
          "args": [
            "kargs"
          ],
          "line": 6239
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css_set_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6112-6192",
          "snippet": "static int cgroup_css_set_fork(struct kernel_clone_args *kargs)\n\t__acquires(&cgroup_mutex) __acquires(&cgroup_threadgroup_rwsem)\n{\n\tint ret;\n\tstruct cgroup *dst_cgrp = NULL;\n\tstruct css_set *cset;\n\tstruct super_block *sb;\n\tstruct file *f;\n\n\tif (kargs->flags & CLONE_INTO_CGROUP)\n\t\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_threadgroup_change_begin(current);\n\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!(kargs->flags & CLONE_INTO_CGROUP)) {\n\t\tkargs->cset = cset;\n\t\treturn 0;\n\t}\n\n\tf = fget_raw(kargs->cgroup);\n\tif (!f) {\n\t\tret = -EBADF;\n\t\tgoto err;\n\t}\n\tsb = f->f_path.dentry->d_sb;\n\n\tdst_cgrp = cgroup_get_from_file(f);\n\tif (IS_ERR(dst_cgrp)) {\n\t\tret = PTR_ERR(dst_cgrp);\n\t\tdst_cgrp = NULL;\n\t\tgoto err;\n\t}\n\n\tif (cgroup_is_dead(dst_cgrp)) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Verify that we the target cgroup is writable for us. This is\n\t * usually done by the vfs layer but since we're not going through\n\t * the vfs layer here we need to do it \"manually\".\n\t */\n\tret = cgroup_may_write(dst_cgrp, sb);\n\tif (ret)\n\t\tgoto err;\n\n\tret = cgroup_attach_permissions(cset->dfl_cgrp, dst_cgrp, sb,\n\t\t\t\t\t!(kargs->flags & CLONE_THREAD),\n\t\t\t\t\tcurrent->nsproxy->cgroup_ns);\n\tif (ret)\n\t\tgoto err;\n\n\tkargs->cset = find_css_set(cset, dst_cgrp);\n\tif (!kargs->cset) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tput_css_set(cset);\n\tfput(f);\n\tkargs->cgrp = dst_cgrp;\n\treturn ret;\n\nerr:\n\tcgroup_threadgroup_change_end(current);\n\tmutex_unlock(&cgroup_mutex);\n\tif (f)\n\t\tfput(f);\n\tif (dst_cgrp)\n\t\tcgroup_put(dst_cgrp);\n\tput_css_set(cset);\n\tif (kargs->cset)\n\t\tput_css_set(kargs->cset);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic int cgroup_css_set_fork(struct kernel_clone_args *kargs)\n\t__acquires(&cgroup_mutex) __acquires(&cgroup_threadgroup_rwsem)\n{\n\tint ret;\n\tstruct cgroup *dst_cgrp = NULL;\n\tstruct css_set *cset;\n\tstruct super_block *sb;\n\tstruct file *f;\n\n\tif (kargs->flags & CLONE_INTO_CGROUP)\n\t\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_threadgroup_change_begin(current);\n\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!(kargs->flags & CLONE_INTO_CGROUP)) {\n\t\tkargs->cset = cset;\n\t\treturn 0;\n\t}\n\n\tf = fget_raw(kargs->cgroup);\n\tif (!f) {\n\t\tret = -EBADF;\n\t\tgoto err;\n\t}\n\tsb = f->f_path.dentry->d_sb;\n\n\tdst_cgrp = cgroup_get_from_file(f);\n\tif (IS_ERR(dst_cgrp)) {\n\t\tret = PTR_ERR(dst_cgrp);\n\t\tdst_cgrp = NULL;\n\t\tgoto err;\n\t}\n\n\tif (cgroup_is_dead(dst_cgrp)) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Verify that we the target cgroup is writable for us. This is\n\t * usually done by the vfs layer but since we're not going through\n\t * the vfs layer here we need to do it \"manually\".\n\t */\n\tret = cgroup_may_write(dst_cgrp, sb);\n\tif (ret)\n\t\tgoto err;\n\n\tret = cgroup_attach_permissions(cset->dfl_cgrp, dst_cgrp, sb,\n\t\t\t\t\t!(kargs->flags & CLONE_THREAD),\n\t\t\t\t\tcurrent->nsproxy->cgroup_ns);\n\tif (ret)\n\t\tgoto err;\n\n\tkargs->cset = find_css_set(cset, dst_cgrp);\n\tif (!kargs->cset) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tput_css_set(cset);\n\tfput(f);\n\tkargs->cgrp = dst_cgrp;\n\treturn ret;\n\nerr:\n\tcgroup_threadgroup_change_end(current);\n\tmutex_unlock(&cgroup_mutex);\n\tif (f)\n\t\tfput(f);\n\tif (dst_cgrp)\n\t\tcgroup_put(dst_cgrp);\n\tput_css_set(cset);\n\tif (kargs->cset)\n\t\tput_css_set(kargs->cset);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 have_canfork_callback;\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nint cgroup_can_fork(struct task_struct *child, struct kernel_clone_args *kargs)\n{\n\tstruct cgroup_subsys *ss;\n\tint i, j, ret;\n\n\tret = cgroup_css_set_fork(kargs);\n\tif (ret)\n\t\treturn ret;\n\n\tdo_each_subsys_mask(ss, i, have_canfork_callback) {\n\t\tret = ss->can_fork(child, kargs->cset);\n\t\tif (ret)\n\t\t\tgoto out_revert;\n\t} while_each_subsys_mask();\n\n\treturn 0;\n\nout_revert:\n\tfor_each_subsys(ss, j) {\n\t\tif (j >= i)\n\t\t\tbreak;\n\t\tif (ss->cancel_fork)\n\t\t\tss->cancel_fork(child, kargs->cset);\n\t}\n\n\tcgroup_css_set_put_fork(kargs);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_css_set_put_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6201-6222",
    "snippet": "static void cgroup_css_set_put_fork(struct kernel_clone_args *kargs)\n\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)\n{\n\tcgroup_threadgroup_change_end(current);\n\n\tif (kargs->flags & CLONE_INTO_CGROUP) {\n\t\tstruct cgroup *cgrp = kargs->cgrp;\n\t\tstruct css_set *cset = kargs->cset;\n\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tif (cset) {\n\t\t\tput_css_set(cset);\n\t\t\tkargs->cset = NULL;\n\t\t}\n\n\t\tif (cgrp) {\n\t\t\tcgroup_put(cgrp);\n\t\t\tkargs->cgrp = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 6218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "cset"
          ],
          "line": 6213
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "955-990",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int css_set_count\t= 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 6210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_threadgroup_change_end",
          "args": [
            "current"
          ],
          "line": 6204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 6202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 6202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_css_set_put_fork(struct kernel_clone_args *kargs)\n\t__releases(&cgroup_threadgroup_rwsem) __releases(&cgroup_mutex)\n{\n\tcgroup_threadgroup_change_end(current);\n\n\tif (kargs->flags & CLONE_INTO_CGROUP) {\n\t\tstruct cgroup *cgrp = kargs->cgrp;\n\t\tstruct css_set *cset = kargs->cset;\n\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tif (cset) {\n\t\t\tput_css_set(cset);\n\t\t\tkargs->cset = NULL;\n\t\t}\n\n\t\tif (cgrp) {\n\t\t\tcgroup_put(cgrp);\n\t\t\tkargs->cgrp = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "cgroup_css_set_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6112-6192",
    "snippet": "static int cgroup_css_set_fork(struct kernel_clone_args *kargs)\n\t__acquires(&cgroup_mutex) __acquires(&cgroup_threadgroup_rwsem)\n{\n\tint ret;\n\tstruct cgroup *dst_cgrp = NULL;\n\tstruct css_set *cset;\n\tstruct super_block *sb;\n\tstruct file *f;\n\n\tif (kargs->flags & CLONE_INTO_CGROUP)\n\t\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_threadgroup_change_begin(current);\n\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!(kargs->flags & CLONE_INTO_CGROUP)) {\n\t\tkargs->cset = cset;\n\t\treturn 0;\n\t}\n\n\tf = fget_raw(kargs->cgroup);\n\tif (!f) {\n\t\tret = -EBADF;\n\t\tgoto err;\n\t}\n\tsb = f->f_path.dentry->d_sb;\n\n\tdst_cgrp = cgroup_get_from_file(f);\n\tif (IS_ERR(dst_cgrp)) {\n\t\tret = PTR_ERR(dst_cgrp);\n\t\tdst_cgrp = NULL;\n\t\tgoto err;\n\t}\n\n\tif (cgroup_is_dead(dst_cgrp)) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Verify that we the target cgroup is writable for us. This is\n\t * usually done by the vfs layer but since we're not going through\n\t * the vfs layer here we need to do it \"manually\".\n\t */\n\tret = cgroup_may_write(dst_cgrp, sb);\n\tif (ret)\n\t\tgoto err;\n\n\tret = cgroup_attach_permissions(cset->dfl_cgrp, dst_cgrp, sb,\n\t\t\t\t\t!(kargs->flags & CLONE_THREAD),\n\t\t\t\t\tcurrent->nsproxy->cgroup_ns);\n\tif (ret)\n\t\tgoto err;\n\n\tkargs->cset = find_css_set(cset, dst_cgrp);\n\tif (!kargs->cset) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tput_css_set(cset);\n\tfput(f);\n\tkargs->cgrp = dst_cgrp;\n\treturn ret;\n\nerr:\n\tcgroup_threadgroup_change_end(current);\n\tmutex_unlock(&cgroup_mutex);\n\tif (f)\n\t\tfput(f);\n\tif (dst_cgrp)\n\t\tcgroup_put(dst_cgrp);\n\tput_css_set(cset);\n\tif (kargs->cset)\n\t\tput_css_set(kargs->cset);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "kargs->cset"
          ],
          "line": 6190
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "955-990",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int css_set_count\t= 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "dst_cgrp"
          ],
          "line": 6187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f"
          ],
          "line": 6185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 6183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_threadgroup_change_end",
          "args": [
            "current"
          ],
          "line": 6182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f"
          ],
          "line": 6177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_css_set",
          "args": [
            "cset",
            "dst_cgrp"
          ],
          "line": 6170
        },
        "resolved": true,
        "details": {
          "function_name": "find_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1200-1301",
          "snippet": "static struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->dying_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_root_count;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int css_set_count\t= 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nstatic struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->dying_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_attach_permissions",
          "args": [
            "cset->dfl_cgrp",
            "dst_cgrp",
            "sb",
            "!(kargs->flags & CLONE_THREAD)",
            "current->nsproxy->cgroup_ns"
          ],
          "line": 6164
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_attach_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4892-4911",
          "snippet": "static int cgroup_attach_permissions(struct cgroup *src_cgrp,\n\t\t\t\t     struct cgroup *dst_cgrp,\n\t\t\t\t     struct super_block *sb, bool threadgroup,\n\t\t\t\t     struct cgroup_namespace *ns)\n{\n\tint ret = 0;\n\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp, sb, ns);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cgroup_migrate_vet_dst(dst_cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!threadgroup && (src_cgrp->dom_cgrp != dst_cgrp->dom_cgrp))\n\t\tret = -EOPNOTSUPP;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_attach_permissions(struct cgroup *src_cgrp,\n\t\t\t\t     struct cgroup *dst_cgrp,\n\t\t\t\t     struct super_block *sb, bool threadgroup,\n\t\t\t\t     struct cgroup_namespace *ns)\n{\n\tint ret = 0;\n\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp, sb, ns);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cgroup_migrate_vet_dst(dst_cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!threadgroup && (src_cgrp->dom_cgrp != dst_cgrp->dom_cgrp))\n\t\tret = -EOPNOTSUPP;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_may_write",
          "args": [
            "dst_cgrp",
            "sb"
          ],
          "line": 6160
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_may_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4845-4859",
          "snippet": "static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)\n{\n\tint ret;\n\tstruct inode *inode;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tinode = kernfs_get_inode(sb, cgrp->procs_file.kn);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tret = inode_permission(&init_user_ns, inode, MAY_WRITE);\n\tiput(inode);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)\n{\n\tint ret;\n\tstruct inode *inode;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tinode = kernfs_get_inode(sb, cgrp->procs_file.kn);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tret = inode_permission(&init_user_ns, inode, MAY_WRITE);\n\tiput(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_dead",
          "args": [
            "dst_cgrp"
          ],
          "line": 6150
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "187-190",
          "snippet": "static inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dst_cgrp"
          ],
          "line": 6145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dst_cgrp"
          ],
          "line": 6144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_from_file",
          "args": [
            "f"
          ],
          "line": 6143
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6078-6094",
          "snippet": "static struct cgroup *cgroup_get_from_file(struct file *f)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup *cgroup_get_from_file(struct file *f)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fget_raw",
          "args": [
            "kargs->cgroup"
          ],
          "line": 6136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 6129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "cset"
          ],
          "line": 6128
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "219-222",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "current"
          ],
          "line": 6127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 6126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_threadgroup_change_begin",
          "args": [
            "current"
          ],
          "line": 6124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 6122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 6113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 6113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic int cgroup_css_set_fork(struct kernel_clone_args *kargs)\n\t__acquires(&cgroup_mutex) __acquires(&cgroup_threadgroup_rwsem)\n{\n\tint ret;\n\tstruct cgroup *dst_cgrp = NULL;\n\tstruct css_set *cset;\n\tstruct super_block *sb;\n\tstruct file *f;\n\n\tif (kargs->flags & CLONE_INTO_CGROUP)\n\t\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_threadgroup_change_begin(current);\n\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!(kargs->flags & CLONE_INTO_CGROUP)) {\n\t\tkargs->cset = cset;\n\t\treturn 0;\n\t}\n\n\tf = fget_raw(kargs->cgroup);\n\tif (!f) {\n\t\tret = -EBADF;\n\t\tgoto err;\n\t}\n\tsb = f->f_path.dentry->d_sb;\n\n\tdst_cgrp = cgroup_get_from_file(f);\n\tif (IS_ERR(dst_cgrp)) {\n\t\tret = PTR_ERR(dst_cgrp);\n\t\tdst_cgrp = NULL;\n\t\tgoto err;\n\t}\n\n\tif (cgroup_is_dead(dst_cgrp)) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Verify that we the target cgroup is writable for us. This is\n\t * usually done by the vfs layer but since we're not going through\n\t * the vfs layer here we need to do it \"manually\".\n\t */\n\tret = cgroup_may_write(dst_cgrp, sb);\n\tif (ret)\n\t\tgoto err;\n\n\tret = cgroup_attach_permissions(cset->dfl_cgrp, dst_cgrp, sb,\n\t\t\t\t\t!(kargs->flags & CLONE_THREAD),\n\t\t\t\t\tcurrent->nsproxy->cgroup_ns);\n\tif (ret)\n\t\tgoto err;\n\n\tkargs->cset = find_css_set(cset, dst_cgrp);\n\tif (!kargs->cset) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tput_css_set(cset);\n\tfput(f);\n\tkargs->cgrp = dst_cgrp;\n\treturn ret;\n\nerr:\n\tcgroup_threadgroup_change_end(current);\n\tmutex_unlock(&cgroup_mutex);\n\tif (f)\n\t\tfput(f);\n\tif (dst_cgrp)\n\t\tcgroup_put(dst_cgrp);\n\tput_css_set(cset);\n\tif (kargs->cset)\n\t\tput_css_set(kargs->cset);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_get_from_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6078-6094",
    "snippet": "static struct cgroup *cgroup_get_from_file(struct file *f)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 6090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 6089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 6088
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "313-316",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "css"
          ],
          "line": 6085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "css"
          ],
          "line": 6084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online_from_dir",
          "args": [
            "f->f_path.dentry",
            "NULL"
          ],
          "line": 6083
        },
        "resolved": true,
        "details": {
          "function_name": "css_tryget_online_from_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6485-6514",
          "snippet": "struct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,\n\t\t\t\t\t\t       struct cgroup_subsys *ss)\n{\n\tstruct kernfs_node *kn = kernfs_node_from_dentry(dentry);\n\tstruct file_system_type *s_type = dentry->d_sb->s_type;\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct cgroup *cgrp;\n\n\t/* is @dentry a cgroup dir? */\n\tif ((s_type != &cgroup_fs_type && s_type != &cgroup2_fs_type) ||\n\t    !kn || kernfs_type(kn) != KERNFS_DIR)\n\t\treturn ERR_PTR(-EBADF);\n\n\trcu_read_lock();\n\n\t/*\n\t * This path doesn't originate from kernfs and @kn could already\n\t * have been or be removed at any point.  @kn->priv is RCU\n\t * protected for this access.  See css_release_work_fn() for details.\n\t */\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (cgrp)\n\t\tcss = cgroup_css(cgrp, ss);\n\n\tif (!css || !css_tryget_online(css))\n\t\tcss = ERR_PTR(-ENOENT);\n\n\trcu_read_unlock();\n\treturn css;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type cgroup2_fs_type;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "struct file_system_type cgroup_fs_type = {\n\t.name\t\t\t= \"cgroup\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup1_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};",
            "static struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct file_system_type cgroup2_fs_type;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstruct file_system_type cgroup_fs_type = {\n\t.name\t\t\t= \"cgroup\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup1_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\nstatic struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\n\nstruct cgroup_subsys_state *css_tryget_online_from_dir(struct dentry *dentry,\n\t\t\t\t\t\t       struct cgroup_subsys *ss)\n{\n\tstruct kernfs_node *kn = kernfs_node_from_dentry(dentry);\n\tstruct file_system_type *s_type = dentry->d_sb->s_type;\n\tstruct cgroup_subsys_state *css = NULL;\n\tstruct cgroup *cgrp;\n\n\t/* is @dentry a cgroup dir? */\n\tif ((s_type != &cgroup_fs_type && s_type != &cgroup2_fs_type) ||\n\t    !kn || kernfs_type(kn) != KERNFS_DIR)\n\t\treturn ERR_PTR(-EBADF);\n\n\trcu_read_lock();\n\n\t/*\n\t * This path doesn't originate from kernfs and @kn could already\n\t * have been or be removed at any point.  @kn->priv is RCU\n\t * protected for this access.  See css_release_work_fn() for details.\n\t */\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (cgrp)\n\t\tcss = cgroup_css(cgrp, ss);\n\n\tif (!css || !css_tryget_online(css))\n\t\tcss = ERR_PTR(-ENOENT);\n\n\trcu_read_unlock();\n\treturn css;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup *cgroup_get_from_file(struct file *f)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *cgrp;\n\n\tcss = css_tryget_online_from_dir(f->f_path.dentry, NULL);\n\tif (IS_ERR(css))\n\t\treturn ERR_CAST(css);\n\n\tcgrp = css->cgroup;\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgroup_put(cgrp);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn cgrp;\n}"
  },
  {
    "function_name": "cgroup_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "6072-6076",
    "snippet": "void cgroup_fork(struct task_struct *child)\n{\n\tRCU_INIT_POINTER(child->cgroups, &init_css_set);\n\tINIT_LIST_HEAD(&child->cg_list);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&child->cg_list"
          ],
          "line": 6075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "child->cgroups",
            "&init_css_set"
          ],
          "line": 6074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\n\nvoid cgroup_fork(struct task_struct *child)\n{\n\tRCU_INIT_POINTER(child->cgroups, &init_css_set);\n\tINIT_LIST_HEAD(&child->cg_list);\n}"
  },
  {
    "function_name": "proc_cgroup_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5992-6063",
    "snippet": "int proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,\n\t\t     struct pid *pid, struct task_struct *tsk)\n{\n\tchar *buf;\n\tint retval;\n\tstruct cgroup_root *root;\n\n\tretval = -ENOMEM;\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\tfor_each_root(root) {\n\t\tstruct cgroup_subsys *ss;\n\t\tstruct cgroup *cgrp;\n\t\tint ssid, count = 0;\n\n\t\tif (root == &cgrp_dfl_root && !cgrp_dfl_visible)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"%d:\", root->hierarchy_id);\n\t\tif (root != &cgrp_dfl_root)\n\t\t\tfor_each_subsys(ss, ssid)\n\t\t\t\tif (root->subsys_mask & (1 << ssid))\n\t\t\t\t\tseq_printf(m, \"%s%s\", count++ ? \",\" : \"\",\n\t\t\t\t\t\t   ss->legacy_name);\n\t\tif (strlen(root->name))\n\t\t\tseq_printf(m, \"%sname=%s\", count ? \",\" : \"\",\n\t\t\t\t   root->name);\n\t\tseq_putc(m, ':');\n\n\t\tcgrp = task_cgroup_from_root(tsk, root);\n\n\t\t/*\n\t\t * On traditional hierarchies, all zombie tasks show up as\n\t\t * belonging to the root cgroup.  On the default hierarchy,\n\t\t * while a zombie doesn't show up in \"cgroup.procs\" and\n\t\t * thus can't be migrated, its /proc/PID/cgroup keeps\n\t\t * reporting the cgroup it belonged to before exiting.  If\n\t\t * the cgroup is removed before the zombie is reaped,\n\t\t * \" (deleted)\" is appended to the cgroup path.\n\t\t */\n\t\tif (cgroup_on_dfl(cgrp) || !(tsk->flags & PF_EXITING)) {\n\t\t\tretval = cgroup_path_ns_locked(cgrp, buf, PATH_MAX,\n\t\t\t\t\t\tcurrent->nsproxy->cgroup_ns);\n\t\t\tif (retval >= PATH_MAX)\n\t\t\t\tretval = -ENAMETOOLONG;\n\t\t\tif (retval < 0)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tseq_puts(m, buf);\n\t\t} else {\n\t\t\tseq_puts(m, \"/\");\n\t\t}\n\n\t\tif (cgroup_on_dfl(cgrp) && cgroup_is_dead(cgrp))\n\t\t\tseq_puts(m, \" (deleted)\\n\");\n\t\telse\n\t\t\tseq_putc(m, '\\n');\n\t}\n\n\tretval = 0;\nout_unlock:\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\tkfree(buf);\nout:\n\treturn retval;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static bool cgrp_dfl_visible;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 6060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 6059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 6058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 6053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" (deleted)\\n\""
          ],
          "line": 6051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_dead",
          "args": [
            "cgrp"
          ],
          "line": 6050
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "187-190",
          "snippet": "static inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 6050
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "313-316",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"/\""
          ],
          "line": 6047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "buf"
          ],
          "line": 6045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_path_ns_locked",
          "args": [
            "cgrp",
            "buf",
            "PATH_MAX",
            "current->nsproxy->cgroup_ns"
          ],
          "line": 6038
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_path_ns_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2282-2288",
          "snippet": "int cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cgroup_from_root",
          "args": [
            "tsk",
            "root"
          ],
          "line": 6026
        },
        "resolved": true,
        "details": {
          "function_name": "task_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1450-1458",
          "snippet": "struct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold css_set_lock the\n\t * task can't change groups.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstruct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold css_set_lock the\n\t * task can't change groups.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "':'"
          ],
          "line": 6024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%sname=%s\"",
            "count ? \",\" : \"\"",
            "root->name"
          ],
          "line": 6022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "root->name"
          ],
          "line": 6021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s%s\"",
            "count++ ? \",\" : \"\"",
            "ss->legacy_name"
          ],
          "line": 6019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 6017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%d:\"",
            "root->hierarchy_id"
          ],
          "line": 6015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 6005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 6004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PATH_MAX",
            "GFP_KERNEL"
          ],
          "line": 6000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic bool cgrp_dfl_visible;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nint proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,\n\t\t     struct pid *pid, struct task_struct *tsk)\n{\n\tchar *buf;\n\tint retval;\n\tstruct cgroup_root *root;\n\n\tretval = -ENOMEM;\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\tfor_each_root(root) {\n\t\tstruct cgroup_subsys *ss;\n\t\tstruct cgroup *cgrp;\n\t\tint ssid, count = 0;\n\n\t\tif (root == &cgrp_dfl_root && !cgrp_dfl_visible)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"%d:\", root->hierarchy_id);\n\t\tif (root != &cgrp_dfl_root)\n\t\t\tfor_each_subsys(ss, ssid)\n\t\t\t\tif (root->subsys_mask & (1 << ssid))\n\t\t\t\t\tseq_printf(m, \"%s%s\", count++ ? \",\" : \"\",\n\t\t\t\t\t\t   ss->legacy_name);\n\t\tif (strlen(root->name))\n\t\t\tseq_printf(m, \"%sname=%s\", count ? \",\" : \"\",\n\t\t\t\t   root->name);\n\t\tseq_putc(m, ':');\n\n\t\tcgrp = task_cgroup_from_root(tsk, root);\n\n\t\t/*\n\t\t * On traditional hierarchies, all zombie tasks show up as\n\t\t * belonging to the root cgroup.  On the default hierarchy,\n\t\t * while a zombie doesn't show up in \"cgroup.procs\" and\n\t\t * thus can't be migrated, its /proc/PID/cgroup keeps\n\t\t * reporting the cgroup it belonged to before exiting.  If\n\t\t * the cgroup is removed before the zombie is reaped,\n\t\t * \" (deleted)\" is appended to the cgroup path.\n\t\t */\n\t\tif (cgroup_on_dfl(cgrp) || !(tsk->flags & PF_EXITING)) {\n\t\t\tretval = cgroup_path_ns_locked(cgrp, buf, PATH_MAX,\n\t\t\t\t\t\tcurrent->nsproxy->cgroup_ns);\n\t\t\tif (retval >= PATH_MAX)\n\t\t\t\tretval = -ENAMETOOLONG;\n\t\t\tif (retval < 0)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tseq_puts(m, buf);\n\t\t} else {\n\t\t\tseq_puts(m, \"/\");\n\t\t}\n\n\t\tif (cgroup_on_dfl(cgrp) && cgroup_is_dead(cgrp))\n\t\t\tseq_puts(m, \" (deleted)\\n\");\n\t\telse\n\t\t\tseq_putc(m, '\\n');\n\t}\n\n\tretval = 0;\nout_unlock:\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\tkfree(buf);\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "cgroup_get_from_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5964-5984",
    "snippet": "struct cgroup *cgroup_get_from_id(u64 id)\n{\n\tstruct kernfs_node *kn;\n\tstruct cgroup *cgrp = NULL;\n\n\tkn = kernfs_find_and_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\tgoto out;\n\n\trcu_read_lock();\n\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (cgrp && !cgroup_tryget(cgrp))\n\t\tcgrp = NULL;\n\n\trcu_read_unlock();\n\n\tkernfs_put(kn);\nout:\n\treturn cgrp;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 5981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_tryget",
          "args": [
            "cgrp"
          ],
          "line": 5976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "*(void __rcu __force **)&kn->priv"
          ],
          "line": 5975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get_node_by_id",
          "args": [
            "cgrp_dfl_root.kf_root",
            "id"
          ],
          "line": 5969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_id(u64 id)\n{\n\tstruct kernfs_node *kn;\n\tstruct cgroup *cgrp = NULL;\n\n\tkn = kernfs_find_and_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\tgoto out;\n\n\trcu_read_lock();\n\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (cgrp && !cgroup_tryget(cgrp))\n\t\tcgrp = NULL;\n\n\trcu_read_unlock();\n\n\tkernfs_put(kn);\nout:\n\treturn cgrp;\n}"
  },
  {
    "function_name": "cgroup_path_from_kernfs_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5948-5957",
    "snippet": "void cgroup_path_from_kernfs_id(u64 id, char *buf, size_t buflen)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = kernfs_find_and_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\treturn;\n\tkernfs_path(kn, buf, buflen);\n\tkernfs_put(kn);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 5956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_path",
          "args": [
            "kn",
            "buf",
            "buflen"
          ],
          "line": 5955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_find_and_get_node_by_id",
          "args": [
            "cgrp_dfl_root.kf_root",
            "id"
          ],
          "line": 5952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\n\nvoid cgroup_path_from_kernfs_id(u64 id, char *buf, size_t buflen)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = kernfs_find_and_get_node_by_id(cgrp_dfl_root.kf_root, id);\n\tif (!kn)\n\t\treturn;\n\tkernfs_path(kn, buf, buflen);\n\tkernfs_put(kn);\n}"
  },
  {
    "function_name": "cgroup_wq_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5932-5945",
    "snippet": "static int __init cgroup_wq_init(void)\n{\n\t/*\n\t * There isn't much point in executing destruction path in\n\t * parallel.  Good chunk is serialized with cgroup_mutex anyway.\n\t * Use 1 for @max_active.\n\t *\n\t * We would prefer to do this in cgroup_init() above, but that\n\t * is called before init_workqueues(): so leave this until after.\n\t */\n\tcgroup_destroy_wq = alloc_workqueue(\"cgroup_destroy\", 0, 1);\n\tBUG_ON(!cgroup_destroy_wq);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *cgroup_destroy_wq;",
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cgroup_destroy_wq"
          ],
          "line": 5943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"cgroup_destroy\"",
            "0",
            "1"
          ],
          "line": 5942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct workqueue_struct *cgroup_destroy_wq;\nvoid __init;\n\nstatic int __init cgroup_wq_init(void)\n{\n\t/*\n\t * There isn't much point in executing destruction path in\n\t * parallel.  Good chunk is serialized with cgroup_mutex anyway.\n\t * Use 1 for @max_active.\n\t *\n\t * We would prefer to do this in cgroup_init() above, but that\n\t * is called before init_workqueues(): so leave this until after.\n\t */\n\tcgroup_destroy_wq = alloc_workqueue(\"cgroup_destroy\", 0, 1);\n\tBUG_ON(!cgroup_destroy_wq);\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5829-5930",
    "snippet": "int __init cgroup_init(void)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tBUILD_BUG_ON(CGROUP_SUBSYS_COUNT > 16);\n\tBUG_ON(cgroup_init_cftypes(NULL, cgroup_base_files));\n\tBUG_ON(cgroup_init_cftypes(NULL, cgroup1_base_files));\n\n\tcgroup_rstat_boot();\n\n\t/*\n\t * The latency of the synchronize_rcu() is too high for cgroups,\n\t * avoid it at the cost of forcing all readers into the slow path.\n\t */\n\trcu_sync_enter_start(&cgroup_threadgroup_rwsem.rss);\n\n\tget_user_ns(init_cgroup_ns.user_ns);\n\n\tmutex_lock(&cgroup_mutex);\n\n\t/*\n\t * Add init_css_set to the hash table so that dfl_root can link to\n\t * it during init.\n\t */\n\thash_add(css_set_table, &init_css_set.hlist,\n\t\t css_set_hash(init_css_set.subsys));\n\n\tBUG_ON(cgroup_setup_root(&cgrp_dfl_root, 0));\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (ss->early_init) {\n\t\t\tstruct cgroup_subsys_state *css =\n\t\t\t\tinit_css_set.subsys[ss->id];\n\n\t\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tBUG_ON(css->id < 0);\n\t\t} else {\n\t\t\tcgroup_init_subsys(ss, false);\n\t\t}\n\n\t\tlist_add_tail(&init_css_set.e_cset_node[ssid],\n\t\t\t      &cgrp_dfl_root.cgrp.e_csets[ssid]);\n\n\t\t/*\n\t\t * Setting dfl_root subsys_mask needs to consider the\n\t\t * disabled flag and cftype registration needs kmalloc,\n\t\t * both of which aren't available during early_init.\n\t\t */\n\t\tif (!cgroup_ssid_enabled(ssid))\n\t\t\tcontinue;\n\n\t\tif (cgroup1_ssid_disabled(ssid))\n\t\t\tprintk(KERN_INFO \"Disabling %s control group subsystem in v1 mounts\\n\",\n\t\t\t       ss->name);\n\n\t\tcgrp_dfl_root.subsys_mask |= 1 << ss->id;\n\n\t\t/* implicit controllers must be threaded too */\n\t\tWARN_ON(ss->implicit_on_dfl && !ss->threaded);\n\n\t\tif (ss->implicit_on_dfl)\n\t\t\tcgrp_dfl_implicit_ss_mask |= 1 << ss->id;\n\t\telse if (!ss->dfl_cftypes)\n\t\t\tcgrp_dfl_inhibit_ss_mask |= 1 << ss->id;\n\n\t\tif (ss->threaded)\n\t\t\tcgrp_dfl_threaded_ss_mask |= 1 << ss->id;\n\n\t\tif (ss->dfl_cftypes == ss->legacy_cftypes) {\n\t\t\tWARN_ON(cgroup_add_cftypes(ss, ss->dfl_cftypes));\n\t\t} else {\n\t\t\tWARN_ON(cgroup_add_dfl_cftypes(ss, ss->dfl_cftypes));\n\t\t\tWARN_ON(cgroup_add_legacy_cftypes(ss, ss->legacy_cftypes));\n\t\t}\n\n\t\tif (ss->bind)\n\t\t\tss->bind(init_css_set.subsys[ssid]);\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tcss_populate_dir(init_css_set.subsys[ssid]);\n\t\tmutex_unlock(&cgroup_mutex);\n\t}\n\n\t/* init_css_set.subsys[] has been updated, re-hash */\n\thash_del(&init_css_set.hlist);\n\thash_add(css_set_table, &init_css_set.hlist,\n\t\t css_set_hash(init_css_set.subsys));\n\n\tWARN_ON(sysfs_create_mount_point(fs_kobj, \"cgroup\"));\n\tWARN_ON(register_filesystem(&cgroup_fs_type));\n\tWARN_ON(register_filesystem(&cgroup2_fs_type));\n\tWARN_ON(!proc_create_single(\"cgroups\", 0, NULL, proc_cgroupstats_show));\n#ifdef CONFIG_CPUSETS\n\tWARN_ON(register_filesystem(&cpuset_fs_type));\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static u16 cgrp_dfl_inhibit_ss_mask;",
      "static u16 cgrp_dfl_implicit_ss_mask;",
      "static u16 cgrp_dfl_threaded_ss_mask;",
      "struct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};",
      "static struct file_system_type cgroup2_fs_type;",
      "static struct cftype cgroup_base_files[];",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};",
      "struct file_system_type cgroup_fs_type = {\n\t.name\t\t\t= \"cgroup\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup1_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};",
      "static struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};",
      "static struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};",
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "register_filesystem(&cpuset_fs_type)"
          ],
          "line": 5926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&cpuset_fs_type"
          ],
          "line": 5926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!proc_create_single(\"cgroups\", 0, NULL, proc_cgroupstats_show)"
          ],
          "line": 5924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single",
          "args": [
            "\"cgroups\"",
            "0",
            "NULL",
            "proc_cgroupstats_show"
          ],
          "line": 5924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "register_filesystem(&cgroup2_fs_type)"
          ],
          "line": 5923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&cgroup2_fs_type"
          ],
          "line": 5923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "register_filesystem(&cgroup_fs_type)"
          ],
          "line": 5922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&cgroup_fs_type"
          ],
          "line": 5922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sysfs_create_mount_point(fs_kobj, \"cgroup\")"
          ],
          "line": 5921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_mount_point",
          "args": [
            "fs_kobj",
            "\"cgroup\""
          ],
          "line": 5921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "css_set_table",
            "&init_css_set.hlist",
            "css_set_hash(init_css_set.subsys)"
          ],
          "line": 5918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_hash",
          "args": [
            "init_css_set.subsys"
          ],
          "line": 5919
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "942-953",
          "snippet": "static unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&init_css_set.hlist"
          ],
          "line": 5917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_populate_dir",
          "args": [
            "init_css_set.subsys[ssid]"
          ],
          "line": 5912
        },
        "resolved": true,
        "details": {
          "function_name": "css_populate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1699-1737",
          "snippet": "static int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);",
            "static struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};\n\nstatic int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->bind",
          "args": [
            "init_css_set.subsys[ssid]"
          ],
          "line": 5909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_add_legacy_cftypes(ss, ss->legacy_cftypes)"
          ],
          "line": 5905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_legacy_cftypes",
          "args": [
            "ss",
            "ss->legacy_cftypes"
          ],
          "line": 5905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_add_dfl_cftypes(ss, ss->dfl_cftypes)"
          ],
          "line": 5904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_dfl_cftypes",
          "args": [
            "ss",
            "ss->dfl_cftypes"
          ],
          "line": 5904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_add_cftypes(ss, ss->dfl_cftypes)"
          ],
          "line": 5902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_cftypes",
          "args": [
            "ss",
            "ss->dfl_cftypes"
          ],
          "line": 5902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ss->implicit_on_dfl && !ss->threaded"
          ],
          "line": 5891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Disabling %s control group subsystem in v1 mounts\\n\"",
            "ss->name"
          ],
          "line": 5885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup1_ssid_disabled",
          "args": [
            "ssid"
          ],
          "line": 5884
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup1_ssid_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-v1.c",
          "lines": "44-47",
          "snippet": "bool cgroup1_ssid_disabled(int ssid)\n{\n\treturn cgroup_no_v1_mask & (1 << ssid);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/delay.h>",
            "#include <linux/sort.h>",
            "#include <linux/kmod.h>",
            "#include <linux/ctype.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgroup_no_v1_mask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include <linux/fs_parser.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgroup_no_v1_mask;\n\nbool cgroup1_ssid_disabled(int ssid)\n{\n\treturn cgroup_no_v1_mask & (1 << ssid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_ssid_enabled",
          "args": [
            "ssid"
          ],
          "line": 5881
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_ssid_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "258-264",
          "snippet": "bool cgroup_ssid_enabled(int ssid)\n{\n\tif (!CGROUP_HAS_SUBSYS_CONFIG)\n\t\treturn false;\n\n\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};\n\nbool cgroup_ssid_enabled(int ssid)\n{\n\tif (!CGROUP_HAS_SUBSYS_CONFIG)\n\t\treturn false;\n\n\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&init_css_set.e_cset_node[ssid]",
            "&cgrp_dfl_root.cgrp.e_csets[ssid]"
          ],
          "line": 5873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init_subsys",
          "args": [
            "ss",
            "false"
          ],
          "line": 5870
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_init_subsys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5733-5784",
          "snippet": "static void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(NULL);\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_release_callback |= (bool)ss->release << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static u16 have_fork_callback",
            "static u16 have_exit_callback",
            "static u16 have_release_callback",
            "static u16 have_canfork_callback",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);",
            "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};",
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic u16 have_fork_callback;\nstatic u16 have_exit_callback;\nstatic u16 have_release_callback;\nstatic u16 have_canfork_callback;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\nvoid __init;\n\nstatic void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(NULL);\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_release_callback |= (bool)ss->release << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "css->id < 0"
          ],
          "line": 5868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_idr_alloc",
          "args": [
            "&ss->css_idr",
            "css",
            "1",
            "2",
            "GFP_KERNEL"
          ],
          "line": 5866
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "319-330",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 5861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cgroup_setup_root(&cgrp_dfl_root, 0)"
          ],
          "line": 5857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_setup_root",
          "args": [
            "&cgrp_dfl_root",
            "0"
          ],
          "line": 5857
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_setup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1986-2087",
          "snippet": "int cgroup_setup_root(struct cgroup_root *root, u16 ss_mask)\n{\n\tLIST_HEAD(tmp_links);\n\tstruct cgroup *root_cgrp = &root->cgrp;\n\tstruct kernfs_syscall_ops *kf_sops;\n\tstruct css_set *cset;\n\tint i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tret = percpu_ref_init(&root_cgrp->self.refcnt, css_release,\n\t\t\t      0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * We're accessing css_set_count without locking css_set_lock here,\n\t * but that's OK - it can only be increased by someone holding\n\t * cgroup_lock, and that's us.  Later rebinding may disable\n\t * controllers on the default hierarchy and thus create new csets,\n\t * which can't be more than the existing ones.  Allocate 2x.\n\t */\n\tret = allocate_cgrp_cset_links(2 * css_set_count, &tmp_links);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tret = cgroup_init_root_id(root);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tkf_sops = root == &cgrp_dfl_root ?\n\t\t&cgroup_kf_syscall_ops : &cgroup1_kf_syscall_ops;\n\n\troot->kf_root = kernfs_create_root(kf_sops,\n\t\t\t\t\t   KERNFS_ROOT_CREATE_DEACTIVATED |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_EXPORTOP |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_USER_XATTR,\n\t\t\t\t\t   root_cgrp);\n\tif (IS_ERR(root->kf_root)) {\n\t\tret = PTR_ERR(root->kf_root);\n\t\tgoto exit_root_id;\n\t}\n\troot_cgrp->kn = root->kf_root->kn;\n\tWARN_ON_ONCE(cgroup_ino(root_cgrp) != 1);\n\troot_cgrp->ancestor_ids[0] = cgroup_id(root_cgrp);\n\n\tret = css_populate_dir(&root_cgrp->self);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = cgroup_rstat_init(root_cgrp);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = rebind_subsystems(root, ss_mask);\n\tif (ret)\n\t\tgoto exit_stats;\n\n\tret = cgroup_bpf_inherit(root_cgrp);\n\tWARN_ON_ONCE(ret);\n\n\ttrace_cgroup_setup_root(root);\n\n\t/*\n\t * There must be no failure case after here, since rebinding takes\n\t * care of subsystems' refcounts, which are explicitly dropped in\n\t * the failure exit path.\n\t */\n\tlist_add(&root->root_list, &cgroup_roots);\n\tcgroup_root_count++;\n\n\t/*\n\t * Link the root cgroup in this hierarchy into all the css_set\n\t * objects.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\thash_for_each(css_set_table, i, cset, hlist) {\n\t\tlink_css_set(&tmp_links, cset, root_cgrp);\n\t\tif (css_set_populated(cset))\n\t\t\tcgroup_update_populated(root_cgrp, true);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tBUG_ON(!list_empty(&root_cgrp->self.children));\n\tBUG_ON(atomic_read(&root->nr_cgrps) != 1);\n\n\tret = 0;\n\tgoto out;\n\nexit_stats:\n\tcgroup_rstat_exit(root_cgrp);\ndestroy_root:\n\tkernfs_destroy_root(root->kf_root);\n\troot->kf_root = NULL;\nexit_root_id:\n\tcgroup_exit_root_id(root);\ncancel_ref:\n\tpercpu_ref_exit(&root_cgrp->self.refcnt);\nout:\n\tfree_cgrp_cset_links(&tmp_links);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_root_count;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static int css_set_count\t= 1;",
            "static struct kernfs_syscall_ops cgroup_kf_syscall_ops;",
            "static struct kernfs_syscall_ops cgroup_kf_syscall_ops = {\n\t.show_options\t\t= cgroup_show_options,\n\t.mkdir\t\t\t= cgroup_mkdir,\n\t.rmdir\t\t\t= cgroup_rmdir,\n\t.show_path\t\t= cgroup_show_path,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic int css_set_count\t= 1;\nstatic struct kernfs_syscall_ops cgroup_kf_syscall_ops;\nstatic struct kernfs_syscall_ops cgroup_kf_syscall_ops = {\n\t.show_options\t\t= cgroup_show_options,\n\t.mkdir\t\t\t= cgroup_mkdir,\n\t.rmdir\t\t\t= cgroup_rmdir,\n\t.show_path\t\t= cgroup_show_path,\n};\n\nint cgroup_setup_root(struct cgroup_root *root, u16 ss_mask)\n{\n\tLIST_HEAD(tmp_links);\n\tstruct cgroup *root_cgrp = &root->cgrp;\n\tstruct kernfs_syscall_ops *kf_sops;\n\tstruct css_set *cset;\n\tint i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tret = percpu_ref_init(&root_cgrp->self.refcnt, css_release,\n\t\t\t      0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * We're accessing css_set_count without locking css_set_lock here,\n\t * but that's OK - it can only be increased by someone holding\n\t * cgroup_lock, and that's us.  Later rebinding may disable\n\t * controllers on the default hierarchy and thus create new csets,\n\t * which can't be more than the existing ones.  Allocate 2x.\n\t */\n\tret = allocate_cgrp_cset_links(2 * css_set_count, &tmp_links);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tret = cgroup_init_root_id(root);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tkf_sops = root == &cgrp_dfl_root ?\n\t\t&cgroup_kf_syscall_ops : &cgroup1_kf_syscall_ops;\n\n\troot->kf_root = kernfs_create_root(kf_sops,\n\t\t\t\t\t   KERNFS_ROOT_CREATE_DEACTIVATED |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_EXPORTOP |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_USER_XATTR,\n\t\t\t\t\t   root_cgrp);\n\tif (IS_ERR(root->kf_root)) {\n\t\tret = PTR_ERR(root->kf_root);\n\t\tgoto exit_root_id;\n\t}\n\troot_cgrp->kn = root->kf_root->kn;\n\tWARN_ON_ONCE(cgroup_ino(root_cgrp) != 1);\n\troot_cgrp->ancestor_ids[0] = cgroup_id(root_cgrp);\n\n\tret = css_populate_dir(&root_cgrp->self);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = cgroup_rstat_init(root_cgrp);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = rebind_subsystems(root, ss_mask);\n\tif (ret)\n\t\tgoto exit_stats;\n\n\tret = cgroup_bpf_inherit(root_cgrp);\n\tWARN_ON_ONCE(ret);\n\n\ttrace_cgroup_setup_root(root);\n\n\t/*\n\t * There must be no failure case after here, since rebinding takes\n\t * care of subsystems' refcounts, which are explicitly dropped in\n\t * the failure exit path.\n\t */\n\tlist_add(&root->root_list, &cgroup_roots);\n\tcgroup_root_count++;\n\n\t/*\n\t * Link the root cgroup in this hierarchy into all the css_set\n\t * objects.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\thash_for_each(css_set_table, i, cset, hlist) {\n\t\tlink_css_set(&tmp_links, cset, root_cgrp);\n\t\tif (css_set_populated(cset))\n\t\t\tcgroup_update_populated(root_cgrp, true);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tBUG_ON(!list_empty(&root_cgrp->self.children));\n\tBUG_ON(atomic_read(&root->nr_cgrps) != 1);\n\n\tret = 0;\n\tgoto out;\n\nexit_stats:\n\tcgroup_rstat_exit(root_cgrp);\ndestroy_root:\n\tkernfs_destroy_root(root->kf_root);\n\troot->kf_root = NULL;\nexit_root_id:\n\tcgroup_exit_root_id(root);\ncancel_ref:\n\tpercpu_ref_exit(&root_cgrp->self.refcnt);\nout:\n\tfree_cgrp_cset_links(&tmp_links);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "css_set_table",
            "&init_css_set.hlist",
            "css_set_hash(init_css_set.subsys)"
          ],
          "line": 5854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "init_cgroup_ns.user_ns"
          ],
          "line": 5846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_sync_enter_start",
          "args": [
            "&cgroup_threadgroup_rwsem.rss"
          ],
          "line": 5844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_boot",
          "args": [],
          "line": 5838
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_boot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "286-292",
          "snippet": "void __init cgroup_rstat_boot(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\traw_spin_lock_init(per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu));\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);",
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_PER_CPU(raw_spinlock_t, cgroup_rstat_cpu_lock);\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid __init cgroup_rstat_boot(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\traw_spin_lock_init(per_cpu_ptr(&cgroup_rstat_cpu_lock, cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cgroup_init_cftypes(NULL, cgroup1_base_files)"
          ],
          "line": 5836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init_cftypes",
          "args": [
            "NULL",
            "cgroup1_base_files"
          ],
          "line": 5836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cgroup_init_cftypes(NULL, cgroup_base_files)"
          ],
          "line": 5835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init_cftypes",
          "args": [
            "NULL",
            "cgroup_base_files"
          ],
          "line": 5835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "CGROUP_SUBSYS_COUNT > 16"
          ],
          "line": 5834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic u16 cgrp_dfl_inhibit_ss_mask;\nstatic u16 cgrp_dfl_implicit_ss_mask;\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstruct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\nstatic struct file_system_type cgroup2_fs_type;\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\nstruct file_system_type cgroup_fs_type = {\n\t.name\t\t\t= \"cgroup\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup1_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\nstatic struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};\nvoid __init;\n\nint __init cgroup_init(void)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tBUILD_BUG_ON(CGROUP_SUBSYS_COUNT > 16);\n\tBUG_ON(cgroup_init_cftypes(NULL, cgroup_base_files));\n\tBUG_ON(cgroup_init_cftypes(NULL, cgroup1_base_files));\n\n\tcgroup_rstat_boot();\n\n\t/*\n\t * The latency of the synchronize_rcu() is too high for cgroups,\n\t * avoid it at the cost of forcing all readers into the slow path.\n\t */\n\trcu_sync_enter_start(&cgroup_threadgroup_rwsem.rss);\n\n\tget_user_ns(init_cgroup_ns.user_ns);\n\n\tmutex_lock(&cgroup_mutex);\n\n\t/*\n\t * Add init_css_set to the hash table so that dfl_root can link to\n\t * it during init.\n\t */\n\thash_add(css_set_table, &init_css_set.hlist,\n\t\t css_set_hash(init_css_set.subsys));\n\n\tBUG_ON(cgroup_setup_root(&cgrp_dfl_root, 0));\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (ss->early_init) {\n\t\t\tstruct cgroup_subsys_state *css =\n\t\t\t\tinit_css_set.subsys[ss->id];\n\n\t\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tBUG_ON(css->id < 0);\n\t\t} else {\n\t\t\tcgroup_init_subsys(ss, false);\n\t\t}\n\n\t\tlist_add_tail(&init_css_set.e_cset_node[ssid],\n\t\t\t      &cgrp_dfl_root.cgrp.e_csets[ssid]);\n\n\t\t/*\n\t\t * Setting dfl_root subsys_mask needs to consider the\n\t\t * disabled flag and cftype registration needs kmalloc,\n\t\t * both of which aren't available during early_init.\n\t\t */\n\t\tif (!cgroup_ssid_enabled(ssid))\n\t\t\tcontinue;\n\n\t\tif (cgroup1_ssid_disabled(ssid))\n\t\t\tprintk(KERN_INFO \"Disabling %s control group subsystem in v1 mounts\\n\",\n\t\t\t       ss->name);\n\n\t\tcgrp_dfl_root.subsys_mask |= 1 << ss->id;\n\n\t\t/* implicit controllers must be threaded too */\n\t\tWARN_ON(ss->implicit_on_dfl && !ss->threaded);\n\n\t\tif (ss->implicit_on_dfl)\n\t\t\tcgrp_dfl_implicit_ss_mask |= 1 << ss->id;\n\t\telse if (!ss->dfl_cftypes)\n\t\t\tcgrp_dfl_inhibit_ss_mask |= 1 << ss->id;\n\n\t\tif (ss->threaded)\n\t\t\tcgrp_dfl_threaded_ss_mask |= 1 << ss->id;\n\n\t\tif (ss->dfl_cftypes == ss->legacy_cftypes) {\n\t\t\tWARN_ON(cgroup_add_cftypes(ss, ss->dfl_cftypes));\n\t\t} else {\n\t\t\tWARN_ON(cgroup_add_dfl_cftypes(ss, ss->dfl_cftypes));\n\t\t\tWARN_ON(cgroup_add_legacy_cftypes(ss, ss->legacy_cftypes));\n\t\t}\n\n\t\tif (ss->bind)\n\t\t\tss->bind(init_css_set.subsys[ssid]);\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tcss_populate_dir(init_css_set.subsys[ssid]);\n\t\tmutex_unlock(&cgroup_mutex);\n\t}\n\n\t/* init_css_set.subsys[] has been updated, re-hash */\n\thash_del(&init_css_set.hlist);\n\thash_add(css_set_table, &init_css_set.hlist,\n\t\t css_set_hash(init_css_set.subsys));\n\n\tWARN_ON(sysfs_create_mount_point(fs_kobj, \"cgroup\"));\n\tWARN_ON(register_filesystem(&cgroup_fs_type));\n\tWARN_ON(register_filesystem(&cgroup2_fs_type));\n\tWARN_ON(!proc_create_single(\"cgroups\", 0, NULL, proc_cgroupstats_show));\n#ifdef CONFIG_CPUSETS\n\tWARN_ON(register_filesystem(&cpuset_fs_type));\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_init_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5792-5821",
    "snippet": "int __init cgroup_init_early(void)\n{\n\tstatic struct cgroup_fs_context __initdata ctx;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tctx.root = &cgrp_dfl_root;\n\tinit_cgroup_root(&ctx);\n\tcgrp_dfl_root.cgrp.self.flags |= CSS_NO_REF;\n\n\tRCU_INIT_POINTER(init_task.cgroups, &init_css_set);\n\n\tfor_each_subsys(ss, i) {\n\t\tWARN(!ss->css_alloc || !ss->css_free || ss->name || ss->id,\n\t\t     \"invalid cgroup_subsys %d:%s css_alloc=%p css_free=%p id:name=%d:%s\\n\",\n\t\t     i, cgroup_subsys_name[i], ss->css_alloc, ss->css_free,\n\t\t     ss->id, ss->name);\n\t\tWARN(strlen(cgroup_subsys_name[i]) > MAX_CGROUP_TYPE_NAMELEN,\n\t\t     \"cgroup_subsys_name %s too long\\n\", cgroup_subsys_name[i]);\n\n\t\tss->id = i;\n\t\tss->name = cgroup_subsys_name[i];\n\t\tif (!ss->legacy_name)\n\t\t\tss->legacy_name = cgroup_subsys_name[i];\n\n\t\tif (ss->early_init)\n\t\t\tcgroup_init_subsys(ss, true);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *cgroup_subsys_name[] = {\n#include <linux/cgroup_subsys.h>\n};",
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};",
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_init_subsys",
          "args": [
            "ss",
            "true"
          ],
          "line": 5818
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_init_subsys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5733-5784",
          "snippet": "static void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(NULL);\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_release_callback |= (bool)ss->release << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static u16 have_fork_callback",
            "static u16 have_exit_callback",
            "static u16 have_release_callback",
            "static u16 have_canfork_callback",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);",
            "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};",
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic u16 have_fork_callback;\nstatic u16 have_exit_callback;\nstatic u16 have_release_callback;\nstatic u16 have_canfork_callback;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\nvoid __init;\n\nstatic void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(NULL);\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_release_callback |= (bool)ss->release << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "strlen(cgroup_subsys_name[i]) > MAX_CGROUP_TYPE_NAMELEN",
            "\"cgroup_subsys_name %s too long\\n\"",
            "cgroup_subsys_name[i]"
          ],
          "line": 5809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cgroup_subsys_name[i]"
          ],
          "line": 5809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!ss->css_alloc || !ss->css_free || ss->name || ss->id",
            "\"invalid cgroup_subsys %d:%s css_alloc=%p css_free=%p id:name=%d:%s\\n\"",
            "i",
            "cgroup_subsys_name[i]",
            "ss->css_alloc",
            "ss->css_free",
            "ss->id",
            "ss->name"
          ],
          "line": 5805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "i"
          ],
          "line": 5804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "init_task.cgroups",
            "&init_css_set"
          ],
          "line": 5802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cgroup_root",
          "args": [
            "&ctx"
          ],
          "line": 5799
        },
        "resolved": true,
        "details": {
          "function_name": "init_cgroup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1967-1984",
          "snippet": "void init_cgroup_root(struct cgroup_fs_context *ctx)\n{\n\tstruct cgroup_root *root = ctx->root;\n\tstruct cgroup *cgrp = &root->cgrp;\n\n\tINIT_LIST_HEAD(&root->root_list);\n\tatomic_set(&root->nr_cgrps, 1);\n\tcgrp->root = root;\n\tinit_cgroup_housekeeping(cgrp);\n\n\troot->flags = ctx->flags;\n\tif (ctx->release_agent)\n\t\tstrscpy(root->release_agent_path, ctx->release_agent, PATH_MAX);\n\tif (ctx->name)\n\t\tstrscpy(root->name, ctx->name, MAX_CGROUP_ROOT_NAMELEN);\n\tif (ctx->cpuset_clone_children)\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &root->cgrp.flags);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid init_cgroup_root(struct cgroup_fs_context *ctx)\n{\n\tstruct cgroup_root *root = ctx->root;\n\tstruct cgroup *cgrp = &root->cgrp;\n\n\tINIT_LIST_HEAD(&root->root_list);\n\tatomic_set(&root->nr_cgrps, 1);\n\tcgrp->root = root;\n\tinit_cgroup_housekeeping(cgrp);\n\n\troot->flags = ctx->flags;\n\tif (ctx->release_agent)\n\t\tstrscpy(root->release_agent_path, ctx->release_agent, PATH_MAX);\n\tif (ctx->name)\n\t\tstrscpy(root->name, ctx->name, MAX_CGROUP_ROOT_NAMELEN);\n\tif (ctx->cpuset_clone_children)\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &root->cgrp.flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic const char *cgroup_subsys_name[] = {\n#include <linux/cgroup_subsys.h>\n};\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\nvoid __init;\n\nint __init cgroup_init_early(void)\n{\n\tstatic struct cgroup_fs_context __initdata ctx;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tctx.root = &cgrp_dfl_root;\n\tinit_cgroup_root(&ctx);\n\tcgrp_dfl_root.cgrp.self.flags |= CSS_NO_REF;\n\n\tRCU_INIT_POINTER(init_task.cgroups, &init_css_set);\n\n\tfor_each_subsys(ss, i) {\n\t\tWARN(!ss->css_alloc || !ss->css_free || ss->name || ss->id,\n\t\t     \"invalid cgroup_subsys %d:%s css_alloc=%p css_free=%p id:name=%d:%s\\n\",\n\t\t     i, cgroup_subsys_name[i], ss->css_alloc, ss->css_free,\n\t\t     ss->id, ss->name);\n\t\tWARN(strlen(cgroup_subsys_name[i]) > MAX_CGROUP_TYPE_NAMELEN,\n\t\t     \"cgroup_subsys_name %s too long\\n\", cgroup_subsys_name[i]);\n\n\t\tss->id = i;\n\t\tss->name = cgroup_subsys_name[i];\n\t\tif (!ss->legacy_name)\n\t\t\tss->legacy_name = cgroup_subsys_name[i];\n\n\t\tif (ss->early_init)\n\t\t\tcgroup_init_subsys(ss, true);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_init_subsys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5733-5784",
    "snippet": "static void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(NULL);\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_release_callback |= (bool)ss->release << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static u16 have_fork_callback",
      "static u16 have_exit_callback",
      "static u16 have_release_callback",
      "static u16 have_canfork_callback",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);",
      "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};",
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "online_css(css)"
          ],
          "line": 5781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "online_css",
          "args": [
            "css"
          ],
          "line": 5781
        },
        "resolved": true,
        "details": {
          "function_name": "online_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5241-5259",
          "snippet": "static int online_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (ss->css_online)\n\t\tret = ss->css_online(css);\n\tif (!ret) {\n\t\tcss->flags |= CSS_ONLINE;\n\t\trcu_assign_pointer(css->cgroup->subsys[ss->id], css);\n\n\t\tatomic_inc(&css->online_cnt);\n\t\tif (css->parent)\n\t\t\tatomic_inc(&css->parent->online_cnt);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic int online_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (ss->css_online)\n\t\tret = ss->css_online(css);\n\tif (!ret) {\n\t\tcss->flags |= CSS_ONLINE;\n\t\trcu_assign_pointer(css->cgroup->subsys[ss->id], css);\n\n\t\tatomic_inc(&css->online_cnt);\n\t\tif (css->parent)\n\t\t\tatomic_inc(&css->parent->online_cnt);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&init_task.tasks)"
          ],
          "line": 5779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&init_task.tasks"
          ],
          "line": 5779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "css->id < 0"
          ],
          "line": 5762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_idr_alloc",
          "args": [
            "&ss->css_idr",
            "css",
            "1",
            "2",
            "GFP_KERNEL"
          ],
          "line": 5761
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "319-330",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_and_link_css",
          "args": [
            "css",
            "ss",
            "&cgrp_dfl_root.cgrp"
          ],
          "line": 5749
        },
        "resolved": true,
        "details": {
          "function_name": "init_and_link_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5212-5238",
          "snippet": "static void init_and_link_css(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup_subsys *ss, struct cgroup *cgrp)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_get_live(cgrp);\n\n\tmemset(css, 0, sizeof(*css));\n\tcss->cgroup = cgrp;\n\tcss->ss = ss;\n\tcss->id = -1;\n\tINIT_LIST_HEAD(&css->sibling);\n\tINIT_LIST_HEAD(&css->children);\n\tINIT_LIST_HEAD(&css->rstat_css_node);\n\tcss->serial_nr = css_serial_nr_next++;\n\tatomic_set(&css->online_cnt, 0);\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcss->parent = cgroup_css(cgroup_parent(cgrp), ss);\n\t\tcss_get(css->parent);\n\t}\n\n\tif (ss->css_rstat_flush)\n\t\tlist_add_rcu(&css->rstat_css_node, &cgrp->rstat_css_list);\n\n\tBUG_ON(cgroup_css(cgrp, ss));\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 css_serial_nr_next = 1;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u64 css_serial_nr_next = 1;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void init_and_link_css(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup_subsys *ss, struct cgroup *cgrp)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_get_live(cgrp);\n\n\tmemset(css, 0, sizeof(*css));\n\tcss->cgroup = cgrp;\n\tcss->ss = ss;\n\tcss->id = -1;\n\tINIT_LIST_HEAD(&css->sibling);\n\tINIT_LIST_HEAD(&css->children);\n\tINIT_LIST_HEAD(&css->rstat_css_node);\n\tcss->serial_nr = css_serial_nr_next++;\n\tatomic_set(&css->online_cnt, 0);\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcss->parent = cgroup_css(cgroup_parent(cgrp), ss);\n\t\tcss_get(css->parent);\n\t}\n\n\tif (ss->css_rstat_flush)\n\t\tlist_add_rcu(&css->rstat_css_node, &cgrp->rstat_css_list);\n\n\tBUG_ON(cgroup_css(cgrp, ss));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(css)"
          ],
          "line": 5748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "css"
          ],
          "line": 5748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_alloc",
          "args": [
            "NULL"
          ],
          "line": 5746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ss->cfts"
          ],
          "line": 5742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_init",
          "args": [
            "&ss->css_idr"
          ],
          "line": 5741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Initializing cgroup subsys %s\\n\"",
            "ss->name"
          ],
          "line": 5737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic u16 have_fork_callback;\nstatic u16 have_exit_callback;\nstatic u16 have_release_callback;\nstatic u16 have_canfork_callback;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\nvoid __init;\n\nstatic void __init cgroup_init_subsys(struct cgroup_subsys *ss, bool early)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tpr_debug(\"Initializing cgroup subsys %s\\n\", ss->name);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tidr_init(&ss->css_idr);\n\tINIT_LIST_HEAD(&ss->cfts);\n\n\t/* Create the root cgroup state for this subsystem */\n\tss->root = &cgrp_dfl_root;\n\tcss = ss->css_alloc(NULL);\n\t/* We don't handle early failures gracefully */\n\tBUG_ON(IS_ERR(css));\n\tinit_and_link_css(css, ss, &cgrp_dfl_root.cgrp);\n\n\t/*\n\t * Root csses are never destroyed and we can't initialize\n\t * percpu_ref during early init.  Disable refcnting.\n\t */\n\tcss->flags |= CSS_NO_REF;\n\n\tif (early) {\n\t\t/* allocation can't be done safely during early init */\n\t\tcss->id = 1;\n\t} else {\n\t\tcss->id = cgroup_idr_alloc(&ss->css_idr, css, 1, 2, GFP_KERNEL);\n\t\tBUG_ON(css->id < 0);\n\t}\n\n\t/* Update the init_css_set to contain a subsys\n\t * pointer to this state - since the subsystem is\n\t * newly registered, all tasks and hence the\n\t * init_css_set is in the subsystem's root cgroup. */\n\tinit_css_set.subsys[ss->id] = css;\n\n\thave_fork_callback |= (bool)ss->fork << ss->id;\n\thave_exit_callback |= (bool)ss->exit << ss->id;\n\thave_release_callback |= (bool)ss->release << ss->id;\n\thave_canfork_callback |= (bool)ss->can_fork << ss->id;\n\n\t/* At system boot, before all subsystems have been\n\t * registered, no tasks have been forked, so we don't\n\t * need to invoke fork callbacks here. */\n\tBUG_ON(!list_empty(&init_task.tasks));\n\n\tBUG_ON(online_css(css));\n\n\tmutex_unlock(&cgroup_mutex);\n}"
  },
  {
    "function_name": "cgroup_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5709-5724",
    "snippet": "int cgroup_rmdir(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\tint ret = 0;\n\n\tcgrp = cgroup_kn_lock_live(kn, false);\n\tif (!cgrp)\n\t\treturn 0;\n\n\tret = cgroup_destroy_locked(cgrp);\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(rmdir, cgrp);\n\n\tcgroup_kn_unlock(kn);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_kn_unlock",
          "args": [
            "kn"
          ],
          "line": 5722
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1583-1596",
          "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "rmdir",
            "cgrp"
          ],
          "line": 5720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_destroy_locked",
          "args": [
            "cgrp"
          ],
          "line": 5718
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_destroy_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5637-5707",
          "snippet": "static int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tspin_lock_irq(&css_set_lock);\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t\t/*\n\t\t * If the dying cgroup is frozen, decrease frozen descendants\n\t\t * counters of ancestor cgroups.\n\t\t */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\ttcgrp->freezer.nr_frozen_descendants--;\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tcgroup1_check_for_release(parent);\n\n\tcgroup_bpf_offline(cgrp);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static void css_release(struct percpu_ref *ref);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tspin_lock_irq(&css_set_lock);\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t\t/*\n\t\t * If the dying cgroup is frozen, decrease frozen descendants\n\t\t * counters of ancestor cgroups.\n\t\t */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\ttcgrp->freezer.nr_frozen_descendants--;\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tcgroup1_check_for_release(parent);\n\n\tcgroup_bpf_offline(cgrp);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_kn_lock_live",
          "args": [
            "kn",
            "false"
          ],
          "line": 5714
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_lock_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1615-1644",
          "snippet": "struct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_rmdir(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\tint ret = 0;\n\n\tcgrp = cgroup_kn_lock_live(kn, false);\n\tif (!cgrp)\n\t\treturn 0;\n\n\tret = cgroup_destroy_locked(cgrp);\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(rmdir, cgrp);\n\n\tcgroup_kn_unlock(kn);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_destroy_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5637-5707",
    "snippet": "static int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tspin_lock_irq(&css_set_lock);\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t\t/*\n\t\t * If the dying cgroup is frozen, decrease frozen descendants\n\t\t * counters of ancestor cgroups.\n\t\t */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\ttcgrp->freezer.nr_frozen_descendants--;\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tcgroup1_check_for_release(parent);\n\n\tcgroup_bpf_offline(cgrp);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static void css_release(struct percpu_ref *ref);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_kill",
          "args": [
            "&cgrp->self.refcnt"
          ],
          "line": 5704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_offline",
          "args": [
            "cgrp"
          ],
          "line": 5701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup1_check_for_release",
          "args": [
            "parent"
          ],
          "line": 5699
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup1_check_for_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-v1.c",
          "lines": "741-746",
          "snippet": "void cgroup1_check_for_release(struct cgroup *cgrp)\n{\n\tif (notify_on_release(cgrp) && !cgroup_is_populated(cgrp) &&\n\t    !css_has_online_children(&cgrp->self) && !cgroup_is_dead(cgrp))\n\t\tschedule_work(&cgrp->release_agent_work);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/delay.h>",
            "#include <linux/sort.h>",
            "#include <linux/kmod.h>",
            "#include <linux/ctype.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include <linux/fs_parser.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup1_check_for_release(struct cgroup *cgrp)\n{\n\tif (notify_on_release(cgrp) && !cgroup_is_populated(cgrp) &&\n\t    !css_has_online_children(&cgrp->self) && !cgroup_is_dead(cgrp))\n\t\tschedule_work(&cgrp->release_agent_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 5694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "tcgrp"
          ],
          "line": 5687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 5687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 5683
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "354-357",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_remove",
          "args": [
            "cgrp->kn"
          ],
          "line": 5681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_clear_dir",
          "args": [
            "&cgrp->self"
          ],
          "line": 5680
        },
        "resolved": true,
        "details": {
          "function_name": "css_clear_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1670-1691",
          "snippet": "static void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);",
            "static struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};\n\nstatic void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_css",
          "args": [
            "css"
          ],
          "line": 5677
        },
        "resolved": true,
        "details": {
          "function_name": "kill_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5579-5611",
          "snippet": "static void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_release(struct percpu_ref *ref);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_css",
          "args": [
            "css",
            "ssid",
            "cgrp"
          ],
          "line": 5676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&cgrp->cset_links",
            "cset_link"
          ],
          "line": 5671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_has_online_children",
          "args": [
            "&cgrp->self"
          ],
          "line": 5659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "cgrp"
          ],
          "line": 5651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 5640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tspin_lock_irq(&css_set_lock);\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t\t/*\n\t\t * If the dying cgroup is frozen, decrease frozen descendants\n\t\t * counters of ancestor cgroups.\n\t\t */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\ttcgrp->freezer.nr_frozen_descendants--;\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tcgroup1_check_for_release(parent);\n\n\tcgroup_bpf_offline(cgrp);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kill_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5579-5611",
    "snippet": "static void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_release(struct percpu_ref *ref);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_ref_kill_and_confirm",
          "args": [
            "&css->refcnt",
            "css_killed_ref_fn"
          ],
          "line": 5610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "css"
          ],
          "line": 5598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_clear_dir",
          "args": [
            "css"
          ],
          "line": 5592
        },
        "resolved": true,
        "details": {
          "function_name": "css_clear_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1670-1691",
          "snippet": "static void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);",
            "static struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};\n\nstatic void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}"
  },
  {
    "function_name": "css_killed_ref_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5559-5568",
    "snippet": "static void css_killed_ref_fn(struct percpu_ref *ref)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(ref, struct cgroup_subsys_state, refcnt);\n\n\tif (atomic_dec_and_test(&css->online_cnt)) {\n\t\tINIT_WORK(&css->destroy_work, css_killed_work_fn);\n\t\tqueue_work(cgroup_destroy_wq, &css->destroy_work);\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *cgroup_destroy_wq;",
      "static void css_release(struct percpu_ref *ref);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "cgroup_destroy_wq",
            "&css->destroy_work"
          ],
          "line": 5566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&css->destroy_work",
            "css_killed_work_fn"
          ],
          "line": 5565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&css->online_cnt"
          ],
          "line": 5564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structcgroup_subsys_state",
            "refcnt"
          ],
          "line": 5562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct workqueue_struct *cgroup_destroy_wq;\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void css_killed_ref_fn(struct percpu_ref *ref)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(ref, struct cgroup_subsys_state, refcnt);\n\n\tif (atomic_dec_and_test(&css->online_cnt)) {\n\t\tINIT_WORK(&css->destroy_work, css_killed_work_fn);\n\t\tqueue_work(cgroup_destroy_wq, &css->destroy_work);\n\t}\n}"
  },
  {
    "function_name": "css_killed_work_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5541-5556",
    "snippet": "static void css_killed_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tdo {\n\t\toffline_css(css);\n\t\tcss_put(css);\n\t\t/* @css can't go away while we're holding cgroup_mutex */\n\t\tcss = css->parent;\n\t} while (css && atomic_dec_and_test(&css->online_cnt));\n\n\tmutex_unlock(&cgroup_mutex);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&css->online_cnt"
          ],
          "line": 5553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "css"
          ],
          "line": 5550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offline_css",
          "args": [
            "css"
          ],
          "line": 5549
        },
        "resolved": true,
        "details": {
          "function_name": "offline_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5262-5278",
          "snippet": "static void offline_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!(css->flags & CSS_ONLINE))\n\t\treturn;\n\n\tif (ss->css_offline)\n\t\tss->css_offline(css);\n\n\tcss->flags &= ~CSS_ONLINE;\n\tRCU_INIT_POINTER(css->cgroup->subsys[ss->id], NULL);\n\n\twake_up_all(&css->cgroup->offline_waitq);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void offline_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!(css->flags & CSS_ONLINE))\n\t\treturn;\n\n\tif (ss->css_offline)\n\t\tss->css_offline(css);\n\n\tcss->flags &= ~CSS_ONLINE;\n\tRCU_INIT_POINTER(css->cgroup->subsys[ss->id], NULL);\n\n\twake_up_all(&css->cgroup->offline_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structcgroup_subsys_state",
            "destroy_work"
          ],
          "line": 5544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void css_killed_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\n\tmutex_lock(&cgroup_mutex);\n\n\tdo {\n\t\toffline_css(css);\n\t\tcss_put(css);\n\t\t/* @css can't go away while we're holding cgroup_mutex */\n\t\tcss = css->parent;\n\t} while (css && atomic_dec_and_test(&css->online_cnt));\n\n\tmutex_unlock(&cgroup_mutex);\n}"
  },
  {
    "function_name": "cgroup_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5479-5534",
    "snippet": "int cgroup_mkdir(struct kernfs_node *parent_kn, const char *name, umode_t mode)\n{\n\tstruct cgroup *parent, *cgrp;\n\tint ret;\n\n\t/* do not accept '\\n' to prevent making /proc/<pid>/cgroup unparsable */\n\tif (strchr(name, '\\n'))\n\t\treturn -EINVAL;\n\n\tparent = cgroup_kn_lock_live(parent_kn, false);\n\tif (!parent)\n\t\treturn -ENODEV;\n\n\tif (!cgroup_check_hierarchy_limits(parent)) {\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\tcgrp = cgroup_create(parent, name, mode);\n\tif (IS_ERR(cgrp)) {\n\t\tret = PTR_ERR(cgrp);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * This extra ref will be put in cgroup_free_fn() and guarantees\n\t * that @cgrp->kn is always accessible.\n\t */\n\tkernfs_get(cgrp->kn);\n\n\tret = cgroup_kn_set_ugid(cgrp->kn);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tret = css_populate_dir(&cgrp->self);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tTRACE_CGROUP_PATH(mkdir, cgrp);\n\n\t/* let's create and online css's */\n\tkernfs_activate(cgrp->kn);\n\n\tret = 0;\n\tgoto out_unlock;\n\nout_destroy:\n\tcgroup_destroy_locked(cgrp);\nout_unlock:\n\tcgroup_kn_unlock(parent_kn);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static void css_release(struct percpu_ref *ref);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_kn_unlock",
          "args": [
            "parent_kn"
          ],
          "line": 5532
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1583-1596",
          "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_destroy_locked",
          "args": [
            "cgrp"
          ],
          "line": 5530
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_destroy_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5637-5707",
          "snippet": "static int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tspin_lock_irq(&css_set_lock);\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t\t/*\n\t\t * If the dying cgroup is frozen, decrease frozen descendants\n\t\t * counters of ancestor cgroups.\n\t\t */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\ttcgrp->freezer.nr_frozen_descendants--;\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tcgroup1_check_for_release(parent);\n\n\tcgroup_bpf_offline(cgrp);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static void css_release(struct percpu_ref *ref);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic int cgroup_destroy_locked(struct cgroup *cgrp)\n\t__releases(&cgroup_mutex) __acquires(&cgroup_mutex)\n{\n\tstruct cgroup *tcgrp, *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *css;\n\tstruct cgrp_cset_link *link;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Only migration can raise populated from zero and we're already\n\t * holding cgroup_mutex.\n\t */\n\tif (cgroup_is_populated(cgrp))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Make sure there's no live children.  We can't test emptiness of\n\t * ->self.children as dead children linger on it while being\n\t * drained; otherwise, \"rmdir parent/child parent\" may fail.\n\t */\n\tif (css_has_online_children(&cgrp->self))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Mark @cgrp and the associated csets dead.  The former prevents\n\t * further task migration and child creation by disabling\n\t * cgroup_lock_live_group().  The latter makes the csets ignored by\n\t * the migration path.\n\t */\n\tcgrp->self.flags &= ~CSS_ONLINE;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tlink->cset->dead = true;\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* initiate massacre of all css's */\n\tfor_each_css(css, ssid, cgrp)\n\t\tkill_css(css);\n\n\t/* clear and remove @cgrp dir, @cgrp has an extra ref on its kn */\n\tcss_clear_dir(&cgrp->self);\n\tkernfs_remove(cgrp->kn);\n\n\tif (parent && cgroup_is_threaded(cgrp))\n\t\tparent->nr_threaded_children--;\n\n\tspin_lock_irq(&css_set_lock);\n\tfor (tcgrp = cgroup_parent(cgrp); tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\ttcgrp->nr_descendants--;\n\t\ttcgrp->nr_dying_descendants++;\n\t\t/*\n\t\t * If the dying cgroup is frozen, decrease frozen descendants\n\t\t * counters of ancestor cgroups.\n\t\t */\n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\ttcgrp->freezer.nr_frozen_descendants--;\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tcgroup1_check_for_release(parent);\n\n\tcgroup_bpf_offline(cgrp);\n\n\t/* put the base reference */\n\tpercpu_ref_kill(&cgrp->self.refcnt);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_activate",
          "args": [
            "cgrp->kn"
          ],
          "line": 5524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "mkdir",
            "cgrp"
          ],
          "line": 5521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control_enable",
          "args": [
            "cgrp"
          ],
          "line": 5517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_populate_dir",
          "args": [
            "&cgrp->self"
          ],
          "line": 5513
        },
        "resolved": true,
        "details": {
          "function_name": "css_populate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1699-1737",
          "snippet": "static int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);",
            "static struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};\n\nstatic int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_kn_set_ugid",
          "args": [
            "cgrp->kn"
          ],
          "line": 5509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "cgrp->kn"
          ],
          "line": 5507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cgrp"
          ],
          "line": 5499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cgrp"
          ],
          "line": 5498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_create",
          "args": [
            "parent",
            "name",
            "mode"
          ],
          "line": 5497
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5340-5454",
          "snippet": "static struct cgroup *cgroup_create(struct cgroup *parent, const char *name,\n\t\t\t\t    umode_t mode)\n{\n\tstruct cgroup_root *root = parent->root;\n\tstruct cgroup *cgrp, *tcgrp;\n\tstruct kernfs_node *kn;\n\tint level = parent->level + 1;\n\tint ret;\n\n\t/* allocate the cgroup and its ID, 0 is reserved for the root */\n\tcgrp = kzalloc(struct_size(cgrp, ancestor_ids, (level + 1)),\n\t\t       GFP_KERNEL);\n\tif (!cgrp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = percpu_ref_init(&cgrp->self.refcnt, css_release, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out_free_cgrp;\n\n\tret = cgroup_rstat_init(cgrp);\n\tif (ret)\n\t\tgoto out_cancel_ref;\n\n\t/* create the directory */\n\tkn = kernfs_create_dir(parent->kn, name, mode, cgrp);\n\tif (IS_ERR(kn)) {\n\t\tret = PTR_ERR(kn);\n\t\tgoto out_stat_exit;\n\t}\n\tcgrp->kn = kn;\n\n\tinit_cgroup_housekeeping(cgrp);\n\n\tcgrp->self.parent = &parent->self;\n\tcgrp->root = root;\n\tcgrp->level = level;\n\n\tret = psi_cgroup_alloc(cgrp);\n\tif (ret)\n\t\tgoto out_kernfs_remove;\n\n\tret = cgroup_bpf_inherit(cgrp);\n\tif (ret)\n\t\tgoto out_psi_free;\n\n\t/*\n\t * New cgroup inherits effective freeze counter, and\n\t * if the parent has to be frozen, the child has too.\n\t */\n\tcgrp->freezer.e_freeze = parent->freezer.e_freeze;\n\tif (cgrp->freezer.e_freeze) {\n\t\t/*\n\t\t * Set the CGRP_FREEZE flag, so when a process will be\n\t\t * attached to the child cgroup, it will become frozen.\n\t\t * At this point the new cgroup is unpopulated, so we can\n\t\t * consider it frozen immediately.\n\t\t */\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\tfor (tcgrp = cgrp; tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\tcgrp->ancestor_ids[tcgrp->level] = cgroup_id(tcgrp);\n\n\t\tif (tcgrp != cgrp) {\n\t\t\ttcgrp->nr_descendants++;\n\n\t\t\t/*\n\t\t\t * If the new cgroup is frozen, all ancestor cgroups\n\t\t\t * get a new frozen descendant, but their state can't\n\t\t\t * change because of this.\n\t\t\t */\n\t\t\tif (cgrp->freezer.e_freeze)\n\t\t\t\ttcgrp->freezer.nr_frozen_descendants++;\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (notify_on_release(parent))\n\t\tset_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n\n\tif (test_bit(CGRP_CPUSET_CLONE_CHILDREN, &parent->flags))\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &cgrp->flags);\n\n\tcgrp->self.serial_nr = css_serial_nr_next++;\n\n\t/* allocation complete, commit to creation */\n\tlist_add_tail_rcu(&cgrp->self.sibling, &cgroup_parent(cgrp)->self.children);\n\tatomic_inc(&root->nr_cgrps);\n\tcgroup_get_live(parent);\n\n\t/*\n\t * On the default hierarchy, a child doesn't automatically inherit\n\t * subtree_control from the parent.  Each is configured manually.\n\t */\n\tif (!cgroup_on_dfl(cgrp))\n\t\tcgrp->subtree_control = cgroup_control(cgrp);\n\n\tcgroup_propagate_control(cgrp);\n\n\treturn cgrp;\n\nout_psi_free:\n\tpsi_cgroup_free(cgrp);\nout_kernfs_remove:\n\tkernfs_remove(cgrp->kn);\nout_stat_exit:\n\tcgroup_rstat_exit(cgrp);\nout_cancel_ref:\n\tpercpu_ref_exit(&cgrp->self.refcnt);\nout_free_cgrp:\n\tkfree(cgrp);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 css_serial_nr_next = 1;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u64 css_serial_nr_next = 1;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic struct cgroup *cgroup_create(struct cgroup *parent, const char *name,\n\t\t\t\t    umode_t mode)\n{\n\tstruct cgroup_root *root = parent->root;\n\tstruct cgroup *cgrp, *tcgrp;\n\tstruct kernfs_node *kn;\n\tint level = parent->level + 1;\n\tint ret;\n\n\t/* allocate the cgroup and its ID, 0 is reserved for the root */\n\tcgrp = kzalloc(struct_size(cgrp, ancestor_ids, (level + 1)),\n\t\t       GFP_KERNEL);\n\tif (!cgrp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = percpu_ref_init(&cgrp->self.refcnt, css_release, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out_free_cgrp;\n\n\tret = cgroup_rstat_init(cgrp);\n\tif (ret)\n\t\tgoto out_cancel_ref;\n\n\t/* create the directory */\n\tkn = kernfs_create_dir(parent->kn, name, mode, cgrp);\n\tif (IS_ERR(kn)) {\n\t\tret = PTR_ERR(kn);\n\t\tgoto out_stat_exit;\n\t}\n\tcgrp->kn = kn;\n\n\tinit_cgroup_housekeeping(cgrp);\n\n\tcgrp->self.parent = &parent->self;\n\tcgrp->root = root;\n\tcgrp->level = level;\n\n\tret = psi_cgroup_alloc(cgrp);\n\tif (ret)\n\t\tgoto out_kernfs_remove;\n\n\tret = cgroup_bpf_inherit(cgrp);\n\tif (ret)\n\t\tgoto out_psi_free;\n\n\t/*\n\t * New cgroup inherits effective freeze counter, and\n\t * if the parent has to be frozen, the child has too.\n\t */\n\tcgrp->freezer.e_freeze = parent->freezer.e_freeze;\n\tif (cgrp->freezer.e_freeze) {\n\t\t/*\n\t\t * Set the CGRP_FREEZE flag, so when a process will be\n\t\t * attached to the child cgroup, it will become frozen.\n\t\t * At this point the new cgroup is unpopulated, so we can\n\t\t * consider it frozen immediately.\n\t\t */\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\tfor (tcgrp = cgrp; tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\tcgrp->ancestor_ids[tcgrp->level] = cgroup_id(tcgrp);\n\n\t\tif (tcgrp != cgrp) {\n\t\t\ttcgrp->nr_descendants++;\n\n\t\t\t/*\n\t\t\t * If the new cgroup is frozen, all ancestor cgroups\n\t\t\t * get a new frozen descendant, but their state can't\n\t\t\t * change because of this.\n\t\t\t */\n\t\t\tif (cgrp->freezer.e_freeze)\n\t\t\t\ttcgrp->freezer.nr_frozen_descendants++;\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (notify_on_release(parent))\n\t\tset_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n\n\tif (test_bit(CGRP_CPUSET_CLONE_CHILDREN, &parent->flags))\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &cgrp->flags);\n\n\tcgrp->self.serial_nr = css_serial_nr_next++;\n\n\t/* allocation complete, commit to creation */\n\tlist_add_tail_rcu(&cgrp->self.sibling, &cgroup_parent(cgrp)->self.children);\n\tatomic_inc(&root->nr_cgrps);\n\tcgroup_get_live(parent);\n\n\t/*\n\t * On the default hierarchy, a child doesn't automatically inherit\n\t * subtree_control from the parent.  Each is configured manually.\n\t */\n\tif (!cgroup_on_dfl(cgrp))\n\t\tcgrp->subtree_control = cgroup_control(cgrp);\n\n\tcgroup_propagate_control(cgrp);\n\n\treturn cgrp;\n\nout_psi_free:\n\tpsi_cgroup_free(cgrp);\nout_kernfs_remove:\n\tkernfs_remove(cgrp->kn);\nout_stat_exit:\n\tcgroup_rstat_exit(cgrp);\nout_cancel_ref:\n\tpercpu_ref_exit(&cgrp->self.refcnt);\nout_free_cgrp:\n\tkfree(cgrp);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_check_hierarchy_limits",
          "args": [
            "parent"
          ],
          "line": 5492
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_check_hierarchy_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5456-5477",
          "snippet": "static bool cgroup_check_hierarchy_limits(struct cgroup *parent)\n{\n\tstruct cgroup *cgroup;\n\tint ret = false;\n\tint level = 1;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tfor (cgroup = parent; cgroup; cgroup = cgroup_parent(cgroup)) {\n\t\tif (cgroup->nr_descendants >= cgroup->max_descendants)\n\t\t\tgoto fail;\n\n\t\tif (level > cgroup->max_depth)\n\t\t\tgoto fail;\n\n\t\tlevel++;\n\t}\n\n\tret = true;\nfail:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic bool cgroup_check_hierarchy_limits(struct cgroup *parent)\n{\n\tstruct cgroup *cgroup;\n\tint ret = false;\n\tint level = 1;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tfor (cgroup = parent; cgroup; cgroup = cgroup_parent(cgroup)) {\n\t\tif (cgroup->nr_descendants >= cgroup->max_descendants)\n\t\t\tgoto fail;\n\n\t\tif (level > cgroup->max_depth)\n\t\t\tgoto fail;\n\n\t\tlevel++;\n\t}\n\n\tret = true;\nfail:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_kn_lock_live",
          "args": [
            "parent_kn",
            "false"
          ],
          "line": 5488
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_lock_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1615-1644",
          "snippet": "struct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'\\n'"
          ],
          "line": 5485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nint cgroup_mkdir(struct kernfs_node *parent_kn, const char *name, umode_t mode)\n{\n\tstruct cgroup *parent, *cgrp;\n\tint ret;\n\n\t/* do not accept '\\n' to prevent making /proc/<pid>/cgroup unparsable */\n\tif (strchr(name, '\\n'))\n\t\treturn -EINVAL;\n\n\tparent = cgroup_kn_lock_live(parent_kn, false);\n\tif (!parent)\n\t\treturn -ENODEV;\n\n\tif (!cgroup_check_hierarchy_limits(parent)) {\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\tcgrp = cgroup_create(parent, name, mode);\n\tif (IS_ERR(cgrp)) {\n\t\tret = PTR_ERR(cgrp);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * This extra ref will be put in cgroup_free_fn() and guarantees\n\t * that @cgrp->kn is always accessible.\n\t */\n\tkernfs_get(cgrp->kn);\n\n\tret = cgroup_kn_set_ugid(cgrp->kn);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tret = css_populate_dir(&cgrp->self);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\tgoto out_destroy;\n\n\tTRACE_CGROUP_PATH(mkdir, cgrp);\n\n\t/* let's create and online css's */\n\tkernfs_activate(cgrp->kn);\n\n\tret = 0;\n\tgoto out_unlock;\n\nout_destroy:\n\tcgroup_destroy_locked(cgrp);\nout_unlock:\n\tcgroup_kn_unlock(parent_kn);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_check_hierarchy_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5456-5477",
    "snippet": "static bool cgroup_check_hierarchy_limits(struct cgroup *parent)\n{\n\tstruct cgroup *cgroup;\n\tint ret = false;\n\tint level = 1;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tfor (cgroup = parent; cgroup; cgroup = cgroup_parent(cgroup)) {\n\t\tif (cgroup->nr_descendants >= cgroup->max_descendants)\n\t\t\tgoto fail;\n\n\t\tif (level > cgroup->max_depth)\n\t\t\tgoto fail;\n\n\t\tlevel++;\n\t}\n\n\tret = true;\nfail:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgroup"
          ],
          "line": 5464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic bool cgroup_check_hierarchy_limits(struct cgroup *parent)\n{\n\tstruct cgroup *cgroup;\n\tint ret = false;\n\tint level = 1;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tfor (cgroup = parent; cgroup; cgroup = cgroup_parent(cgroup)) {\n\t\tif (cgroup->nr_descendants >= cgroup->max_descendants)\n\t\t\tgoto fail;\n\n\t\tif (level > cgroup->max_depth)\n\t\t\tgoto fail;\n\n\t\tlevel++;\n\t}\n\n\tret = true;\nfail:\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5340-5454",
    "snippet": "static struct cgroup *cgroup_create(struct cgroup *parent, const char *name,\n\t\t\t\t    umode_t mode)\n{\n\tstruct cgroup_root *root = parent->root;\n\tstruct cgroup *cgrp, *tcgrp;\n\tstruct kernfs_node *kn;\n\tint level = parent->level + 1;\n\tint ret;\n\n\t/* allocate the cgroup and its ID, 0 is reserved for the root */\n\tcgrp = kzalloc(struct_size(cgrp, ancestor_ids, (level + 1)),\n\t\t       GFP_KERNEL);\n\tif (!cgrp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = percpu_ref_init(&cgrp->self.refcnt, css_release, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out_free_cgrp;\n\n\tret = cgroup_rstat_init(cgrp);\n\tif (ret)\n\t\tgoto out_cancel_ref;\n\n\t/* create the directory */\n\tkn = kernfs_create_dir(parent->kn, name, mode, cgrp);\n\tif (IS_ERR(kn)) {\n\t\tret = PTR_ERR(kn);\n\t\tgoto out_stat_exit;\n\t}\n\tcgrp->kn = kn;\n\n\tinit_cgroup_housekeeping(cgrp);\n\n\tcgrp->self.parent = &parent->self;\n\tcgrp->root = root;\n\tcgrp->level = level;\n\n\tret = psi_cgroup_alloc(cgrp);\n\tif (ret)\n\t\tgoto out_kernfs_remove;\n\n\tret = cgroup_bpf_inherit(cgrp);\n\tif (ret)\n\t\tgoto out_psi_free;\n\n\t/*\n\t * New cgroup inherits effective freeze counter, and\n\t * if the parent has to be frozen, the child has too.\n\t */\n\tcgrp->freezer.e_freeze = parent->freezer.e_freeze;\n\tif (cgrp->freezer.e_freeze) {\n\t\t/*\n\t\t * Set the CGRP_FREEZE flag, so when a process will be\n\t\t * attached to the child cgroup, it will become frozen.\n\t\t * At this point the new cgroup is unpopulated, so we can\n\t\t * consider it frozen immediately.\n\t\t */\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\tfor (tcgrp = cgrp; tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\tcgrp->ancestor_ids[tcgrp->level] = cgroup_id(tcgrp);\n\n\t\tif (tcgrp != cgrp) {\n\t\t\ttcgrp->nr_descendants++;\n\n\t\t\t/*\n\t\t\t * If the new cgroup is frozen, all ancestor cgroups\n\t\t\t * get a new frozen descendant, but their state can't\n\t\t\t * change because of this.\n\t\t\t */\n\t\t\tif (cgrp->freezer.e_freeze)\n\t\t\t\ttcgrp->freezer.nr_frozen_descendants++;\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (notify_on_release(parent))\n\t\tset_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n\n\tif (test_bit(CGRP_CPUSET_CLONE_CHILDREN, &parent->flags))\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &cgrp->flags);\n\n\tcgrp->self.serial_nr = css_serial_nr_next++;\n\n\t/* allocation complete, commit to creation */\n\tlist_add_tail_rcu(&cgrp->self.sibling, &cgroup_parent(cgrp)->self.children);\n\tatomic_inc(&root->nr_cgrps);\n\tcgroup_get_live(parent);\n\n\t/*\n\t * On the default hierarchy, a child doesn't automatically inherit\n\t * subtree_control from the parent.  Each is configured manually.\n\t */\n\tif (!cgroup_on_dfl(cgrp))\n\t\tcgrp->subtree_control = cgroup_control(cgrp);\n\n\tcgroup_propagate_control(cgrp);\n\n\treturn cgrp;\n\nout_psi_free:\n\tpsi_cgroup_free(cgrp);\nout_kernfs_remove:\n\tkernfs_remove(cgrp->kn);\nout_stat_exit:\n\tcgroup_rstat_exit(cgrp);\nout_cancel_ref:\n\tpercpu_ref_exit(&cgrp->self.refcnt);\nout_free_cgrp:\n\tkfree(cgrp);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 css_serial_nr_next = 1;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 5453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cgrp"
          ],
          "line": 5452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&cgrp->self.refcnt"
          ],
          "line": 5450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_exit",
          "args": [
            "cgrp"
          ],
          "line": 5448
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "267-284",
          "snippet": "void cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_remove",
          "args": [
            "cgrp->kn"
          ],
          "line": 5446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_cgroup_free",
          "args": [
            "cgrp"
          ],
          "line": 5444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_propagate_control",
          "args": [
            "cgrp"
          ],
          "line": 5439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_control",
          "args": [
            "cgrp"
          ],
          "line": 5437
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "433-451",
          "snippet": "static u16 cgroup_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tu16 root_ss_mask = cgrp->root->subsys_mask;\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_control;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\tif (cgroup_on_dfl(cgrp))\n\t\troot_ss_mask &= ~(cgrp_dfl_inhibit_ss_mask |\n\t\t\t\t  cgrp_dfl_implicit_ss_mask);\n\treturn root_ss_mask;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_inhibit_ss_mask;",
            "static u16 cgrp_dfl_implicit_ss_mask;",
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_inhibit_ss_mask;\nstatic u16 cgrp_dfl_implicit_ss_mask;\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic u16 cgroup_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tu16 root_ss_mask = cgrp->root->subsys_mask;\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_control;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\tif (cgroup_on_dfl(cgrp))\n\t\troot_ss_mask &= ~(cgrp_dfl_inhibit_ss_mask |\n\t\t\t\t  cgrp_dfl_implicit_ss_mask);\n\treturn root_ss_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 5436
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "313-316",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_get_live",
          "args": [
            "parent"
          ],
          "line": 5430
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "613-617",
          "snippet": "static void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->nr_cgrps"
          ],
          "line": 5429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&cgrp->self.sibling",
            "&cgroup_parent(cgrp)->self.children"
          ],
          "line": 5428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 5428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_CPUSET_CLONE_CHILDREN",
            "&cgrp->flags"
          ],
          "line": 5423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_CPUSET_CLONE_CHILDREN",
            "&parent->flags"
          ],
          "line": 5422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_NOTIFY_ON_RELEASE",
            "&cgrp->flags"
          ],
          "line": 5420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_on_release",
          "args": [
            "parent"
          ],
          "line": 5419
        },
        "resolved": true,
        "details": {
          "function_name": "notify_on_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "192-195",
          "snippet": "static inline bool notify_on_release(const struct cgroup *cgrp)\n{\n\treturn test_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline bool notify_on_release(const struct cgroup *cgrp)\n{\n\treturn test_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_id",
          "args": [
            "tcgrp"
          ],
          "line": 5403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "tcgrp"
          ],
          "line": 5402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 5398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_FREEZE",
            "&cgrp->flags"
          ],
          "line": 5397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_inherit",
          "args": [
            "cgrp"
          ],
          "line": 5381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_cgroup_alloc",
          "args": [
            "cgrp"
          ],
          "line": 5377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cgroup_housekeeping",
          "args": [
            "cgrp"
          ],
          "line": 5371
        },
        "resolved": true,
        "details": {
          "function_name": "init_cgroup_housekeeping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1942-1965",
          "snippet": "static void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kn"
          ],
          "line": 5366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kn"
          ],
          "line": 5365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_create_dir",
          "args": [
            "parent->kn",
            "name",
            "mode",
            "cgrp"
          ],
          "line": 5364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_init",
          "args": [
            "cgrp"
          ],
          "line": 5359
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "245-265",
          "snippet": "int cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nint cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&cgrp->self.refcnt",
            "css_release",
            "0",
            "GFP_KERNEL"
          ],
          "line": 5355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 5353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "struct_size(cgrp, ancestor_ids, (level + 1))",
            "GFP_KERNEL"
          ],
          "line": 5350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "cgrp",
            "ancestor_ids",
            "(level + 1)"
          ],
          "line": 5350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u64 css_serial_nr_next = 1;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic struct cgroup *cgroup_create(struct cgroup *parent, const char *name,\n\t\t\t\t    umode_t mode)\n{\n\tstruct cgroup_root *root = parent->root;\n\tstruct cgroup *cgrp, *tcgrp;\n\tstruct kernfs_node *kn;\n\tint level = parent->level + 1;\n\tint ret;\n\n\t/* allocate the cgroup and its ID, 0 is reserved for the root */\n\tcgrp = kzalloc(struct_size(cgrp, ancestor_ids, (level + 1)),\n\t\t       GFP_KERNEL);\n\tif (!cgrp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = percpu_ref_init(&cgrp->self.refcnt, css_release, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out_free_cgrp;\n\n\tret = cgroup_rstat_init(cgrp);\n\tif (ret)\n\t\tgoto out_cancel_ref;\n\n\t/* create the directory */\n\tkn = kernfs_create_dir(parent->kn, name, mode, cgrp);\n\tif (IS_ERR(kn)) {\n\t\tret = PTR_ERR(kn);\n\t\tgoto out_stat_exit;\n\t}\n\tcgrp->kn = kn;\n\n\tinit_cgroup_housekeeping(cgrp);\n\n\tcgrp->self.parent = &parent->self;\n\tcgrp->root = root;\n\tcgrp->level = level;\n\n\tret = psi_cgroup_alloc(cgrp);\n\tif (ret)\n\t\tgoto out_kernfs_remove;\n\n\tret = cgroup_bpf_inherit(cgrp);\n\tif (ret)\n\t\tgoto out_psi_free;\n\n\t/*\n\t * New cgroup inherits effective freeze counter, and\n\t * if the parent has to be frozen, the child has too.\n\t */\n\tcgrp->freezer.e_freeze = parent->freezer.e_freeze;\n\tif (cgrp->freezer.e_freeze) {\n\t\t/*\n\t\t * Set the CGRP_FREEZE flag, so when a process will be\n\t\t * attached to the child cgroup, it will become frozen.\n\t\t * At this point the new cgroup is unpopulated, so we can\n\t\t * consider it frozen immediately.\n\t\t */\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\tfor (tcgrp = cgrp; tcgrp; tcgrp = cgroup_parent(tcgrp)) {\n\t\tcgrp->ancestor_ids[tcgrp->level] = cgroup_id(tcgrp);\n\n\t\tif (tcgrp != cgrp) {\n\t\t\ttcgrp->nr_descendants++;\n\n\t\t\t/*\n\t\t\t * If the new cgroup is frozen, all ancestor cgroups\n\t\t\t * get a new frozen descendant, but their state can't\n\t\t\t * change because of this.\n\t\t\t */\n\t\t\tif (cgrp->freezer.e_freeze)\n\t\t\t\ttcgrp->freezer.nr_frozen_descendants++;\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (notify_on_release(parent))\n\t\tset_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n\n\tif (test_bit(CGRP_CPUSET_CLONE_CHILDREN, &parent->flags))\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &cgrp->flags);\n\n\tcgrp->self.serial_nr = css_serial_nr_next++;\n\n\t/* allocation complete, commit to creation */\n\tlist_add_tail_rcu(&cgrp->self.sibling, &cgroup_parent(cgrp)->self.children);\n\tatomic_inc(&root->nr_cgrps);\n\tcgroup_get_live(parent);\n\n\t/*\n\t * On the default hierarchy, a child doesn't automatically inherit\n\t * subtree_control from the parent.  Each is configured manually.\n\t */\n\tif (!cgroup_on_dfl(cgrp))\n\t\tcgrp->subtree_control = cgroup_control(cgrp);\n\n\tcgroup_propagate_control(cgrp);\n\n\treturn cgrp;\n\nout_psi_free:\n\tpsi_cgroup_free(cgrp);\nout_kernfs_remove:\n\tkernfs_remove(cgrp->kn);\nout_stat_exit:\n\tcgroup_rstat_exit(cgrp);\nout_cancel_ref:\n\tpercpu_ref_exit(&cgrp->self.refcnt);\nout_free_cgrp:\n\tkfree(cgrp);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "css_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5289-5333",
    "snippet": "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *parent_css = cgroup_css(parent, ss);\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcss = ss->css_alloc(parent_css);\n\tif (!css)\n\t\tcss = ERR_PTR(-ENOMEM);\n\tif (IS_ERR(css))\n\t\treturn css;\n\n\tinit_and_link_css(css, ss, cgrp);\n\n\terr = percpu_ref_init(&css->refcnt, css_release, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_free_css;\n\n\terr = cgroup_idr_alloc(&ss->css_idr, NULL, 2, 0, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_free_css;\n\tcss->id = err;\n\n\t/* @css is ready to be brought online now, make it visible */\n\tlist_add_tail_rcu(&css->sibling, &parent_css->children);\n\tcgroup_idr_replace(&ss->css_idr, css, css->id);\n\n\terr = online_css(css);\n\tif (err)\n\t\tgoto err_list_del;\n\n\treturn css;\n\nerr_list_del:\n\tlist_del_rcu(&css->sibling);\nerr_free_css:\n\tlist_del_rcu(&css->rstat_css_node);\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *cgroup_destroy_wq;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 5332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_rcu_work",
          "args": [
            "cgroup_destroy_wq",
            "&css->destroy_rwork"
          ],
          "line": 5331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RCU_WORK",
          "args": [
            "&css->destroy_rwork",
            "css_free_rwork_fn"
          ],
          "line": 5330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&css->rstat_css_node"
          ],
          "line": 5329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&css->sibling"
          ],
          "line": 5327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "online_css",
          "args": [
            "css"
          ],
          "line": 5320
        },
        "resolved": true,
        "details": {
          "function_name": "online_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5241-5259",
          "snippet": "static int online_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (ss->css_online)\n\t\tret = ss->css_online(css);\n\tif (!ret) {\n\t\tcss->flags |= CSS_ONLINE;\n\t\trcu_assign_pointer(css->cgroup->subsys[ss->id], css);\n\n\t\tatomic_inc(&css->online_cnt);\n\t\tif (css->parent)\n\t\t\tatomic_inc(&css->parent->online_cnt);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic int online_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (ss->css_online)\n\t\tret = ss->css_online(css);\n\tif (!ret) {\n\t\tcss->flags |= CSS_ONLINE;\n\t\trcu_assign_pointer(css->cgroup->subsys[ss->id], css);\n\n\t\tatomic_inc(&css->online_cnt);\n\t\tif (css->parent)\n\t\t\tatomic_inc(&css->parent->online_cnt);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_idr_replace",
          "args": [
            "&ss->css_idr",
            "css",
            "css->id"
          ],
          "line": 5318
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "332-340",
          "snippet": "static void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&css->sibling",
            "&parent_css->children"
          ],
          "line": 5317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_idr_alloc",
          "args": [
            "&ss->css_idr",
            "NULL",
            "2",
            "0",
            "GFP_KERNEL"
          ],
          "line": 5311
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "319-330",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&css->refcnt",
            "css_release",
            "0",
            "GFP_KERNEL"
          ],
          "line": 5307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_and_link_css",
          "args": [
            "css",
            "ss",
            "cgrp"
          ],
          "line": 5305
        },
        "resolved": true,
        "details": {
          "function_name": "init_and_link_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5212-5238",
          "snippet": "static void init_and_link_css(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup_subsys *ss, struct cgroup *cgrp)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_get_live(cgrp);\n\n\tmemset(css, 0, sizeof(*css));\n\tcss->cgroup = cgrp;\n\tcss->ss = ss;\n\tcss->id = -1;\n\tINIT_LIST_HEAD(&css->sibling);\n\tINIT_LIST_HEAD(&css->children);\n\tINIT_LIST_HEAD(&css->rstat_css_node);\n\tcss->serial_nr = css_serial_nr_next++;\n\tatomic_set(&css->online_cnt, 0);\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcss->parent = cgroup_css(cgroup_parent(cgrp), ss);\n\t\tcss_get(css->parent);\n\t}\n\n\tif (ss->css_rstat_flush)\n\t\tlist_add_rcu(&css->rstat_css_node, &cgrp->rstat_css_list);\n\n\tBUG_ON(cgroup_css(cgrp, ss));\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 css_serial_nr_next = 1;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u64 css_serial_nr_next = 1;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void init_and_link_css(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup_subsys *ss, struct cgroup *cgrp)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_get_live(cgrp);\n\n\tmemset(css, 0, sizeof(*css));\n\tcss->cgroup = cgrp;\n\tcss->ss = ss;\n\tcss->id = -1;\n\tINIT_LIST_HEAD(&css->sibling);\n\tINIT_LIST_HEAD(&css->children);\n\tINIT_LIST_HEAD(&css->rstat_css_node);\n\tcss->serial_nr = css_serial_nr_next++;\n\tatomic_set(&css->online_cnt, 0);\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcss->parent = cgroup_css(cgroup_parent(cgrp), ss);\n\t\tcss_get(css->parent);\n\t}\n\n\tif (ss->css_rstat_flush)\n\t\tlist_add_rcu(&css->rstat_css_node, &cgrp->rstat_css_list);\n\n\tBUG_ON(cgroup_css(cgrp, ss));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "css"
          ],
          "line": 5302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 5301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_alloc",
          "args": [
            "parent_css"
          ],
          "line": 5299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "parent",
            "ss"
          ],
          "line": 5293
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "481-489",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 5292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct workqueue_struct *cgroup_destroy_wq;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *parent_css = cgroup_css(parent, ss);\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcss = ss->css_alloc(parent_css);\n\tif (!css)\n\t\tcss = ERR_PTR(-ENOMEM);\n\tif (IS_ERR(css))\n\t\treturn css;\n\n\tinit_and_link_css(css, ss, cgrp);\n\n\terr = percpu_ref_init(&css->refcnt, css_release, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_free_css;\n\n\terr = cgroup_idr_alloc(&ss->css_idr, NULL, 2, 0, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_free_css;\n\tcss->id = err;\n\n\t/* @css is ready to be brought online now, make it visible */\n\tlist_add_tail_rcu(&css->sibling, &parent_css->children);\n\tcgroup_idr_replace(&ss->css_idr, css, css->id);\n\n\terr = online_css(css);\n\tif (err)\n\t\tgoto err_list_del;\n\n\treturn css;\n\nerr_list_del:\n\tlist_del_rcu(&css->sibling);\nerr_free_css:\n\tlist_del_rcu(&css->rstat_css_node);\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "offline_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5262-5278",
    "snippet": "static void offline_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!(css->flags & CSS_ONLINE))\n\t\treturn;\n\n\tif (ss->css_offline)\n\t\tss->css_offline(css);\n\n\tcss->flags &= ~CSS_ONLINE;\n\tRCU_INIT_POINTER(css->cgroup->subsys[ss->id], NULL);\n\n\twake_up_all(&css->cgroup->offline_waitq);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&css->cgroup->offline_waitq"
          ],
          "line": 5277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "css->cgroup->subsys[ss->id]",
            "NULL"
          ],
          "line": 5275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_offline",
          "args": [
            "css"
          ],
          "line": 5272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void offline_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!(css->flags & CSS_ONLINE))\n\t\treturn;\n\n\tif (ss->css_offline)\n\t\tss->css_offline(css);\n\n\tcss->flags &= ~CSS_ONLINE;\n\tRCU_INIT_POINTER(css->cgroup->subsys[ss->id], NULL);\n\n\twake_up_all(&css->cgroup->offline_waitq);\n}"
  },
  {
    "function_name": "online_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5241-5259",
    "snippet": "static int online_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (ss->css_online)\n\t\tret = ss->css_online(css);\n\tif (!ret) {\n\t\tcss->flags |= CSS_ONLINE;\n\t\trcu_assign_pointer(css->cgroup->subsys[ss->id], css);\n\n\t\tatomic_inc(&css->online_cnt);\n\t\tif (css->parent)\n\t\t\tatomic_inc(&css->parent->online_cnt);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&css->parent->online_cnt"
          ],
          "line": 5256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&css->online_cnt"
          ],
          "line": 5254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "css->cgroup->subsys[ss->id]",
            "css"
          ],
          "line": 5252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_online",
          "args": [
            "css"
          ],
          "line": 5249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic int online_css(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (ss->css_online)\n\t\tret = ss->css_online(css);\n\tif (!ret) {\n\t\tcss->flags |= CSS_ONLINE;\n\t\trcu_assign_pointer(css->cgroup->subsys[ss->id], css);\n\n\t\tatomic_inc(&css->online_cnt);\n\t\tif (css->parent)\n\t\t\tatomic_inc(&css->parent->online_cnt);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "init_and_link_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5212-5238",
    "snippet": "static void init_and_link_css(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup_subsys *ss, struct cgroup *cgrp)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_get_live(cgrp);\n\n\tmemset(css, 0, sizeof(*css));\n\tcss->cgroup = cgrp;\n\tcss->ss = ss;\n\tcss->id = -1;\n\tINIT_LIST_HEAD(&css->sibling);\n\tINIT_LIST_HEAD(&css->children);\n\tINIT_LIST_HEAD(&css->rstat_css_node);\n\tcss->serial_nr = css_serial_nr_next++;\n\tatomic_set(&css->online_cnt, 0);\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcss->parent = cgroup_css(cgroup_parent(cgrp), ss);\n\t\tcss_get(css->parent);\n\t}\n\n\tif (ss->css_rstat_flush)\n\t\tlist_add_rcu(&css->rstat_css_node, &cgrp->rstat_css_list);\n\n\tBUG_ON(cgroup_css(cgrp, ss));\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 css_serial_nr_next = 1;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cgroup_css(cgrp, ss)"
          ],
          "line": 5237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 5237
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "481-489",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&css->rstat_css_node",
            "&cgrp->rstat_css_list"
          ],
          "line": 5235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "css->parent"
          ],
          "line": 5231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 5230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 5229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&css->online_cnt",
            "0"
          ],
          "line": 5227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&css->rstat_css_node"
          ],
          "line": 5225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&css->children"
          ],
          "line": 5224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&css->sibling"
          ],
          "line": 5223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "css",
            "0",
            "sizeof(*css)"
          ],
          "line": 5219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_live",
          "args": [
            "cgrp"
          ],
          "line": 5217
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "613-617",
          "snippet": "static void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u64 css_serial_nr_next = 1;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void init_and_link_css(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup_subsys *ss, struct cgroup *cgrp)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_get_live(cgrp);\n\n\tmemset(css, 0, sizeof(*css));\n\tcss->cgroup = cgrp;\n\tcss->ss = ss;\n\tcss->id = -1;\n\tINIT_LIST_HEAD(&css->sibling);\n\tINIT_LIST_HEAD(&css->children);\n\tINIT_LIST_HEAD(&css->rstat_css_node);\n\tcss->serial_nr = css_serial_nr_next++;\n\tatomic_set(&css->online_cnt, 0);\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcss->parent = cgroup_css(cgroup_parent(cgrp), ss);\n\t\tcss_get(css->parent);\n\t}\n\n\tif (ss->css_rstat_flush)\n\t\tlist_add_rcu(&css->rstat_css_node, &cgrp->rstat_css_list);\n\n\tBUG_ON(cgroup_css(cgrp, ss));\n}"
  },
  {
    "function_name": "css_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5203-5210",
    "snippet": "static void css_release(struct percpu_ref *ref)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(ref, struct cgroup_subsys_state, refcnt);\n\n\tINIT_WORK(&css->destroy_work, css_release_work_fn);\n\tqueue_work(cgroup_destroy_wq, &css->destroy_work);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *cgroup_destroy_wq;",
      "static void css_release(struct percpu_ref *ref);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "cgroup_destroy_wq",
            "&css->destroy_work"
          ],
          "line": 5209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&css->destroy_work",
            "css_release_work_fn"
          ],
          "line": 5208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structcgroup_subsys_state",
            "refcnt"
          ],
          "line": 5206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct workqueue_struct *cgroup_destroy_wq;\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void css_release(struct percpu_ref *ref)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(ref, struct cgroup_subsys_state, refcnt);\n\n\tINIT_WORK(&css->destroy_work, css_release_work_fn);\n\tqueue_work(cgroup_destroy_wq, &css->destroy_work);\n}"
  },
  {
    "function_name": "css_release_work_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5149-5201",
    "snippet": "static void css_release_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tcss->flags |= CSS_RELEASED;\n\tlist_del_rcu(&css->sibling);\n\n\tif (ss) {\n\t\t/* css release path */\n\t\tif (!list_empty(&css->rstat_css_node)) {\n\t\t\tcgroup_rstat_flush(cgrp);\n\t\t\tlist_del_rcu(&css->rstat_css_node);\n\t\t}\n\n\t\tcgroup_idr_replace(&ss->css_idr, NULL, css->id);\n\t\tif (ss->css_released)\n\t\t\tss->css_released(css);\n\t} else {\n\t\tstruct cgroup *tcgrp;\n\n\t\t/* cgroup release path */\n\t\tTRACE_CGROUP_PATH(release, cgrp);\n\n\t\tcgroup_rstat_flush(cgrp);\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tfor (tcgrp = cgroup_parent(cgrp); tcgrp;\n\t\t     tcgrp = cgroup_parent(tcgrp))\n\t\t\ttcgrp->nr_dying_descendants--;\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\t/*\n\t\t * There are two control paths which try to determine\n\t\t * cgroup from dentry without going through kernfs -\n\t\t * cgroupstats_build() and css_tryget_online_from_dir().\n\t\t * Those are supported by RCU protecting clearing of\n\t\t * cgrp->kn->priv backpointer.\n\t\t */\n\t\tif (cgrp->kn)\n\t\t\tRCU_INIT_POINTER(*(void __rcu __force **)&cgrp->kn->priv,\n\t\t\t\t\t NULL);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *cgroup_destroy_wq;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_rcu_work",
          "args": [
            "cgroup_destroy_wq",
            "&css->destroy_rwork"
          ],
          "line": 5200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RCU_WORK",
          "args": [
            "&css->destroy_rwork",
            "css_free_rwork_fn"
          ],
          "line": 5199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "*(void __rcu __force **)&cgrp->kn->priv",
            "NULL"
          ],
          "line": 5193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "tcgrp"
          ],
          "line": 5181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 5180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 5179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_flush",
          "args": [
            "cgrp"
          ],
          "line": 5177
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_flush_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "228-234",
          "snippet": "void cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_rstat_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_rstat_lock);\n\nvoid cgroup_rstat_flush_hold(struct cgroup *cgrp)\n\t__acquires(&cgroup_rstat_lock)\n{\n\tmight_sleep();\n\tspin_lock_irq(&cgroup_rstat_lock);\n\tcgroup_rstat_flush_locked(cgrp, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "release",
            "cgrp"
          ],
          "line": 5175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_released",
          "args": [
            "css"
          ],
          "line": 5170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_idr_replace",
          "args": [
            "&ss->css_idr",
            "NULL",
            "css->id"
          ],
          "line": 5168
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "332-340",
          "snippet": "static void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&css->rstat_css_node"
          ],
          "line": 5165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&css->rstat_css_node"
          ],
          "line": 5163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&css->sibling"
          ],
          "line": 5159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 5156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structcgroup_subsys_state",
            "destroy_work"
          ],
          "line": 5152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct workqueue_struct *cgroup_destroy_wq;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void css_release_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tcss->flags |= CSS_RELEASED;\n\tlist_del_rcu(&css->sibling);\n\n\tif (ss) {\n\t\t/* css release path */\n\t\tif (!list_empty(&css->rstat_css_node)) {\n\t\t\tcgroup_rstat_flush(cgrp);\n\t\t\tlist_del_rcu(&css->rstat_css_node);\n\t\t}\n\n\t\tcgroup_idr_replace(&ss->css_idr, NULL, css->id);\n\t\tif (ss->css_released)\n\t\t\tss->css_released(css);\n\t} else {\n\t\tstruct cgroup *tcgrp;\n\n\t\t/* cgroup release path */\n\t\tTRACE_CGROUP_PATH(release, cgrp);\n\n\t\tcgroup_rstat_flush(cgrp);\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tfor (tcgrp = cgroup_parent(cgrp); tcgrp;\n\t\t     tcgrp = cgroup_parent(tcgrp))\n\t\t\ttcgrp->nr_dying_descendants--;\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\t/*\n\t\t * There are two control paths which try to determine\n\t\t * cgroup from dentry without going through kernfs -\n\t\t * cgroupstats_build() and css_tryget_online_from_dir().\n\t\t * Those are supported by RCU protecting clearing of\n\t\t * cgrp->kn->priv backpointer.\n\t\t */\n\t\tif (cgrp->kn)\n\t\t\tRCU_INIT_POINTER(*(void __rcu __force **)&cgrp->kn->priv,\n\t\t\t\t\t NULL);\n\t}\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n}"
  },
  {
    "function_name": "css_free_rwork_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "5100-5147",
    "snippet": "static void css_free_rwork_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css = container_of(to_rcu_work(work),\n\t\t\t\tstruct cgroup_subsys_state, destroy_rwork);\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tpercpu_ref_exit(&css->refcnt);\n\n\tif (ss) {\n\t\t/* css free path */\n\t\tstruct cgroup_subsys_state *parent = css->parent;\n\t\tint id = css->id;\n\n\t\tss->css_free(css);\n\t\tcgroup_idr_remove(&ss->css_idr, id);\n\t\tcgroup_put(cgrp);\n\n\t\tif (parent)\n\t\t\tcss_put(parent);\n\t} else {\n\t\t/* cgroup free path */\n\t\tatomic_dec(&cgrp->root->nr_cgrps);\n\t\tcgroup1_pidlist_destroy_all(cgrp);\n\t\tcancel_work_sync(&cgrp->release_agent_work);\n\n\t\tif (cgroup_parent(cgrp)) {\n\t\t\t/*\n\t\t\t * We get a ref to the parent, and put the ref when\n\t\t\t * this cgroup is being freed, so it's guaranteed\n\t\t\t * that the parent won't be destroyed before its\n\t\t\t * children.\n\t\t\t */\n\t\t\tcgroup_put(cgroup_parent(cgrp));\n\t\t\tkernfs_put(cgrp->kn);\n\t\t\tpsi_cgroup_free(cgrp);\n\t\t\tcgroup_rstat_exit(cgrp);\n\t\t\tkfree(cgrp);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is root cgroup's refcnt reaching zero,\n\t\t\t * which indicates that the root should be\n\t\t\t * released.\n\t\t\t */\n\t\t\tcgroup_destroy_root(cgrp->root);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void css_release(struct percpu_ref *ref);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_destroy_root",
          "args": [
            "cgrp->root"
          ],
          "line": 5144
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_destroy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1336-1377",
          "snippet": "static void cgroup_destroy_root(struct cgroup_root *root)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\ttrace_cgroup_destroy_root(root);\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\tBUG_ON(atomic_read(&root->nr_cgrps));\n\tBUG_ON(!list_empty(&cgrp->self.children));\n\n\t/* Rebind all subsystems back to the default hierarchy */\n\tWARN_ON(rebind_subsystems(&cgrp_dfl_root, root->subsys_mask));\n\n\t/*\n\t * Release all the links from cset_links to this hierarchy's\n\t * root cgroup\n\t */\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_for_each_entry_safe(link, tmp_link, &cgrp->cset_links, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tkfree(link);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!list_empty(&root->root_list)) {\n\t\tlist_del(&root->root_list);\n\t\tcgroup_root_count--;\n\t}\n\n\tcgroup_exit_root_id(root);\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tcgroup_rstat_exit(cgrp);\n\tkernfs_destroy_root(root->kf_root);\n\tcgroup_free_root(root);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_root_count;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_destroy_root(struct cgroup_root *root)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\ttrace_cgroup_destroy_root(root);\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\tBUG_ON(atomic_read(&root->nr_cgrps));\n\tBUG_ON(!list_empty(&cgrp->self.children));\n\n\t/* Rebind all subsystems back to the default hierarchy */\n\tWARN_ON(rebind_subsystems(&cgrp_dfl_root, root->subsys_mask));\n\n\t/*\n\t * Release all the links from cset_links to this hierarchy's\n\t * root cgroup\n\t */\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_for_each_entry_safe(link, tmp_link, &cgrp->cset_links, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tkfree(link);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!list_empty(&root->root_list)) {\n\t\tlist_del(&root->root_list);\n\t\tcgroup_root_count--;\n\t}\n\n\tcgroup_exit_root_id(root);\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tcgroup_rstat_exit(cgrp);\n\tkernfs_destroy_root(root->kf_root);\n\tcgroup_free_root(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cgrp"
          ],
          "line": 5137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_exit",
          "args": [
            "cgrp"
          ],
          "line": 5136
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "267-284",
          "snippet": "void cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_cgroup_free",
          "args": [
            "cgrp"
          ],
          "line": 5135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "cgrp->kn"
          ],
          "line": 5134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgroup_parent(cgrp)"
          ],
          "line": 5133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 5133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 5126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "&cgrp->release_agent_work"
          ],
          "line": 5124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup1_pidlist_destroy_all",
          "args": [
            "cgrp"
          ],
          "line": 5123
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup1_pidlist_destroy_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-v1.c",
          "lines": "196-207",
          "snippet": "void cgroup1_pidlist_destroy_all(struct cgroup *cgrp)\n{\n\tstruct cgroup_pidlist *l, *tmp_l;\n\n\tmutex_lock(&cgrp->pidlist_mutex);\n\tlist_for_each_entry_safe(l, tmp_l, &cgrp->pidlists, links)\n\t\tmod_delayed_work(cgroup_pidlist_destroy_wq, &l->destroy_dwork, 0);\n\tmutex_unlock(&cgrp->pidlist_mutex);\n\n\tflush_workqueue(cgroup_pidlist_destroy_wq);\n\tBUG_ON(!list_empty(&cgrp->pidlists));\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/delay.h>",
            "#include <linux/sort.h>",
            "#include <linux/kmod.h>",
            "#include <linux/ctype.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *cgroup_pidlist_destroy_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include <linux/fs_parser.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nstatic struct workqueue_struct *cgroup_pidlist_destroy_wq;\n\nvoid cgroup1_pidlist_destroy_all(struct cgroup *cgrp)\n{\n\tstruct cgroup_pidlist *l, *tmp_l;\n\n\tmutex_lock(&cgrp->pidlist_mutex);\n\tlist_for_each_entry_safe(l, tmp_l, &cgrp->pidlists, links)\n\t\tmod_delayed_work(cgroup_pidlist_destroy_wq, &l->destroy_dwork, 0);\n\tmutex_unlock(&cgrp->pidlist_mutex);\n\n\tflush_workqueue(cgroup_pidlist_destroy_wq);\n\tBUG_ON(!list_empty(&cgrp->pidlists));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&cgrp->root->nr_cgrps"
          ],
          "line": 5122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "parent"
          ],
          "line": 5119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 5116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_idr_remove",
          "args": [
            "&ss->css_idr",
            "id"
          ],
          "line": 5115
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "342-347",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss->css_free",
          "args": [
            "css"
          ],
          "line": 5114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&css->refcnt"
          ],
          "line": 5107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "to_rcu_work(work)",
            "structcgroup_subsys_state",
            "destroy_rwork"
          ],
          "line": 5102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_rcu_work",
          "args": [
            "work"
          ],
          "line": 5102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void css_free_rwork_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css = container_of(to_rcu_work(work),\n\t\t\t\tstruct cgroup_subsys_state, destroy_rwork);\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tpercpu_ref_exit(&css->refcnt);\n\n\tif (ss) {\n\t\t/* css free path */\n\t\tstruct cgroup_subsys_state *parent = css->parent;\n\t\tint id = css->id;\n\n\t\tss->css_free(css);\n\t\tcgroup_idr_remove(&ss->css_idr, id);\n\t\tcgroup_put(cgrp);\n\n\t\tif (parent)\n\t\t\tcss_put(parent);\n\t} else {\n\t\t/* cgroup free path */\n\t\tatomic_dec(&cgrp->root->nr_cgrps);\n\t\tcgroup1_pidlist_destroy_all(cgrp);\n\t\tcancel_work_sync(&cgrp->release_agent_work);\n\n\t\tif (cgroup_parent(cgrp)) {\n\t\t\t/*\n\t\t\t * We get a ref to the parent, and put the ref when\n\t\t\t * this cgroup is being freed, so it's guaranteed\n\t\t\t * that the parent won't be destroyed before its\n\t\t\t * children.\n\t\t\t */\n\t\t\tcgroup_put(cgroup_parent(cgrp));\n\t\t\tkernfs_put(cgrp->kn);\n\t\t\tpsi_cgroup_free(cgrp);\n\t\t\tcgroup_rstat_exit(cgrp);\n\t\t\tkfree(cgrp);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is root cgroup's refcnt reaching zero,\n\t\t\t * which indicates that the root should be\n\t\t\t * released.\n\t\t\t */\n\t\t\tcgroup_destroy_root(cgrp->root);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "cgroup_threads_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4971-4975",
    "snippet": "static ssize_t cgroup_threads_write(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes, loff_t off)\n{\n\treturn __cgroup_procs_write(of, buf, false) ?: nbytes;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cgroup_procs_write",
          "args": [
            "of",
            "buf",
            "false"
          ],
          "line": 4974
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_procs_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4913-4958",
          "snippet": "static ssize_t __cgroup_procs_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t    bool threadgroup)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tconst struct cred *saved_cred;\n\tssize_t ret;\n\tbool locked;\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, threadgroup, &locked);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Process and thread migrations follow same delegation rule. Check\n\t * permissions using the credentials from file open to protect against\n\t * inherited fd attacks.\n\t */\n\tsaved_cred = override_creds(of->file->f_cred);\n\tret = cgroup_attach_permissions(src_cgrp, dst_cgrp,\n\t\t\t\t\tof->file->f_path.dentry->d_sb,\n\t\t\t\t\tthreadgroup, ctx->ns);\n\trevert_creds(saved_cred);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, threadgroup);\n\nout_finish:\n\tcgroup_procs_write_finish(task, locked);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic ssize_t __cgroup_procs_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t    bool threadgroup)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tconst struct cred *saved_cred;\n\tssize_t ret;\n\tbool locked;\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, threadgroup, &locked);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Process and thread migrations follow same delegation rule. Check\n\t * permissions using the credentials from file open to protect against\n\t * inherited fd attacks.\n\t */\n\tsaved_cred = override_creds(of->file->f_cred);\n\tret = cgroup_attach_permissions(src_cgrp, dst_cgrp,\n\t\t\t\t\tof->file->f_path.dentry->d_sb,\n\t\t\t\t\tthreadgroup, ctx->ns);\n\trevert_creds(saved_cred);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, threadgroup);\n\nout_finish:\n\tcgroup_procs_write_finish(task, locked);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic ssize_t cgroup_threads_write(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes, loff_t off)\n{\n\treturn __cgroup_procs_write(of, buf, false) ?: nbytes;\n}"
  },
  {
    "function_name": "cgroup_threads_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4966-4969",
    "snippet": "static void *cgroup_threads_start(struct seq_file *s, loff_t *pos)\n{\n\treturn __cgroup_procs_start(s, pos, 0);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cgroup_procs_start",
          "args": [
            "s",
            "pos",
            "0"
          ],
          "line": 4968
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_procs_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4796-4820",
          "snippet": "static void *__cgroup_procs_start(struct seq_file *s, loff_t *pos,\n\t\t\t\t  unsigned int iter_flags)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct css_task_iter *it = &ctx->procs.iter;\n\n\t/*\n\t * When a seq_file is seeked, it's always traversed sequentially\n\t * from position 0, so we can simply keep iterating on !0 *pos.\n\t */\n\tif (!ctx->procs.started) {\n\t\tif (WARN_ON_ONCE((*pos)))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t\tctx->procs.started = true;\n\t} else if (!(*pos)) {\n\t\tcss_task_iter_end(it);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t} else\n\t\treturn it->cur_task;\n\n\treturn cgroup_procs_next(s, NULL, NULL);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void *__cgroup_procs_start(struct seq_file *s, loff_t *pos,\n\t\t\t\t  unsigned int iter_flags)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct css_task_iter *it = &ctx->procs.iter;\n\n\t/*\n\t * When a seq_file is seeked, it's always traversed sequentially\n\t * from position 0, so we can simply keep iterating on !0 *pos.\n\t */\n\tif (!ctx->procs.started) {\n\t\tif (WARN_ON_ONCE((*pos)))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t\tctx->procs.started = true;\n\t} else if (!(*pos)) {\n\t\tcss_task_iter_end(it);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t} else\n\t\treturn it->cur_task;\n\n\treturn cgroup_procs_next(s, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void *cgroup_threads_start(struct seq_file *s, loff_t *pos)\n{\n\treturn __cgroup_procs_start(s, pos, 0);\n}"
  },
  {
    "function_name": "cgroup_procs_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4960-4964",
    "snippet": "static ssize_t cgroup_procs_write(struct kernfs_open_file *of,\n\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\treturn __cgroup_procs_write(of, buf, true) ?: nbytes;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cgroup_procs_write",
          "args": [
            "of",
            "buf",
            "true"
          ],
          "line": 4963
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_procs_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4913-4958",
          "snippet": "static ssize_t __cgroup_procs_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t    bool threadgroup)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tconst struct cred *saved_cred;\n\tssize_t ret;\n\tbool locked;\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, threadgroup, &locked);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Process and thread migrations follow same delegation rule. Check\n\t * permissions using the credentials from file open to protect against\n\t * inherited fd attacks.\n\t */\n\tsaved_cred = override_creds(of->file->f_cred);\n\tret = cgroup_attach_permissions(src_cgrp, dst_cgrp,\n\t\t\t\t\tof->file->f_path.dentry->d_sb,\n\t\t\t\t\tthreadgroup, ctx->ns);\n\trevert_creds(saved_cred);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, threadgroup);\n\nout_finish:\n\tcgroup_procs_write_finish(task, locked);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic ssize_t __cgroup_procs_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t    bool threadgroup)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tconst struct cred *saved_cred;\n\tssize_t ret;\n\tbool locked;\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, threadgroup, &locked);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Process and thread migrations follow same delegation rule. Check\n\t * permissions using the credentials from file open to protect against\n\t * inherited fd attacks.\n\t */\n\tsaved_cred = override_creds(of->file->f_cred);\n\tret = cgroup_attach_permissions(src_cgrp, dst_cgrp,\n\t\t\t\t\tof->file->f_path.dentry->d_sb,\n\t\t\t\t\tthreadgroup, ctx->ns);\n\trevert_creds(saved_cred);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, threadgroup);\n\nout_finish:\n\tcgroup_procs_write_finish(task, locked);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic ssize_t cgroup_procs_write(struct kernfs_open_file *of,\n\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\treturn __cgroup_procs_write(of, buf, true) ?: nbytes;\n}"
  },
  {
    "function_name": "__cgroup_procs_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4913-4958",
    "snippet": "static ssize_t __cgroup_procs_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t    bool threadgroup)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tconst struct cred *saved_cred;\n\tssize_t ret;\n\tbool locked;\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, threadgroup, &locked);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Process and thread migrations follow same delegation rule. Check\n\t * permissions using the credentials from file open to protect against\n\t * inherited fd attacks.\n\t */\n\tsaved_cred = override_creds(of->file->f_cred);\n\tret = cgroup_attach_permissions(src_cgrp, dst_cgrp,\n\t\t\t\t\tof->file->f_path.dentry->d_sb,\n\t\t\t\t\tthreadgroup, ctx->ns);\n\trevert_creds(saved_cred);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, threadgroup);\n\nout_finish:\n\tcgroup_procs_write_finish(task, locked);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_kn_unlock",
          "args": [
            "of->kn"
          ],
          "line": 4955
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1583-1596",
          "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_procs_write_finish",
          "args": [
            "task",
            "locked"
          ],
          "line": 4953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_attach_task",
          "args": [
            "dst_cgrp",
            "task",
            "threadgroup"
          ],
          "line": 4950
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_attach_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2783-4623",
          "snippet": "int cgroup_attach_task(struct cgroup *dst_cgrp, struct task_struct *leader,\n\t\t       bool threadgroup)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct task_struct *task;\n\tint ret = 0;\n\n\t/* look up all src csets */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_src(task_css_set(task), dst_cgrp, &mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* prepare dst csets and commit */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (!ret)\n\t\tret = cgroup_migrate(leader, threadgroup, &mgctx);\n\n\tcgroup_migrate_finish(&mgctx);\n\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(attach_task, dst_cgrp, leader, threadgroup);\n\n\treturn ret;\n}\n\nstruct task_struct *cgroup_procs_write_start(char *buf, bool threadgroup,\n\t\t\t\t\t     bool *locked)\n\t__acquires(&cgroup_threadgroup_rwsem)\n{\n\tstruct task_struct *tsk;\n\tpid_t pid;\n\n\tif (kstrtoint(strstrip(buf), 0, &pid) || pid < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If we migrate a single thread, we don't care about threadgroup\n\t * stability. If the thread is `current`, it won't exit(2) under our\n\t * hands or change PID through exec(2). We exclude\n\t * cgroup_update_dfl_csses and other cgroup_{proc,thread}s_write\n\t * callers by cgroup_mutex.\n\t * Therefore, we can skip the global lock.\n\t */\n\tlockdep_assert_held(&cgroup_mutex);\n\tif (pid || threadgroup) {\n\t\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\t\t*locked = true;\n\t} else {\n\t\t*locked = false;\n\t}\n\n\trcu_read_lock();\n\tif (pid) {\n\t\ttsk = find_task_by_vpid(pid);\n\t\tif (!tsk) {\n\t\t\ttsk = ERR_PTR(-ESRCH);\n\t\t\tgoto out_unlock_threadgroup;\n\t\t}\n\t} else {\n\t\ttsk = current;\n\t}\n\n\tif (threadgroup)\n\t\ttsk = tsk->group_leader;\n\n\t/*\n\t * kthreads may acquire PF_NO_SETAFFINITY during initialization.\n\t * If userland migrates such a kthread to a non-root cgroup, it can\n\t * become trapped in a cpuset, or RT kthread may be born in a\n\t * cgroup with no rt_runtime allocated.  Just say no.\n\t */\n\tif (tsk->no_cgroup_migration || (tsk->flags & PF_NO_SETAFFINITY)) {\n\t\ttsk = ERR_PTR(-EINVAL);\n\t\tgoto out_unlock_threadgroup;\n\t}\n\n\tget_task_struct(tsk);\n\tgoto out_unlock_rcu;\n\nout_unlock_threadgroup:\n\tif (*locked) {\n\t\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\t\t*locked = false;\n\t}\nout_unlock_rcu:\n\trcu_read_unlock();\n\treturn tsk;\n}\n\nvoid cgroup_procs_write_finish(struct task_struct *task, bool locked)\n\t__releases(&cgroup_threadgroup_rwsem)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\t/* release reference from cgroup_procs_write_start() */\n\tput_task_struct(task);\n\n\tif (locked)\n\t\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\tfor_each_subsys(ss, ssid)\n\t\tif (ss->post_attach)\n\t\t\tss->post_attach();\n}\n\nstatic void cgroup_print_ss_mask(struct seq_file *seq, u16 ss_mask)\n{\n\tstruct cgroup_subsys *ss;\n\tbool printed = false;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tif (printed)\n\t\t\tseq_putc(seq, ' ');\n\t\tseq_puts(seq, ss->name);\n\t\tprinted = true;\n\t} while_each_subsys_mask();\n\tif (printed)\n\t\tseq_putc(seq, '\\n');\n}\n\n/* show controllers which are enabled from the parent */\nstatic int cgroup_controllers_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgroup_control(cgrp));\n\treturn 0;\n}\n\n/* show controllers which are enabled for a given cgroup's children */\nstatic int cgroup_subtree_control_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgrp->subtree_control);\n\treturn 0;\n}\n\n/**\n * cgroup_update_dfl_csses - update css assoc of a subtree in default hierarchy\n * @cgrp: root of the subtree to update csses for\n *\n * @cgrp's control masks have changed and its subtree's css associations\n * need to be updated accordingly.  This function looks up all css_sets\n * which are attached to the subtree, creates the matching updated css_sets\n * and migrates the tasks to the new ones.\n */\nstatic int cgroup_update_dfl_csses(struct cgroup *cgrp)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup *dsct;\n\tstruct css_set *src_cset;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\t/* look up all csses currently attached to @cgrp's subtree */\n\tspin_lock_irq(&css_set_lock);\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &dsct->cset_links, cset_link)\n\t\t\tcgroup_migrate_add_src(link->cset, dsct, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* NULL dst indicates self on default hierarchy */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(src_cset, &mgctx.preloaded_src_csets, mg_preload_node) {\n\t\tstruct task_struct *task, *ntask;\n\n\t\t/* all tasks in src_csets need to be migrated */\n\t\tlist_for_each_entry_safe(task, ntask, &src_cset->tasks, cg_list)\n\t\t\tcgroup_migrate_add_task(task, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_migrate_execute(&mgctx);\nout_finish:\n\tcgroup_migrate_finish(&mgctx);\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\treturn ret;\n}\n\n/**\n * cgroup_lock_and_drain_offline - lock cgroup_mutex and drain offlined csses\n * @cgrp: root of the target subtree\n *\n * Because css offlining is asynchronous, userland may try to re-enable a\n * controller while the previous css is still around.  This function grabs\n * cgroup_mutex and drains the previous css instances of @cgrp's subtree.\n */\nvoid cgroup_lock_and_drain_offline(struct cgroup *cgrp)\n\t__acquires(&cgroup_mutex)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\nrestart:\n\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\t\t\tDEFINE_WAIT(wait);\n\n\t\t\tif (!css || !percpu_ref_is_dying(&css->refcnt))\n\t\t\t\tcontinue;\n\n\t\t\tcgroup_get_live(dsct);\n\t\t\tprepare_to_wait(&dsct->offline_waitq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tschedule();\n\t\t\tfinish_wait(&dsct->offline_waitq, &wait);\n\n\t\t\tcgroup_put(dsct);\n\t\t\tgoto restart;\n\t\t}\n\t}\n}\n\n/**\n * cgroup_save_control - save control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Save ->subtree_control, ->subtree_ss_mask and ->dom_cgrp to the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_save_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->old_subtree_control = dsct->subtree_control;\n\t\tdsct->old_subtree_ss_mask = dsct->subtree_ss_mask;\n\t\tdsct->old_dom_cgrp = dsct->dom_cgrp;\n\t}\n}\n\n/**\n * cgroup_propagate_control - refresh control masks of a subtree\n * @cgrp: root of the target subtree\n *\n * For @cgrp and its subtree, ensure ->subtree_ss_mask matches\n * ->subtree_control and propagate controller availability through the\n * subtree so that descendants don't have unavailable controllers enabled.\n */\nstatic void cgroup_propagate_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control &= cgroup_control(dsct);\n\t\tdsct->subtree_ss_mask =\n\t\t\tcgroup_calc_subtree_ss_mask(dsct->subtree_control,\n\t\t\t\t\t\t    cgroup_ss_mask(dsct));\n\t}\n}\n\n/**\n * cgroup_restore_control - restore control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Restore ->subtree_control, ->subtree_ss_mask and ->dom_cgrp from the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_restore_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control = dsct->old_subtree_control;\n\t\tdsct->subtree_ss_mask = dsct->old_subtree_ss_mask;\n\t\tdsct->dom_cgrp = dsct->old_dom_cgrp;\n\t}\n}\n\nstatic bool css_visible(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tif (cgroup_control(cgrp) & (1 << ss->id))\n\t\treturn true;\n\tif (!(cgroup_ss_mask(cgrp) & (1 << ss->id)))\n\t\treturn false;\n\treturn cgroup_on_dfl(cgrp) && ss->implicit_on_dfl;\n}\n\n/**\n * cgroup_apply_control_enable - enable or show csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and create new csses or make the existing ones\n * visible.  A css is created invisible if it's being implicitly enabled\n * through dependency.  An invisible css is made visible when the userland\n * explicitly enables it.\n *\n * Returns 0 on success, -errno on failure.  On failure, csses which have\n * been processed already aren't cleaned up.  The caller is responsible for\n * cleaning up with cgroup_apply_control_disable().\n */\nstatic int cgroup_apply_control_enable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid, ret;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tif (!(cgroup_ss_mask(dsct) & (1 << ss->id)))\n\t\t\t\tcontinue;\n\n\t\t\tif (!css) {\n\t\t\t\tcss = css_create(dsct, ss);\n\t\t\t\tif (IS_ERR(css))\n\t\t\t\t\treturn PTR_ERR(css);\n\t\t\t}\n\n\t\t\tWARN_ON_ONCE(percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (css_visible(css)) {\n\t\t\t\tret = css_populate_dir(css);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_apply_control_disable - kill or hide csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and kill and hide csses so that they match\n * cgroup_ss_mask() and cgroup_visible_mask().\n *\n * A css is hidden when the userland requests it to be disabled while other\n * subsystems are still depending on it.  The css must not actively control\n * resources and be in the vanilla state if it's made visible again later.\n * Controllers which may be depended upon should provide ->css_reset() for\n * this purpose.\n */\nstatic void cgroup_apply_control_disable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tif (!css)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (css->parent &&\n\t\t\t    !(cgroup_ss_mask(dsct) & (1 << ss->id))) {\n\t\t\t\tkill_css(css);\n\t\t\t} else if (!css_visible(css)) {\n\t\t\t\tcss_clear_dir(css);\n\t\t\t\tif (ss->css_reset)\n\t\t\t\t\tss->css_reset(css);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * cgroup_apply_control - apply control mask updates to the subtree\n * @cgrp: root of the target subtree\n *\n * subsystems can be enabled and disabled in a subtree using the following\n * steps.\n *\n * 1. Call cgroup_save_control() to stash the current state.\n * 2. Update ->subtree_control masks in the subtree as desired.\n * 3. Call cgroup_apply_control() to apply the changes.\n * 4. Optionally perform other related operations.\n * 5. Call cgroup_finalize_control() to finish up.\n *\n * This function implements step 3 and propagates the mask changes\n * throughout @cgrp's subtree, updates csses accordingly and perform\n * process migrations.\n */\nstatic int cgroup_apply_control(struct cgroup *cgrp)\n{\n\tint ret;\n\n\tcgroup_propagate_control(cgrp);\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * At this point, cgroup_e_css_by_mask() results reflect the new csses\n\t * making the following cgroup_update_dfl_csses() properly update\n\t * css associations of all tasks in the subtree.\n\t */\n\tret = cgroup_update_dfl_csses(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n/**\n * cgroup_finalize_control - finalize control mask update\n * @cgrp: root of the target subtree\n * @ret: the result of the update\n *\n * Finalize control mask update.  See cgroup_apply_control() for more info.\n */\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret)\n{\n\tif (ret) {\n\t\tcgroup_restore_control(cgrp);\n\t\tcgroup_propagate_control(cgrp);\n\t}\n\n\tcgroup_apply_control_disable(cgrp);\n}\n\nstatic int cgroup_vet_subtree_control_enable(struct cgroup *cgrp, u16 enable)\n{\n\tu16 domain_enable = enable & ~cgrp_dfl_threaded_ss_mask;\n\n\t/* if nothing is getting enabled, nothing to worry about */\n\tif (!enable)\n\t\treturn 0;\n\n\t/* can @cgrp host any resources? */\n\tif (!cgroup_is_valid_domain(cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn 0;\n\n\tif (domain_enable) {\n\t\t/* can't enable domain controllers inside a thread subtree */\n\t\tif (cgroup_is_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\t/*\n\t\t * Threaded controllers can handle internal competitions\n\t\t * and are always allowed inside a (prospective) thread\n\t\t * subtree.\n\t\t */\n\t\tif (cgroup_can_be_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Controllers can't be enabled for a cgroup with tasks to avoid\n\t * child cgroups competing against tasks.\n\t */\n\tif (cgroup_has_tasks(cgrp))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n/* change the enabled child controllers for a cgroup in the default hierarchy */\nstatic ssize_t cgroup_subtree_control_write(struct kernfs_open_file *of,\n\t\t\t\t\t    char *buf, size_t nbytes,\n\t\t\t\t\t    loff_t off)\n{\n\tu16 enable = 0, disable = 0;\n\tstruct cgroup *cgrp, *child;\n\tstruct cgroup_subsys *ss;\n\tchar *tok;\n\tint ssid, ret;\n\n\t/*\n\t * Parse input - space separated list of subsystem names prefixed\n\t * with either + or -.\n\t */\n\tbuf = strstrip(buf);\n\twhile ((tok = strsep(&buf, \" \"))) {\n\t\tif (tok[0] == '\\0')\n\t\t\tcontinue;\n\t\tdo_each_subsys_mask(ss, ssid, ~cgrp_dfl_inhibit_ss_mask) {\n\t\t\tif (!cgroup_ssid_enabled(ssid) ||\n\t\t\t    strcmp(tok + 1, ss->name))\n\t\t\t\tcontinue;\n\n\t\t\tif (*tok == '+') {\n\t\t\t\tenable |= 1 << ssid;\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t} else if (*tok == '-') {\n\t\t\t\tdisable |= 1 << ssid;\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t} while_each_subsys_mask();\n\t\tif (ssid == CGROUP_SUBSYS_COUNT)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (enable & (1 << ssid)) {\n\t\t\tif (cgrp->subtree_control & (1 << ssid)) {\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(cgroup_control(cgrp) & (1 << ssid))) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else if (disable & (1 << ssid)) {\n\t\t\tif (!(cgrp->subtree_control & (1 << ssid))) {\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* a child has it enabled? */\n\t\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\t\tif (child->subtree_control & (1 << ssid)) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!enable && !disable) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tret = cgroup_vet_subtree_control_enable(cgrp, enable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* save and update control masks and prepare csses */\n\tcgroup_save_control(cgrp);\n\n\tcgrp->subtree_control |= enable;\n\tcgrp->subtree_control &= ~disable;\n\n\tret = cgroup_apply_control(cgrp);\n\tcgroup_finalize_control(cgrp, ret);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tkernfs_activate(cgrp->kn);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\n/**\n * cgroup_enable_threaded - make @cgrp threaded\n * @cgrp: the target cgroup\n *\n * Called when \"threaded\" is written to the cgroup.type interface file and\n * tries to make @cgrp threaded and join the parent's resource domain.\n * This function is never called on the root cgroup as cgroup.type doesn't\n * exist on it.\n */\nstatic int cgroup_enable_threaded(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup *dom_cgrp = parent->dom_cgrp;\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* noop if already threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @cgroup is populated or has domain controllers enabled, it\n\t * can't be switched.  While the below cgroup_can_be_thread_root()\n\t * test can catch the same conditions, that's only when @parent is\n\t * not mixable, so let's check it explicitly.\n\t */\n\tif (cgroup_is_populated(cgrp) ||\n\t    cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn -EOPNOTSUPP;\n\n\t/* we're joining the parent's domain, ensure its validity */\n\tif (!cgroup_is_valid_domain(dom_cgrp) ||\n\t    !cgroup_can_be_thread_root(dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * The following shouldn't cause actual migrations and should\n\t * always succeed.\n\t */\n\tcgroup_save_control(cgrp);\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp)\n\t\tif (dsct == cgrp || cgroup_is_threaded(dsct))\n\t\t\tdsct->dom_cgrp = dom_cgrp;\n\n\tret = cgroup_apply_control(cgrp);\n\tif (!ret)\n\t\tparent->nr_threaded_children++;\n\n\tcgroup_finalize_control(cgrp, ret);\n\treturn ret;\n}\n\nstatic int cgroup_type_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tif (cgroup_is_threaded(cgrp))\n\t\tseq_puts(seq, \"threaded\\n\");\n\telse if (!cgroup_is_valid_domain(cgrp))\n\t\tseq_puts(seq, \"domain invalid\\n\");\n\telse if (cgroup_is_thread_root(cgrp))\n\t\tseq_puts(seq, \"domain threaded\\n\");\n\telse\n\t\tseq_puts(seq, \"domain\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_type_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\t/* only switching to threaded mode is supported */\n\tif (strcmp(strstrip(buf), \"threaded\"))\n\t\treturn -EINVAL;\n\n\t/* drain dying csses before we re-apply (threaded) subtree control */\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\t/* threaded can only be enabled */\n\tret = cgroup_enable_threaded(cgrp);\n\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\nstatic int cgroup_max_descendants_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint descendants = READ_ONCE(cgrp->max_descendants);\n\n\tif (descendants == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", descendants);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_descendants_write(struct kernfs_open_file *of,\n\t\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint descendants;\n\tssize_t ret;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdescendants = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &descendants);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (descendants < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_descendants = descendants;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_max_depth_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint depth = READ_ONCE(cgrp->max_depth);\n\n\tif (depth == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", depth);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_depth_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint depth;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdepth = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &depth);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (depth < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_depth = depth;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_events_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"populated %d\\n\", cgroup_is_populated(cgrp));\n\tseq_printf(seq, \"frozen %d\\n\", test_bit(CGRP_FROZEN, &cgrp->flags));\n\n\treturn 0;\n}\n\nstatic int cgroup_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgroup = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"nr_descendants %d\\n\",\n\t\t   cgroup->nr_descendants);\n\tseq_printf(seq, \"nr_dying_descendants %d\\n\",\n\t\t   cgroup->nr_dying_descendants);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cgroup_extra_stat_show(struct seq_file *seq,\n\t\t\t\t\t\t struct cgroup *cgrp, int ssid)\n{\n\tstruct cgroup_subsys *ss = cgroup_subsys[ssid];\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!ss->css_extra_stat_show)\n\t\treturn 0;\n\n\tcss = cgroup_tryget_css(cgrp, ss);\n\tif (!css)\n\t\treturn 0;\n\n\tret = ss->css_extra_stat_show(seq, css);\n\tcss_put(css);\n\treturn ret;\n}\n\nstatic int cpu_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup __maybe_unused *cgrp = seq_css(seq)->cgroup;\n\tint ret = 0;\n\n\tcgroup_base_stat_cputime_show(seq);\n#ifdef CONFIG_CGROUP_SCHED\n\tret = cgroup_extra_stat_show(seq, cgrp, cpu_cgrp_id);\n#endif\n\treturn ret;\n}\n\n#ifdef CONFIG_PSI\nstatic int cgroup_io_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_IO);\n}\nstatic int cgroup_memory_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_MEM);\n}\nstatic int cgroup_cpu_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_CPU);\n}\n\nstatic ssize_t cgroup_pressure_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t\t  size_t nbytes, enum psi_res res)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct psi_trigger *new;\n\tstruct cgroup *cgrp;\n\tstruct psi_group *psi;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tcgroup_get(cgrp);\n\tcgroup_kn_unlock(of->kn);\n\n\tpsi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\tnew = psi_trigger_create(psi, buf, nbytes, res);\n\tif (IS_ERR(new)) {\n\t\tcgroup_put(cgrp);\n\t\treturn PTR_ERR(new);\n\t}\n\n\tpsi_trigger_replace(&ctx->psi.trigger, new);\n\n\tcgroup_put(cgrp);\n\n\treturn nbytes;\n}\n\nstatic ssize_t cgroup_io_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_IO);\n}\n\nstatic ssize_t cgroup_memory_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_MEM);\n}\n\nstatic ssize_t cgroup_cpu_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_CPU);\n}\n\nstatic __poll_t cgroup_pressure_poll(struct kernfs_open_file *of,\n\t\t\t\t\t  poll_table *pt)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\treturn psi_trigger_poll(&ctx->psi.trigger, of->file, pt);\n}\n\nstatic void cgroup_pressure_release(struct kernfs_open_file *of)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tpsi_trigger_replace(&ctx->psi.trigger, NULL);\n}\n\nbool cgroup_psi_enabled(void)\n{\n\treturn (cgroup_feature_disable_mask & (1 << OPT_FEATURE_PRESSURE)) == 0;\n}\n\n#else /* CONFIG_PSI */\nbool cgroup_psi_enabled(void)\n{\n\treturn false;\n}\n\n#endif /* CONFIG_PSI */\n\nstatic int cgroup_freeze_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"%d\\n\", cgrp->freezer.freeze);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_freeze_write(struct kernfs_open_file *of,\n\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint freeze;\n\n\tret = kstrtoint(strstrip(buf), 0, &freeze);\n\tif (ret)\n\t\treturn ret;\n\n\tif (freeze < 0 || freeze > 1)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgroup_freeze(cgrp, freeze);\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic void __cgroup_kill(struct cgroup *cgrp)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tset_bit(CGRP_KILL, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tcss_task_iter_start(&cgrp->self, CSS_TASK_ITER_PROCS | CSS_TASK_ITER_THREADED, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t/* Ignore kernel threads here. */\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\n\t\t/* Skip tasks that are already dying. */\n\t\tif (__fatal_signal_pending(task))\n\t\t\tcontinue;\n\n\t\tsend_sig(SIGKILL, task, 0);\n\t}\n\tcss_task_iter_end(&it);\n\n\tspin_lock_irq(&css_set_lock);\n\tclear_bit(CGRP_KILL, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n}\n\nstatic void cgroup_kill(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *dsct;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_for_each_live_descendant_pre(dsct, css, cgrp)\n\t\t__cgroup_kill(dsct);\n}\n\nstatic ssize_t cgroup_kill_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tssize_t ret = 0;\n\tint kill;\n\tstruct cgroup *cgrp;\n\n\tret = kstrtoint(strstrip(buf), 0, &kill);\n\tif (ret)\n\t\treturn ret;\n\n\tif (kill != 1)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Killing is a process directed operation, i.e. the whole thread-group\n\t * is taken down so act like we do for cgroup.procs and only make this\n\t * writable in non-threaded cgroups.\n\t */\n\tif (cgroup_is_threaded(cgrp))\n\t\tret = -EOPNOTSUPP;\n\telse\n\t\tcgroup_kill(cgrp);\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\nstatic int cgroup_file_open(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of_cft(of);\n\tstruct cgroup_file_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ns = current->nsproxy->cgroup_ns;\n\tget_cgroup_ns(ctx->ns);\n\tof->priv = ctx;\n\n\tif (!cft->open)\n\t\treturn 0;\n\n\tret = cft->open(of);\n\tif (ret) {\n\t\tput_cgroup_ns(ctx->ns);\n\t\tkfree(ctx);\n\t}\n\treturn ret;\n}\n\nstatic void cgroup_file_release(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of_cft(of);\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tif (cft->release)\n\t\tcft->release(of);\n\tput_cgroup_ns(ctx->ns);\n\tkfree(ctx);\n}\n\nstatic ssize_t cgroup_file_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!nbytes)\n\t\treturn 0;\n\n\t/*\n\t * If namespaces are delegation boundaries, disallow writes to\n\t * files in an non-init namespace root from inside the namespace\n\t * except for the files explicitly marked delegatable -\n\t * cgroup.procs and cgroup.subtree_control.\n\t */\n\tif ((cgrp->root->flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    !(cft->flags & CFTYPE_NS_DELEGATABLE) &&\n\t    ctx->ns != &init_cgroup_ns && ctx->ns->root_cset->dfl_cgrp == cgrp)\n\t\treturn -EPERM;\n\n\tif (cft->write)\n\t\treturn cft->write(of, buf, nbytes, off);\n\n\t/*\n\t * kernfs guarantees that a file isn't deleted with operations in\n\t * flight, which means that the matching css is and stays alive and\n\t * doesn't need to be pinned.  The RCU locking is not necessary\n\t * either.  It's just for the convenience of using cgroup_css().\n\t */\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, cft->ss);\n\trcu_read_unlock();\n\n\tif (cft->write_u64) {\n\t\tunsigned long long v;\n\t\tret = kstrtoull(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_u64(css, cft, v);\n\t} else if (cft->write_s64) {\n\t\tlong long v;\n\t\tret = kstrtoll(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_s64(css, cft, v);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret ?: nbytes;\n}\n\nstatic __poll_t cgroup_file_poll(struct kernfs_open_file *of, poll_table *pt)\n{\n\tstruct cftype *cft = of_cft(of);\n\n\tif (cft->poll)\n\t\treturn cft->poll(of, pt);\n\n\treturn kernfs_generic_poll(of, pt);\n}\n\nstatic void *cgroup_seqfile_start(struct seq_file *seq, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_start(seq, ppos);\n}\n\nstatic void *cgroup_seqfile_next(struct seq_file *seq, void *v, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_next(seq, v, ppos);\n}\n\nstatic void cgroup_seqfile_stop(struct seq_file *seq, void *v)\n{\n\tif (seq_cft(seq)->seq_stop)\n\t\tseq_cft(seq)->seq_stop(seq, v);\n}\n\nstatic int cgroup_seqfile_show(struct seq_file *m, void *arg)\n{\n\tstruct cftype *cft = seq_cft(m);\n\tstruct cgroup_subsys_state *css = seq_css(m);\n\n\tif (cft->seq_show)\n\t\treturn cft->seq_show(m, arg);\n\n\tif (cft->read_u64)\n\t\tseq_printf(m, \"%llu\\n\", cft->read_u64(css, cft));\n\telse if (cft->read_s64)\n\t\tseq_printf(m, \"%lld\\n\", cft->read_s64(css, cft));\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct kernfs_ops cgroup_kf_single_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.poll\t\t\t= cgroup_file_poll,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\nstatic struct kernfs_ops cgroup_kf_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.poll\t\t\t= cgroup_file_poll,\n\t.seq_start\t\t= cgroup_seqfile_start,\n\t.seq_next\t\t= cgroup_seqfile_next,\n\t.seq_stop\t\t= cgroup_seqfile_stop,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\n/* set uid and gid of cgroup dirs and files to that of the creator */\nstatic int cgroup_kn_set_ugid(struct kernfs_node *kn)\n{\n\tstruct iattr iattr = { .ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t       .ia_uid = current_fsuid(),\n\t\t\t       .ia_gid = current_fsgid(), };\n\n\tif (uid_eq(iattr.ia_uid, GLOBAL_ROOT_UID) &&\n\t    gid_eq(iattr.ia_gid, GLOBAL_ROOT_GID))\n\t\treturn 0;\n\n\treturn kernfs_setattr(kn, &iattr);\n}\n\nstatic void cgroup_file_notify_timer(struct timer_list *timer)\n{\n\tcgroup_file_notify(container_of(timer, struct cgroup_file,\n\t\t\t\t\tnotify_timer));\n}\n\nstatic int cgroup_add_file(struct cgroup_subsys_state *css, struct cgroup *cgrp,\n\t\t\t   struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\tstruct kernfs_node *kn;\n\tstruct lock_class_key *key = NULL;\n\tint ret;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tkey = &cft->lockdep_key;\n#endif\n\tkn = __kernfs_create_file(cgrp->kn, cgroup_file_name(cgrp, cft, name),\n\t\t\t\t  cgroup_file_mode(cft),\n\t\t\t\t  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,\n\t\t\t\t  0, cft->kf_ops, cft,\n\t\t\t\t  NULL, key);\n\tif (IS_ERR(kn))\n\t\treturn PTR_ERR(kn);\n\n\tret = cgroup_kn_set_ugid(kn);\n\tif (ret) {\n\t\tkernfs_remove(kn);\n\t\treturn ret;\n\t}\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\ttimer_setup(&cfile->notify_timer, cgroup_file_notify_timer, 0);\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = kn;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_addrm_files - add or remove files to a cgroup directory\n * @css: the target css\n * @cgrp: the target cgroup (usually css->cgroup)\n * @cfts: array of cftypes to be added\n * @is_add: whether to add or remove\n *\n * Depending on @is_add, add or remove files defined by @cfts on @cgrp.\n * For removals, this function never fails.\n */\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add)\n{\n\tstruct cftype *cft, *cft_end = NULL;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\nrestart:\n\tfor (cft = cfts; cft != cft_end && cft->name[0] != '\\0'; cft++) {\n\t\t/* does cft->flags tell us to skip this file on @cgrp? */\n\t\tif ((cft->flags & CFTYPE_PRESSURE) && !cgroup_psi_enabled())\n\t\t\tcontinue;\n\t\tif ((cft->flags & __CFTYPE_ONLY_ON_DFL) && !cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & __CFTYPE_NOT_ON_DFL) && cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_NOT_ON_ROOT) && !cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_ONLY_ON_ROOT) && cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_DEBUG) && !cgroup_debug)\n\t\t\tcontinue;\n\t\tif (is_add) {\n\t\t\tret = cgroup_add_file(css, cgrp, cft);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"%s: failed to add %s, err=%d\\n\",\n\t\t\t\t\t__func__, cft->name, ret);\n\t\t\t\tcft_end = cft;\n\t\t\t\tis_add = false;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t} else {\n\t\t\tcgroup_rm_file(cgrp, cft);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int cgroup_apply_cftypes(struct cftype *cfts, bool is_add)\n{\n\tstruct cgroup_subsys *ss = cfts[0].ss;\n\tstruct cgroup *root = &ss->root->cgrp;\n\tstruct cgroup_subsys_state *css;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* add/rm files for all cgroups created before */\n\tcss_for_each_descendant_pre(css, cgroup_css(root, ss)) {\n\t\tstruct cgroup *cgrp = css->cgroup;\n\n\t\tif (!(css->flags & CSS_VISIBLE))\n\t\t\tcontinue;\n\n\t\tret = cgroup_addrm_files(css, cgrp, cfts, is_add);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (is_add && !ret)\n\t\tkernfs_activate(root->kn);\n\treturn ret;\n}\n\nstatic void cgroup_exit_cftypes(struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\t/* free copy for custom atomic_write_len, see init_cftypes() */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE)\n\t\t\tkfree(cft->kf_ops);\n\t\tcft->kf_ops = NULL;\n\t\tcft->ss = NULL;\n\n\t\t/* revert flags set by cgroup core while adding @cfts */\n\t\tcft->flags &= ~(__CFTYPE_ONLY_ON_DFL | __CFTYPE_NOT_ON_DFL);\n\t}\n}\n\nstatic int cgroup_init_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\tstruct kernfs_ops *kf_ops;\n\n\t\tWARN_ON(cft->ss || cft->kf_ops);\n\n\t\tif ((cft->flags & CFTYPE_PRESSURE) && !cgroup_psi_enabled())\n\t\t\tcontinue;\n\n\t\tif (cft->seq_start)\n\t\t\tkf_ops = &cgroup_kf_ops;\n\t\telse\n\t\t\tkf_ops = &cgroup_kf_single_ops;\n\n\t\t/*\n\t\t * Ugh... if @cft wants a custom max_write_len, we need to\n\t\t * make a copy of kf_ops to set its atomic_write_len.\n\t\t */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE) {\n\t\t\tkf_ops = kmemdup(kf_ops, sizeof(*kf_ops), GFP_KERNEL);\n\t\t\tif (!kf_ops) {\n\t\t\t\tcgroup_exit_cftypes(cfts);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tkf_ops->atomic_write_len = cft->max_write_len;\n\t\t}\n\n\t\tcft->kf_ops = kf_ops;\n\t\tcft->ss = ss;\n\t}\n\n\treturn 0;\n}\n\nstatic int cgroup_rm_cftypes_locked(struct cftype *cfts)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!cfts || !cfts[0].ss)\n\t\treturn -ENOENT;\n\n\tlist_del(&cfts->node);\n\tcgroup_apply_cftypes(cfts, false);\n\tcgroup_exit_cftypes(cfts);\n\treturn 0;\n}\n\n/**\n * cgroup_rm_cftypes - remove an array of cftypes from a subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Unregister @cfts.  Files described by @cfts are removed from all\n * existing cgroups and all future cgroups won't have them either.  This\n * function can be called anytime whether @cfts' subsys is attached or not.\n *\n * Returns 0 on successful unregistration, -ENOENT if @cfts is not\n * registered.\n */\nint cgroup_rm_cftypes(struct cftype *cfts)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = cgroup_rm_cftypes_locked(cfts);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_cftypes - add an array of cftypes to a subsystem\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Register @cfts to @ss.  Files described by @cfts are created for all\n * existing cgroups to which @ss is attached and all future cgroups will\n * have them too.  This function can be called anytime whether @ss is\n * attached or not.\n *\n * Returns 0 on successful registration, -errno on failure.  Note that this\n * function currently returns 0 as long as @cfts registration is successful\n * even if some file creation attempts on existing cgroups fail.\n */\nstatic int cgroup_add_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tint ret;\n\n\tif (!cgroup_ssid_enabled(ss->id))\n\t\treturn 0;\n\n\tif (!cfts || cfts[0].name[0] == '\\0')\n\t\treturn 0;\n\n\tret = cgroup_init_cftypes(ss, cfts);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tlist_add_tail(&cfts->node, &ss->cfts);\n\tret = cgroup_apply_cftypes(cfts, true);\n\tif (ret)\n\t\tcgroup_rm_cftypes_locked(cfts);\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_dfl_cftypes - add an array of cftypes for default hierarchy\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the default hierarchy.\n */\nint cgroup_add_dfl_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_ONLY_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_add_legacy_cftypes - add an array of cftypes for legacy hierarchies\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the legacy hierarchies.\n */\nint cgroup_add_legacy_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_NOT_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_file_notify - generate a file modified event for a cgroup_file\n * @cfile: target cgroup_file\n *\n * @cfile must have been obtained by setting cftype->file_offset.\n */\nvoid cgroup_file_notify(struct cgroup_file *cfile)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_file_kn_lock, flags);\n\tif (cfile->kn) {\n\t\tunsigned long last = cfile->notified_at;\n\t\tunsigned long next = last + CGROUP_FILE_NOTIFY_MIN_INTV;\n\n\t\tif (time_in_range(jiffies, last, next)) {\n\t\t\ttimer_reduce(&cfile->notify_timer, next);\n\t\t} else {\n\t\t\tkernfs_notify(cfile->kn);\n\t\t\tcfile->notified_at = jiffies;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cgroup_file_kn_lock, flags);\n}\n\n/**\n * css_next_child - find the next child of a given css\n * @pos: the current position (%NULL to initiate traversal)\n * @parent: css whose children to walk\n *\n * This function returns the next child of @parent and should be called\n * under either cgroup_mutex or RCU read lock.  The only requirement is\n * that @parent and @pos are accessible.  The next sibling is guaranteed to\n * be returned regardless of their states.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *css_next_child(struct cgroup_subsys_state *pos,\n\t\t\t\t\t   struct cgroup_subsys_state *parent)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/*\n\t * @pos could already have been unlinked from the sibling list.\n\t * Once a cgroup is removed, its ->sibling.next is no longer\n\t * updated when its next sibling changes.  CSS_RELEASED is set when\n\t * @pos is taken off list, at which time its next pointer is valid,\n\t * and, as releases are serialized, the one pointed to by the next\n\t * pointer is guaranteed to not have started release yet.  This\n\t * implies that if we observe !CSS_RELEASED on @pos in this RCU\n\t * critical section, the one pointed to by its next pointer is\n\t * guaranteed to not have finished its RCU grace period even if we\n\t * have dropped rcu_read_lock() in-between iterations.\n\t *\n\t * If @pos has CSS_RELEASED set, its next pointer can't be\n\t * dereferenced; however, as each css is given a monotonically\n\t * increasing unique serial number and always appended to the\n\t * sibling list, the next one can be found by walking the parent's\n\t * children until the first css with higher serial number than\n\t * @pos's.  While this path can be slower, it happens iff iteration\n\t * races against release and the race window is very small.\n\t */\n\tif (!pos) {\n\t\tnext = list_entry_rcu(parent->children.next, struct cgroup_subsys_state, sibling);\n\t} else if (likely(!(pos->flags & CSS_RELEASED))) {\n\t\tnext = list_entry_rcu(pos->sibling.next, struct cgroup_subsys_state, sibling);\n\t} else {\n\t\tlist_for_each_entry_rcu(next, &parent->children, sibling,\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex))\n\t\t\tif (next->serial_nr > pos->serial_nr)\n\t\t\t\tbreak;\n\t}\n\n\t/*\n\t * @next, if not pointing to the head, can be dereferenced and is\n\t * the next sibling.\n\t */\n\tif (&next->sibling != &parent->children)\n\t\treturn next;\n\treturn NULL;\n}\n\n/**\n * css_next_descendant_pre - find the next descendant for pre-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_pre().  Find the next descendant\n * to visit for pre-order traversal of @root's descendants.  @root is\n * included in the iteration and the first node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @root are accessible and @pos is a descendant of @root.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_pre(struct cgroup_subsys_state *pos,\n\t\t\tstruct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit @root */\n\tif (!pos)\n\t\treturn root;\n\n\t/* visit the first child if exists */\n\tnext = css_next_child(NULL, pos);\n\tif (next)\n\t\treturn next;\n\n\t/* no child, visit my or the closest ancestor's next sibling */\n\twhile (pos != root) {\n\t\tnext = css_next_child(pos, pos->parent);\n\t\tif (next)\n\t\t\treturn next;\n\t\tpos = pos->parent;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(css_next_descendant_pre);\n\n/**\n * css_rightmost_descendant - return the rightmost descendant of a css\n * @pos: css of interest\n *\n * Return the rightmost descendant of @pos.  If there's no descendant, @pos\n * is returned.  This can be used during pre-order traversal to skip\n * subtree of @pos.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct rightmost descendant as\n * long as @pos is accessible.\n */\nstruct cgroup_subsys_state *\ncss_rightmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last, *tmp;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\tdo {\n\t\tlast = pos;\n\t\t/* ->prev isn't RCU safe, walk ->next till the end */\n\t\tpos = NULL;\n\t\tcss_for_each_child(tmp, last)\n\t\t\tpos = tmp;\n\t} while (pos);\n\n\treturn last;\n}\n\nstatic struct cgroup_subsys_state *\ncss_leftmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last;\n\n\tdo {\n\t\tlast = pos;\n\t\tpos = css_next_child(NULL, pos);\n\t} while (pos);\n\n\treturn last;\n}\n\n/**\n * css_next_descendant_post - find the next descendant for post-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_post().  Find the next descendant\n * to visit for post-order traversal of @root's descendants.  @root is\n * included in the iteration and the last node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @cgroup are accessible and @pos is a descendant of\n * @cgroup.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_post(struct cgroup_subsys_state *pos,\n\t\t\t struct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit leftmost descendant which may be @root */\n\tif (!pos)\n\t\treturn css_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\tnext = css_next_child(pos, pos->parent);\n\tif (next)\n\t\treturn css_leftmost_descendant(next);\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}\n\n/**\n * css_has_online_children - does a css have online children\n * @css: the target css\n *\n * Returns %true if @css has any online children; otherwise, %false.  This\n * function can be called from any context but the caller is responsible\n * for synchronizing against on/offlining as necessary.\n */\nbool css_has_online_children(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys_state *child;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tcss_for_each_child(child, css) {\n\t\tif (child->flags & CSS_ONLINE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic struct css_set *css_task_iter_next_css_set(struct css_task_iter *it)\n{\n\tstruct list_head *l;\n\tstruct cgrp_cset_link *link;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* find the next threaded cset */\n\tif (it->tcset_pos) {\n\t\tl = it->tcset_pos->next;\n\n\t\tif (l != it->tcset_head) {\n\t\t\tit->tcset_pos = l;\n\t\t\treturn container_of(l, struct css_set,\n\t\t\t\t\t    threaded_csets_node);\n\t\t}\n\n\t\tit->tcset_pos = NULL;\n\t}\n\n\t/* find the next cset */\n\tl = it->cset_pos;\n\tl = l->next;\n\tif (l == it->cset_head) {\n\t\tit->cset_pos = NULL;\n\t\treturn NULL;\n\t}\n\n\tif (it->ss) {\n\t\tcset = container_of(l, struct css_set, e_cset_node[it->ss->id]);\n\t} else {\n\t\tlink = list_entry(l, struct cgrp_cset_link, cset_link);\n\t\tcset = link->cset;\n\t}\n\n\tit->cset_pos = l;\n\n\t/* initialize threaded css_set walking */\n\tif (it->flags & CSS_TASK_ITER_THREADED) {\n\t\tif (it->cur_dcset)\n\t\t\tput_css_set_locked(it->cur_dcset);\n\t\tit->cur_dcset = cset;\n\t\tget_css_set(cset);\n\n\t\tit->tcset_head = &cset->threaded_csets;\n\t\tit->tcset_pos = &cset->threaded_csets;\n\t}\n\n\treturn cset;\n}\n\n/**\n * css_task_iter_advance_css_set - advance a task iterator to the next css_set\n * @it: the iterator to advance\n *\n * Advance @it to the next css_set to walk.\n */\nstatic void css_task_iter_advance_css_set(struct css_task_iter *it)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* Advance to the next non-empty css_set and find first non-empty tasks list*/\n\twhile ((cset = css_task_iter_next_css_set(it))) {\n\t\tif (!list_empty(&cset->tasks)) {\n\t\t\tit->cur_tasks_head = &cset->tasks;\n\t\t\tbreak;\n\t\t} else if (!list_empty(&cset->mg_tasks)) {\n\t\t\tit->cur_tasks_head = &cset->mg_tasks;\n\t\t\tbreak;\n\t\t} else if (!list_empty(&cset->dying_tasks)) {\n\t\t\tit->cur_tasks_head = &cset->dying_tasks;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cset) {\n\t\tit->task_pos = NULL;\n\t\treturn;\n\t}\n\tit->task_pos = it->cur_tasks_head->next;\n\n\t/*\n\t * We don't keep css_sets locked across iteration steps and thus\n\t * need to take steps to ensure that iteration can be resumed after\n\t * the lock is re-acquired.  Iteration is performed at two levels -\n\t * css_sets and tasks in them.\n\t *\n\t * Once created, a css_set never leaves its cgroup lists, so a\n\t * pinned css_set is guaranteed to stay put and we can resume\n\t * iteration afterwards.\n\t *\n\t * Tasks may leave @cset across iteration steps.  This is resolved\n\t * by registering each iterator with the css_set currently being\n\t * walked and making css_set_move_task() advance iterators whose\n\t * next task is leaving.\n\t */\n\tif (it->cur_cset) {\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t}\n\tget_css_set(cset);\n\tit->cur_cset = cset;\n\tlist_add(&it->iters_node, &cset->task_iters);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_FILE_NOTIFY_MIN_INTV\tDIV_ROUND_UP(HZ, 100)",
            "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
          ],
          "globals_used": [
            "bool cgroup_debug",
            "static DEFINE_SPINLOCK(cgroup_file_kn_lock);",
            "static u16 cgrp_dfl_inhibit_ss_mask;",
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "struct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};",
            "static u16 cgroup_feature_disable_mask",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NOTIFY_MIN_INTV\tDIV_ROUND_UP(HZ, 100)\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nbool cgroup_debug;\nstatic DEFINE_SPINLOCK(cgroup_file_kn_lock);\nstatic u16 cgrp_dfl_inhibit_ss_mask;\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstruct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\nstatic u16 cgroup_feature_disable_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nint cgroup_attach_task(struct cgroup *dst_cgrp, struct task_struct *leader,\n\t\t       bool threadgroup)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct task_struct *task;\n\tint ret = 0;\n\n\t/* look up all src csets */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_src(task_css_set(task), dst_cgrp, &mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* prepare dst csets and commit */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (!ret)\n\t\tret = cgroup_migrate(leader, threadgroup, &mgctx);\n\n\tcgroup_migrate_finish(&mgctx);\n\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(attach_task, dst_cgrp, leader, threadgroup);\n\n\treturn ret;\n}\n\nstruct task_struct *cgroup_procs_write_start(char *buf, bool threadgroup,\n\t\t\t\t\t     bool *locked)\n\t__acquires(&cgroup_threadgroup_rwsem)\n{\n\tstruct task_struct *tsk;\n\tpid_t pid;\n\n\tif (kstrtoint(strstrip(buf), 0, &pid) || pid < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If we migrate a single thread, we don't care about threadgroup\n\t * stability. If the thread is `current`, it won't exit(2) under our\n\t * hands or change PID through exec(2). We exclude\n\t * cgroup_update_dfl_csses and other cgroup_{proc,thread}s_write\n\t * callers by cgroup_mutex.\n\t * Therefore, we can skip the global lock.\n\t */\n\tlockdep_assert_held(&cgroup_mutex);\n\tif (pid || threadgroup) {\n\t\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\t\t*locked = true;\n\t} else {\n\t\t*locked = false;\n\t}\n\n\trcu_read_lock();\n\tif (pid) {\n\t\ttsk = find_task_by_vpid(pid);\n\t\tif (!tsk) {\n\t\t\ttsk = ERR_PTR(-ESRCH);\n\t\t\tgoto out_unlock_threadgroup;\n\t\t}\n\t} else {\n\t\ttsk = current;\n\t}\n\n\tif (threadgroup)\n\t\ttsk = tsk->group_leader;\n\n\t/*\n\t * kthreads may acquire PF_NO_SETAFFINITY during initialization.\n\t * If userland migrates such a kthread to a non-root cgroup, it can\n\t * become trapped in a cpuset, or RT kthread may be born in a\n\t * cgroup with no rt_runtime allocated.  Just say no.\n\t */\n\tif (tsk->no_cgroup_migration || (tsk->flags & PF_NO_SETAFFINITY)) {\n\t\ttsk = ERR_PTR(-EINVAL);\n\t\tgoto out_unlock_threadgroup;\n\t}\n\n\tget_task_struct(tsk);\n\tgoto out_unlock_rcu;\n\nout_unlock_threadgroup:\n\tif (*locked) {\n\t\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\t\t*locked = false;\n\t}\nout_unlock_rcu:\n\trcu_read_unlock();\n\treturn tsk;\n}\n\nvoid cgroup_procs_write_finish(struct task_struct *task, bool locked)\n\t__releases(&cgroup_threadgroup_rwsem)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\t/* release reference from cgroup_procs_write_start() */\n\tput_task_struct(task);\n\n\tif (locked)\n\t\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\tfor_each_subsys(ss, ssid)\n\t\tif (ss->post_attach)\n\t\t\tss->post_attach();\n}\n\nstatic void cgroup_print_ss_mask(struct seq_file *seq, u16 ss_mask)\n{\n\tstruct cgroup_subsys *ss;\n\tbool printed = false;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tif (printed)\n\t\t\tseq_putc(seq, ' ');\n\t\tseq_puts(seq, ss->name);\n\t\tprinted = true;\n\t} while_each_subsys_mask();\n\tif (printed)\n\t\tseq_putc(seq, '\\n');\n}\n\n/* show controllers which are enabled from the parent */\nstatic int cgroup_controllers_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgroup_control(cgrp));\n\treturn 0;\n}\n\n/* show controllers which are enabled for a given cgroup's children */\nstatic int cgroup_subtree_control_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgrp->subtree_control);\n\treturn 0;\n}\n\n/**\n * cgroup_update_dfl_csses - update css assoc of a subtree in default hierarchy\n * @cgrp: root of the subtree to update csses for\n *\n * @cgrp's control masks have changed and its subtree's css associations\n * need to be updated accordingly.  This function looks up all css_sets\n * which are attached to the subtree, creates the matching updated css_sets\n * and migrates the tasks to the new ones.\n */\nstatic int cgroup_update_dfl_csses(struct cgroup *cgrp)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup *dsct;\n\tstruct css_set *src_cset;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\t/* look up all csses currently attached to @cgrp's subtree */\n\tspin_lock_irq(&css_set_lock);\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &dsct->cset_links, cset_link)\n\t\t\tcgroup_migrate_add_src(link->cset, dsct, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* NULL dst indicates self on default hierarchy */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(src_cset, &mgctx.preloaded_src_csets, mg_preload_node) {\n\t\tstruct task_struct *task, *ntask;\n\n\t\t/* all tasks in src_csets need to be migrated */\n\t\tlist_for_each_entry_safe(task, ntask, &src_cset->tasks, cg_list)\n\t\t\tcgroup_migrate_add_task(task, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_migrate_execute(&mgctx);\nout_finish:\n\tcgroup_migrate_finish(&mgctx);\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\treturn ret;\n}\n\n/**\n * cgroup_lock_and_drain_offline - lock cgroup_mutex and drain offlined csses\n * @cgrp: root of the target subtree\n *\n * Because css offlining is asynchronous, userland may try to re-enable a\n * controller while the previous css is still around.  This function grabs\n * cgroup_mutex and drains the previous css instances of @cgrp's subtree.\n */\nvoid cgroup_lock_and_drain_offline(struct cgroup *cgrp)\n\t__acquires(&cgroup_mutex)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\nrestart:\n\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\t\t\tDEFINE_WAIT(wait);\n\n\t\t\tif (!css || !percpu_ref_is_dying(&css->refcnt))\n\t\t\t\tcontinue;\n\n\t\t\tcgroup_get_live(dsct);\n\t\t\tprepare_to_wait(&dsct->offline_waitq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tschedule();\n\t\t\tfinish_wait(&dsct->offline_waitq, &wait);\n\n\t\t\tcgroup_put(dsct);\n\t\t\tgoto restart;\n\t\t}\n\t}\n}\n\n/**\n * cgroup_save_control - save control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Save ->subtree_control, ->subtree_ss_mask and ->dom_cgrp to the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_save_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->old_subtree_control = dsct->subtree_control;\n\t\tdsct->old_subtree_ss_mask = dsct->subtree_ss_mask;\n\t\tdsct->old_dom_cgrp = dsct->dom_cgrp;\n\t}\n}\n\n/**\n * cgroup_propagate_control - refresh control masks of a subtree\n * @cgrp: root of the target subtree\n *\n * For @cgrp and its subtree, ensure ->subtree_ss_mask matches\n * ->subtree_control and propagate controller availability through the\n * subtree so that descendants don't have unavailable controllers enabled.\n */\nstatic void cgroup_propagate_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control &= cgroup_control(dsct);\n\t\tdsct->subtree_ss_mask =\n\t\t\tcgroup_calc_subtree_ss_mask(dsct->subtree_control,\n\t\t\t\t\t\t    cgroup_ss_mask(dsct));\n\t}\n}\n\n/**\n * cgroup_restore_control - restore control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Restore ->subtree_control, ->subtree_ss_mask and ->dom_cgrp from the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_restore_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control = dsct->old_subtree_control;\n\t\tdsct->subtree_ss_mask = dsct->old_subtree_ss_mask;\n\t\tdsct->dom_cgrp = dsct->old_dom_cgrp;\n\t}\n}\n\nstatic bool css_visible(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tif (cgroup_control(cgrp) & (1 << ss->id))\n\t\treturn true;\n\tif (!(cgroup_ss_mask(cgrp) & (1 << ss->id)))\n\t\treturn false;\n\treturn cgroup_on_dfl(cgrp) && ss->implicit_on_dfl;\n}\n\n/**\n * cgroup_apply_control_enable - enable or show csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and create new csses or make the existing ones\n * visible.  A css is created invisible if it's being implicitly enabled\n * through dependency.  An invisible css is made visible when the userland\n * explicitly enables it.\n *\n * Returns 0 on success, -errno on failure.  On failure, csses which have\n * been processed already aren't cleaned up.  The caller is responsible for\n * cleaning up with cgroup_apply_control_disable().\n */\nstatic int cgroup_apply_control_enable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid, ret;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tif (!(cgroup_ss_mask(dsct) & (1 << ss->id)))\n\t\t\t\tcontinue;\n\n\t\t\tif (!css) {\n\t\t\t\tcss = css_create(dsct, ss);\n\t\t\t\tif (IS_ERR(css))\n\t\t\t\t\treturn PTR_ERR(css);\n\t\t\t}\n\n\t\t\tWARN_ON_ONCE(percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (css_visible(css)) {\n\t\t\t\tret = css_populate_dir(css);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_apply_control_disable - kill or hide csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and kill and hide csses so that they match\n * cgroup_ss_mask() and cgroup_visible_mask().\n *\n * A css is hidden when the userland requests it to be disabled while other\n * subsystems are still depending on it.  The css must not actively control\n * resources and be in the vanilla state if it's made visible again later.\n * Controllers which may be depended upon should provide ->css_reset() for\n * this purpose.\n */\nstatic void cgroup_apply_control_disable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tif (!css)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (css->parent &&\n\t\t\t    !(cgroup_ss_mask(dsct) & (1 << ss->id))) {\n\t\t\t\tkill_css(css);\n\t\t\t} else if (!css_visible(css)) {\n\t\t\t\tcss_clear_dir(css);\n\t\t\t\tif (ss->css_reset)\n\t\t\t\t\tss->css_reset(css);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * cgroup_apply_control - apply control mask updates to the subtree\n * @cgrp: root of the target subtree\n *\n * subsystems can be enabled and disabled in a subtree using the following\n * steps.\n *\n * 1. Call cgroup_save_control() to stash the current state.\n * 2. Update ->subtree_control masks in the subtree as desired.\n * 3. Call cgroup_apply_control() to apply the changes.\n * 4. Optionally perform other related operations.\n * 5. Call cgroup_finalize_control() to finish up.\n *\n * This function implements step 3 and propagates the mask changes\n * throughout @cgrp's subtree, updates csses accordingly and perform\n * process migrations.\n */\nstatic int cgroup_apply_control(struct cgroup *cgrp)\n{\n\tint ret;\n\n\tcgroup_propagate_control(cgrp);\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * At this point, cgroup_e_css_by_mask() results reflect the new csses\n\t * making the following cgroup_update_dfl_csses() properly update\n\t * css associations of all tasks in the subtree.\n\t */\n\tret = cgroup_update_dfl_csses(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n/**\n * cgroup_finalize_control - finalize control mask update\n * @cgrp: root of the target subtree\n * @ret: the result of the update\n *\n * Finalize control mask update.  See cgroup_apply_control() for more info.\n */\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret)\n{\n\tif (ret) {\n\t\tcgroup_restore_control(cgrp);\n\t\tcgroup_propagate_control(cgrp);\n\t}\n\n\tcgroup_apply_control_disable(cgrp);\n}\n\nstatic int cgroup_vet_subtree_control_enable(struct cgroup *cgrp, u16 enable)\n{\n\tu16 domain_enable = enable & ~cgrp_dfl_threaded_ss_mask;\n\n\t/* if nothing is getting enabled, nothing to worry about */\n\tif (!enable)\n\t\treturn 0;\n\n\t/* can @cgrp host any resources? */\n\tif (!cgroup_is_valid_domain(cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn 0;\n\n\tif (domain_enable) {\n\t\t/* can't enable domain controllers inside a thread subtree */\n\t\tif (cgroup_is_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\t/*\n\t\t * Threaded controllers can handle internal competitions\n\t\t * and are always allowed inside a (prospective) thread\n\t\t * subtree.\n\t\t */\n\t\tif (cgroup_can_be_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Controllers can't be enabled for a cgroup with tasks to avoid\n\t * child cgroups competing against tasks.\n\t */\n\tif (cgroup_has_tasks(cgrp))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n/* change the enabled child controllers for a cgroup in the default hierarchy */\nstatic ssize_t cgroup_subtree_control_write(struct kernfs_open_file *of,\n\t\t\t\t\t    char *buf, size_t nbytes,\n\t\t\t\t\t    loff_t off)\n{\n\tu16 enable = 0, disable = 0;\n\tstruct cgroup *cgrp, *child;\n\tstruct cgroup_subsys *ss;\n\tchar *tok;\n\tint ssid, ret;\n\n\t/*\n\t * Parse input - space separated list of subsystem names prefixed\n\t * with either + or -.\n\t */\n\tbuf = strstrip(buf);\n\twhile ((tok = strsep(&buf, \" \"))) {\n\t\tif (tok[0] == '\\0')\n\t\t\tcontinue;\n\t\tdo_each_subsys_mask(ss, ssid, ~cgrp_dfl_inhibit_ss_mask) {\n\t\t\tif (!cgroup_ssid_enabled(ssid) ||\n\t\t\t    strcmp(tok + 1, ss->name))\n\t\t\t\tcontinue;\n\n\t\t\tif (*tok == '+') {\n\t\t\t\tenable |= 1 << ssid;\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t} else if (*tok == '-') {\n\t\t\t\tdisable |= 1 << ssid;\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t} while_each_subsys_mask();\n\t\tif (ssid == CGROUP_SUBSYS_COUNT)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (enable & (1 << ssid)) {\n\t\t\tif (cgrp->subtree_control & (1 << ssid)) {\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(cgroup_control(cgrp) & (1 << ssid))) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else if (disable & (1 << ssid)) {\n\t\t\tif (!(cgrp->subtree_control & (1 << ssid))) {\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* a child has it enabled? */\n\t\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\t\tif (child->subtree_control & (1 << ssid)) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!enable && !disable) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tret = cgroup_vet_subtree_control_enable(cgrp, enable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* save and update control masks and prepare csses */\n\tcgroup_save_control(cgrp);\n\n\tcgrp->subtree_control |= enable;\n\tcgrp->subtree_control &= ~disable;\n\n\tret = cgroup_apply_control(cgrp);\n\tcgroup_finalize_control(cgrp, ret);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tkernfs_activate(cgrp->kn);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\n/**\n * cgroup_enable_threaded - make @cgrp threaded\n * @cgrp: the target cgroup\n *\n * Called when \"threaded\" is written to the cgroup.type interface file and\n * tries to make @cgrp threaded and join the parent's resource domain.\n * This function is never called on the root cgroup as cgroup.type doesn't\n * exist on it.\n */\nstatic int cgroup_enable_threaded(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup *dom_cgrp = parent->dom_cgrp;\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* noop if already threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @cgroup is populated or has domain controllers enabled, it\n\t * can't be switched.  While the below cgroup_can_be_thread_root()\n\t * test can catch the same conditions, that's only when @parent is\n\t * not mixable, so let's check it explicitly.\n\t */\n\tif (cgroup_is_populated(cgrp) ||\n\t    cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn -EOPNOTSUPP;\n\n\t/* we're joining the parent's domain, ensure its validity */\n\tif (!cgroup_is_valid_domain(dom_cgrp) ||\n\t    !cgroup_can_be_thread_root(dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * The following shouldn't cause actual migrations and should\n\t * always succeed.\n\t */\n\tcgroup_save_control(cgrp);\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp)\n\t\tif (dsct == cgrp || cgroup_is_threaded(dsct))\n\t\t\tdsct->dom_cgrp = dom_cgrp;\n\n\tret = cgroup_apply_control(cgrp);\n\tif (!ret)\n\t\tparent->nr_threaded_children++;\n\n\tcgroup_finalize_control(cgrp, ret);\n\treturn ret;\n}\n\nstatic int cgroup_type_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tif (cgroup_is_threaded(cgrp))\n\t\tseq_puts(seq, \"threaded\\n\");\n\telse if (!cgroup_is_valid_domain(cgrp))\n\t\tseq_puts(seq, \"domain invalid\\n\");\n\telse if (cgroup_is_thread_root(cgrp))\n\t\tseq_puts(seq, \"domain threaded\\n\");\n\telse\n\t\tseq_puts(seq, \"domain\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_type_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\t/* only switching to threaded mode is supported */\n\tif (strcmp(strstrip(buf), \"threaded\"))\n\t\treturn -EINVAL;\n\n\t/* drain dying csses before we re-apply (threaded) subtree control */\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\t/* threaded can only be enabled */\n\tret = cgroup_enable_threaded(cgrp);\n\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\nstatic int cgroup_max_descendants_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint descendants = READ_ONCE(cgrp->max_descendants);\n\n\tif (descendants == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", descendants);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_descendants_write(struct kernfs_open_file *of,\n\t\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint descendants;\n\tssize_t ret;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdescendants = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &descendants);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (descendants < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_descendants = descendants;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_max_depth_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint depth = READ_ONCE(cgrp->max_depth);\n\n\tif (depth == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", depth);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_depth_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint depth;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdepth = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &depth);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (depth < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_depth = depth;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_events_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"populated %d\\n\", cgroup_is_populated(cgrp));\n\tseq_printf(seq, \"frozen %d\\n\", test_bit(CGRP_FROZEN, &cgrp->flags));\n\n\treturn 0;\n}\n\nstatic int cgroup_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgroup = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"nr_descendants %d\\n\",\n\t\t   cgroup->nr_descendants);\n\tseq_printf(seq, \"nr_dying_descendants %d\\n\",\n\t\t   cgroup->nr_dying_descendants);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cgroup_extra_stat_show(struct seq_file *seq,\n\t\t\t\t\t\t struct cgroup *cgrp, int ssid)\n{\n\tstruct cgroup_subsys *ss = cgroup_subsys[ssid];\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!ss->css_extra_stat_show)\n\t\treturn 0;\n\n\tcss = cgroup_tryget_css(cgrp, ss);\n\tif (!css)\n\t\treturn 0;\n\n\tret = ss->css_extra_stat_show(seq, css);\n\tcss_put(css);\n\treturn ret;\n}\n\nstatic int cpu_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup __maybe_unused *cgrp = seq_css(seq)->cgroup;\n\tint ret = 0;\n\n\tcgroup_base_stat_cputime_show(seq);\n#ifdef CONFIG_CGROUP_SCHED\n\tret = cgroup_extra_stat_show(seq, cgrp, cpu_cgrp_id);\n#endif\n\treturn ret;\n}\n\n#ifdef CONFIG_PSI\nstatic int cgroup_io_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_IO);\n}\nstatic int cgroup_memory_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_MEM);\n}\nstatic int cgroup_cpu_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_CPU);\n}\n\nstatic ssize_t cgroup_pressure_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t\t  size_t nbytes, enum psi_res res)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct psi_trigger *new;\n\tstruct cgroup *cgrp;\n\tstruct psi_group *psi;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tcgroup_get(cgrp);\n\tcgroup_kn_unlock(of->kn);\n\n\tpsi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\tnew = psi_trigger_create(psi, buf, nbytes, res);\n\tif (IS_ERR(new)) {\n\t\tcgroup_put(cgrp);\n\t\treturn PTR_ERR(new);\n\t}\n\n\tpsi_trigger_replace(&ctx->psi.trigger, new);\n\n\tcgroup_put(cgrp);\n\n\treturn nbytes;\n}\n\nstatic ssize_t cgroup_io_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_IO);\n}\n\nstatic ssize_t cgroup_memory_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_MEM);\n}\n\nstatic ssize_t cgroup_cpu_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_CPU);\n}\n\nstatic __poll_t cgroup_pressure_poll(struct kernfs_open_file *of,\n\t\t\t\t\t  poll_table *pt)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\treturn psi_trigger_poll(&ctx->psi.trigger, of->file, pt);\n}\n\nstatic void cgroup_pressure_release(struct kernfs_open_file *of)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tpsi_trigger_replace(&ctx->psi.trigger, NULL);\n}\n\nbool cgroup_psi_enabled(void)\n{\n\treturn (cgroup_feature_disable_mask & (1 << OPT_FEATURE_PRESSURE)) == 0;\n}\n\n#else /* CONFIG_PSI */\nbool cgroup_psi_enabled(void)\n{\n\treturn false;\n}\n\n#endif /* CONFIG_PSI */\n\nstatic int cgroup_freeze_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"%d\\n\", cgrp->freezer.freeze);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_freeze_write(struct kernfs_open_file *of,\n\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint freeze;\n\n\tret = kstrtoint(strstrip(buf), 0, &freeze);\n\tif (ret)\n\t\treturn ret;\n\n\tif (freeze < 0 || freeze > 1)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgroup_freeze(cgrp, freeze);\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic void __cgroup_kill(struct cgroup *cgrp)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tset_bit(CGRP_KILL, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tcss_task_iter_start(&cgrp->self, CSS_TASK_ITER_PROCS | CSS_TASK_ITER_THREADED, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t/* Ignore kernel threads here. */\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\n\t\t/* Skip tasks that are already dying. */\n\t\tif (__fatal_signal_pending(task))\n\t\t\tcontinue;\n\n\t\tsend_sig(SIGKILL, task, 0);\n\t}\n\tcss_task_iter_end(&it);\n\n\tspin_lock_irq(&css_set_lock);\n\tclear_bit(CGRP_KILL, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n}\n\nstatic void cgroup_kill(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *dsct;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_for_each_live_descendant_pre(dsct, css, cgrp)\n\t\t__cgroup_kill(dsct);\n}\n\nstatic ssize_t cgroup_kill_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tssize_t ret = 0;\n\tint kill;\n\tstruct cgroup *cgrp;\n\n\tret = kstrtoint(strstrip(buf), 0, &kill);\n\tif (ret)\n\t\treturn ret;\n\n\tif (kill != 1)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Killing is a process directed operation, i.e. the whole thread-group\n\t * is taken down so act like we do for cgroup.procs and only make this\n\t * writable in non-threaded cgroups.\n\t */\n\tif (cgroup_is_threaded(cgrp))\n\t\tret = -EOPNOTSUPP;\n\telse\n\t\tcgroup_kill(cgrp);\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\nstatic int cgroup_file_open(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of_cft(of);\n\tstruct cgroup_file_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ns = current->nsproxy->cgroup_ns;\n\tget_cgroup_ns(ctx->ns);\n\tof->priv = ctx;\n\n\tif (!cft->open)\n\t\treturn 0;\n\n\tret = cft->open(of);\n\tif (ret) {\n\t\tput_cgroup_ns(ctx->ns);\n\t\tkfree(ctx);\n\t}\n\treturn ret;\n}\n\nstatic void cgroup_file_release(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of_cft(of);\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tif (cft->release)\n\t\tcft->release(of);\n\tput_cgroup_ns(ctx->ns);\n\tkfree(ctx);\n}\n\nstatic ssize_t cgroup_file_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!nbytes)\n\t\treturn 0;\n\n\t/*\n\t * If namespaces are delegation boundaries, disallow writes to\n\t * files in an non-init namespace root from inside the namespace\n\t * except for the files explicitly marked delegatable -\n\t * cgroup.procs and cgroup.subtree_control.\n\t */\n\tif ((cgrp->root->flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    !(cft->flags & CFTYPE_NS_DELEGATABLE) &&\n\t    ctx->ns != &init_cgroup_ns && ctx->ns->root_cset->dfl_cgrp == cgrp)\n\t\treturn -EPERM;\n\n\tif (cft->write)\n\t\treturn cft->write(of, buf, nbytes, off);\n\n\t/*\n\t * kernfs guarantees that a file isn't deleted with operations in\n\t * flight, which means that the matching css is and stays alive and\n\t * doesn't need to be pinned.  The RCU locking is not necessary\n\t * either.  It's just for the convenience of using cgroup_css().\n\t */\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, cft->ss);\n\trcu_read_unlock();\n\n\tif (cft->write_u64) {\n\t\tunsigned long long v;\n\t\tret = kstrtoull(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_u64(css, cft, v);\n\t} else if (cft->write_s64) {\n\t\tlong long v;\n\t\tret = kstrtoll(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_s64(css, cft, v);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret ?: nbytes;\n}\n\nstatic __poll_t cgroup_file_poll(struct kernfs_open_file *of, poll_table *pt)\n{\n\tstruct cftype *cft = of_cft(of);\n\n\tif (cft->poll)\n\t\treturn cft->poll(of, pt);\n\n\treturn kernfs_generic_poll(of, pt);\n}\n\nstatic void *cgroup_seqfile_start(struct seq_file *seq, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_start(seq, ppos);\n}\n\nstatic void *cgroup_seqfile_next(struct seq_file *seq, void *v, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_next(seq, v, ppos);\n}\n\nstatic void cgroup_seqfile_stop(struct seq_file *seq, void *v)\n{\n\tif (seq_cft(seq)->seq_stop)\n\t\tseq_cft(seq)->seq_stop(seq, v);\n}\n\nstatic int cgroup_seqfile_show(struct seq_file *m, void *arg)\n{\n\tstruct cftype *cft = seq_cft(m);\n\tstruct cgroup_subsys_state *css = seq_css(m);\n\n\tif (cft->seq_show)\n\t\treturn cft->seq_show(m, arg);\n\n\tif (cft->read_u64)\n\t\tseq_printf(m, \"%llu\\n\", cft->read_u64(css, cft));\n\telse if (cft->read_s64)\n\t\tseq_printf(m, \"%lld\\n\", cft->read_s64(css, cft));\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct kernfs_ops cgroup_kf_single_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.poll\t\t\t= cgroup_file_poll,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\nstatic struct kernfs_ops cgroup_kf_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.poll\t\t\t= cgroup_file_poll,\n\t.seq_start\t\t= cgroup_seqfile_start,\n\t.seq_next\t\t= cgroup_seqfile_next,\n\t.seq_stop\t\t= cgroup_seqfile_stop,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\n/* set uid and gid of cgroup dirs and files to that of the creator */\nstatic int cgroup_kn_set_ugid(struct kernfs_node *kn)\n{\n\tstruct iattr iattr = { .ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t       .ia_uid = current_fsuid(),\n\t\t\t       .ia_gid = current_fsgid(), };\n\n\tif (uid_eq(iattr.ia_uid, GLOBAL_ROOT_UID) &&\n\t    gid_eq(iattr.ia_gid, GLOBAL_ROOT_GID))\n\t\treturn 0;\n\n\treturn kernfs_setattr(kn, &iattr);\n}\n\nstatic void cgroup_file_notify_timer(struct timer_list *timer)\n{\n\tcgroup_file_notify(container_of(timer, struct cgroup_file,\n\t\t\t\t\tnotify_timer));\n}\n\nstatic int cgroup_add_file(struct cgroup_subsys_state *css, struct cgroup *cgrp,\n\t\t\t   struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\tstruct kernfs_node *kn;\n\tstruct lock_class_key *key = NULL;\n\tint ret;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tkey = &cft->lockdep_key;\n#endif\n\tkn = __kernfs_create_file(cgrp->kn, cgroup_file_name(cgrp, cft, name),\n\t\t\t\t  cgroup_file_mode(cft),\n\t\t\t\t  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,\n\t\t\t\t  0, cft->kf_ops, cft,\n\t\t\t\t  NULL, key);\n\tif (IS_ERR(kn))\n\t\treturn PTR_ERR(kn);\n\n\tret = cgroup_kn_set_ugid(kn);\n\tif (ret) {\n\t\tkernfs_remove(kn);\n\t\treturn ret;\n\t}\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\ttimer_setup(&cfile->notify_timer, cgroup_file_notify_timer, 0);\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = kn;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_addrm_files - add or remove files to a cgroup directory\n * @css: the target css\n * @cgrp: the target cgroup (usually css->cgroup)\n * @cfts: array of cftypes to be added\n * @is_add: whether to add or remove\n *\n * Depending on @is_add, add or remove files defined by @cfts on @cgrp.\n * For removals, this function never fails.\n */\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add)\n{\n\tstruct cftype *cft, *cft_end = NULL;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\nrestart:\n\tfor (cft = cfts; cft != cft_end && cft->name[0] != '\\0'; cft++) {\n\t\t/* does cft->flags tell us to skip this file on @cgrp? */\n\t\tif ((cft->flags & CFTYPE_PRESSURE) && !cgroup_psi_enabled())\n\t\t\tcontinue;\n\t\tif ((cft->flags & __CFTYPE_ONLY_ON_DFL) && !cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & __CFTYPE_NOT_ON_DFL) && cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_NOT_ON_ROOT) && !cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_ONLY_ON_ROOT) && cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_DEBUG) && !cgroup_debug)\n\t\t\tcontinue;\n\t\tif (is_add) {\n\t\t\tret = cgroup_add_file(css, cgrp, cft);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"%s: failed to add %s, err=%d\\n\",\n\t\t\t\t\t__func__, cft->name, ret);\n\t\t\t\tcft_end = cft;\n\t\t\t\tis_add = false;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t} else {\n\t\t\tcgroup_rm_file(cgrp, cft);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int cgroup_apply_cftypes(struct cftype *cfts, bool is_add)\n{\n\tstruct cgroup_subsys *ss = cfts[0].ss;\n\tstruct cgroup *root = &ss->root->cgrp;\n\tstruct cgroup_subsys_state *css;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* add/rm files for all cgroups created before */\n\tcss_for_each_descendant_pre(css, cgroup_css(root, ss)) {\n\t\tstruct cgroup *cgrp = css->cgroup;\n\n\t\tif (!(css->flags & CSS_VISIBLE))\n\t\t\tcontinue;\n\n\t\tret = cgroup_addrm_files(css, cgrp, cfts, is_add);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (is_add && !ret)\n\t\tkernfs_activate(root->kn);\n\treturn ret;\n}\n\nstatic void cgroup_exit_cftypes(struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\t/* free copy for custom atomic_write_len, see init_cftypes() */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE)\n\t\t\tkfree(cft->kf_ops);\n\t\tcft->kf_ops = NULL;\n\t\tcft->ss = NULL;\n\n\t\t/* revert flags set by cgroup core while adding @cfts */\n\t\tcft->flags &= ~(__CFTYPE_ONLY_ON_DFL | __CFTYPE_NOT_ON_DFL);\n\t}\n}\n\nstatic int cgroup_init_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\tstruct kernfs_ops *kf_ops;\n\n\t\tWARN_ON(cft->ss || cft->kf_ops);\n\n\t\tif ((cft->flags & CFTYPE_PRESSURE) && !cgroup_psi_enabled())\n\t\t\tcontinue;\n\n\t\tif (cft->seq_start)\n\t\t\tkf_ops = &cgroup_kf_ops;\n\t\telse\n\t\t\tkf_ops = &cgroup_kf_single_ops;\n\n\t\t/*\n\t\t * Ugh... if @cft wants a custom max_write_len, we need to\n\t\t * make a copy of kf_ops to set its atomic_write_len.\n\t\t */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE) {\n\t\t\tkf_ops = kmemdup(kf_ops, sizeof(*kf_ops), GFP_KERNEL);\n\t\t\tif (!kf_ops) {\n\t\t\t\tcgroup_exit_cftypes(cfts);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tkf_ops->atomic_write_len = cft->max_write_len;\n\t\t}\n\n\t\tcft->kf_ops = kf_ops;\n\t\tcft->ss = ss;\n\t}\n\n\treturn 0;\n}\n\nstatic int cgroup_rm_cftypes_locked(struct cftype *cfts)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!cfts || !cfts[0].ss)\n\t\treturn -ENOENT;\n\n\tlist_del(&cfts->node);\n\tcgroup_apply_cftypes(cfts, false);\n\tcgroup_exit_cftypes(cfts);\n\treturn 0;\n}\n\n/**\n * cgroup_rm_cftypes - remove an array of cftypes from a subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Unregister @cfts.  Files described by @cfts are removed from all\n * existing cgroups and all future cgroups won't have them either.  This\n * function can be called anytime whether @cfts' subsys is attached or not.\n *\n * Returns 0 on successful unregistration, -ENOENT if @cfts is not\n * registered.\n */\nint cgroup_rm_cftypes(struct cftype *cfts)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = cgroup_rm_cftypes_locked(cfts);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_cftypes - add an array of cftypes to a subsystem\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Register @cfts to @ss.  Files described by @cfts are created for all\n * existing cgroups to which @ss is attached and all future cgroups will\n * have them too.  This function can be called anytime whether @ss is\n * attached or not.\n *\n * Returns 0 on successful registration, -errno on failure.  Note that this\n * function currently returns 0 as long as @cfts registration is successful\n * even if some file creation attempts on existing cgroups fail.\n */\nstatic int cgroup_add_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tint ret;\n\n\tif (!cgroup_ssid_enabled(ss->id))\n\t\treturn 0;\n\n\tif (!cfts || cfts[0].name[0] == '\\0')\n\t\treturn 0;\n\n\tret = cgroup_init_cftypes(ss, cfts);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tlist_add_tail(&cfts->node, &ss->cfts);\n\tret = cgroup_apply_cftypes(cfts, true);\n\tif (ret)\n\t\tcgroup_rm_cftypes_locked(cfts);\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_dfl_cftypes - add an array of cftypes for default hierarchy\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the default hierarchy.\n */\nint cgroup_add_dfl_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_ONLY_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_add_legacy_cftypes - add an array of cftypes for legacy hierarchies\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the legacy hierarchies.\n */\nint cgroup_add_legacy_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_NOT_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_file_notify - generate a file modified event for a cgroup_file\n * @cfile: target cgroup_file\n *\n * @cfile must have been obtained by setting cftype->file_offset.\n */\nvoid cgroup_file_notify(struct cgroup_file *cfile)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_file_kn_lock, flags);\n\tif (cfile->kn) {\n\t\tunsigned long last = cfile->notified_at;\n\t\tunsigned long next = last + CGROUP_FILE_NOTIFY_MIN_INTV;\n\n\t\tif (time_in_range(jiffies, last, next)) {\n\t\t\ttimer_reduce(&cfile->notify_timer, next);\n\t\t} else {\n\t\t\tkernfs_notify(cfile->kn);\n\t\t\tcfile->notified_at = jiffies;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cgroup_file_kn_lock, flags);\n}\n\n/**\n * css_next_child - find the next child of a given css\n * @pos: the current position (%NULL to initiate traversal)\n * @parent: css whose children to walk\n *\n * This function returns the next child of @parent and should be called\n * under either cgroup_mutex or RCU read lock.  The only requirement is\n * that @parent and @pos are accessible.  The next sibling is guaranteed to\n * be returned regardless of their states.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *css_next_child(struct cgroup_subsys_state *pos,\n\t\t\t\t\t   struct cgroup_subsys_state *parent)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/*\n\t * @pos could already have been unlinked from the sibling list.\n\t * Once a cgroup is removed, its ->sibling.next is no longer\n\t * updated when its next sibling changes.  CSS_RELEASED is set when\n\t * @pos is taken off list, at which time its next pointer is valid,\n\t * and, as releases are serialized, the one pointed to by the next\n\t * pointer is guaranteed to not have started release yet.  This\n\t * implies that if we observe !CSS_RELEASED on @pos in this RCU\n\t * critical section, the one pointed to by its next pointer is\n\t * guaranteed to not have finished its RCU grace period even if we\n\t * have dropped rcu_read_lock() in-between iterations.\n\t *\n\t * If @pos has CSS_RELEASED set, its next pointer can't be\n\t * dereferenced; however, as each css is given a monotonically\n\t * increasing unique serial number and always appended to the\n\t * sibling list, the next one can be found by walking the parent's\n\t * children until the first css with higher serial number than\n\t * @pos's.  While this path can be slower, it happens iff iteration\n\t * races against release and the race window is very small.\n\t */\n\tif (!pos) {\n\t\tnext = list_entry_rcu(parent->children.next, struct cgroup_subsys_state, sibling);\n\t} else if (likely(!(pos->flags & CSS_RELEASED))) {\n\t\tnext = list_entry_rcu(pos->sibling.next, struct cgroup_subsys_state, sibling);\n\t} else {\n\t\tlist_for_each_entry_rcu(next, &parent->children, sibling,\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex))\n\t\t\tif (next->serial_nr > pos->serial_nr)\n\t\t\t\tbreak;\n\t}\n\n\t/*\n\t * @next, if not pointing to the head, can be dereferenced and is\n\t * the next sibling.\n\t */\n\tif (&next->sibling != &parent->children)\n\t\treturn next;\n\treturn NULL;\n}\n\n/**\n * css_next_descendant_pre - find the next descendant for pre-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_pre().  Find the next descendant\n * to visit for pre-order traversal of @root's descendants.  @root is\n * included in the iteration and the first node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @root are accessible and @pos is a descendant of @root.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_pre(struct cgroup_subsys_state *pos,\n\t\t\tstruct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit @root */\n\tif (!pos)\n\t\treturn root;\n\n\t/* visit the first child if exists */\n\tnext = css_next_child(NULL, pos);\n\tif (next)\n\t\treturn next;\n\n\t/* no child, visit my or the closest ancestor's next sibling */\n\twhile (pos != root) {\n\t\tnext = css_next_child(pos, pos->parent);\n\t\tif (next)\n\t\t\treturn next;\n\t\tpos = pos->parent;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(css_next_descendant_pre);\n\n/**\n * css_rightmost_descendant - return the rightmost descendant of a css\n * @pos: css of interest\n *\n * Return the rightmost descendant of @pos.  If there's no descendant, @pos\n * is returned.  This can be used during pre-order traversal to skip\n * subtree of @pos.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct rightmost descendant as\n * long as @pos is accessible.\n */\nstruct cgroup_subsys_state *\ncss_rightmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last, *tmp;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\tdo {\n\t\tlast = pos;\n\t\t/* ->prev isn't RCU safe, walk ->next till the end */\n\t\tpos = NULL;\n\t\tcss_for_each_child(tmp, last)\n\t\t\tpos = tmp;\n\t} while (pos);\n\n\treturn last;\n}\n\nstatic struct cgroup_subsys_state *\ncss_leftmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last;\n\n\tdo {\n\t\tlast = pos;\n\t\tpos = css_next_child(NULL, pos);\n\t} while (pos);\n\n\treturn last;\n}\n\n/**\n * css_next_descendant_post - find the next descendant for post-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_post().  Find the next descendant\n * to visit for post-order traversal of @root's descendants.  @root is\n * included in the iteration and the last node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @cgroup are accessible and @pos is a descendant of\n * @cgroup.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_post(struct cgroup_subsys_state *pos,\n\t\t\t struct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit leftmost descendant which may be @root */\n\tif (!pos)\n\t\treturn css_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\tnext = css_next_child(pos, pos->parent);\n\tif (next)\n\t\treturn css_leftmost_descendant(next);\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}\n\n/**\n * css_has_online_children - does a css have online children\n * @css: the target css\n *\n * Returns %true if @css has any online children; otherwise, %false.  This\n * function can be called from any context but the caller is responsible\n * for synchronizing against on/offlining as necessary.\n */\nbool css_has_online_children(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys_state *child;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tcss_for_each_child(child, css) {\n\t\tif (child->flags & CSS_ONLINE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic struct css_set *css_task_iter_next_css_set(struct css_task_iter *it)\n{\n\tstruct list_head *l;\n\tstruct cgrp_cset_link *link;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* find the next threaded cset */\n\tif (it->tcset_pos) {\n\t\tl = it->tcset_pos->next;\n\n\t\tif (l != it->tcset_head) {\n\t\t\tit->tcset_pos = l;\n\t\t\treturn container_of(l, struct css_set,\n\t\t\t\t\t    threaded_csets_node);\n\t\t}\n\n\t\tit->tcset_pos = NULL;\n\t}\n\n\t/* find the next cset */\n\tl = it->cset_pos;\n\tl = l->next;\n\tif (l == it->cset_head) {\n\t\tit->cset_pos = NULL;\n\t\treturn NULL;\n\t}\n\n\tif (it->ss) {\n\t\tcset = container_of(l, struct css_set, e_cset_node[it->ss->id]);\n\t} else {\n\t\tlink = list_entry(l, struct cgrp_cset_link, cset_link);\n\t\tcset = link->cset;\n\t}\n\n\tit->cset_pos = l;\n\n\t/* initialize threaded css_set walking */\n\tif (it->flags & CSS_TASK_ITER_THREADED) {\n\t\tif (it->cur_dcset)\n\t\t\tput_css_set_locked(it->cur_dcset);\n\t\tit->cur_dcset = cset;\n\t\tget_css_set(cset);\n\n\t\tit->tcset_head = &cset->threaded_csets;\n\t\tit->tcset_pos = &cset->threaded_csets;\n\t}\n\n\treturn cset;\n}\n\n/**\n * css_task_iter_advance_css_set - advance a task iterator to the next css_set\n * @it: the iterator to advance\n *\n * Advance @it to the next css_set to walk.\n */\nstatic void css_task_iter_advance_css_set(struct css_task_iter *it)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* Advance to the next non-empty css_set and find first non-empty tasks list*/\n\twhile ((cset = css_task_iter_next_css_set(it))) {\n\t\tif (!list_empty(&cset->tasks)) {\n\t\t\tit->cur_tasks_head = &cset->tasks;\n\t\t\tbreak;\n\t\t} else if (!list_empty(&cset->mg_tasks)) {\n\t\t\tit->cur_tasks_head = &cset->mg_tasks;\n\t\t\tbreak;\n\t\t} else if (!list_empty(&cset->dying_tasks)) {\n\t\t\tit->cur_tasks_head = &cset->dying_tasks;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cset) {\n\t\tit->task_pos = NULL;\n\t\treturn;\n\t}\n\tit->task_pos = it->cur_tasks_head->next;\n\n\t/*\n\t * We don't keep css_sets locked across iteration steps and thus\n\t * need to take steps to ensure that iteration can be resumed after\n\t * the lock is re-acquired.  Iteration is performed at two levels -\n\t * css_sets and tasks in them.\n\t *\n\t * Once created, a css_set never leaves its cgroup lists, so a\n\t * pinned css_set is guaranteed to stay put and we can resume\n\t * iteration afterwards.\n\t *\n\t * Tasks may leave @cset across iteration steps.  This is resolved\n\t * by registering each iterator with the css_set currently being\n\t * walked and making css_set_move_task() advance iterators whose\n\t * next task is leaving.\n\t */\n\tif (it->cur_cset) {\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t}\n\tget_css_set(cset);\n\tit->cur_cset = cset;\n\tlist_add(&it->iters_node, &cset->task_iters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "saved_cred"
          ],
          "line": 4946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_attach_permissions",
          "args": [
            "src_cgrp",
            "dst_cgrp",
            "of->file->f_path.dentry->d_sb",
            "threadgroup",
            "ctx->ns"
          ],
          "line": 4943
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_attach_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4892-4911",
          "snippet": "static int cgroup_attach_permissions(struct cgroup *src_cgrp,\n\t\t\t\t     struct cgroup *dst_cgrp,\n\t\t\t\t     struct super_block *sb, bool threadgroup,\n\t\t\t\t     struct cgroup_namespace *ns)\n{\n\tint ret = 0;\n\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp, sb, ns);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cgroup_migrate_vet_dst(dst_cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!threadgroup && (src_cgrp->dom_cgrp != dst_cgrp->dom_cgrp))\n\t\tret = -EOPNOTSUPP;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_attach_permissions(struct cgroup *src_cgrp,\n\t\t\t\t     struct cgroup *dst_cgrp,\n\t\t\t\t     struct super_block *sb, bool threadgroup,\n\t\t\t\t     struct cgroup_namespace *ns)\n{\n\tint ret = 0;\n\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp, sb, ns);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cgroup_migrate_vet_dst(dst_cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!threadgroup && (src_cgrp->dom_cgrp != dst_cgrp->dom_cgrp))\n\t\tret = -EOPNOTSUPP;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "of->file->f_cred"
          ],
          "line": 4942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 4935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cgroup_from_root",
          "args": [
            "task",
            "&cgrp_dfl_root"
          ],
          "line": 4934
        },
        "resolved": true,
        "details": {
          "function_name": "task_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1450-1458",
          "snippet": "struct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold css_set_lock the\n\t * task can't change groups.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstruct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold css_set_lock the\n\t * task can't change groups.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 4933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "task"
          ],
          "line": 4928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_procs_write_start",
          "args": [
            "buf",
            "threadgroup",
            "&locked"
          ],
          "line": 4927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_kn_lock_live",
          "args": [
            "of->kn",
            "false"
          ],
          "line": 4923
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_lock_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1615-1644",
          "snippet": "struct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic ssize_t __cgroup_procs_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t    bool threadgroup)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup *src_cgrp, *dst_cgrp;\n\tstruct task_struct *task;\n\tconst struct cred *saved_cred;\n\tssize_t ret;\n\tbool locked;\n\n\tdst_cgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!dst_cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, threadgroup, &locked);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* find the source cgroup */\n\tspin_lock_irq(&css_set_lock);\n\tsrc_cgrp = task_cgroup_from_root(task, &cgrp_dfl_root);\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Process and thread migrations follow same delegation rule. Check\n\t * permissions using the credentials from file open to protect against\n\t * inherited fd attacks.\n\t */\n\tsaved_cred = override_creds(of->file->f_cred);\n\tret = cgroup_attach_permissions(src_cgrp, dst_cgrp,\n\t\t\t\t\tof->file->f_path.dentry->d_sb,\n\t\t\t\t\tthreadgroup, ctx->ns);\n\trevert_creds(saved_cred);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(dst_cgrp, task, threadgroup);\n\nout_finish:\n\tcgroup_procs_write_finish(task, locked);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_attach_permissions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4892-4911",
    "snippet": "static int cgroup_attach_permissions(struct cgroup *src_cgrp,\n\t\t\t\t     struct cgroup *dst_cgrp,\n\t\t\t\t     struct super_block *sb, bool threadgroup,\n\t\t\t\t     struct cgroup_namespace *ns)\n{\n\tint ret = 0;\n\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp, sb, ns);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cgroup_migrate_vet_dst(dst_cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!threadgroup && (src_cgrp->dom_cgrp != dst_cgrp->dom_cgrp))\n\t\tret = -EOPNOTSUPP;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_migrate_vet_dst",
          "args": [
            "dst_cgrp"
          ],
          "line": 4903
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_vet_dst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2563-2589",
          "snippet": "int cgroup_migrate_vet_dst(struct cgroup *dst_cgrp)\n{\n\t/* v1 doesn't have any restriction */\n\tif (!cgroup_on_dfl(dst_cgrp))\n\t\treturn 0;\n\n\t/* verify @dst_cgrp can host resources */\n\tif (!cgroup_is_valid_domain(dst_cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(dst_cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @dst_cgrp is already or can become a thread root or is\n\t * threaded, it doesn't matter.\n\t */\n\tif (cgroup_can_be_thread_root(dst_cgrp) || cgroup_is_threaded(dst_cgrp))\n\t\treturn 0;\n\n\t/* apply no-internal-process constraint */\n\tif (dst_cgrp->subtree_control)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nint cgroup_migrate_vet_dst(struct cgroup *dst_cgrp)\n{\n\t/* v1 doesn't have any restriction */\n\tif (!cgroup_on_dfl(dst_cgrp))\n\t\treturn 0;\n\n\t/* verify @dst_cgrp can host resources */\n\tif (!cgroup_is_valid_domain(dst_cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(dst_cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @dst_cgrp is already or can become a thread root or is\n\t * threaded, it doesn't matter.\n\t */\n\tif (cgroup_can_be_thread_root(dst_cgrp) || cgroup_is_threaded(dst_cgrp))\n\t\treturn 0;\n\n\t/* apply no-internal-process constraint */\n\tif (dst_cgrp->subtree_control)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_procs_write_permission",
          "args": [
            "src_cgrp",
            "dst_cgrp",
            "sb",
            "ns"
          ],
          "line": 4899
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_procs_write_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4861-4890",
          "snippet": "static int cgroup_procs_write_permission(struct cgroup *src_cgrp,\n\t\t\t\t\t struct cgroup *dst_cgrp,\n\t\t\t\t\t struct super_block *sb,\n\t\t\t\t\t struct cgroup_namespace *ns)\n{\n\tstruct cgroup *com_cgrp = src_cgrp;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* find the common ancestor */\n\twhile (!cgroup_is_descendant(dst_cgrp, com_cgrp))\n\t\tcom_cgrp = cgroup_parent(com_cgrp);\n\n\t/* %current should be authorized to migrate to the common ancestor */\n\tret = cgroup_may_write(com_cgrp, sb);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If namespaces are delegation boundaries, %current must be able\n\t * to see both source and destination cgroups from its namespace.\n\t */\n\tif ((cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    (!cgroup_is_descendant(src_cgrp, ns->root_cset->dfl_cgrp) ||\n\t     !cgroup_is_descendant(dst_cgrp, ns->root_cset->dfl_cgrp)))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_procs_write_permission(struct cgroup *src_cgrp,\n\t\t\t\t\t struct cgroup *dst_cgrp,\n\t\t\t\t\t struct super_block *sb,\n\t\t\t\t\t struct cgroup_namespace *ns)\n{\n\tstruct cgroup *com_cgrp = src_cgrp;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* find the common ancestor */\n\twhile (!cgroup_is_descendant(dst_cgrp, com_cgrp))\n\t\tcom_cgrp = cgroup_parent(com_cgrp);\n\n\t/* %current should be authorized to migrate to the common ancestor */\n\tret = cgroup_may_write(com_cgrp, sb);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If namespaces are delegation boundaries, %current must be able\n\t * to see both source and destination cgroups from its namespace.\n\t */\n\tif ((cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    (!cgroup_is_descendant(src_cgrp, ns->root_cset->dfl_cgrp) ||\n\t     !cgroup_is_descendant(dst_cgrp, ns->root_cset->dfl_cgrp)))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_attach_permissions(struct cgroup *src_cgrp,\n\t\t\t\t     struct cgroup *dst_cgrp,\n\t\t\t\t     struct super_block *sb, bool threadgroup,\n\t\t\t\t     struct cgroup_namespace *ns)\n{\n\tint ret = 0;\n\n\tret = cgroup_procs_write_permission(src_cgrp, dst_cgrp, sb, ns);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cgroup_migrate_vet_dst(dst_cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!threadgroup && (src_cgrp->dom_cgrp != dst_cgrp->dom_cgrp))\n\t\tret = -EOPNOTSUPP;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_procs_write_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4861-4890",
    "snippet": "static int cgroup_procs_write_permission(struct cgroup *src_cgrp,\n\t\t\t\t\t struct cgroup *dst_cgrp,\n\t\t\t\t\t struct super_block *sb,\n\t\t\t\t\t struct cgroup_namespace *ns)\n{\n\tstruct cgroup *com_cgrp = src_cgrp;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* find the common ancestor */\n\twhile (!cgroup_is_descendant(dst_cgrp, com_cgrp))\n\t\tcom_cgrp = cgroup_parent(com_cgrp);\n\n\t/* %current should be authorized to migrate to the common ancestor */\n\tret = cgroup_may_write(com_cgrp, sb);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If namespaces are delegation boundaries, %current must be able\n\t * to see both source and destination cgroups from its namespace.\n\t */\n\tif ((cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    (!cgroup_is_descendant(src_cgrp, ns->root_cset->dfl_cgrp) ||\n\t     !cgroup_is_descendant(dst_cgrp, ns->root_cset->dfl_cgrp)))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_is_descendant",
          "args": [
            "dst_cgrp",
            "ns->root_cset->dfl_cgrp"
          ],
          "line": 4886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_descendant",
          "args": [
            "src_cgrp",
            "ns->root_cset->dfl_cgrp"
          ],
          "line": 4885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_may_write",
          "args": [
            "com_cgrp",
            "sb"
          ],
          "line": 4876
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_may_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4845-4859",
          "snippet": "static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)\n{\n\tint ret;\n\tstruct inode *inode;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tinode = kernfs_get_inode(sb, cgrp->procs_file.kn);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tret = inode_permission(&init_user_ns, inode, MAY_WRITE);\n\tiput(inode);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)\n{\n\tint ret;\n\tstruct inode *inode;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tinode = kernfs_get_inode(sb, cgrp->procs_file.kn);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tret = inode_permission(&init_user_ns, inode, MAY_WRITE);\n\tiput(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "com_cgrp"
          ],
          "line": 4873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_descendant",
          "args": [
            "dst_cgrp",
            "com_cgrp"
          ],
          "line": 4872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_procs_write_permission(struct cgroup *src_cgrp,\n\t\t\t\t\t struct cgroup *dst_cgrp,\n\t\t\t\t\t struct super_block *sb,\n\t\t\t\t\t struct cgroup_namespace *ns)\n{\n\tstruct cgroup *com_cgrp = src_cgrp;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* find the common ancestor */\n\twhile (!cgroup_is_descendant(dst_cgrp, com_cgrp))\n\t\tcom_cgrp = cgroup_parent(com_cgrp);\n\n\t/* %current should be authorized to migrate to the common ancestor */\n\tret = cgroup_may_write(com_cgrp, sb);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If namespaces are delegation boundaries, %current must be able\n\t * to see both source and destination cgroups from its namespace.\n\t */\n\tif ((cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    (!cgroup_is_descendant(src_cgrp, ns->root_cset->dfl_cgrp) ||\n\t     !cgroup_is_descendant(dst_cgrp, ns->root_cset->dfl_cgrp)))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_may_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4845-4859",
    "snippet": "static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)\n{\n\tint ret;\n\tstruct inode *inode;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tinode = kernfs_get_inode(sb, cgrp->procs_file.kn);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tret = inode_permission(&init_user_ns, inode, MAY_WRITE);\n\tiput(inode);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 4857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "&init_user_ns",
            "inode",
            "MAY_WRITE"
          ],
          "line": 4856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_inode",
          "args": [
            "sb",
            "cgrp->procs_file.kn"
          ],
          "line": 4852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)\n{\n\tint ret;\n\tstruct inode *inode;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tinode = kernfs_get_inode(sb, cgrp->procs_file.kn);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tret = inode_permission(&init_user_ns, inode, MAY_WRITE);\n\tiput(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_procs_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4839-4843",
    "snippet": "static int cgroup_procs_show(struct seq_file *s, void *v)\n{\n\tseq_printf(s, \"%d\\n\", task_pid_vnr(v));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%d\\n\"",
            "task_pid_vnr(v)"
          ],
          "line": 4841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "v"
          ],
          "line": 4841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_procs_show(struct seq_file *s, void *v)\n{\n\tseq_printf(s, \"%d\\n\", task_pid_vnr(v));\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_procs_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4822-4837",
    "snippet": "static void *cgroup_procs_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\n\t/*\n\t * All processes of a threaded subtree belong to the domain cgroup\n\t * of the subtree.  Only threads can be distributed across the\n\t * subtree.  Reject reads on cgroup.procs in the subtree proper.\n\t * They're always empty anyway.\n\t */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\treturn __cgroup_procs_start(s, pos, CSS_TASK_ITER_PROCS |\n\t\t\t\t\t    CSS_TASK_ITER_THREADED);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cgroup_procs_start",
          "args": [
            "s",
            "pos",
            "CSS_TASK_ITER_PROCS |\n\t\t\t\t\t    CSS_TASK_ITER_THREADED"
          ],
          "line": 4835
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_procs_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4796-4820",
          "snippet": "static void *__cgroup_procs_start(struct seq_file *s, loff_t *pos,\n\t\t\t\t  unsigned int iter_flags)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct css_task_iter *it = &ctx->procs.iter;\n\n\t/*\n\t * When a seq_file is seeked, it's always traversed sequentially\n\t * from position 0, so we can simply keep iterating on !0 *pos.\n\t */\n\tif (!ctx->procs.started) {\n\t\tif (WARN_ON_ONCE((*pos)))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t\tctx->procs.started = true;\n\t} else if (!(*pos)) {\n\t\tcss_task_iter_end(it);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t} else\n\t\treturn it->cur_task;\n\n\treturn cgroup_procs_next(s, NULL, NULL);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void *__cgroup_procs_start(struct seq_file *s, loff_t *pos,\n\t\t\t\t  unsigned int iter_flags)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct css_task_iter *it = &ctx->procs.iter;\n\n\t/*\n\t * When a seq_file is seeked, it's always traversed sequentially\n\t * from position 0, so we can simply keep iterating on !0 *pos.\n\t */\n\tif (!ctx->procs.started) {\n\t\tif (WARN_ON_ONCE((*pos)))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t\tctx->procs.started = true;\n\t} else if (!(*pos)) {\n\t\tcss_task_iter_end(it);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t} else\n\t\treturn it->cur_task;\n\n\treturn cgroup_procs_next(s, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 4833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 4832
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "354-357",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "s"
          ],
          "line": 4824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void *cgroup_procs_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\n\t/*\n\t * All processes of a threaded subtree belong to the domain cgroup\n\t * of the subtree.  Only threads can be distributed across the\n\t * subtree.  Reject reads on cgroup.procs in the subtree proper.\n\t * They're always empty anyway.\n\t */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\treturn __cgroup_procs_start(s, pos, CSS_TASK_ITER_PROCS |\n\t\t\t\t\t    CSS_TASK_ITER_THREADED);\n}"
  },
  {
    "function_name": "__cgroup_procs_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4796-4820",
    "snippet": "static void *__cgroup_procs_start(struct seq_file *s, loff_t *pos,\n\t\t\t\t  unsigned int iter_flags)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct css_task_iter *it = &ctx->procs.iter;\n\n\t/*\n\t * When a seq_file is seeked, it's always traversed sequentially\n\t * from position 0, so we can simply keep iterating on !0 *pos.\n\t */\n\tif (!ctx->procs.started) {\n\t\tif (WARN_ON_ONCE((*pos)))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t\tctx->procs.started = true;\n\t} else if (!(*pos)) {\n\t\tcss_task_iter_end(it);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t} else\n\t\treturn it->cur_task;\n\n\treturn cgroup_procs_next(s, NULL, NULL);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_procs_next",
          "args": [
            "s",
            "NULL",
            "NULL"
          ],
          "line": 4819
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_procs_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4785-4794",
          "snippet": "static void *cgroup_procs_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tif (pos)\n\t\t(*pos)++;\n\n\treturn css_task_iter_next(&ctx->procs.iter);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void *cgroup_procs_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tif (pos)\n\t\t(*pos)++;\n\n\treturn css_task_iter_next(&ctx->procs.iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&cgrp->self",
            "iter_flags",
            "it"
          ],
          "line": 4815
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4700-4720",
          "snippet": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "it"
          ],
          "line": 4814
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4761-4775",
          "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 4810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(*pos)"
          ],
          "line": 4809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "s"
          ],
          "line": 4800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void *__cgroup_procs_start(struct seq_file *s, loff_t *pos,\n\t\t\t\t  unsigned int iter_flags)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct css_task_iter *it = &ctx->procs.iter;\n\n\t/*\n\t * When a seq_file is seeked, it's always traversed sequentially\n\t * from position 0, so we can simply keep iterating on !0 *pos.\n\t */\n\tif (!ctx->procs.started) {\n\t\tif (WARN_ON_ONCE((*pos)))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t\tctx->procs.started = true;\n\t} else if (!(*pos)) {\n\t\tcss_task_iter_end(it);\n\t\tcss_task_iter_start(&cgrp->self, iter_flags, it);\n\t} else\n\t\treturn it->cur_task;\n\n\treturn cgroup_procs_next(s, NULL, NULL);\n}"
  },
  {
    "function_name": "cgroup_procs_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4785-4794",
    "snippet": "static void *cgroup_procs_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tif (pos)\n\t\t(*pos)++;\n\n\treturn css_task_iter_next(&ctx->procs.iter);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "&ctx->procs.iter"
          ],
          "line": 4793
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4730-4753",
          "snippet": "struct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void *cgroup_procs_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tif (pos)\n\t\t(*pos)++;\n\n\treturn css_task_iter_next(&ctx->procs.iter);\n}"
  },
  {
    "function_name": "cgroup_procs_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4777-4783",
    "snippet": "static void cgroup_procs_release(struct kernfs_open_file *of)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tif (ctx->procs.started)\n\t\tcss_task_iter_end(&ctx->procs.iter);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "&ctx->procs.iter"
          ],
          "line": 4782
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4761-4775",
          "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_procs_release(struct kernfs_open_file *of)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tif (ctx->procs.started)\n\t\tcss_task_iter_end(&ctx->procs.iter);\n}"
  },
  {
    "function_name": "css_task_iter_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4761-4775",
    "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "it->cur_task"
          ],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "it->cur_dcset"
          ],
          "line": 4771
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "955-990",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int css_set_count\t= 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 4767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&it->iters_node"
          ],
          "line": 4765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 4764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
  },
  {
    "function_name": "css_task_iter_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4730-4753",
    "snippet": "struct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 4750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_advance",
          "args": [
            "it"
          ],
          "line": 4747
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_advance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4636-4687",
          "snippet": "static void css_task_iter_advance(struct css_task_iter *it)\n{\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&css_set_lock);\nrepeat:\n\tif (it->task_pos) {\n\t\t/*\n\t\t * Advance iterator to find next entry. We go through cset\n\t\t * tasks, mg_tasks and dying_tasks, when consumed we move onto\n\t\t * the next cset.\n\t\t */\n\t\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\t\tit->flags &= ~CSS_TASK_ITER_SKIPPED;\n\t\telse\n\t\t\tit->task_pos = it->task_pos->next;\n\n\t\tif (it->task_pos == &it->cur_cset->tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->mg_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->mg_tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->dying_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->dying_tasks)\n\t\t\tcss_task_iter_advance_css_set(it);\n\t} else {\n\t\t/* called from start, proceed to the first cset */\n\t\tcss_task_iter_advance_css_set(it);\n\t}\n\n\tif (!it->task_pos)\n\t\treturn;\n\n\ttask = list_entry(it->task_pos, struct task_struct, cg_list);\n\n\tif (it->flags & CSS_TASK_ITER_PROCS) {\n\t\t/* if PROCS, skip over tasks which aren't group leaders */\n\t\tif (!thread_group_leader(task))\n\t\t\tgoto repeat;\n\n\t\t/* and dying leaders w/o live member threads */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks &&\n\t\t    !atomic_read(&task->signal->live))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* skip all dying ones */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks)\n\t\t\tgoto repeat;\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void css_task_iter_advance(struct css_task_iter *it)\n{\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&css_set_lock);\nrepeat:\n\tif (it->task_pos) {\n\t\t/*\n\t\t * Advance iterator to find next entry. We go through cset\n\t\t * tasks, mg_tasks and dying_tasks, when consumed we move onto\n\t\t * the next cset.\n\t\t */\n\t\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\t\tit->flags &= ~CSS_TASK_ITER_SKIPPED;\n\t\telse\n\t\t\tit->task_pos = it->task_pos->next;\n\n\t\tif (it->task_pos == &it->cur_cset->tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->mg_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->mg_tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->dying_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->dying_tasks)\n\t\t\tcss_task_iter_advance_css_set(it);\n\t} else {\n\t\t/* called from start, proceed to the first cset */\n\t\tcss_task_iter_advance_css_set(it);\n\t}\n\n\tif (!it->task_pos)\n\t\treturn;\n\n\ttask = list_entry(it->task_pos, struct task_struct, cg_list);\n\n\tif (it->flags & CSS_TASK_ITER_PROCS) {\n\t\t/* if PROCS, skip over tasks which aren't group leaders */\n\t\tif (!thread_group_leader(task))\n\t\t\tgoto repeat;\n\n\t\t/* and dying leaders w/o live member threads */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks &&\n\t\t    !atomic_read(&task->signal->live))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* skip all dying ones */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks)\n\t\t\tgoto repeat;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "it->cur_task"
          ],
          "line": 4746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "it->task_pos",
            "structtask_struct",
            "cg_list"
          ],
          "line": 4744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "it->cur_task"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}"
  },
  {
    "function_name": "css_task_iter_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4700-4720",
    "snippet": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
    ],
    "globals_used": [
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 4719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_advance",
          "args": [
            "it"
          ],
          "line": 4717
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_advance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4636-4687",
          "snippet": "static void css_task_iter_advance(struct css_task_iter *it)\n{\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&css_set_lock);\nrepeat:\n\tif (it->task_pos) {\n\t\t/*\n\t\t * Advance iterator to find next entry. We go through cset\n\t\t * tasks, mg_tasks and dying_tasks, when consumed we move onto\n\t\t * the next cset.\n\t\t */\n\t\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\t\tit->flags &= ~CSS_TASK_ITER_SKIPPED;\n\t\telse\n\t\t\tit->task_pos = it->task_pos->next;\n\n\t\tif (it->task_pos == &it->cur_cset->tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->mg_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->mg_tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->dying_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->dying_tasks)\n\t\t\tcss_task_iter_advance_css_set(it);\n\t} else {\n\t\t/* called from start, proceed to the first cset */\n\t\tcss_task_iter_advance_css_set(it);\n\t}\n\n\tif (!it->task_pos)\n\t\treturn;\n\n\ttask = list_entry(it->task_pos, struct task_struct, cg_list);\n\n\tif (it->flags & CSS_TASK_ITER_PROCS) {\n\t\t/* if PROCS, skip over tasks which aren't group leaders */\n\t\tif (!thread_group_leader(task))\n\t\t\tgoto repeat;\n\n\t\t/* and dying leaders w/o live member threads */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks &&\n\t\t    !atomic_read(&task->signal->live))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* skip all dying ones */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks)\n\t\t\tgoto repeat;\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void css_task_iter_advance(struct css_task_iter *it)\n{\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&css_set_lock);\nrepeat:\n\tif (it->task_pos) {\n\t\t/*\n\t\t * Advance iterator to find next entry. We go through cset\n\t\t * tasks, mg_tasks and dying_tasks, when consumed we move onto\n\t\t * the next cset.\n\t\t */\n\t\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\t\tit->flags &= ~CSS_TASK_ITER_SKIPPED;\n\t\telse\n\t\t\tit->task_pos = it->task_pos->next;\n\n\t\tif (it->task_pos == &it->cur_cset->tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->mg_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->mg_tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->dying_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->dying_tasks)\n\t\t\tcss_task_iter_advance_css_set(it);\n\t} else {\n\t\t/* called from start, proceed to the first cset */\n\t\tcss_task_iter_advance_css_set(it);\n\t}\n\n\tif (!it->task_pos)\n\t\treturn;\n\n\ttask = list_entry(it->task_pos, struct task_struct, cg_list);\n\n\tif (it->flags & CSS_TASK_ITER_PROCS) {\n\t\t/* if PROCS, skip over tasks which aren't group leaders */\n\t\tif (!thread_group_leader(task))\n\t\t\tgoto repeat;\n\n\t\t/* and dying leaders w/o live member threads */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks &&\n\t\t    !atomic_read(&task->signal->live))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* skip all dying ones */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks)\n\t\t\tgoto repeat;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 4705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "it",
            "0",
            "sizeof(*it)"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}"
  },
  {
    "function_name": "css_task_iter_advance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4636-4687",
    "snippet": "static void css_task_iter_advance(struct css_task_iter *it)\n{\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&css_set_lock);\nrepeat:\n\tif (it->task_pos) {\n\t\t/*\n\t\t * Advance iterator to find next entry. We go through cset\n\t\t * tasks, mg_tasks and dying_tasks, when consumed we move onto\n\t\t * the next cset.\n\t\t */\n\t\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\t\tit->flags &= ~CSS_TASK_ITER_SKIPPED;\n\t\telse\n\t\t\tit->task_pos = it->task_pos->next;\n\n\t\tif (it->task_pos == &it->cur_cset->tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->mg_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->mg_tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->dying_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->dying_tasks)\n\t\t\tcss_task_iter_advance_css_set(it);\n\t} else {\n\t\t/* called from start, proceed to the first cset */\n\t\tcss_task_iter_advance_css_set(it);\n\t}\n\n\tif (!it->task_pos)\n\t\treturn;\n\n\ttask = list_entry(it->task_pos, struct task_struct, cg_list);\n\n\tif (it->flags & CSS_TASK_ITER_PROCS) {\n\t\t/* if PROCS, skip over tasks which aren't group leaders */\n\t\tif (!thread_group_leader(task))\n\t\t\tgoto repeat;\n\n\t\t/* and dying leaders w/o live member threads */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks &&\n\t\t    !atomic_read(&task->signal->live))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* skip all dying ones */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks)\n\t\t\tgoto repeat;\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&task->signal->live"
          ],
          "line": 4680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "task"
          ],
          "line": 4675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "it->task_pos",
            "structtask_struct",
            "cg_list"
          ],
          "line": 4671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_advance_css_set",
          "args": [
            "it"
          ],
          "line": 4665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_advance_css_set",
          "args": [
            "it"
          ],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 4640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void css_task_iter_advance(struct css_task_iter *it)\n{\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&css_set_lock);\nrepeat:\n\tif (it->task_pos) {\n\t\t/*\n\t\t * Advance iterator to find next entry. We go through cset\n\t\t * tasks, mg_tasks and dying_tasks, when consumed we move onto\n\t\t * the next cset.\n\t\t */\n\t\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\t\tit->flags &= ~CSS_TASK_ITER_SKIPPED;\n\t\telse\n\t\t\tit->task_pos = it->task_pos->next;\n\n\t\tif (it->task_pos == &it->cur_cset->tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->mg_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->mg_tasks) {\n\t\t\tit->cur_tasks_head = &it->cur_cset->dying_tasks;\n\t\t\tit->task_pos = it->cur_tasks_head->next;\n\t\t}\n\t\tif (it->task_pos == &it->cur_cset->dying_tasks)\n\t\t\tcss_task_iter_advance_css_set(it);\n\t} else {\n\t\t/* called from start, proceed to the first cset */\n\t\tcss_task_iter_advance_css_set(it);\n\t}\n\n\tif (!it->task_pos)\n\t\treturn;\n\n\ttask = list_entry(it->task_pos, struct task_struct, cg_list);\n\n\tif (it->flags & CSS_TASK_ITER_PROCS) {\n\t\t/* if PROCS, skip over tasks which aren't group leaders */\n\t\tif (!thread_group_leader(task))\n\t\t\tgoto repeat;\n\n\t\t/* and dying leaders w/o live member threads */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks &&\n\t\t    !atomic_read(&task->signal->live))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* skip all dying ones */\n\t\tif (it->cur_tasks_head == &it->cur_cset->dying_tasks)\n\t\t\tgoto repeat;\n\t}\n}"
  },
  {
    "function_name": "css_task_iter_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "4625-4634",
    "snippet": "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (it->task_pos == &task->cg_list) {\n\t\tit->task_pos = it->task_pos->next;\n\t\tit->flags |= CSS_TASK_ITER_SKIPPED;\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 4628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (it->task_pos == &task->cg_list) {\n\t\tit->task_pos = it->task_pos->next;\n\t\tit->flags |= CSS_TASK_ITER_SKIPPED;\n\t}\n}"
  },
  {
    "function_name": "cgroup_attach_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2783-4623",
    "snippet": "int cgroup_attach_task(struct cgroup *dst_cgrp, struct task_struct *leader,\n\t\t       bool threadgroup)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct task_struct *task;\n\tint ret = 0;\n\n\t/* look up all src csets */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_src(task_css_set(task), dst_cgrp, &mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* prepare dst csets and commit */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (!ret)\n\t\tret = cgroup_migrate(leader, threadgroup, &mgctx);\n\n\tcgroup_migrate_finish(&mgctx);\n\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(attach_task, dst_cgrp, leader, threadgroup);\n\n\treturn ret;\n}\n\nstruct task_struct *cgroup_procs_write_start(char *buf, bool threadgroup,\n\t\t\t\t\t     bool *locked)\n\t__acquires(&cgroup_threadgroup_rwsem)\n{\n\tstruct task_struct *tsk;\n\tpid_t pid;\n\n\tif (kstrtoint(strstrip(buf), 0, &pid) || pid < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If we migrate a single thread, we don't care about threadgroup\n\t * stability. If the thread is `current`, it won't exit(2) under our\n\t * hands or change PID through exec(2). We exclude\n\t * cgroup_update_dfl_csses and other cgroup_{proc,thread}s_write\n\t * callers by cgroup_mutex.\n\t * Therefore, we can skip the global lock.\n\t */\n\tlockdep_assert_held(&cgroup_mutex);\n\tif (pid || threadgroup) {\n\t\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\t\t*locked = true;\n\t} else {\n\t\t*locked = false;\n\t}\n\n\trcu_read_lock();\n\tif (pid) {\n\t\ttsk = find_task_by_vpid(pid);\n\t\tif (!tsk) {\n\t\t\ttsk = ERR_PTR(-ESRCH);\n\t\t\tgoto out_unlock_threadgroup;\n\t\t}\n\t} else {\n\t\ttsk = current;\n\t}\n\n\tif (threadgroup)\n\t\ttsk = tsk->group_leader;\n\n\t/*\n\t * kthreads may acquire PF_NO_SETAFFINITY during initialization.\n\t * If userland migrates such a kthread to a non-root cgroup, it can\n\t * become trapped in a cpuset, or RT kthread may be born in a\n\t * cgroup with no rt_runtime allocated.  Just say no.\n\t */\n\tif (tsk->no_cgroup_migration || (tsk->flags & PF_NO_SETAFFINITY)) {\n\t\ttsk = ERR_PTR(-EINVAL);\n\t\tgoto out_unlock_threadgroup;\n\t}\n\n\tget_task_struct(tsk);\n\tgoto out_unlock_rcu;\n\nout_unlock_threadgroup:\n\tif (*locked) {\n\t\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\t\t*locked = false;\n\t}\nout_unlock_rcu:\n\trcu_read_unlock();\n\treturn tsk;\n}\n\nvoid cgroup_procs_write_finish(struct task_struct *task, bool locked)\n\t__releases(&cgroup_threadgroup_rwsem)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\t/* release reference from cgroup_procs_write_start() */\n\tput_task_struct(task);\n\n\tif (locked)\n\t\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\tfor_each_subsys(ss, ssid)\n\t\tif (ss->post_attach)\n\t\t\tss->post_attach();\n}\n\nstatic void cgroup_print_ss_mask(struct seq_file *seq, u16 ss_mask)\n{\n\tstruct cgroup_subsys *ss;\n\tbool printed = false;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tif (printed)\n\t\t\tseq_putc(seq, ' ');\n\t\tseq_puts(seq, ss->name);\n\t\tprinted = true;\n\t} while_each_subsys_mask();\n\tif (printed)\n\t\tseq_putc(seq, '\\n');\n}\n\n/* show controllers which are enabled from the parent */\nstatic int cgroup_controllers_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgroup_control(cgrp));\n\treturn 0;\n}\n\n/* show controllers which are enabled for a given cgroup's children */\nstatic int cgroup_subtree_control_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgrp->subtree_control);\n\treturn 0;\n}\n\n/**\n * cgroup_update_dfl_csses - update css assoc of a subtree in default hierarchy\n * @cgrp: root of the subtree to update csses for\n *\n * @cgrp's control masks have changed and its subtree's css associations\n * need to be updated accordingly.  This function looks up all css_sets\n * which are attached to the subtree, creates the matching updated css_sets\n * and migrates the tasks to the new ones.\n */\nstatic int cgroup_update_dfl_csses(struct cgroup *cgrp)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup *dsct;\n\tstruct css_set *src_cset;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\t/* look up all csses currently attached to @cgrp's subtree */\n\tspin_lock_irq(&css_set_lock);\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &dsct->cset_links, cset_link)\n\t\t\tcgroup_migrate_add_src(link->cset, dsct, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* NULL dst indicates self on default hierarchy */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(src_cset, &mgctx.preloaded_src_csets, mg_preload_node) {\n\t\tstruct task_struct *task, *ntask;\n\n\t\t/* all tasks in src_csets need to be migrated */\n\t\tlist_for_each_entry_safe(task, ntask, &src_cset->tasks, cg_list)\n\t\t\tcgroup_migrate_add_task(task, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_migrate_execute(&mgctx);\nout_finish:\n\tcgroup_migrate_finish(&mgctx);\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\treturn ret;\n}\n\n/**\n * cgroup_lock_and_drain_offline - lock cgroup_mutex and drain offlined csses\n * @cgrp: root of the target subtree\n *\n * Because css offlining is asynchronous, userland may try to re-enable a\n * controller while the previous css is still around.  This function grabs\n * cgroup_mutex and drains the previous css instances of @cgrp's subtree.\n */\nvoid cgroup_lock_and_drain_offline(struct cgroup *cgrp)\n\t__acquires(&cgroup_mutex)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\nrestart:\n\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\t\t\tDEFINE_WAIT(wait);\n\n\t\t\tif (!css || !percpu_ref_is_dying(&css->refcnt))\n\t\t\t\tcontinue;\n\n\t\t\tcgroup_get_live(dsct);\n\t\t\tprepare_to_wait(&dsct->offline_waitq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tschedule();\n\t\t\tfinish_wait(&dsct->offline_waitq, &wait);\n\n\t\t\tcgroup_put(dsct);\n\t\t\tgoto restart;\n\t\t}\n\t}\n}\n\n/**\n * cgroup_save_control - save control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Save ->subtree_control, ->subtree_ss_mask and ->dom_cgrp to the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_save_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->old_subtree_control = dsct->subtree_control;\n\t\tdsct->old_subtree_ss_mask = dsct->subtree_ss_mask;\n\t\tdsct->old_dom_cgrp = dsct->dom_cgrp;\n\t}\n}\n\n/**\n * cgroup_propagate_control - refresh control masks of a subtree\n * @cgrp: root of the target subtree\n *\n * For @cgrp and its subtree, ensure ->subtree_ss_mask matches\n * ->subtree_control and propagate controller availability through the\n * subtree so that descendants don't have unavailable controllers enabled.\n */\nstatic void cgroup_propagate_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control &= cgroup_control(dsct);\n\t\tdsct->subtree_ss_mask =\n\t\t\tcgroup_calc_subtree_ss_mask(dsct->subtree_control,\n\t\t\t\t\t\t    cgroup_ss_mask(dsct));\n\t}\n}\n\n/**\n * cgroup_restore_control - restore control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Restore ->subtree_control, ->subtree_ss_mask and ->dom_cgrp from the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_restore_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control = dsct->old_subtree_control;\n\t\tdsct->subtree_ss_mask = dsct->old_subtree_ss_mask;\n\t\tdsct->dom_cgrp = dsct->old_dom_cgrp;\n\t}\n}\n\nstatic bool css_visible(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tif (cgroup_control(cgrp) & (1 << ss->id))\n\t\treturn true;\n\tif (!(cgroup_ss_mask(cgrp) & (1 << ss->id)))\n\t\treturn false;\n\treturn cgroup_on_dfl(cgrp) && ss->implicit_on_dfl;\n}\n\n/**\n * cgroup_apply_control_enable - enable or show csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and create new csses or make the existing ones\n * visible.  A css is created invisible if it's being implicitly enabled\n * through dependency.  An invisible css is made visible when the userland\n * explicitly enables it.\n *\n * Returns 0 on success, -errno on failure.  On failure, csses which have\n * been processed already aren't cleaned up.  The caller is responsible for\n * cleaning up with cgroup_apply_control_disable().\n */\nstatic int cgroup_apply_control_enable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid, ret;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tif (!(cgroup_ss_mask(dsct) & (1 << ss->id)))\n\t\t\t\tcontinue;\n\n\t\t\tif (!css) {\n\t\t\t\tcss = css_create(dsct, ss);\n\t\t\t\tif (IS_ERR(css))\n\t\t\t\t\treturn PTR_ERR(css);\n\t\t\t}\n\n\t\t\tWARN_ON_ONCE(percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (css_visible(css)) {\n\t\t\t\tret = css_populate_dir(css);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_apply_control_disable - kill or hide csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and kill and hide csses so that they match\n * cgroup_ss_mask() and cgroup_visible_mask().\n *\n * A css is hidden when the userland requests it to be disabled while other\n * subsystems are still depending on it.  The css must not actively control\n * resources and be in the vanilla state if it's made visible again later.\n * Controllers which may be depended upon should provide ->css_reset() for\n * this purpose.\n */\nstatic void cgroup_apply_control_disable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tif (!css)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (css->parent &&\n\t\t\t    !(cgroup_ss_mask(dsct) & (1 << ss->id))) {\n\t\t\t\tkill_css(css);\n\t\t\t} else if (!css_visible(css)) {\n\t\t\t\tcss_clear_dir(css);\n\t\t\t\tif (ss->css_reset)\n\t\t\t\t\tss->css_reset(css);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * cgroup_apply_control - apply control mask updates to the subtree\n * @cgrp: root of the target subtree\n *\n * subsystems can be enabled and disabled in a subtree using the following\n * steps.\n *\n * 1. Call cgroup_save_control() to stash the current state.\n * 2. Update ->subtree_control masks in the subtree as desired.\n * 3. Call cgroup_apply_control() to apply the changes.\n * 4. Optionally perform other related operations.\n * 5. Call cgroup_finalize_control() to finish up.\n *\n * This function implements step 3 and propagates the mask changes\n * throughout @cgrp's subtree, updates csses accordingly and perform\n * process migrations.\n */\nstatic int cgroup_apply_control(struct cgroup *cgrp)\n{\n\tint ret;\n\n\tcgroup_propagate_control(cgrp);\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * At this point, cgroup_e_css_by_mask() results reflect the new csses\n\t * making the following cgroup_update_dfl_csses() properly update\n\t * css associations of all tasks in the subtree.\n\t */\n\tret = cgroup_update_dfl_csses(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n/**\n * cgroup_finalize_control - finalize control mask update\n * @cgrp: root of the target subtree\n * @ret: the result of the update\n *\n * Finalize control mask update.  See cgroup_apply_control() for more info.\n */\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret)\n{\n\tif (ret) {\n\t\tcgroup_restore_control(cgrp);\n\t\tcgroup_propagate_control(cgrp);\n\t}\n\n\tcgroup_apply_control_disable(cgrp);\n}\n\nstatic int cgroup_vet_subtree_control_enable(struct cgroup *cgrp, u16 enable)\n{\n\tu16 domain_enable = enable & ~cgrp_dfl_threaded_ss_mask;\n\n\t/* if nothing is getting enabled, nothing to worry about */\n\tif (!enable)\n\t\treturn 0;\n\n\t/* can @cgrp host any resources? */\n\tif (!cgroup_is_valid_domain(cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn 0;\n\n\tif (domain_enable) {\n\t\t/* can't enable domain controllers inside a thread subtree */\n\t\tif (cgroup_is_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\t/*\n\t\t * Threaded controllers can handle internal competitions\n\t\t * and are always allowed inside a (prospective) thread\n\t\t * subtree.\n\t\t */\n\t\tif (cgroup_can_be_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Controllers can't be enabled for a cgroup with tasks to avoid\n\t * child cgroups competing against tasks.\n\t */\n\tif (cgroup_has_tasks(cgrp))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n/* change the enabled child controllers for a cgroup in the default hierarchy */\nstatic ssize_t cgroup_subtree_control_write(struct kernfs_open_file *of,\n\t\t\t\t\t    char *buf, size_t nbytes,\n\t\t\t\t\t    loff_t off)\n{\n\tu16 enable = 0, disable = 0;\n\tstruct cgroup *cgrp, *child;\n\tstruct cgroup_subsys *ss;\n\tchar *tok;\n\tint ssid, ret;\n\n\t/*\n\t * Parse input - space separated list of subsystem names prefixed\n\t * with either + or -.\n\t */\n\tbuf = strstrip(buf);\n\twhile ((tok = strsep(&buf, \" \"))) {\n\t\tif (tok[0] == '\\0')\n\t\t\tcontinue;\n\t\tdo_each_subsys_mask(ss, ssid, ~cgrp_dfl_inhibit_ss_mask) {\n\t\t\tif (!cgroup_ssid_enabled(ssid) ||\n\t\t\t    strcmp(tok + 1, ss->name))\n\t\t\t\tcontinue;\n\n\t\t\tif (*tok == '+') {\n\t\t\t\tenable |= 1 << ssid;\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t} else if (*tok == '-') {\n\t\t\t\tdisable |= 1 << ssid;\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t} while_each_subsys_mask();\n\t\tif (ssid == CGROUP_SUBSYS_COUNT)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (enable & (1 << ssid)) {\n\t\t\tif (cgrp->subtree_control & (1 << ssid)) {\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(cgroup_control(cgrp) & (1 << ssid))) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else if (disable & (1 << ssid)) {\n\t\t\tif (!(cgrp->subtree_control & (1 << ssid))) {\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* a child has it enabled? */\n\t\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\t\tif (child->subtree_control & (1 << ssid)) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!enable && !disable) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tret = cgroup_vet_subtree_control_enable(cgrp, enable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* save and update control masks and prepare csses */\n\tcgroup_save_control(cgrp);\n\n\tcgrp->subtree_control |= enable;\n\tcgrp->subtree_control &= ~disable;\n\n\tret = cgroup_apply_control(cgrp);\n\tcgroup_finalize_control(cgrp, ret);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tkernfs_activate(cgrp->kn);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\n/**\n * cgroup_enable_threaded - make @cgrp threaded\n * @cgrp: the target cgroup\n *\n * Called when \"threaded\" is written to the cgroup.type interface file and\n * tries to make @cgrp threaded and join the parent's resource domain.\n * This function is never called on the root cgroup as cgroup.type doesn't\n * exist on it.\n */\nstatic int cgroup_enable_threaded(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup *dom_cgrp = parent->dom_cgrp;\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* noop if already threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @cgroup is populated or has domain controllers enabled, it\n\t * can't be switched.  While the below cgroup_can_be_thread_root()\n\t * test can catch the same conditions, that's only when @parent is\n\t * not mixable, so let's check it explicitly.\n\t */\n\tif (cgroup_is_populated(cgrp) ||\n\t    cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn -EOPNOTSUPP;\n\n\t/* we're joining the parent's domain, ensure its validity */\n\tif (!cgroup_is_valid_domain(dom_cgrp) ||\n\t    !cgroup_can_be_thread_root(dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * The following shouldn't cause actual migrations and should\n\t * always succeed.\n\t */\n\tcgroup_save_control(cgrp);\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp)\n\t\tif (dsct == cgrp || cgroup_is_threaded(dsct))\n\t\t\tdsct->dom_cgrp = dom_cgrp;\n\n\tret = cgroup_apply_control(cgrp);\n\tif (!ret)\n\t\tparent->nr_threaded_children++;\n\n\tcgroup_finalize_control(cgrp, ret);\n\treturn ret;\n}\n\nstatic int cgroup_type_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tif (cgroup_is_threaded(cgrp))\n\t\tseq_puts(seq, \"threaded\\n\");\n\telse if (!cgroup_is_valid_domain(cgrp))\n\t\tseq_puts(seq, \"domain invalid\\n\");\n\telse if (cgroup_is_thread_root(cgrp))\n\t\tseq_puts(seq, \"domain threaded\\n\");\n\telse\n\t\tseq_puts(seq, \"domain\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_type_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\t/* only switching to threaded mode is supported */\n\tif (strcmp(strstrip(buf), \"threaded\"))\n\t\treturn -EINVAL;\n\n\t/* drain dying csses before we re-apply (threaded) subtree control */\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\t/* threaded can only be enabled */\n\tret = cgroup_enable_threaded(cgrp);\n\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\nstatic int cgroup_max_descendants_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint descendants = READ_ONCE(cgrp->max_descendants);\n\n\tif (descendants == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", descendants);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_descendants_write(struct kernfs_open_file *of,\n\t\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint descendants;\n\tssize_t ret;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdescendants = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &descendants);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (descendants < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_descendants = descendants;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_max_depth_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint depth = READ_ONCE(cgrp->max_depth);\n\n\tif (depth == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", depth);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_depth_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint depth;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdepth = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &depth);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (depth < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_depth = depth;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_events_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"populated %d\\n\", cgroup_is_populated(cgrp));\n\tseq_printf(seq, \"frozen %d\\n\", test_bit(CGRP_FROZEN, &cgrp->flags));\n\n\treturn 0;\n}\n\nstatic int cgroup_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgroup = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"nr_descendants %d\\n\",\n\t\t   cgroup->nr_descendants);\n\tseq_printf(seq, \"nr_dying_descendants %d\\n\",\n\t\t   cgroup->nr_dying_descendants);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cgroup_extra_stat_show(struct seq_file *seq,\n\t\t\t\t\t\t struct cgroup *cgrp, int ssid)\n{\n\tstruct cgroup_subsys *ss = cgroup_subsys[ssid];\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!ss->css_extra_stat_show)\n\t\treturn 0;\n\n\tcss = cgroup_tryget_css(cgrp, ss);\n\tif (!css)\n\t\treturn 0;\n\n\tret = ss->css_extra_stat_show(seq, css);\n\tcss_put(css);\n\treturn ret;\n}\n\nstatic int cpu_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup __maybe_unused *cgrp = seq_css(seq)->cgroup;\n\tint ret = 0;\n\n\tcgroup_base_stat_cputime_show(seq);\n#ifdef CONFIG_CGROUP_SCHED\n\tret = cgroup_extra_stat_show(seq, cgrp, cpu_cgrp_id);\n#endif\n\treturn ret;\n}\n\n#ifdef CONFIG_PSI\nstatic int cgroup_io_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_IO);\n}\nstatic int cgroup_memory_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_MEM);\n}\nstatic int cgroup_cpu_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_CPU);\n}\n\nstatic ssize_t cgroup_pressure_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t\t  size_t nbytes, enum psi_res res)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct psi_trigger *new;\n\tstruct cgroup *cgrp;\n\tstruct psi_group *psi;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tcgroup_get(cgrp);\n\tcgroup_kn_unlock(of->kn);\n\n\tpsi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\tnew = psi_trigger_create(psi, buf, nbytes, res);\n\tif (IS_ERR(new)) {\n\t\tcgroup_put(cgrp);\n\t\treturn PTR_ERR(new);\n\t}\n\n\tpsi_trigger_replace(&ctx->psi.trigger, new);\n\n\tcgroup_put(cgrp);\n\n\treturn nbytes;\n}\n\nstatic ssize_t cgroup_io_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_IO);\n}\n\nstatic ssize_t cgroup_memory_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_MEM);\n}\n\nstatic ssize_t cgroup_cpu_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_CPU);\n}\n\nstatic __poll_t cgroup_pressure_poll(struct kernfs_open_file *of,\n\t\t\t\t\t  poll_table *pt)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\treturn psi_trigger_poll(&ctx->psi.trigger, of->file, pt);\n}\n\nstatic void cgroup_pressure_release(struct kernfs_open_file *of)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tpsi_trigger_replace(&ctx->psi.trigger, NULL);\n}\n\nbool cgroup_psi_enabled(void)\n{\n\treturn (cgroup_feature_disable_mask & (1 << OPT_FEATURE_PRESSURE)) == 0;\n}\n\n#else /* CONFIG_PSI */\nbool cgroup_psi_enabled(void)\n{\n\treturn false;\n}\n\n#endif /* CONFIG_PSI */\n\nstatic int cgroup_freeze_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"%d\\n\", cgrp->freezer.freeze);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_freeze_write(struct kernfs_open_file *of,\n\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint freeze;\n\n\tret = kstrtoint(strstrip(buf), 0, &freeze);\n\tif (ret)\n\t\treturn ret;\n\n\tif (freeze < 0 || freeze > 1)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgroup_freeze(cgrp, freeze);\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic void __cgroup_kill(struct cgroup *cgrp)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tset_bit(CGRP_KILL, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tcss_task_iter_start(&cgrp->self, CSS_TASK_ITER_PROCS | CSS_TASK_ITER_THREADED, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t/* Ignore kernel threads here. */\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\n\t\t/* Skip tasks that are already dying. */\n\t\tif (__fatal_signal_pending(task))\n\t\t\tcontinue;\n\n\t\tsend_sig(SIGKILL, task, 0);\n\t}\n\tcss_task_iter_end(&it);\n\n\tspin_lock_irq(&css_set_lock);\n\tclear_bit(CGRP_KILL, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n}\n\nstatic void cgroup_kill(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *dsct;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_for_each_live_descendant_pre(dsct, css, cgrp)\n\t\t__cgroup_kill(dsct);\n}\n\nstatic ssize_t cgroup_kill_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tssize_t ret = 0;\n\tint kill;\n\tstruct cgroup *cgrp;\n\n\tret = kstrtoint(strstrip(buf), 0, &kill);\n\tif (ret)\n\t\treturn ret;\n\n\tif (kill != 1)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Killing is a process directed operation, i.e. the whole thread-group\n\t * is taken down so act like we do for cgroup.procs and only make this\n\t * writable in non-threaded cgroups.\n\t */\n\tif (cgroup_is_threaded(cgrp))\n\t\tret = -EOPNOTSUPP;\n\telse\n\t\tcgroup_kill(cgrp);\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\nstatic int cgroup_file_open(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of_cft(of);\n\tstruct cgroup_file_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ns = current->nsproxy->cgroup_ns;\n\tget_cgroup_ns(ctx->ns);\n\tof->priv = ctx;\n\n\tif (!cft->open)\n\t\treturn 0;\n\n\tret = cft->open(of);\n\tif (ret) {\n\t\tput_cgroup_ns(ctx->ns);\n\t\tkfree(ctx);\n\t}\n\treturn ret;\n}\n\nstatic void cgroup_file_release(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of_cft(of);\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tif (cft->release)\n\t\tcft->release(of);\n\tput_cgroup_ns(ctx->ns);\n\tkfree(ctx);\n}\n\nstatic ssize_t cgroup_file_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!nbytes)\n\t\treturn 0;\n\n\t/*\n\t * If namespaces are delegation boundaries, disallow writes to\n\t * files in an non-init namespace root from inside the namespace\n\t * except for the files explicitly marked delegatable -\n\t * cgroup.procs and cgroup.subtree_control.\n\t */\n\tif ((cgrp->root->flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    !(cft->flags & CFTYPE_NS_DELEGATABLE) &&\n\t    ctx->ns != &init_cgroup_ns && ctx->ns->root_cset->dfl_cgrp == cgrp)\n\t\treturn -EPERM;\n\n\tif (cft->write)\n\t\treturn cft->write(of, buf, nbytes, off);\n\n\t/*\n\t * kernfs guarantees that a file isn't deleted with operations in\n\t * flight, which means that the matching css is and stays alive and\n\t * doesn't need to be pinned.  The RCU locking is not necessary\n\t * either.  It's just for the convenience of using cgroup_css().\n\t */\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, cft->ss);\n\trcu_read_unlock();\n\n\tif (cft->write_u64) {\n\t\tunsigned long long v;\n\t\tret = kstrtoull(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_u64(css, cft, v);\n\t} else if (cft->write_s64) {\n\t\tlong long v;\n\t\tret = kstrtoll(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_s64(css, cft, v);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret ?: nbytes;\n}\n\nstatic __poll_t cgroup_file_poll(struct kernfs_open_file *of, poll_table *pt)\n{\n\tstruct cftype *cft = of_cft(of);\n\n\tif (cft->poll)\n\t\treturn cft->poll(of, pt);\n\n\treturn kernfs_generic_poll(of, pt);\n}\n\nstatic void *cgroup_seqfile_start(struct seq_file *seq, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_start(seq, ppos);\n}\n\nstatic void *cgroup_seqfile_next(struct seq_file *seq, void *v, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_next(seq, v, ppos);\n}\n\nstatic void cgroup_seqfile_stop(struct seq_file *seq, void *v)\n{\n\tif (seq_cft(seq)->seq_stop)\n\t\tseq_cft(seq)->seq_stop(seq, v);\n}\n\nstatic int cgroup_seqfile_show(struct seq_file *m, void *arg)\n{\n\tstruct cftype *cft = seq_cft(m);\n\tstruct cgroup_subsys_state *css = seq_css(m);\n\n\tif (cft->seq_show)\n\t\treturn cft->seq_show(m, arg);\n\n\tif (cft->read_u64)\n\t\tseq_printf(m, \"%llu\\n\", cft->read_u64(css, cft));\n\telse if (cft->read_s64)\n\t\tseq_printf(m, \"%lld\\n\", cft->read_s64(css, cft));\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct kernfs_ops cgroup_kf_single_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.poll\t\t\t= cgroup_file_poll,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\nstatic struct kernfs_ops cgroup_kf_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.poll\t\t\t= cgroup_file_poll,\n\t.seq_start\t\t= cgroup_seqfile_start,\n\t.seq_next\t\t= cgroup_seqfile_next,\n\t.seq_stop\t\t= cgroup_seqfile_stop,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\n/* set uid and gid of cgroup dirs and files to that of the creator */\nstatic int cgroup_kn_set_ugid(struct kernfs_node *kn)\n{\n\tstruct iattr iattr = { .ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t       .ia_uid = current_fsuid(),\n\t\t\t       .ia_gid = current_fsgid(), };\n\n\tif (uid_eq(iattr.ia_uid, GLOBAL_ROOT_UID) &&\n\t    gid_eq(iattr.ia_gid, GLOBAL_ROOT_GID))\n\t\treturn 0;\n\n\treturn kernfs_setattr(kn, &iattr);\n}\n\nstatic void cgroup_file_notify_timer(struct timer_list *timer)\n{\n\tcgroup_file_notify(container_of(timer, struct cgroup_file,\n\t\t\t\t\tnotify_timer));\n}\n\nstatic int cgroup_add_file(struct cgroup_subsys_state *css, struct cgroup *cgrp,\n\t\t\t   struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\tstruct kernfs_node *kn;\n\tstruct lock_class_key *key = NULL;\n\tint ret;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tkey = &cft->lockdep_key;\n#endif\n\tkn = __kernfs_create_file(cgrp->kn, cgroup_file_name(cgrp, cft, name),\n\t\t\t\t  cgroup_file_mode(cft),\n\t\t\t\t  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,\n\t\t\t\t  0, cft->kf_ops, cft,\n\t\t\t\t  NULL, key);\n\tif (IS_ERR(kn))\n\t\treturn PTR_ERR(kn);\n\n\tret = cgroup_kn_set_ugid(kn);\n\tif (ret) {\n\t\tkernfs_remove(kn);\n\t\treturn ret;\n\t}\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\ttimer_setup(&cfile->notify_timer, cgroup_file_notify_timer, 0);\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = kn;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_addrm_files - add or remove files to a cgroup directory\n * @css: the target css\n * @cgrp: the target cgroup (usually css->cgroup)\n * @cfts: array of cftypes to be added\n * @is_add: whether to add or remove\n *\n * Depending on @is_add, add or remove files defined by @cfts on @cgrp.\n * For removals, this function never fails.\n */\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add)\n{\n\tstruct cftype *cft, *cft_end = NULL;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\nrestart:\n\tfor (cft = cfts; cft != cft_end && cft->name[0] != '\\0'; cft++) {\n\t\t/* does cft->flags tell us to skip this file on @cgrp? */\n\t\tif ((cft->flags & CFTYPE_PRESSURE) && !cgroup_psi_enabled())\n\t\t\tcontinue;\n\t\tif ((cft->flags & __CFTYPE_ONLY_ON_DFL) && !cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & __CFTYPE_NOT_ON_DFL) && cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_NOT_ON_ROOT) && !cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_ONLY_ON_ROOT) && cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_DEBUG) && !cgroup_debug)\n\t\t\tcontinue;\n\t\tif (is_add) {\n\t\t\tret = cgroup_add_file(css, cgrp, cft);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"%s: failed to add %s, err=%d\\n\",\n\t\t\t\t\t__func__, cft->name, ret);\n\t\t\t\tcft_end = cft;\n\t\t\t\tis_add = false;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t} else {\n\t\t\tcgroup_rm_file(cgrp, cft);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int cgroup_apply_cftypes(struct cftype *cfts, bool is_add)\n{\n\tstruct cgroup_subsys *ss = cfts[0].ss;\n\tstruct cgroup *root = &ss->root->cgrp;\n\tstruct cgroup_subsys_state *css;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* add/rm files for all cgroups created before */\n\tcss_for_each_descendant_pre(css, cgroup_css(root, ss)) {\n\t\tstruct cgroup *cgrp = css->cgroup;\n\n\t\tif (!(css->flags & CSS_VISIBLE))\n\t\t\tcontinue;\n\n\t\tret = cgroup_addrm_files(css, cgrp, cfts, is_add);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (is_add && !ret)\n\t\tkernfs_activate(root->kn);\n\treturn ret;\n}\n\nstatic void cgroup_exit_cftypes(struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\t/* free copy for custom atomic_write_len, see init_cftypes() */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE)\n\t\t\tkfree(cft->kf_ops);\n\t\tcft->kf_ops = NULL;\n\t\tcft->ss = NULL;\n\n\t\t/* revert flags set by cgroup core while adding @cfts */\n\t\tcft->flags &= ~(__CFTYPE_ONLY_ON_DFL | __CFTYPE_NOT_ON_DFL);\n\t}\n}\n\nstatic int cgroup_init_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\tstruct kernfs_ops *kf_ops;\n\n\t\tWARN_ON(cft->ss || cft->kf_ops);\n\n\t\tif ((cft->flags & CFTYPE_PRESSURE) && !cgroup_psi_enabled())\n\t\t\tcontinue;\n\n\t\tif (cft->seq_start)\n\t\t\tkf_ops = &cgroup_kf_ops;\n\t\telse\n\t\t\tkf_ops = &cgroup_kf_single_ops;\n\n\t\t/*\n\t\t * Ugh... if @cft wants a custom max_write_len, we need to\n\t\t * make a copy of kf_ops to set its atomic_write_len.\n\t\t */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE) {\n\t\t\tkf_ops = kmemdup(kf_ops, sizeof(*kf_ops), GFP_KERNEL);\n\t\t\tif (!kf_ops) {\n\t\t\t\tcgroup_exit_cftypes(cfts);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tkf_ops->atomic_write_len = cft->max_write_len;\n\t\t}\n\n\t\tcft->kf_ops = kf_ops;\n\t\tcft->ss = ss;\n\t}\n\n\treturn 0;\n}\n\nstatic int cgroup_rm_cftypes_locked(struct cftype *cfts)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!cfts || !cfts[0].ss)\n\t\treturn -ENOENT;\n\n\tlist_del(&cfts->node);\n\tcgroup_apply_cftypes(cfts, false);\n\tcgroup_exit_cftypes(cfts);\n\treturn 0;\n}\n\n/**\n * cgroup_rm_cftypes - remove an array of cftypes from a subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Unregister @cfts.  Files described by @cfts are removed from all\n * existing cgroups and all future cgroups won't have them either.  This\n * function can be called anytime whether @cfts' subsys is attached or not.\n *\n * Returns 0 on successful unregistration, -ENOENT if @cfts is not\n * registered.\n */\nint cgroup_rm_cftypes(struct cftype *cfts)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = cgroup_rm_cftypes_locked(cfts);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_cftypes - add an array of cftypes to a subsystem\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Register @cfts to @ss.  Files described by @cfts are created for all\n * existing cgroups to which @ss is attached and all future cgroups will\n * have them too.  This function can be called anytime whether @ss is\n * attached or not.\n *\n * Returns 0 on successful registration, -errno on failure.  Note that this\n * function currently returns 0 as long as @cfts registration is successful\n * even if some file creation attempts on existing cgroups fail.\n */\nstatic int cgroup_add_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tint ret;\n\n\tif (!cgroup_ssid_enabled(ss->id))\n\t\treturn 0;\n\n\tif (!cfts || cfts[0].name[0] == '\\0')\n\t\treturn 0;\n\n\tret = cgroup_init_cftypes(ss, cfts);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tlist_add_tail(&cfts->node, &ss->cfts);\n\tret = cgroup_apply_cftypes(cfts, true);\n\tif (ret)\n\t\tcgroup_rm_cftypes_locked(cfts);\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_dfl_cftypes - add an array of cftypes for default hierarchy\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the default hierarchy.\n */\nint cgroup_add_dfl_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_ONLY_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_add_legacy_cftypes - add an array of cftypes for legacy hierarchies\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the legacy hierarchies.\n */\nint cgroup_add_legacy_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_NOT_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_file_notify - generate a file modified event for a cgroup_file\n * @cfile: target cgroup_file\n *\n * @cfile must have been obtained by setting cftype->file_offset.\n */\nvoid cgroup_file_notify(struct cgroup_file *cfile)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_file_kn_lock, flags);\n\tif (cfile->kn) {\n\t\tunsigned long last = cfile->notified_at;\n\t\tunsigned long next = last + CGROUP_FILE_NOTIFY_MIN_INTV;\n\n\t\tif (time_in_range(jiffies, last, next)) {\n\t\t\ttimer_reduce(&cfile->notify_timer, next);\n\t\t} else {\n\t\t\tkernfs_notify(cfile->kn);\n\t\t\tcfile->notified_at = jiffies;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cgroup_file_kn_lock, flags);\n}\n\n/**\n * css_next_child - find the next child of a given css\n * @pos: the current position (%NULL to initiate traversal)\n * @parent: css whose children to walk\n *\n * This function returns the next child of @parent and should be called\n * under either cgroup_mutex or RCU read lock.  The only requirement is\n * that @parent and @pos are accessible.  The next sibling is guaranteed to\n * be returned regardless of their states.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *css_next_child(struct cgroup_subsys_state *pos,\n\t\t\t\t\t   struct cgroup_subsys_state *parent)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/*\n\t * @pos could already have been unlinked from the sibling list.\n\t * Once a cgroup is removed, its ->sibling.next is no longer\n\t * updated when its next sibling changes.  CSS_RELEASED is set when\n\t * @pos is taken off list, at which time its next pointer is valid,\n\t * and, as releases are serialized, the one pointed to by the next\n\t * pointer is guaranteed to not have started release yet.  This\n\t * implies that if we observe !CSS_RELEASED on @pos in this RCU\n\t * critical section, the one pointed to by its next pointer is\n\t * guaranteed to not have finished its RCU grace period even if we\n\t * have dropped rcu_read_lock() in-between iterations.\n\t *\n\t * If @pos has CSS_RELEASED set, its next pointer can't be\n\t * dereferenced; however, as each css is given a monotonically\n\t * increasing unique serial number and always appended to the\n\t * sibling list, the next one can be found by walking the parent's\n\t * children until the first css with higher serial number than\n\t * @pos's.  While this path can be slower, it happens iff iteration\n\t * races against release and the race window is very small.\n\t */\n\tif (!pos) {\n\t\tnext = list_entry_rcu(parent->children.next, struct cgroup_subsys_state, sibling);\n\t} else if (likely(!(pos->flags & CSS_RELEASED))) {\n\t\tnext = list_entry_rcu(pos->sibling.next, struct cgroup_subsys_state, sibling);\n\t} else {\n\t\tlist_for_each_entry_rcu(next, &parent->children, sibling,\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex))\n\t\t\tif (next->serial_nr > pos->serial_nr)\n\t\t\t\tbreak;\n\t}\n\n\t/*\n\t * @next, if not pointing to the head, can be dereferenced and is\n\t * the next sibling.\n\t */\n\tif (&next->sibling != &parent->children)\n\t\treturn next;\n\treturn NULL;\n}\n\n/**\n * css_next_descendant_pre - find the next descendant for pre-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_pre().  Find the next descendant\n * to visit for pre-order traversal of @root's descendants.  @root is\n * included in the iteration and the first node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @root are accessible and @pos is a descendant of @root.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_pre(struct cgroup_subsys_state *pos,\n\t\t\tstruct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit @root */\n\tif (!pos)\n\t\treturn root;\n\n\t/* visit the first child if exists */\n\tnext = css_next_child(NULL, pos);\n\tif (next)\n\t\treturn next;\n\n\t/* no child, visit my or the closest ancestor's next sibling */\n\twhile (pos != root) {\n\t\tnext = css_next_child(pos, pos->parent);\n\t\tif (next)\n\t\t\treturn next;\n\t\tpos = pos->parent;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(css_next_descendant_pre);\n\n/**\n * css_rightmost_descendant - return the rightmost descendant of a css\n * @pos: css of interest\n *\n * Return the rightmost descendant of @pos.  If there's no descendant, @pos\n * is returned.  This can be used during pre-order traversal to skip\n * subtree of @pos.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct rightmost descendant as\n * long as @pos is accessible.\n */\nstruct cgroup_subsys_state *\ncss_rightmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last, *tmp;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\tdo {\n\t\tlast = pos;\n\t\t/* ->prev isn't RCU safe, walk ->next till the end */\n\t\tpos = NULL;\n\t\tcss_for_each_child(tmp, last)\n\t\t\tpos = tmp;\n\t} while (pos);\n\n\treturn last;\n}\n\nstatic struct cgroup_subsys_state *\ncss_leftmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last;\n\n\tdo {\n\t\tlast = pos;\n\t\tpos = css_next_child(NULL, pos);\n\t} while (pos);\n\n\treturn last;\n}\n\n/**\n * css_next_descendant_post - find the next descendant for post-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_post().  Find the next descendant\n * to visit for post-order traversal of @root's descendants.  @root is\n * included in the iteration and the last node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @cgroup are accessible and @pos is a descendant of\n * @cgroup.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_post(struct cgroup_subsys_state *pos,\n\t\t\t struct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit leftmost descendant which may be @root */\n\tif (!pos)\n\t\treturn css_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\tnext = css_next_child(pos, pos->parent);\n\tif (next)\n\t\treturn css_leftmost_descendant(next);\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}\n\n/**\n * css_has_online_children - does a css have online children\n * @css: the target css\n *\n * Returns %true if @css has any online children; otherwise, %false.  This\n * function can be called from any context but the caller is responsible\n * for synchronizing against on/offlining as necessary.\n */\nbool css_has_online_children(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys_state *child;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tcss_for_each_child(child, css) {\n\t\tif (child->flags & CSS_ONLINE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic struct css_set *css_task_iter_next_css_set(struct css_task_iter *it)\n{\n\tstruct list_head *l;\n\tstruct cgrp_cset_link *link;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* find the next threaded cset */\n\tif (it->tcset_pos) {\n\t\tl = it->tcset_pos->next;\n\n\t\tif (l != it->tcset_head) {\n\t\t\tit->tcset_pos = l;\n\t\t\treturn container_of(l, struct css_set,\n\t\t\t\t\t    threaded_csets_node);\n\t\t}\n\n\t\tit->tcset_pos = NULL;\n\t}\n\n\t/* find the next cset */\n\tl = it->cset_pos;\n\tl = l->next;\n\tif (l == it->cset_head) {\n\t\tit->cset_pos = NULL;\n\t\treturn NULL;\n\t}\n\n\tif (it->ss) {\n\t\tcset = container_of(l, struct css_set, e_cset_node[it->ss->id]);\n\t} else {\n\t\tlink = list_entry(l, struct cgrp_cset_link, cset_link);\n\t\tcset = link->cset;\n\t}\n\n\tit->cset_pos = l;\n\n\t/* initialize threaded css_set walking */\n\tif (it->flags & CSS_TASK_ITER_THREADED) {\n\t\tif (it->cur_dcset)\n\t\t\tput_css_set_locked(it->cur_dcset);\n\t\tit->cur_dcset = cset;\n\t\tget_css_set(cset);\n\n\t\tit->tcset_head = &cset->threaded_csets;\n\t\tit->tcset_pos = &cset->threaded_csets;\n\t}\n\n\treturn cset;\n}\n\n/**\n * css_task_iter_advance_css_set - advance a task iterator to the next css_set\n * @it: the iterator to advance\n *\n * Advance @it to the next css_set to walk.\n */\nstatic void css_task_iter_advance_css_set(struct css_task_iter *it)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* Advance to the next non-empty css_set and find first non-empty tasks list*/\n\twhile ((cset = css_task_iter_next_css_set(it))) {\n\t\tif (!list_empty(&cset->tasks)) {\n\t\t\tit->cur_tasks_head = &cset->tasks;\n\t\t\tbreak;\n\t\t} else if (!list_empty(&cset->mg_tasks)) {\n\t\t\tit->cur_tasks_head = &cset->mg_tasks;\n\t\t\tbreak;\n\t\t} else if (!list_empty(&cset->dying_tasks)) {\n\t\t\tit->cur_tasks_head = &cset->dying_tasks;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cset) {\n\t\tit->task_pos = NULL;\n\t\treturn;\n\t}\n\tit->task_pos = it->cur_tasks_head->next;\n\n\t/*\n\t * We don't keep css_sets locked across iteration steps and thus\n\t * need to take steps to ensure that iteration can be resumed after\n\t * the lock is re-acquired.  Iteration is performed at two levels -\n\t * css_sets and tasks in them.\n\t *\n\t * Once created, a css_set never leaves its cgroup lists, so a\n\t * pinned css_set is guaranteed to stay put and we can resume\n\t * iteration afterwards.\n\t *\n\t * Tasks may leave @cset across iteration steps.  This is resolved\n\t * by registering each iterator with the css_set currently being\n\t * walked and making css_set_move_task() advance iterators whose\n\t * next task is leaving.\n\t */\n\tif (it->cur_cset) {\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t}\n\tget_css_set(cset);\n\tit->cur_cset = cset;\n\tlist_add(&it->iters_node, &cset->task_iters);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_FILE_NOTIFY_MIN_INTV\tDIV_ROUND_UP(HZ, 100)",
      "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
    ],
    "globals_used": [
      "bool cgroup_debug",
      "static DEFINE_SPINLOCK(cgroup_file_kn_lock);",
      "static u16 cgrp_dfl_inhibit_ss_mask;",
      "static u16 cgrp_dfl_threaded_ss_mask;",
      "struct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};",
      "static u16 cgroup_feature_disable_mask",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&it->iters_node",
            "&cset->task_iters"
          ],
          "line": 4622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "cset"
          ],
          "line": 4620
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "219-222",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_css_set_locked",
          "args": [
            "it->cur_cset"
          ],
          "line": 4618
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "955-990",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int css_set_count\t= 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&it->iters_node"
          ],
          "line": 4617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cset->dying_tasks"
          ],
          "line": 4590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cset->mg_tasks"
          ],
          "line": 4587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cset->tasks"
          ],
          "line": 4584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_next_css_set",
          "args": [
            "it"
          ],
          "line": 4583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "l",
            "structcgrp_cset_link",
            "cset_link"
          ],
          "line": 4550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "l",
            "structcss_set",
            "e_cset_node[it->ss->id]"
          ],
          "line": 4548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "l",
            "structcss_set",
            "threaded_csets_node"
          ],
          "line": 4532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 4524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_next_css_set",
          "args": [
            "structcss_task_iter *it"
          ],
          "line": 4518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_child",
          "args": [
            "child",
            "css"
          ],
          "line": 4508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_leftmost_descendant",
          "args": [
            "next"
          ],
          "line": 4488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_next_child",
          "args": [
            "pos",
            "pos->parent"
          ],
          "line": 4486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_leftmost_descendant",
          "args": [
            "root"
          ],
          "line": 4479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_assert_mutex_or_rcu_locked",
          "args": [],
          "line": 4475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_next_child",
          "args": [
            "NULL",
            "pos"
          ],
          "line": 4441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_leftmost_descendant",
          "args": [
            "structcgroup_subsys_state *pos"
          ],
          "line": 4435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_child",
          "args": [
            "tmp",
            "last"
          ],
          "line": 4427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_assert_mutex_or_rcu_locked",
          "args": [],
          "line": 4421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_next_child",
          "args": [
            "pos",
            "pos->parent"
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_next_child",
          "args": [
            "NULL",
            "pos"
          ],
          "line": 4387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_assert_mutex_or_rcu_locked",
          "args": [],
          "line": 4380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "next",
            "&parent->children",
            "sibling",
            "lockdep_is_held(&cgroup_mutex)"
          ],
          "line": 4338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "pos->sibling.next",
            "structcgroup_subsys_state",
            "sibling"
          ],
          "line": 4336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(pos->flags & CSS_RELEASED)"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "parent->children.next",
            "structcgroup_subsys_state",
            "sibling"
          ],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_assert_mutex_or_rcu_locked",
          "args": [],
          "line": 4311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&cgroup_file_kn_lock",
            "flags"
          ],
          "line": 4286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_notify",
          "args": [
            "cfile->kn"
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_reduce",
          "args": [
            "&cfile->notify_timer",
            "next"
          ],
          "line": 4280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_in_range",
          "args": [
            "jiffies",
            "last",
            "next"
          ],
          "line": 4279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&cgroup_file_kn_lock",
            "flags"
          ],
          "line": 4274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_cftypes",
          "args": [
            "ss",
            "cfts"
          ],
          "line": 4261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_cftypes",
          "args": [
            "ss",
            "cfts"
          ],
          "line": 4244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rm_cftypes_locked",
          "args": [
            "cfts"
          ],
          "line": 4224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_cftypes",
          "args": [
            "cfts",
            "true"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cfts->node",
            "&ss->cfts"
          ],
          "line": 4221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init_cftypes",
          "args": [
            "ss",
            "cfts"
          ],
          "line": 4215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_ssid_enabled",
          "args": [
            "ss->id"
          ],
          "line": 4209
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_ssid_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "258-264",
          "snippet": "bool cgroup_ssid_enabled(int ssid)\n{\n\tif (!CGROUP_HAS_SUBSYS_CONFIG)\n\t\treturn false;\n\n\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};\n\nbool cgroup_ssid_enabled(int ssid)\n{\n\tif (!CGROUP_HAS_SUBSYS_CONFIG)\n\t\treturn false;\n\n\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rm_cftypes_locked",
          "args": [
            "cfts"
          ],
          "line": 4186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_exit_cftypes",
          "args": [
            "cfts"
          ],
          "line": 4166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_cftypes",
          "args": [
            "cfts",
            "false"
          ],
          "line": 4165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cfts->node"
          ],
          "line": 4164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_exit_cftypes",
          "args": [
            "cfts"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "kf_ops",
            "sizeof(*kf_ops)",
            "GFP_KERNEL"
          ],
          "line": 4142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_psi_enabled",
          "args": [],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cft->ss || cft->kf_ops"
          ],
          "line": 4127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cft->kf_ops"
          ],
          "line": 4111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_activate",
          "args": [
            "root->kn"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_addrm_files",
          "args": [
            "css",
            "cgrp",
            "cfts",
            "is_add"
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "css",
            "cgroup_css(root, ss)"
          ],
          "line": 4088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "root",
            "ss"
          ],
          "line": 4088
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "481-489",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rm_file",
          "args": [
            "cgrp",
            "cft"
          ],
          "line": 4072
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rm_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1646-1664",
          "snippet": "static void cgroup_rm_file(struct cgroup *cgrp, const struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_subsys_state *css = cgroup_css(cgrp, cft->ss);\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = NULL;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\n\t\tdel_timer_sync(&cfile->notify_timer);\n\t}\n\n\tkernfs_remove_by_name(cgrp->kn, cgroup_file_name(cgrp, cft, name));\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_file_kn_lock);",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nstatic DEFINE_SPINLOCK(cgroup_file_kn_lock);\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void cgroup_rm_file(struct cgroup *cgrp, const struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_subsys_state *css = cgroup_css(cgrp, cft->ss);\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = NULL;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\n\t\tdel_timer_sync(&cfile->notify_timer);\n\t}\n\n\tkernfs_remove_by_name(cgrp->kn, cgroup_file_name(cgrp, cft, name));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: failed to add %s, err=%d\\n\"",
            "__func__",
            "cft->name",
            "ret"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_add_file",
          "args": [
            "css",
            "cgrp",
            "cft"
          ],
          "line": 4063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 4058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 4056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 4054
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "313-316",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_psi_enabled",
          "args": [],
          "line": 4050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 4045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cgroup_file_kn_lock"
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cgroup_file_kn_lock"
          ],
          "line": 4020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&cfile->notify_timer",
            "cgroup_file_notify_timer",
            "0"
          ],
          "line": 4018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_remove",
          "args": [
            "kn"
          ],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_kn_set_ugid",
          "args": [
            "kn"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kn"
          ],
          "line": 4007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kn"
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernfs_create_file",
          "args": [
            "cgrp->kn",
            "cgroup_file_name(cgrp, cft, name)",
            "cgroup_file_mode(cft)",
            "GLOBAL_ROOT_UID",
            "GLOBAL_ROOT_GID",
            "0",
            "cft->kf_ops",
            "cft",
            "NULL",
            "key"
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_mode",
          "args": [
            "cft"
          ],
          "line": 4002
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_file_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1512-1527",
          "snippet": "static umode_t cgroup_file_mode(const struct cftype *cft)\n{\n\tumode_t mode = 0;\n\n\tif (cft->read_u64 || cft->read_s64 || cft->seq_show)\n\t\tmode |= S_IRUGO;\n\n\tif (cft->write_u64 || cft->write_s64 || cft->write) {\n\t\tif (cft->flags & CFTYPE_WORLD_WRITABLE)\n\t\t\tmode |= S_IWUGO;\n\t\telse\n\t\t\tmode |= S_IWUSR;\n\t}\n\n\treturn mode;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic umode_t cgroup_file_mode(const struct cftype *cft)\n{\n\tumode_t mode = 0;\n\n\tif (cft->read_u64 || cft->read_s64 || cft->seq_show)\n\t\tmode |= S_IRUGO;\n\n\tif (cft->write_u64 || cft->write_s64 || cft->write) {\n\t\tif (cft->flags & CFTYPE_WORLD_WRITABLE)\n\t\t\tmode |= S_IWUGO;\n\t\telse\n\t\t\tmode |= S_IWUSR;\n\t}\n\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_file_name",
          "args": [
            "cgrp",
            "cft",
            "name"
          ],
          "line": 4001
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_file_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1488-1504",
          "snippet": "static char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX)) {\n\t\tconst char *dbg = (cft->flags & CFTYPE_DEBUG) ? \".__DEBUG__.\" : \"\";\n\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s%s.%s\",\n\t\t\t dbg, cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\t} else {\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX)) {\n\t\tconst char *dbg = (cft->flags & CFTYPE_DEBUG) ? \".__DEBUG__.\" : \"\";\n\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s%s.%s\",\n\t\t\t dbg, cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\t} else {\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_add_file",
          "args": [
            "structcgroup_subsys_state *css",
            "structcgroup *cgrp",
            "structcftype *cft"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_notify_timer",
          "args": [
            "structtimer_list *timer"
          ],
          "line": 3984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_setattr",
          "args": [
            "kn",
            "&iattr"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "iattr.ia_gid",
            "GLOBAL_ROOT_GID"
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "iattr.ia_uid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 3975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%lld\\n\"",
            "cft->read_s64(css, cft)"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->read_s64",
          "args": [
            "css",
            "cft"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%llu\\n\"",
            "cft->read_u64(css, cft)"
          ],
          "line": 3941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->read_u64",
          "args": [
            "css",
            "cft"
          ],
          "line": 3941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->seq_show",
          "args": [
            "m",
            "arg"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 3935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "m"
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_seqfile_show",
          "args": [
            "structseq_file *m",
            "void *arg"
          ],
          "line": 3932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "seq",
            "v"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "seq"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "seq"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_seqfile_stop",
          "args": [
            "structseq_file *seq",
            "void *v"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "seq",
            "v",
            "ppos"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "seq"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_seqfile_next",
          "args": [
            "structseq_file *seq",
            "void *v",
            "loff_t *ppos"
          ],
          "line": 3921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "seq",
            "ppos"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "seq"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_seqfile_start",
          "args": [
            "structseq_file *seq",
            "loff_t *ppos"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_generic_poll",
          "args": [
            "of",
            "pt"
          ],
          "line": 3913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->poll",
          "args": [
            "of",
            "pt"
          ],
          "line": 3911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->write_s64",
          "args": [
            "css",
            "cft",
            "v"
          ],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoll",
          "args": [
            "buf",
            "0",
            "&v"
          ],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->write_u64",
          "args": [
            "css",
            "cft",
            "v"
          ],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "buf",
            "0",
            "&v"
          ],
          "line": 3891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->write",
          "args": [
            "of",
            "buf",
            "nbytes",
            "off"
          ],
          "line": 3877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_write",
          "args": [
            "structkernfs_open_file *of",
            "char *buf",
            "size_tnbytes",
            "loff_toff"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx"
          ],
          "line": 3850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "ctx->ns"
          ],
          "line": 3849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->release",
          "args": [
            "of"
          ],
          "line": 3848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 3844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx"
          ],
          "line": 3837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "ctx->ns"
          ],
          "line": 3836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cft->open",
          "args": [
            "of"
          ],
          "line": 3834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cgroup_ns",
          "args": [
            "ctx->ns"
          ],
          "line": 3828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ctx)",
            "GFP_KERNEL"
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 3819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_kn_unlock",
          "args": [
            "of->kn"
          ],
          "line": 3812
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1583-1596",
          "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_kill",
          "args": [
            "cgrp"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kill_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2202-2220",
          "snippet": "static void cgroup_kill_sb(struct super_block *sb)\n{\n\tstruct kernfs_root *kf_root = kernfs_root_from_sb(sb);\n\tstruct cgroup_root *root = cgroup_root_from_kf(kf_root);\n\n\t/*\n\t * If @root doesn't have any children, start killing it.\n\t * This prevents new mounts by disabling percpu_ref_tryget_live().\n\t *\n\t * And don't kill the default root.\n\t */\n\tif (list_empty(&root->cgrp.self.children) && root != &cgrp_dfl_root &&\n\t    !percpu_ref_is_dying(&root->cgrp.self.refcnt)) {\n\t\tcgroup_bpf_offline(&root->cgrp);\n\t\tpercpu_ref_kill(&root->cgrp.self.refcnt);\n\t}\n\tcgroup_put(&root->cgrp);\n\tkernfs_kill_sb(sb);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_kill_sb(struct super_block *sb)\n{\n\tstruct kernfs_root *kf_root = kernfs_root_from_sb(sb);\n\tstruct cgroup_root *root = cgroup_root_from_kf(kf_root);\n\n\t/*\n\t * If @root doesn't have any children, start killing it.\n\t * This prevents new mounts by disabling percpu_ref_tryget_live().\n\t *\n\t * And don't kill the default root.\n\t */\n\tif (list_empty(&root->cgrp.self.children) && root != &cgrp_dfl_root &&\n\t    !percpu_ref_is_dying(&root->cgrp.self.refcnt)) {\n\t\tcgroup_bpf_offline(&root->cgrp);\n\t\tpercpu_ref_kill(&root->cgrp.self.refcnt);\n\t}\n\tcgroup_put(&root->cgrp);\n\tkernfs_kill_sb(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 3807
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "354-357",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_kn_lock_live",
          "args": [
            "of->kn",
            "false"
          ],
          "line": 3798
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_lock_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1615-1644",
          "snippet": "struct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "strstrip(buf)",
            "0",
            "&kill"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_kill_write",
          "args": [
            "structkernfs_open_file *of",
            "char *buf",
            "size_tnbytes",
            "loff_toff"
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cgroup_kill",
          "args": [
            "dsct"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_pre",
          "args": [
            "dsct",
            "css",
            "cgrp"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 3770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CGRP_KILL",
            "&cgrp->flags"
          ],
          "line": 3769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 3768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "&it"
          ],
          "line": 3766
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4761-4775",
          "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGKILL",
            "task",
            "0"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fatal_signal_pending",
          "args": [
            "task"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "&it"
          ],
          "line": 3755
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4730-4753",
          "snippet": "struct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&cgrp->self",
            "CSS_TASK_ITER_PROCS | CSS_TASK_ITER_THREADED",
            "&it"
          ],
          "line": 3754
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4700-4720",
          "snippet": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_KILL",
            "&cgrp->flags"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 3750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 3748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_freeze",
          "args": [
            "cgrp",
            "freeze"
          ],
          "line": 3736
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_freeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "260-323",
          "snippet": "void cgroup_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *dsct;\n\tbool applied = false;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Nothing changed? Just exit.\n\t */\n\tif (cgrp->freezer.freeze == freeze)\n\t\treturn;\n\n\tcgrp->freezer.freeze = freeze;\n\n\t/*\n\t * Propagate changes downwards the cgroup tree.\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tdsct = css->cgroup;\n\n\t\tif (cgroup_is_dead(dsct))\n\t\t\tcontinue;\n\n\t\tif (freeze) {\n\t\t\tdsct->freezer.e_freeze++;\n\t\t\t/*\n\t\t\t * Already frozen because of ancestor's settings?\n\t\t\t */\n\t\t\tif (dsct->freezer.e_freeze > 1)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tdsct->freezer.e_freeze--;\n\t\t\t/*\n\t\t\t * Still frozen because of ancestor's settings?\n\t\t\t */\n\t\t\tif (dsct->freezer.e_freeze > 0)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(dsct->freezer.e_freeze < 0);\n\t\t}\n\n\t\t/*\n\t\t * Do change actual state: freeze or unfreeze.\n\t\t */\n\t\tcgroup_do_freeze(dsct, freeze);\n\t\tapplied = true;\n\t}\n\n\t/*\n\t * Even if the actual state hasn't changed, let's notify a user.\n\t * The state can be enforced by an ancestor cgroup: the cgroup\n\t * can already be in the desired state or it can be locked in the\n\t * opposite state, so that the transition will never happen.\n\t * In both cases it's better to notify a user, that there is\n\t * nothing to wait for.\n\t */\n\tif (!applied) {\n\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp,\n\t\t\t\t  test_bit(CGRP_FROZEN, &cgrp->flags));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\t}\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *dsct;\n\tbool applied = false;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/*\n\t * Nothing changed? Just exit.\n\t */\n\tif (cgrp->freezer.freeze == freeze)\n\t\treturn;\n\n\tcgrp->freezer.freeze = freeze;\n\n\t/*\n\t * Propagate changes downwards the cgroup tree.\n\t */\n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tdsct = css->cgroup;\n\n\t\tif (cgroup_is_dead(dsct))\n\t\t\tcontinue;\n\n\t\tif (freeze) {\n\t\t\tdsct->freezer.e_freeze++;\n\t\t\t/*\n\t\t\t * Already frozen because of ancestor's settings?\n\t\t\t */\n\t\t\tif (dsct->freezer.e_freeze > 1)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tdsct->freezer.e_freeze--;\n\t\t\t/*\n\t\t\t * Still frozen because of ancestor's settings?\n\t\t\t */\n\t\t\tif (dsct->freezer.e_freeze > 0)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(dsct->freezer.e_freeze < 0);\n\t\t}\n\n\t\t/*\n\t\t * Do change actual state: freeze or unfreeze.\n\t\t */\n\t\tcgroup_do_freeze(dsct, freeze);\n\t\tapplied = true;\n\t}\n\n\t/*\n\t * Even if the actual state hasn't changed, let's notify a user.\n\t * The state can be enforced by an ancestor cgroup: the cgroup\n\t * can already be in the desired state or it can be locked in the\n\t * opposite state, so that the transition will never happen.\n\t * In both cases it's better to notify a user, that there is\n\t * nothing to wait for.\n\t */\n\tif (!applied) {\n\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp,\n\t\t\t\t  test_bit(CGRP_FROZEN, &cgrp->flags));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "strstrip(buf)",
            "0",
            "&freeze"
          ],
          "line": 3725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 3725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_freeze_write",
          "args": [
            "structkernfs_open_file *of",
            "char *buf",
            "size_tnbytes",
            "loff_toff"
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%d\\n\"",
            "cgrp->freezer.freeze"
          ],
          "line": 3713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_freeze_show",
          "args": [
            "structseq_file *seq",
            "void *v"
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_psi_enabled",
          "args": [
            "void"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_psi_enabled",
          "args": [
            "void"
          ],
          "line": 3696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_trigger_replace",
          "args": [
            "&ctx->psi.trigger",
            "NULL"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_pressure_release",
          "args": [
            "structkernfs_open_file *of"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_trigger_poll",
          "args": [
            "&ctx->psi.trigger",
            "of->file",
            "pt"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_pressure_poll",
          "args": [
            "structkernfs_open_file *of",
            "poll_table *pt"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_pressure_write",
          "args": [
            "of",
            "buf",
            "nbytes",
            "PSI_CPU"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_cpu_pressure_write",
          "args": [
            "structkernfs_open_file *of",
            "char *buf",
            "size_tnbytes",
            "loff_toff"
          ],
          "line": 3674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_pressure_write",
          "args": [
            "of",
            "buf",
            "nbytes",
            "PSI_MEM"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_memory_pressure_write",
          "args": [
            "structkernfs_open_file *of",
            "char *buf",
            "size_tnbytes",
            "loff_toff"
          ],
          "line": 3667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_pressure_write",
          "args": [
            "of",
            "buf",
            "nbytes",
            "PSI_IO"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 3655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_trigger_replace",
          "args": [
            "&ctx->psi.trigger",
            "new"
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 3650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_trigger_create",
          "args": [
            "psi",
            "buf",
            "nbytes",
            "res"
          ],
          "line": 3647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_ino",
          "args": [
            "cgrp"
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get",
          "args": [
            "cgrp"
          ],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "6577-6589",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_pressure_write",
          "args": [
            "structkernfs_open_file *of",
            "char *buf",
            "size_tnbytes",
            "enumpsi_res res"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_show",
          "args": [
            "seq",
            "psi",
            "PSI_CPU"
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_ino",
          "args": [
            "cgrp"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_cpu_pressure_show",
          "args": [
            "structseq_file *seq",
            "void *v"
          ],
          "line": 3623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_show",
          "args": [
            "seq",
            "psi",
            "PSI_MEM"
          ],
          "line": 3621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_ino",
          "args": [
            "cgrp"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_memory_pressure_show",
          "args": [
            "structseq_file *seq",
            "void *v"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_show",
          "args": [
            "seq",
            "psi",
            "PSI_IO"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_ino",
          "args": [
            "cgrp"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_io_pressure_show",
          "args": [
            "structseq_file *seq",
            "void *v"
          ],
          "line": 3609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_extra_stat_show",
          "args": [
            "seq",
            "cgrp",
            "cpu_cgrp_id"
          ],
          "line": 3603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_base_stat_cputime_show",
          "args": [
            "seq"
          ],
          "line": 3601
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_base_stat_cputime_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "436-463",
          "snippet": "void cgroup_base_stat_cputime_show(struct seq_file *seq)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tu64 usage, utime, stime;\n\tstruct task_cputime cputime;\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcgroup_rstat_flush_hold(cgrp);\n\t\tusage = cgrp->bstat.cputime.sum_exec_runtime;\n\t\tcputime_adjust(&cgrp->bstat.cputime, &cgrp->prev_cputime,\n\t\t\t       &utime, &stime);\n\t\tcgroup_rstat_flush_release();\n\t} else {\n\t\troot_cgroup_cputime(&cputime);\n\t\tusage = cputime.sum_exec_runtime;\n\t\tutime = cputime.utime;\n\t\tstime = cputime.stime;\n\t}\n\n\tdo_div(usage, NSEC_PER_USEC);\n\tdo_div(utime, NSEC_PER_USEC);\n\tdo_div(stime, NSEC_PER_USEC);\n\n\tseq_printf(seq, \"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\",\n\t\t   usage, utime, stime);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_base_stat_cputime_show(struct seq_file *seq)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tu64 usage, utime, stime;\n\tstruct task_cputime cputime;\n\n\tif (cgroup_parent(cgrp)) {\n\t\tcgroup_rstat_flush_hold(cgrp);\n\t\tusage = cgrp->bstat.cputime.sum_exec_runtime;\n\t\tcputime_adjust(&cgrp->bstat.cputime, &cgrp->prev_cputime,\n\t\t\t       &utime, &stime);\n\t\tcgroup_rstat_flush_release();\n\t} else {\n\t\troot_cgroup_cputime(&cputime);\n\t\tusage = cputime.sum_exec_runtime;\n\t\tutime = cputime.utime;\n\t\tstime = cputime.stime;\n\t}\n\n\tdo_div(usage, NSEC_PER_USEC);\n\tdo_div(utime, NSEC_PER_USEC);\n\tdo_div(stime, NSEC_PER_USEC);\n\n\tseq_printf(seq, \"usage_usec %llu\\n\"\n\t\t   \"user_usec %llu\\n\"\n\t\t   \"system_usec %llu\\n\",\n\t\t   usage, utime, stime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "css"
          ],
          "line": 3592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_extra_stat_show",
          "args": [
            "seq",
            "css"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_tryget_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 3587
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_tryget_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "499-511",
          "snippet": "static struct cgroup_subsys_state *cgroup_tryget_css(struct cgroup *cgrp,\n\t\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, ss);\n\tif (css && !css_tryget_online(css))\n\t\tcss = NULL;\n\trcu_read_unlock();\n\n\treturn css;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup_subsys_state *cgroup_tryget_css(struct cgroup *cgrp,\n\t\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, ss);\n\tif (css && !css_tryget_online(css))\n\t\tcss = NULL;\n\trcu_read_unlock();\n\n\treturn css;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_extra_stat_show",
          "args": [
            "structseq_file *seq",
            "structcgroup *cgrp",
            "intssid"
          ],
          "line": 3577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"nr_dying_descendants %d\\n\"",
            "cgroup->nr_dying_descendants"
          ],
          "line": 3571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"nr_descendants %d\\n\"",
            "cgroup->nr_descendants"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_stat_show",
          "args": [
            "structseq_file *seq",
            "void *v"
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"frozen %d\\n\"",
            "test_bit(CGRP_FROZEN, &cgrp->flags)"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_FROZEN",
            "&cgrp->flags"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"populated %d\\n\"",
            "cgroup_is_populated(cgrp)"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "cgrp"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "0",
            "&depth"
          ],
          "line": 3536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"max\""
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 3532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_max_depth_write",
          "args": [
            "structkernfs_open_file *of",
            "char *buf",
            "size_tnbytes",
            "loff_toff"
          ],
          "line": 3525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%d\\n\"",
            "depth"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"max\\n\""
          ],
          "line": 3518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cgrp->max_depth"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "0",
            "&descendants"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"max\""
          ],
          "line": 3490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_max_descendants_write",
          "args": [
            "structkernfs_open_file *of",
            "char *buf",
            "size_tnbytes",
            "loff_toff"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%d\\n\"",
            "descendants"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"max\\n\""
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cgrp->max_descendants"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_enable_threaded",
          "args": [
            "cgrp"
          ],
          "line": 3463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strstrip(buf)",
            "\"threaded\""
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"domain\\n\""
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"domain threaded\\n\""
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_thread_root",
          "args": [
            "cgrp"
          ],
          "line": 3439
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_thread_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "393-412",
          "snippet": "bool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"domain invalid\\n\""
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_valid_domain",
          "args": [
            "cgrp"
          ],
          "line": 3437
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_valid_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "415-430",
          "snippet": "static bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"threaded\\n\""
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_finalize_control",
          "args": [
            "cgrp",
            "ret"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control",
          "args": [
            "cgrp"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_pre",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_save_control",
          "args": [
            "cgrp"
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_can_be_thread_root",
          "args": [
            "dom_cgrp"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_can_be_thread_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "371-390",
          "snippet": "static bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "cgrp"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_activate",
          "args": [
            "cgrp->kn"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_finalize_control",
          "args": [
            "cgrp",
            "ret"
          ],
          "line": 3365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control",
          "args": [
            "cgrp"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_save_control",
          "args": [
            "cgrp"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_vet_subtree_control_enable",
          "args": [
            "cgrp",
            "enable"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_child",
          "args": [
            "child",
            "cgrp"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_control",
          "args": [
            "cgrp"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "433-451",
          "snippet": "static u16 cgroup_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tu16 root_ss_mask = cgrp->root->subsys_mask;\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_control;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\tif (cgroup_on_dfl(cgrp))\n\t\troot_ss_mask &= ~(cgrp_dfl_inhibit_ss_mask |\n\t\t\t\t  cgrp_dfl_implicit_ss_mask);\n\treturn root_ss_mask;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_inhibit_ss_mask;",
            "static u16 cgrp_dfl_implicit_ss_mask;",
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_inhibit_ss_mask;\nstatic u16 cgrp_dfl_implicit_ss_mask;\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic u16 cgroup_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tu16 root_ss_mask = cgrp->root->subsys_mask;\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_control;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\tif (cgroup_on_dfl(cgrp))\n\t\troot_ss_mask &= ~(cgrp_dfl_inhibit_ss_mask |\n\t\t\t\t  cgrp_dfl_implicit_ss_mask);\n\treturn root_ss_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tok + 1",
            "ss->name"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "~cgrp_dfl_inhibit_ss_mask"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&buf",
            "\" \""
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_has_tasks",
          "args": [
            "cgrp"
          ],
          "line": 3273
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_has_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "349-352",
          "snippet": "static bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_mixable",
          "args": [
            "cgrp"
          ],
          "line": 3252
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_mixable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "360-368",
          "snippet": "static bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_vet_subtree_control_enable",
          "args": [
            "structcgroup *cgrp",
            "u16enable"
          ],
          "line": 3239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control_disable",
          "args": [
            "cgrp"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_propagate_control",
          "args": [
            "cgrp"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_restore_control",
          "args": [
            "cgrp"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_update_dfl_csses",
          "args": [
            "cgrp"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control_enable",
          "args": [
            "cgrp"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_propagate_control",
          "args": [
            "cgrp"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->css_reset",
          "args": [
            "css"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_clear_dir",
          "args": [
            "css"
          ],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "css_clear_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1670-1691",
          "snippet": "static void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);",
            "static struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};\n\nstatic void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_visible",
          "args": [
            "css"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_css",
          "args": [
            "css"
          ],
          "line": 3173
        },
        "resolved": true,
        "details": {
          "function_name": "kill_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5579-5611",
          "snippet": "static void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_release(struct percpu_ref *ref);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_release(struct percpu_ref *ref);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void kill_css(struct cgroup_subsys_state *css)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (css->flags & CSS_DYING)\n\t\treturn;\n\n\tcss->flags |= CSS_DYING;\n\n\t/*\n\t * This must happen before css is disassociated with its cgroup.\n\t * See seq_css() for details.\n\t */\n\tcss_clear_dir(css);\n\n\t/*\n\t * Killing would put the base ref, but we need to keep it alive\n\t * until after ->css_offline().\n\t */\n\tcss_get(css);\n\n\t/*\n\t * cgroup core guarantees that, by the time ->css_offline() is\n\t * invoked, no new css reference will be given out via\n\t * css_tryget_online().  We can't simply call percpu_ref_kill() and\n\t * proceed to offlining css's because percpu_ref_kill() doesn't\n\t * guarantee that the ref is seen as killed on all CPUs on return.\n\t *\n\t * Use percpu_ref_kill_and_confirm() to get notifications as each\n\t * css is confirmed to be seen as killed on all CPUs.\n\t */\n\tpercpu_ref_kill_and_confirm(&css->refcnt, css_killed_ref_fn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_ss_mask",
          "args": [
            "dsct"
          ],
          "line": 3172
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_ss_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "454-468",
          "snippet": "static u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "percpu_ref_is_dying(&css->refcnt)"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_is_dying",
          "args": [
            "&css->refcnt"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_post",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 3162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_populate_dir",
          "args": [
            "css"
          ],
          "line": 3132
        },
        "resolved": true,
        "details": {
          "function_name": "css_populate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1699-1737",
          "snippet": "static int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);",
            "static struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};\n\nstatic int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_visible",
          "args": [
            "css"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "percpu_ref_is_dying(&css->refcnt)"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_is_dying",
          "args": [
            "&css->refcnt"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "css"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "css"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_create",
          "args": [
            "dsct",
            "ss"
          ],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "css_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "5289-5333",
          "snippet": "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *parent_css = cgroup_css(parent, ss);\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcss = ss->css_alloc(parent_css);\n\tif (!css)\n\t\tcss = ERR_PTR(-ENOMEM);\n\tif (IS_ERR(css))\n\t\treturn css;\n\n\tinit_and_link_css(css, ss, cgrp);\n\n\terr = percpu_ref_init(&css->refcnt, css_release, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_free_css;\n\n\terr = cgroup_idr_alloc(&ss->css_idr, NULL, 2, 0, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_free_css;\n\tcss->id = err;\n\n\t/* @css is ready to be brought online now, make it visible */\n\tlist_add_tail_rcu(&css->sibling, &parent_css->children);\n\tcgroup_idr_replace(&ss->css_idr, css, css->id);\n\n\terr = online_css(css);\n\tif (err)\n\t\tgoto err_list_del;\n\n\treturn css;\n\nerr_list_del:\n\tlist_del_rcu(&css->sibling);\nerr_free_css:\n\tlist_del_rcu(&css->rstat_css_node);\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *cgroup_destroy_wq;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct workqueue_struct *cgroup_destroy_wq;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup_subsys_state *parent_css = cgroup_css(parent, ss);\n\tstruct cgroup_subsys_state *css;\n\tint err;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcss = ss->css_alloc(parent_css);\n\tif (!css)\n\t\tcss = ERR_PTR(-ENOMEM);\n\tif (IS_ERR(css))\n\t\treturn css;\n\n\tinit_and_link_css(css, ss, cgrp);\n\n\terr = percpu_ref_init(&css->refcnt, css_release, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_free_css;\n\n\terr = cgroup_idr_alloc(&ss->css_idr, NULL, 2, 0, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_free_css;\n\tcss->id = err;\n\n\t/* @css is ready to be brought online now, make it visible */\n\tlist_add_tail_rcu(&css->sibling, &parent_css->children);\n\tcgroup_idr_replace(&ss->css_idr, css, css->id);\n\n\terr = online_css(css);\n\tif (err)\n\t\tgoto err_list_del;\n\n\treturn css;\n\nerr_list_del:\n\tlist_del_rcu(&css->sibling);\nerr_free_css:\n\tlist_del_rcu(&css->rstat_css_node);\n\tINIT_RCU_WORK(&css->destroy_rwork, css_free_rwork_fn);\n\tqueue_rcu_work(cgroup_destroy_wq, &css->destroy_rwork);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_pre",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_visible",
          "args": [
            "structcgroup_subsys_state *css"
          ],
          "line": 3084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_post",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_calc_subtree_ss_mask",
          "args": [
            "dsct->subtree_control",
            "cgroup_ss_mask(dsct)"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_calc_subtree_ss_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1541-1571",
          "snippet": "static u16 cgroup_calc_subtree_ss_mask(u16 subtree_control, u16 this_ss_mask)\n{\n\tu16 cur_ss_mask = subtree_control;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcur_ss_mask |= cgrp_dfl_implicit_ss_mask;\n\n\twhile (true) {\n\t\tu16 new_ss_mask = cur_ss_mask;\n\n\t\tdo_each_subsys_mask(ss, ssid, cur_ss_mask) {\n\t\t\tnew_ss_mask |= ss->depends_on;\n\t\t} while_each_subsys_mask();\n\n\t\t/*\n\t\t * Mask out subsystems which aren't available.  This can\n\t\t * happen only if some depended-upon subsystems were bound\n\t\t * to non-default hierarchies.\n\t\t */\n\t\tnew_ss_mask &= this_ss_mask;\n\n\t\tif (new_ss_mask == cur_ss_mask)\n\t\t\tbreak;\n\t\tcur_ss_mask = new_ss_mask;\n\t}\n\n\treturn cur_ss_mask;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_implicit_ss_mask;",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_implicit_ss_mask;\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic u16 cgroup_calc_subtree_ss_mask(u16 subtree_control, u16 this_ss_mask)\n{\n\tu16 cur_ss_mask = subtree_control;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcur_ss_mask |= cgrp_dfl_implicit_ss_mask;\n\n\twhile (true) {\n\t\tu16 new_ss_mask = cur_ss_mask;\n\n\t\tdo_each_subsys_mask(ss, ssid, cur_ss_mask) {\n\t\t\tnew_ss_mask |= ss->depends_on;\n\t\t} while_each_subsys_mask();\n\n\t\t/*\n\t\t * Mask out subsystems which aren't available.  This can\n\t\t * happen only if some depended-upon subsystems were bound\n\t\t * to non-default hierarchies.\n\t\t */\n\t\tnew_ss_mask &= this_ss_mask;\n\n\t\tif (new_ss_mask == cur_ss_mask)\n\t\t\tbreak;\n\t\tcur_ss_mask = new_ss_mask;\n\t}\n\n\treturn cur_ss_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_pre",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_pre",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "dsct"
          ],
          "line": 3017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&dsct->offline_waitq",
            "&wait"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&dsct->offline_waitq",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_get_live",
          "args": [
            "dsct"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "613-617",
          "snippet": "static void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_is_dying",
          "args": [
            "&css->refcnt"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_post",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_finish",
          "args": [
            "&mgctx"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2598-2619",
          "snippet": "void cgroup_migrate_finish(struct cgroup_mgctx *mgctx)\n{\n\tLIST_HEAD(preloaded);\n\tstruct css_set *cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_splice_tail_init(&mgctx->preloaded_src_csets, &preloaded);\n\tlist_splice_tail_init(&mgctx->preloaded_dst_csets, &preloaded);\n\n\tlist_for_each_entry_safe(cset, tmp_cset, &preloaded, mg_preload_node) {\n\t\tcset->mg_src_cgrp = NULL;\n\t\tcset->mg_dst_cgrp = NULL;\n\t\tcset->mg_dst_cset = NULL;\n\t\tlist_del_init(&cset->mg_preload_node);\n\t\tput_css_set_locked(cset);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_migrate_finish(struct cgroup_mgctx *mgctx)\n{\n\tLIST_HEAD(preloaded);\n\tstruct css_set *cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_splice_tail_init(&mgctx->preloaded_src_csets, &preloaded);\n\tlist_splice_tail_init(&mgctx->preloaded_dst_csets, &preloaded);\n\n\tlist_for_each_entry_safe(cset, tmp_cset, &preloaded, mg_preload_node) {\n\t\tcset->mg_src_cgrp = NULL;\n\t\tcset->mg_dst_cgrp = NULL;\n\t\tcset->mg_dst_cset = NULL;\n\t\tlist_del_init(&cset->mg_preload_node);\n\t\tput_css_set_locked(cset);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_execute",
          "args": [
            "&mgctx"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2456-2552",
          "snippet": "static int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t\t/*\n\t\t\t * If the source or destination cgroup is frozen,\n\t\t\t * the task might require to change its state.\n\t\t\t */\n\t\t\tcgroup_freezer_migrate_task(task, from_cset->dfl_cgrp,\n\t\t\t\t\t\t    to_cset->dfl_cgrp);\n\t\t\tput_css_set_locked(from_cset);\n\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t\t/*\n\t\t\t * If the source or destination cgroup is frozen,\n\t\t\t * the task might require to change its state.\n\t\t\t */\n\t\t\tcgroup_freezer_migrate_task(task, from_cset->dfl_cgrp,\n\t\t\t\t\t\t    to_cset->dfl_cgrp);\n\t\t\tput_css_set_locked(from_cset);\n\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_add_task",
          "args": [
            "task",
            "&mgctx"
          ],
          "line": 2971
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_add_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2356-2383",
          "snippet": "static void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* cgroup_threadgroup_rwsem protects racing against forks */\n\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* cgroup_threadgroup_rwsem protects racing against forks */\n\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "task",
            "ntask",
            "&src_cset->tasks",
            "cg_list"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "src_cset",
            "&mgctx.preloaded_src_csets",
            "mg_preload_node"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_prepare_dst",
          "args": [
            "&mgctx"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_prepare_dst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2684-2731",
          "snippet": "int cgroup_migrate_prepare_dst(struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *src_cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* look up the dst cset for each src cset and link it to src */\n\tlist_for_each_entry_safe(src_cset, tmp_cset, &mgctx->preloaded_src_csets,\n\t\t\t\t mg_preload_node) {\n\t\tstruct css_set *dst_cset;\n\t\tstruct cgroup_subsys *ss;\n\t\tint ssid;\n\n\t\tdst_cset = find_css_set(src_cset, src_cset->mg_dst_cgrp);\n\t\tif (!dst_cset)\n\t\t\treturn -ENOMEM;\n\n\t\tWARN_ON_ONCE(src_cset->mg_dst_cset || dst_cset->mg_dst_cset);\n\n\t\t/*\n\t\t * If src cset equals dst, it's noop.  Drop the src.\n\t\t * cgroup_migrate() will skip the cset too.  Note that we\n\t\t * can't handle src == dst as some nodes are used by both.\n\t\t */\n\t\tif (src_cset == dst_cset) {\n\t\t\tsrc_cset->mg_src_cgrp = NULL;\n\t\t\tsrc_cset->mg_dst_cgrp = NULL;\n\t\t\tlist_del_init(&src_cset->mg_preload_node);\n\t\t\tput_css_set(src_cset);\n\t\t\tput_css_set(dst_cset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc_cset->mg_dst_cset = dst_cset;\n\n\t\tif (list_empty(&dst_cset->mg_preload_node))\n\t\t\tlist_add_tail(&dst_cset->mg_preload_node,\n\t\t\t\t      &mgctx->preloaded_dst_csets);\n\t\telse\n\t\t\tput_css_set(dst_cset);\n\n\t\tfor_each_subsys(ss, ssid)\n\t\t\tif (src_cset->subsys[ssid] != dst_cset->subsys[ssid])\n\t\t\t\tmgctx->ss_mask |= 1 << ssid;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nint cgroup_migrate_prepare_dst(struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *src_cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* look up the dst cset for each src cset and link it to src */\n\tlist_for_each_entry_safe(src_cset, tmp_cset, &mgctx->preloaded_src_csets,\n\t\t\t\t mg_preload_node) {\n\t\tstruct css_set *dst_cset;\n\t\tstruct cgroup_subsys *ss;\n\t\tint ssid;\n\n\t\tdst_cset = find_css_set(src_cset, src_cset->mg_dst_cgrp);\n\t\tif (!dst_cset)\n\t\t\treturn -ENOMEM;\n\n\t\tWARN_ON_ONCE(src_cset->mg_dst_cset || dst_cset->mg_dst_cset);\n\n\t\t/*\n\t\t * If src cset equals dst, it's noop.  Drop the src.\n\t\t * cgroup_migrate() will skip the cset too.  Note that we\n\t\t * can't handle src == dst as some nodes are used by both.\n\t\t */\n\t\tif (src_cset == dst_cset) {\n\t\t\tsrc_cset->mg_src_cgrp = NULL;\n\t\t\tsrc_cset->mg_dst_cgrp = NULL;\n\t\t\tlist_del_init(&src_cset->mg_preload_node);\n\t\t\tput_css_set(src_cset);\n\t\t\tput_css_set(dst_cset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc_cset->mg_dst_cset = dst_cset;\n\n\t\tif (list_empty(&dst_cset->mg_preload_node))\n\t\t\tlist_add_tail(&dst_cset->mg_preload_node,\n\t\t\t\t      &mgctx->preloaded_dst_csets);\n\t\telse\n\t\t\tput_css_set(dst_cset);\n\n\t\tfor_each_subsys(ss, ssid)\n\t\t\tif (src_cset->subsys[ssid] != dst_cset->subsys[ssid])\n\t\t\t\tmgctx->ss_mask |= 1 << ssid;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_add_src",
          "args": [
            "link->cset",
            "dsct",
            "&mgctx"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_add_src",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2637-2668",
          "snippet": "void cgroup_migrate_add_src(struct css_set *src_cset,\n\t\t\t    struct cgroup *dst_cgrp,\n\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup *src_cgrp;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If ->dead, @src_set is associated with one or more dead cgroups\n\t * and doesn't contain any migratable tasks.  Ignore it early so\n\t * that the rest of migration path doesn't get confused by it.\n\t */\n\tif (src_cset->dead)\n\t\treturn;\n\n\tif (!list_empty(&src_cset->mg_preload_node))\n\t\treturn;\n\n\tsrc_cgrp = cset_cgroup_from_root(src_cset, dst_cgrp->root);\n\n\tWARN_ON(src_cset->mg_src_cgrp);\n\tWARN_ON(src_cset->mg_dst_cgrp);\n\tWARN_ON(!list_empty(&src_cset->mg_tasks));\n\tWARN_ON(!list_empty(&src_cset->mg_node));\n\n\tsrc_cset->mg_src_cgrp = src_cgrp;\n\tsrc_cset->mg_dst_cgrp = dst_cgrp;\n\tget_css_set(src_cset);\n\tlist_add_tail(&src_cset->mg_preload_node, &mgctx->preloaded_src_csets);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_migrate_add_src(struct css_set *src_cset,\n\t\t\t    struct cgroup *dst_cgrp,\n\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup *src_cgrp;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If ->dead, @src_set is associated with one or more dead cgroups\n\t * and doesn't contain any migratable tasks.  Ignore it early so\n\t * that the rest of migration path doesn't get confused by it.\n\t */\n\tif (src_cset->dead)\n\t\treturn;\n\n\tif (!list_empty(&src_cset->mg_preload_node))\n\t\treturn;\n\n\tsrc_cgrp = cset_cgroup_from_root(src_cset, dst_cgrp->root);\n\n\tWARN_ON(src_cset->mg_src_cgrp);\n\tWARN_ON(src_cset->mg_dst_cgrp);\n\tWARN_ON(!list_empty(&src_cset->mg_tasks));\n\tWARN_ON(!list_empty(&src_cset->mg_node));\n\n\tsrc_cset->mg_src_cgrp = src_cgrp;\n\tsrc_cset->mg_dst_cgrp = dst_cgrp;\n\tget_css_set(src_cset);\n\tlist_add_tail(&src_cset->mg_preload_node, &mgctx->preloaded_src_csets);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&dsct->cset_links",
            "cset_link"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_for_each_live_descendant_pre",
          "args": [
            "dsct",
            "d_css",
            "cgrp"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_CGROUP_MGCTX",
          "args": [
            "mgctx"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_print_ss_mask",
          "args": [
            "seq",
            "cgrp->subtree_control"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_subtree_control_show",
          "args": [
            "structseq_file *seq",
            "void *v"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_print_ss_mask",
          "args": [
            "seq",
            "cgroup_control(cgrp)"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "seq",
            "'\\n'"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "ss->name"
          ],
          "line": 2904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "seq",
            "' '"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "ss_mask"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_print_ss_mask",
          "args": [
            "structseq_file *seq",
            "u16ss_mask"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->post_attach",
          "args": [],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "tsk"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESRCH"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "strstrip(buf)",
            "0",
            "&pid"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&cgroup_threadgroup_rwsem"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_procs_write_start",
          "args": [
            "char *buf",
            "boolthreadgroup",
            "bool *locked"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "attach_task",
            "dst_cgrp",
            "leader",
            "threadgroup"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_migrate",
          "args": [
            "leader",
            "threadgroup",
            "&mgctx"
          ],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2751-2773",
          "snippet": "int cgroup_migrate(struct task_struct *leader, bool threadgroup,\n\t\t   struct cgroup_mgctx *mgctx)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Prevent freeing of tasks while we take a snapshot. Tasks that are\n\t * already PF_EXITING could be freed from underneath us unless we\n\t * take an rcu_read_lock.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_task(task, mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn cgroup_migrate_execute(mgctx);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nint cgroup_migrate(struct task_struct *leader, bool threadgroup,\n\t\t   struct cgroup_mgctx *mgctx)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Prevent freeing of tasks while we take a snapshot. Tasks that are\n\t * already PF_EXITING could be freed from underneath us unless we\n\t * take an rcu_read_lock.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_task(task, mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn cgroup_migrate_execute(mgctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "leader",
            "task"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "task"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_CGROUP_MGCTX",
          "args": [
            "mgctx"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NOTIFY_MIN_INTV\tDIV_ROUND_UP(HZ, 100)\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nbool cgroup_debug;\nstatic DEFINE_SPINLOCK(cgroup_file_kn_lock);\nstatic u16 cgrp_dfl_inhibit_ss_mask;\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstruct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\nstatic u16 cgroup_feature_disable_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\n\nint cgroup_attach_task(struct cgroup *dst_cgrp, struct task_struct *leader,\n\t\t       bool threadgroup)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct task_struct *task;\n\tint ret = 0;\n\n\t/* look up all src csets */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_src(task_css_set(task), dst_cgrp, &mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* prepare dst csets and commit */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (!ret)\n\t\tret = cgroup_migrate(leader, threadgroup, &mgctx);\n\n\tcgroup_migrate_finish(&mgctx);\n\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(attach_task, dst_cgrp, leader, threadgroup);\n\n\treturn ret;\n}\n\nstruct task_struct *cgroup_procs_write_start(char *buf, bool threadgroup,\n\t\t\t\t\t     bool *locked)\n\t__acquires(&cgroup_threadgroup_rwsem)\n{\n\tstruct task_struct *tsk;\n\tpid_t pid;\n\n\tif (kstrtoint(strstrip(buf), 0, &pid) || pid < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If we migrate a single thread, we don't care about threadgroup\n\t * stability. If the thread is `current`, it won't exit(2) under our\n\t * hands or change PID through exec(2). We exclude\n\t * cgroup_update_dfl_csses and other cgroup_{proc,thread}s_write\n\t * callers by cgroup_mutex.\n\t * Therefore, we can skip the global lock.\n\t */\n\tlockdep_assert_held(&cgroup_mutex);\n\tif (pid || threadgroup) {\n\t\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\t\t*locked = true;\n\t} else {\n\t\t*locked = false;\n\t}\n\n\trcu_read_lock();\n\tif (pid) {\n\t\ttsk = find_task_by_vpid(pid);\n\t\tif (!tsk) {\n\t\t\ttsk = ERR_PTR(-ESRCH);\n\t\t\tgoto out_unlock_threadgroup;\n\t\t}\n\t} else {\n\t\ttsk = current;\n\t}\n\n\tif (threadgroup)\n\t\ttsk = tsk->group_leader;\n\n\t/*\n\t * kthreads may acquire PF_NO_SETAFFINITY during initialization.\n\t * If userland migrates such a kthread to a non-root cgroup, it can\n\t * become trapped in a cpuset, or RT kthread may be born in a\n\t * cgroup with no rt_runtime allocated.  Just say no.\n\t */\n\tif (tsk->no_cgroup_migration || (tsk->flags & PF_NO_SETAFFINITY)) {\n\t\ttsk = ERR_PTR(-EINVAL);\n\t\tgoto out_unlock_threadgroup;\n\t}\n\n\tget_task_struct(tsk);\n\tgoto out_unlock_rcu;\n\nout_unlock_threadgroup:\n\tif (*locked) {\n\t\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\t\t*locked = false;\n\t}\nout_unlock_rcu:\n\trcu_read_unlock();\n\treturn tsk;\n}\n\nvoid cgroup_procs_write_finish(struct task_struct *task, bool locked)\n\t__releases(&cgroup_threadgroup_rwsem)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\t/* release reference from cgroup_procs_write_start() */\n\tput_task_struct(task);\n\n\tif (locked)\n\t\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\tfor_each_subsys(ss, ssid)\n\t\tif (ss->post_attach)\n\t\t\tss->post_attach();\n}\n\nstatic void cgroup_print_ss_mask(struct seq_file *seq, u16 ss_mask)\n{\n\tstruct cgroup_subsys *ss;\n\tbool printed = false;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tif (printed)\n\t\t\tseq_putc(seq, ' ');\n\t\tseq_puts(seq, ss->name);\n\t\tprinted = true;\n\t} while_each_subsys_mask();\n\tif (printed)\n\t\tseq_putc(seq, '\\n');\n}\n\n/* show controllers which are enabled from the parent */\nstatic int cgroup_controllers_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgroup_control(cgrp));\n\treturn 0;\n}\n\n/* show controllers which are enabled for a given cgroup's children */\nstatic int cgroup_subtree_control_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tcgroup_print_ss_mask(seq, cgrp->subtree_control);\n\treturn 0;\n}\n\n/**\n * cgroup_update_dfl_csses - update css assoc of a subtree in default hierarchy\n * @cgrp: root of the subtree to update csses for\n *\n * @cgrp's control masks have changed and its subtree's css associations\n * need to be updated accordingly.  This function looks up all css_sets\n * which are attached to the subtree, creates the matching updated css_sets\n * and migrates the tasks to the new ones.\n */\nstatic int cgroup_update_dfl_csses(struct cgroup *cgrp)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup *dsct;\n\tstruct css_set *src_cset;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\t/* look up all csses currently attached to @cgrp's subtree */\n\tspin_lock_irq(&css_set_lock);\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &dsct->cset_links, cset_link)\n\t\t\tcgroup_migrate_add_src(link->cset, dsct, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* NULL dst indicates self on default hierarchy */\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(src_cset, &mgctx.preloaded_src_csets, mg_preload_node) {\n\t\tstruct task_struct *task, *ntask;\n\n\t\t/* all tasks in src_csets need to be migrated */\n\t\tlist_for_each_entry_safe(task, ntask, &src_cset->tasks, cg_list)\n\t\t\tcgroup_migrate_add_task(task, &mgctx);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_migrate_execute(&mgctx);\nout_finish:\n\tcgroup_migrate_finish(&mgctx);\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\treturn ret;\n}\n\n/**\n * cgroup_lock_and_drain_offline - lock cgroup_mutex and drain offlined csses\n * @cgrp: root of the target subtree\n *\n * Because css offlining is asynchronous, userland may try to re-enable a\n * controller while the previous css is still around.  This function grabs\n * cgroup_mutex and drains the previous css instances of @cgrp's subtree.\n */\nvoid cgroup_lock_and_drain_offline(struct cgroup *cgrp)\n\t__acquires(&cgroup_mutex)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\nrestart:\n\tmutex_lock(&cgroup_mutex);\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\t\t\tDEFINE_WAIT(wait);\n\n\t\t\tif (!css || !percpu_ref_is_dying(&css->refcnt))\n\t\t\t\tcontinue;\n\n\t\t\tcgroup_get_live(dsct);\n\t\t\tprepare_to_wait(&dsct->offline_waitq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\t\tmutex_unlock(&cgroup_mutex);\n\t\t\tschedule();\n\t\t\tfinish_wait(&dsct->offline_waitq, &wait);\n\n\t\t\tcgroup_put(dsct);\n\t\t\tgoto restart;\n\t\t}\n\t}\n}\n\n/**\n * cgroup_save_control - save control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Save ->subtree_control, ->subtree_ss_mask and ->dom_cgrp to the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_save_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->old_subtree_control = dsct->subtree_control;\n\t\tdsct->old_subtree_ss_mask = dsct->subtree_ss_mask;\n\t\tdsct->old_dom_cgrp = dsct->dom_cgrp;\n\t}\n}\n\n/**\n * cgroup_propagate_control - refresh control masks of a subtree\n * @cgrp: root of the target subtree\n *\n * For @cgrp and its subtree, ensure ->subtree_ss_mask matches\n * ->subtree_control and propagate controller availability through the\n * subtree so that descendants don't have unavailable controllers enabled.\n */\nstatic void cgroup_propagate_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control &= cgroup_control(dsct);\n\t\tdsct->subtree_ss_mask =\n\t\t\tcgroup_calc_subtree_ss_mask(dsct->subtree_control,\n\t\t\t\t\t\t    cgroup_ss_mask(dsct));\n\t}\n}\n\n/**\n * cgroup_restore_control - restore control masks and dom_cgrp of a subtree\n * @cgrp: root of the target subtree\n *\n * Restore ->subtree_control, ->subtree_ss_mask and ->dom_cgrp from the\n * respective old_ prefixed fields for @cgrp's subtree including @cgrp\n * itself.\n */\nstatic void cgroup_restore_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tdsct->subtree_control = dsct->old_subtree_control;\n\t\tdsct->subtree_ss_mask = dsct->old_subtree_ss_mask;\n\t\tdsct->dom_cgrp = dsct->old_dom_cgrp;\n\t}\n}\n\nstatic bool css_visible(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys *ss = css->ss;\n\tstruct cgroup *cgrp = css->cgroup;\n\n\tif (cgroup_control(cgrp) & (1 << ss->id))\n\t\treturn true;\n\tif (!(cgroup_ss_mask(cgrp) & (1 << ss->id)))\n\t\treturn false;\n\treturn cgroup_on_dfl(cgrp) && ss->implicit_on_dfl;\n}\n\n/**\n * cgroup_apply_control_enable - enable or show csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and create new csses or make the existing ones\n * visible.  A css is created invisible if it's being implicitly enabled\n * through dependency.  An invisible css is made visible when the userland\n * explicitly enables it.\n *\n * Returns 0 on success, -errno on failure.  On failure, csses which have\n * been processed already aren't cleaned up.  The caller is responsible for\n * cleaning up with cgroup_apply_control_disable().\n */\nstatic int cgroup_apply_control_enable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid, ret;\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tif (!(cgroup_ss_mask(dsct) & (1 << ss->id)))\n\t\t\t\tcontinue;\n\n\t\t\tif (!css) {\n\t\t\t\tcss = css_create(dsct, ss);\n\t\t\t\tif (IS_ERR(css))\n\t\t\t\t\treturn PTR_ERR(css);\n\t\t\t}\n\n\t\t\tWARN_ON_ONCE(percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (css_visible(css)) {\n\t\t\t\tret = css_populate_dir(css);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_apply_control_disable - kill or hide csses according to control\n * @cgrp: root of the target subtree\n *\n * Walk @cgrp's subtree and kill and hide csses so that they match\n * cgroup_ss_mask() and cgroup_visible_mask().\n *\n * A css is hidden when the userland requests it to be disabled while other\n * subsystems are still depending on it.  The css must not actively control\n * resources and be in the vanilla state if it's made visible again later.\n * Controllers which may be depended upon should provide ->css_reset() for\n * this purpose.\n */\nstatic void cgroup_apply_control_disable(struct cgroup *cgrp)\n{\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tcgroup_for_each_live_descendant_post(dsct, d_css, cgrp) {\n\t\tfor_each_subsys(ss, ssid) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(dsct, ss);\n\n\t\t\tif (!css)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(percpu_ref_is_dying(&css->refcnt));\n\n\t\t\tif (css->parent &&\n\t\t\t    !(cgroup_ss_mask(dsct) & (1 << ss->id))) {\n\t\t\t\tkill_css(css);\n\t\t\t} else if (!css_visible(css)) {\n\t\t\t\tcss_clear_dir(css);\n\t\t\t\tif (ss->css_reset)\n\t\t\t\t\tss->css_reset(css);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * cgroup_apply_control - apply control mask updates to the subtree\n * @cgrp: root of the target subtree\n *\n * subsystems can be enabled and disabled in a subtree using the following\n * steps.\n *\n * 1. Call cgroup_save_control() to stash the current state.\n * 2. Update ->subtree_control masks in the subtree as desired.\n * 3. Call cgroup_apply_control() to apply the changes.\n * 4. Optionally perform other related operations.\n * 5. Call cgroup_finalize_control() to finish up.\n *\n * This function implements step 3 and propagates the mask changes\n * throughout @cgrp's subtree, updates csses accordingly and perform\n * process migrations.\n */\nstatic int cgroup_apply_control(struct cgroup *cgrp)\n{\n\tint ret;\n\n\tcgroup_propagate_control(cgrp);\n\n\tret = cgroup_apply_control_enable(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * At this point, cgroup_e_css_by_mask() results reflect the new csses\n\t * making the following cgroup_update_dfl_csses() properly update\n\t * css associations of all tasks in the subtree.\n\t */\n\tret = cgroup_update_dfl_csses(cgrp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n/**\n * cgroup_finalize_control - finalize control mask update\n * @cgrp: root of the target subtree\n * @ret: the result of the update\n *\n * Finalize control mask update.  See cgroup_apply_control() for more info.\n */\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret)\n{\n\tif (ret) {\n\t\tcgroup_restore_control(cgrp);\n\t\tcgroup_propagate_control(cgrp);\n\t}\n\n\tcgroup_apply_control_disable(cgrp);\n}\n\nstatic int cgroup_vet_subtree_control_enable(struct cgroup *cgrp, u16 enable)\n{\n\tu16 domain_enable = enable & ~cgrp_dfl_threaded_ss_mask;\n\n\t/* if nothing is getting enabled, nothing to worry about */\n\tif (!enable)\n\t\treturn 0;\n\n\t/* can @cgrp host any resources? */\n\tif (!cgroup_is_valid_domain(cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn 0;\n\n\tif (domain_enable) {\n\t\t/* can't enable domain controllers inside a thread subtree */\n\t\tif (cgroup_is_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\t/*\n\t\t * Threaded controllers can handle internal competitions\n\t\t * and are always allowed inside a (prospective) thread\n\t\t * subtree.\n\t\t */\n\t\tif (cgroup_can_be_thread_root(cgrp) || cgroup_is_threaded(cgrp))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Controllers can't be enabled for a cgroup with tasks to avoid\n\t * child cgroups competing against tasks.\n\t */\n\tif (cgroup_has_tasks(cgrp))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n/* change the enabled child controllers for a cgroup in the default hierarchy */\nstatic ssize_t cgroup_subtree_control_write(struct kernfs_open_file *of,\n\t\t\t\t\t    char *buf, size_t nbytes,\n\t\t\t\t\t    loff_t off)\n{\n\tu16 enable = 0, disable = 0;\n\tstruct cgroup *cgrp, *child;\n\tstruct cgroup_subsys *ss;\n\tchar *tok;\n\tint ssid, ret;\n\n\t/*\n\t * Parse input - space separated list of subsystem names prefixed\n\t * with either + or -.\n\t */\n\tbuf = strstrip(buf);\n\twhile ((tok = strsep(&buf, \" \"))) {\n\t\tif (tok[0] == '\\0')\n\t\t\tcontinue;\n\t\tdo_each_subsys_mask(ss, ssid, ~cgrp_dfl_inhibit_ss_mask) {\n\t\t\tif (!cgroup_ssid_enabled(ssid) ||\n\t\t\t    strcmp(tok + 1, ss->name))\n\t\t\t\tcontinue;\n\n\t\t\tif (*tok == '+') {\n\t\t\t\tenable |= 1 << ssid;\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t} else if (*tok == '-') {\n\t\t\t\tdisable |= 1 << ssid;\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t} while_each_subsys_mask();\n\t\tif (ssid == CGROUP_SUBSYS_COUNT)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tfor_each_subsys(ss, ssid) {\n\t\tif (enable & (1 << ssid)) {\n\t\t\tif (cgrp->subtree_control & (1 << ssid)) {\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(cgroup_control(cgrp) & (1 << ssid))) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else if (disable & (1 << ssid)) {\n\t\t\tif (!(cgrp->subtree_control & (1 << ssid))) {\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* a child has it enabled? */\n\t\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\t\tif (child->subtree_control & (1 << ssid)) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!enable && !disable) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tret = cgroup_vet_subtree_control_enable(cgrp, enable);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* save and update control masks and prepare csses */\n\tcgroup_save_control(cgrp);\n\n\tcgrp->subtree_control |= enable;\n\tcgrp->subtree_control &= ~disable;\n\n\tret = cgroup_apply_control(cgrp);\n\tcgroup_finalize_control(cgrp, ret);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tkernfs_activate(cgrp->kn);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\n/**\n * cgroup_enable_threaded - make @cgrp threaded\n * @cgrp: the target cgroup\n *\n * Called when \"threaded\" is written to the cgroup.type interface file and\n * tries to make @cgrp threaded and join the parent's resource domain.\n * This function is never called on the root cgroup as cgroup.type doesn't\n * exist on it.\n */\nstatic int cgroup_enable_threaded(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tstruct cgroup *dom_cgrp = parent->dom_cgrp;\n\tstruct cgroup *dsct;\n\tstruct cgroup_subsys_state *d_css;\n\tint ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* noop if already threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @cgroup is populated or has domain controllers enabled, it\n\t * can't be switched.  While the below cgroup_can_be_thread_root()\n\t * test can catch the same conditions, that's only when @parent is\n\t * not mixable, so let's check it explicitly.\n\t */\n\tif (cgroup_is_populated(cgrp) ||\n\t    cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn -EOPNOTSUPP;\n\n\t/* we're joining the parent's domain, ensure its validity */\n\tif (!cgroup_is_valid_domain(dom_cgrp) ||\n\t    !cgroup_can_be_thread_root(dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * The following shouldn't cause actual migrations and should\n\t * always succeed.\n\t */\n\tcgroup_save_control(cgrp);\n\n\tcgroup_for_each_live_descendant_pre(dsct, d_css, cgrp)\n\t\tif (dsct == cgrp || cgroup_is_threaded(dsct))\n\t\t\tdsct->dom_cgrp = dom_cgrp;\n\n\tret = cgroup_apply_control(cgrp);\n\tif (!ret)\n\t\tparent->nr_threaded_children++;\n\n\tcgroup_finalize_control(cgrp, ret);\n\treturn ret;\n}\n\nstatic int cgroup_type_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tif (cgroup_is_threaded(cgrp))\n\t\tseq_puts(seq, \"threaded\\n\");\n\telse if (!cgroup_is_valid_domain(cgrp))\n\t\tseq_puts(seq, \"domain invalid\\n\");\n\telse if (cgroup_is_thread_root(cgrp))\n\t\tseq_puts(seq, \"domain threaded\\n\");\n\telse\n\t\tseq_puts(seq, \"domain\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_type_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\t/* only switching to threaded mode is supported */\n\tif (strcmp(strstrip(buf), \"threaded\"))\n\t\treturn -EINVAL;\n\n\t/* drain dying csses before we re-apply (threaded) subtree control */\n\tcgrp = cgroup_kn_lock_live(of->kn, true);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\t/* threaded can only be enabled */\n\tret = cgroup_enable_threaded(cgrp);\n\n\tcgroup_kn_unlock(of->kn);\n\treturn ret ?: nbytes;\n}\n\nstatic int cgroup_max_descendants_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint descendants = READ_ONCE(cgrp->max_descendants);\n\n\tif (descendants == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", descendants);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_descendants_write(struct kernfs_open_file *of,\n\t\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tint descendants;\n\tssize_t ret;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdescendants = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &descendants);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (descendants < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_descendants = descendants;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_max_depth_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tint depth = READ_ONCE(cgrp->max_depth);\n\n\tif (depth == INT_MAX)\n\t\tseq_puts(seq, \"max\\n\");\n\telse\n\t\tseq_printf(seq, \"%d\\n\", depth);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_max_depth_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint depth;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, \"max\")) {\n\t\tdepth = INT_MAX;\n\t} else {\n\t\tret = kstrtoint(buf, 0, &depth);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (depth < 0)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgrp->max_depth = depth;\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic int cgroup_events_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"populated %d\\n\", cgroup_is_populated(cgrp));\n\tseq_printf(seq, \"frozen %d\\n\", test_bit(CGRP_FROZEN, &cgrp->flags));\n\n\treturn 0;\n}\n\nstatic int cgroup_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgroup = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"nr_descendants %d\\n\",\n\t\t   cgroup->nr_descendants);\n\tseq_printf(seq, \"nr_dying_descendants %d\\n\",\n\t\t   cgroup->nr_dying_descendants);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cgroup_extra_stat_show(struct seq_file *seq,\n\t\t\t\t\t\t struct cgroup *cgrp, int ssid)\n{\n\tstruct cgroup_subsys *ss = cgroup_subsys[ssid];\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!ss->css_extra_stat_show)\n\t\treturn 0;\n\n\tcss = cgroup_tryget_css(cgrp, ss);\n\tif (!css)\n\t\treturn 0;\n\n\tret = ss->css_extra_stat_show(seq, css);\n\tcss_put(css);\n\treturn ret;\n}\n\nstatic int cpu_stat_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup __maybe_unused *cgrp = seq_css(seq)->cgroup;\n\tint ret = 0;\n\n\tcgroup_base_stat_cputime_show(seq);\n#ifdef CONFIG_CGROUP_SCHED\n\tret = cgroup_extra_stat_show(seq, cgrp, cpu_cgrp_id);\n#endif\n\treturn ret;\n}\n\n#ifdef CONFIG_PSI\nstatic int cgroup_io_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_IO);\n}\nstatic int cgroup_memory_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_MEM);\n}\nstatic int cgroup_cpu_pressure_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\tstruct psi_group *psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\n\treturn psi_show(seq, psi, PSI_CPU);\n}\n\nstatic ssize_t cgroup_pressure_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t\t  size_t nbytes, enum psi_res res)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct psi_trigger *new;\n\tstruct cgroup *cgrp;\n\tstruct psi_group *psi;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tcgroup_get(cgrp);\n\tcgroup_kn_unlock(of->kn);\n\n\tpsi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi;\n\tnew = psi_trigger_create(psi, buf, nbytes, res);\n\tif (IS_ERR(new)) {\n\t\tcgroup_put(cgrp);\n\t\treturn PTR_ERR(new);\n\t}\n\n\tpsi_trigger_replace(&ctx->psi.trigger, new);\n\n\tcgroup_put(cgrp);\n\n\treturn nbytes;\n}\n\nstatic ssize_t cgroup_io_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_IO);\n}\n\nstatic ssize_t cgroup_memory_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_MEM);\n}\n\nstatic ssize_t cgroup_cpu_pressure_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes,\n\t\t\t\t\t  loff_t off)\n{\n\treturn cgroup_pressure_write(of, buf, nbytes, PSI_CPU);\n}\n\nstatic __poll_t cgroup_pressure_poll(struct kernfs_open_file *of,\n\t\t\t\t\t  poll_table *pt)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\treturn psi_trigger_poll(&ctx->psi.trigger, of->file, pt);\n}\n\nstatic void cgroup_pressure_release(struct kernfs_open_file *of)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tpsi_trigger_replace(&ctx->psi.trigger, NULL);\n}\n\nbool cgroup_psi_enabled(void)\n{\n\treturn (cgroup_feature_disable_mask & (1 << OPT_FEATURE_PRESSURE)) == 0;\n}\n\n#else /* CONFIG_PSI */\nbool cgroup_psi_enabled(void)\n{\n\treturn false;\n}\n\n#endif /* CONFIG_PSI */\n\nstatic int cgroup_freeze_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tseq_printf(seq, \"%d\\n\", cgrp->freezer.freeze);\n\n\treturn 0;\n}\n\nstatic ssize_t cgroup_freeze_write(struct kernfs_open_file *of,\n\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tssize_t ret;\n\tint freeze;\n\n\tret = kstrtoint(strstrip(buf), 0, &freeze);\n\tif (ret)\n\t\treturn ret;\n\n\tif (freeze < 0 || freeze > 1)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\tcgroup_freeze(cgrp, freeze);\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn nbytes;\n}\n\nstatic void __cgroup_kill(struct cgroup *cgrp)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tset_bit(CGRP_KILL, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tcss_task_iter_start(&cgrp->self, CSS_TASK_ITER_PROCS | CSS_TASK_ITER_THREADED, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t/* Ignore kernel threads here. */\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\n\t\t/* Skip tasks that are already dying. */\n\t\tif (__fatal_signal_pending(task))\n\t\t\tcontinue;\n\n\t\tsend_sig(SIGKILL, task, 0);\n\t}\n\tcss_task_iter_end(&it);\n\n\tspin_lock_irq(&css_set_lock);\n\tclear_bit(CGRP_KILL, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n}\n\nstatic void cgroup_kill(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *dsct;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcgroup_for_each_live_descendant_pre(dsct, css, cgrp)\n\t\t__cgroup_kill(dsct);\n}\n\nstatic ssize_t cgroup_kill_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tssize_t ret = 0;\n\tint kill;\n\tstruct cgroup *cgrp;\n\n\tret = kstrtoint(strstrip(buf), 0, &kill);\n\tif (ret)\n\t\treturn ret;\n\n\tif (kill != 1)\n\t\treturn -ERANGE;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENOENT;\n\n\t/*\n\t * Killing is a process directed operation, i.e. the whole thread-group\n\t * is taken down so act like we do for cgroup.procs and only make this\n\t * writable in non-threaded cgroups.\n\t */\n\tif (cgroup_is_threaded(cgrp))\n\t\tret = -EOPNOTSUPP;\n\telse\n\t\tcgroup_kill(cgrp);\n\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\nstatic int cgroup_file_open(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of_cft(of);\n\tstruct cgroup_file_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ns = current->nsproxy->cgroup_ns;\n\tget_cgroup_ns(ctx->ns);\n\tof->priv = ctx;\n\n\tif (!cft->open)\n\t\treturn 0;\n\n\tret = cft->open(of);\n\tif (ret) {\n\t\tput_cgroup_ns(ctx->ns);\n\t\tkfree(ctx);\n\t}\n\treturn ret;\n}\n\nstatic void cgroup_file_release(struct kernfs_open_file *of)\n{\n\tstruct cftype *cft = of_cft(of);\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tif (cft->release)\n\t\tcft->release(of);\n\tput_cgroup_ns(ctx->ns);\n\tkfree(ctx);\n}\n\nstatic ssize_t cgroup_file_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\tstruct cgroup_subsys_state *css;\n\tint ret;\n\n\tif (!nbytes)\n\t\treturn 0;\n\n\t/*\n\t * If namespaces are delegation boundaries, disallow writes to\n\t * files in an non-init namespace root from inside the namespace\n\t * except for the files explicitly marked delegatable -\n\t * cgroup.procs and cgroup.subtree_control.\n\t */\n\tif ((cgrp->root->flags & CGRP_ROOT_NS_DELEGATE) &&\n\t    !(cft->flags & CFTYPE_NS_DELEGATABLE) &&\n\t    ctx->ns != &init_cgroup_ns && ctx->ns->root_cset->dfl_cgrp == cgrp)\n\t\treturn -EPERM;\n\n\tif (cft->write)\n\t\treturn cft->write(of, buf, nbytes, off);\n\n\t/*\n\t * kernfs guarantees that a file isn't deleted with operations in\n\t * flight, which means that the matching css is and stays alive and\n\t * doesn't need to be pinned.  The RCU locking is not necessary\n\t * either.  It's just for the convenience of using cgroup_css().\n\t */\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, cft->ss);\n\trcu_read_unlock();\n\n\tif (cft->write_u64) {\n\t\tunsigned long long v;\n\t\tret = kstrtoull(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_u64(css, cft, v);\n\t} else if (cft->write_s64) {\n\t\tlong long v;\n\t\tret = kstrtoll(buf, 0, &v);\n\t\tif (!ret)\n\t\t\tret = cft->write_s64(css, cft, v);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret ?: nbytes;\n}\n\nstatic __poll_t cgroup_file_poll(struct kernfs_open_file *of, poll_table *pt)\n{\n\tstruct cftype *cft = of_cft(of);\n\n\tif (cft->poll)\n\t\treturn cft->poll(of, pt);\n\n\treturn kernfs_generic_poll(of, pt);\n}\n\nstatic void *cgroup_seqfile_start(struct seq_file *seq, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_start(seq, ppos);\n}\n\nstatic void *cgroup_seqfile_next(struct seq_file *seq, void *v, loff_t *ppos)\n{\n\treturn seq_cft(seq)->seq_next(seq, v, ppos);\n}\n\nstatic void cgroup_seqfile_stop(struct seq_file *seq, void *v)\n{\n\tif (seq_cft(seq)->seq_stop)\n\t\tseq_cft(seq)->seq_stop(seq, v);\n}\n\nstatic int cgroup_seqfile_show(struct seq_file *m, void *arg)\n{\n\tstruct cftype *cft = seq_cft(m);\n\tstruct cgroup_subsys_state *css = seq_css(m);\n\n\tif (cft->seq_show)\n\t\treturn cft->seq_show(m, arg);\n\n\tif (cft->read_u64)\n\t\tseq_printf(m, \"%llu\\n\", cft->read_u64(css, cft));\n\telse if (cft->read_s64)\n\t\tseq_printf(m, \"%lld\\n\", cft->read_s64(css, cft));\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct kernfs_ops cgroup_kf_single_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.poll\t\t\t= cgroup_file_poll,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\nstatic struct kernfs_ops cgroup_kf_ops = {\n\t.atomic_write_len\t= PAGE_SIZE,\n\t.open\t\t\t= cgroup_file_open,\n\t.release\t\t= cgroup_file_release,\n\t.write\t\t\t= cgroup_file_write,\n\t.poll\t\t\t= cgroup_file_poll,\n\t.seq_start\t\t= cgroup_seqfile_start,\n\t.seq_next\t\t= cgroup_seqfile_next,\n\t.seq_stop\t\t= cgroup_seqfile_stop,\n\t.seq_show\t\t= cgroup_seqfile_show,\n};\n\n/* set uid and gid of cgroup dirs and files to that of the creator */\nstatic int cgroup_kn_set_ugid(struct kernfs_node *kn)\n{\n\tstruct iattr iattr = { .ia_valid = ATTR_UID | ATTR_GID,\n\t\t\t       .ia_uid = current_fsuid(),\n\t\t\t       .ia_gid = current_fsgid(), };\n\n\tif (uid_eq(iattr.ia_uid, GLOBAL_ROOT_UID) &&\n\t    gid_eq(iattr.ia_gid, GLOBAL_ROOT_GID))\n\t\treturn 0;\n\n\treturn kernfs_setattr(kn, &iattr);\n}\n\nstatic void cgroup_file_notify_timer(struct timer_list *timer)\n{\n\tcgroup_file_notify(container_of(timer, struct cgroup_file,\n\t\t\t\t\tnotify_timer));\n}\n\nstatic int cgroup_add_file(struct cgroup_subsys_state *css, struct cgroup *cgrp,\n\t\t\t   struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\tstruct kernfs_node *kn;\n\tstruct lock_class_key *key = NULL;\n\tint ret;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tkey = &cft->lockdep_key;\n#endif\n\tkn = __kernfs_create_file(cgrp->kn, cgroup_file_name(cgrp, cft, name),\n\t\t\t\t  cgroup_file_mode(cft),\n\t\t\t\t  GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,\n\t\t\t\t  0, cft->kf_ops, cft,\n\t\t\t\t  NULL, key);\n\tif (IS_ERR(kn))\n\t\treturn PTR_ERR(kn);\n\n\tret = cgroup_kn_set_ugid(kn);\n\tif (ret) {\n\t\tkernfs_remove(kn);\n\t\treturn ret;\n\t}\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\ttimer_setup(&cfile->notify_timer, cgroup_file_notify_timer, 0);\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = kn;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\t}\n\n\treturn 0;\n}\n\n/**\n * cgroup_addrm_files - add or remove files to a cgroup directory\n * @css: the target css\n * @cgrp: the target cgroup (usually css->cgroup)\n * @cfts: array of cftypes to be added\n * @is_add: whether to add or remove\n *\n * Depending on @is_add, add or remove files defined by @cfts on @cgrp.\n * For removals, this function never fails.\n */\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add)\n{\n\tstruct cftype *cft, *cft_end = NULL;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\nrestart:\n\tfor (cft = cfts; cft != cft_end && cft->name[0] != '\\0'; cft++) {\n\t\t/* does cft->flags tell us to skip this file on @cgrp? */\n\t\tif ((cft->flags & CFTYPE_PRESSURE) && !cgroup_psi_enabled())\n\t\t\tcontinue;\n\t\tif ((cft->flags & __CFTYPE_ONLY_ON_DFL) && !cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & __CFTYPE_NOT_ON_DFL) && cgroup_on_dfl(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_NOT_ON_ROOT) && !cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_ONLY_ON_ROOT) && cgroup_parent(cgrp))\n\t\t\tcontinue;\n\t\tif ((cft->flags & CFTYPE_DEBUG) && !cgroup_debug)\n\t\t\tcontinue;\n\t\tif (is_add) {\n\t\t\tret = cgroup_add_file(css, cgrp, cft);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"%s: failed to add %s, err=%d\\n\",\n\t\t\t\t\t__func__, cft->name, ret);\n\t\t\t\tcft_end = cft;\n\t\t\t\tis_add = false;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t} else {\n\t\t\tcgroup_rm_file(cgrp, cft);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int cgroup_apply_cftypes(struct cftype *cfts, bool is_add)\n{\n\tstruct cgroup_subsys *ss = cfts[0].ss;\n\tstruct cgroup *root = &ss->root->cgrp;\n\tstruct cgroup_subsys_state *css;\n\tint ret = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* add/rm files for all cgroups created before */\n\tcss_for_each_descendant_pre(css, cgroup_css(root, ss)) {\n\t\tstruct cgroup *cgrp = css->cgroup;\n\n\t\tif (!(css->flags & CSS_VISIBLE))\n\t\t\tcontinue;\n\n\t\tret = cgroup_addrm_files(css, cgrp, cfts, is_add);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (is_add && !ret)\n\t\tkernfs_activate(root->kn);\n\treturn ret;\n}\n\nstatic void cgroup_exit_cftypes(struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\t/* free copy for custom atomic_write_len, see init_cftypes() */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE)\n\t\t\tkfree(cft->kf_ops);\n\t\tcft->kf_ops = NULL;\n\t\tcft->ss = NULL;\n\n\t\t/* revert flags set by cgroup core while adding @cfts */\n\t\tcft->flags &= ~(__CFTYPE_ONLY_ON_DFL | __CFTYPE_NOT_ON_DFL);\n\t}\n}\n\nstatic int cgroup_init_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft->name[0] != '\\0'; cft++) {\n\t\tstruct kernfs_ops *kf_ops;\n\n\t\tWARN_ON(cft->ss || cft->kf_ops);\n\n\t\tif ((cft->flags & CFTYPE_PRESSURE) && !cgroup_psi_enabled())\n\t\t\tcontinue;\n\n\t\tif (cft->seq_start)\n\t\t\tkf_ops = &cgroup_kf_ops;\n\t\telse\n\t\t\tkf_ops = &cgroup_kf_single_ops;\n\n\t\t/*\n\t\t * Ugh... if @cft wants a custom max_write_len, we need to\n\t\t * make a copy of kf_ops to set its atomic_write_len.\n\t\t */\n\t\tif (cft->max_write_len && cft->max_write_len != PAGE_SIZE) {\n\t\t\tkf_ops = kmemdup(kf_ops, sizeof(*kf_ops), GFP_KERNEL);\n\t\t\tif (!kf_ops) {\n\t\t\t\tcgroup_exit_cftypes(cfts);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tkf_ops->atomic_write_len = cft->max_write_len;\n\t\t}\n\n\t\tcft->kf_ops = kf_ops;\n\t\tcft->ss = ss;\n\t}\n\n\treturn 0;\n}\n\nstatic int cgroup_rm_cftypes_locked(struct cftype *cfts)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!cfts || !cfts[0].ss)\n\t\treturn -ENOENT;\n\n\tlist_del(&cfts->node);\n\tcgroup_apply_cftypes(cfts, false);\n\tcgroup_exit_cftypes(cfts);\n\treturn 0;\n}\n\n/**\n * cgroup_rm_cftypes - remove an array of cftypes from a subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Unregister @cfts.  Files described by @cfts are removed from all\n * existing cgroups and all future cgroups won't have them either.  This\n * function can be called anytime whether @cfts' subsys is attached or not.\n *\n * Returns 0 on successful unregistration, -ENOENT if @cfts is not\n * registered.\n */\nint cgroup_rm_cftypes(struct cftype *cfts)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tret = cgroup_rm_cftypes_locked(cfts);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_cftypes - add an array of cftypes to a subsystem\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Register @cfts to @ss.  Files described by @cfts are created for all\n * existing cgroups to which @ss is attached and all future cgroups will\n * have them too.  This function can be called anytime whether @ss is\n * attached or not.\n *\n * Returns 0 on successful registration, -errno on failure.  Note that this\n * function currently returns 0 as long as @cfts registration is successful\n * even if some file creation attempts on existing cgroups fail.\n */\nstatic int cgroup_add_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tint ret;\n\n\tif (!cgroup_ssid_enabled(ss->id))\n\t\treturn 0;\n\n\tif (!cfts || cfts[0].name[0] == '\\0')\n\t\treturn 0;\n\n\tret = cgroup_init_cftypes(ss, cfts);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tlist_add_tail(&cfts->node, &ss->cfts);\n\tret = cgroup_apply_cftypes(cfts, true);\n\tif (ret)\n\t\tcgroup_rm_cftypes_locked(cfts);\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}\n\n/**\n * cgroup_add_dfl_cftypes - add an array of cftypes for default hierarchy\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the default hierarchy.\n */\nint cgroup_add_dfl_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_ONLY_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_add_legacy_cftypes - add an array of cftypes for legacy hierarchies\n * @ss: target cgroup subsystem\n * @cfts: zero-length name terminated array of cftypes\n *\n * Similar to cgroup_add_cftypes() but the added files are only used for\n * the legacy hierarchies.\n */\nint cgroup_add_legacy_cftypes(struct cgroup_subsys *ss, struct cftype *cfts)\n{\n\tstruct cftype *cft;\n\n\tfor (cft = cfts; cft && cft->name[0] != '\\0'; cft++)\n\t\tcft->flags |= __CFTYPE_NOT_ON_DFL;\n\treturn cgroup_add_cftypes(ss, cfts);\n}\n\n/**\n * cgroup_file_notify - generate a file modified event for a cgroup_file\n * @cfile: target cgroup_file\n *\n * @cfile must have been obtained by setting cftype->file_offset.\n */\nvoid cgroup_file_notify(struct cgroup_file *cfile)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cgroup_file_kn_lock, flags);\n\tif (cfile->kn) {\n\t\tunsigned long last = cfile->notified_at;\n\t\tunsigned long next = last + CGROUP_FILE_NOTIFY_MIN_INTV;\n\n\t\tif (time_in_range(jiffies, last, next)) {\n\t\t\ttimer_reduce(&cfile->notify_timer, next);\n\t\t} else {\n\t\t\tkernfs_notify(cfile->kn);\n\t\t\tcfile->notified_at = jiffies;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cgroup_file_kn_lock, flags);\n}\n\n/**\n * css_next_child - find the next child of a given css\n * @pos: the current position (%NULL to initiate traversal)\n * @parent: css whose children to walk\n *\n * This function returns the next child of @parent and should be called\n * under either cgroup_mutex or RCU read lock.  The only requirement is\n * that @parent and @pos are accessible.  The next sibling is guaranteed to\n * be returned regardless of their states.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *css_next_child(struct cgroup_subsys_state *pos,\n\t\t\t\t\t   struct cgroup_subsys_state *parent)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/*\n\t * @pos could already have been unlinked from the sibling list.\n\t * Once a cgroup is removed, its ->sibling.next is no longer\n\t * updated when its next sibling changes.  CSS_RELEASED is set when\n\t * @pos is taken off list, at which time its next pointer is valid,\n\t * and, as releases are serialized, the one pointed to by the next\n\t * pointer is guaranteed to not have started release yet.  This\n\t * implies that if we observe !CSS_RELEASED on @pos in this RCU\n\t * critical section, the one pointed to by its next pointer is\n\t * guaranteed to not have finished its RCU grace period even if we\n\t * have dropped rcu_read_lock() in-between iterations.\n\t *\n\t * If @pos has CSS_RELEASED set, its next pointer can't be\n\t * dereferenced; however, as each css is given a monotonically\n\t * increasing unique serial number and always appended to the\n\t * sibling list, the next one can be found by walking the parent's\n\t * children until the first css with higher serial number than\n\t * @pos's.  While this path can be slower, it happens iff iteration\n\t * races against release and the race window is very small.\n\t */\n\tif (!pos) {\n\t\tnext = list_entry_rcu(parent->children.next, struct cgroup_subsys_state, sibling);\n\t} else if (likely(!(pos->flags & CSS_RELEASED))) {\n\t\tnext = list_entry_rcu(pos->sibling.next, struct cgroup_subsys_state, sibling);\n\t} else {\n\t\tlist_for_each_entry_rcu(next, &parent->children, sibling,\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex))\n\t\t\tif (next->serial_nr > pos->serial_nr)\n\t\t\t\tbreak;\n\t}\n\n\t/*\n\t * @next, if not pointing to the head, can be dereferenced and is\n\t * the next sibling.\n\t */\n\tif (&next->sibling != &parent->children)\n\t\treturn next;\n\treturn NULL;\n}\n\n/**\n * css_next_descendant_pre - find the next descendant for pre-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_pre().  Find the next descendant\n * to visit for pre-order traversal of @root's descendants.  @root is\n * included in the iteration and the first node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @root are accessible and @pos is a descendant of @root.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_pre(struct cgroup_subsys_state *pos,\n\t\t\tstruct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit @root */\n\tif (!pos)\n\t\treturn root;\n\n\t/* visit the first child if exists */\n\tnext = css_next_child(NULL, pos);\n\tif (next)\n\t\treturn next;\n\n\t/* no child, visit my or the closest ancestor's next sibling */\n\twhile (pos != root) {\n\t\tnext = css_next_child(pos, pos->parent);\n\t\tif (next)\n\t\t\treturn next;\n\t\tpos = pos->parent;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(css_next_descendant_pre);\n\n/**\n * css_rightmost_descendant - return the rightmost descendant of a css\n * @pos: css of interest\n *\n * Return the rightmost descendant of @pos.  If there's no descendant, @pos\n * is returned.  This can be used during pre-order traversal to skip\n * subtree of @pos.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct rightmost descendant as\n * long as @pos is accessible.\n */\nstruct cgroup_subsys_state *\ncss_rightmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last, *tmp;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\tdo {\n\t\tlast = pos;\n\t\t/* ->prev isn't RCU safe, walk ->next till the end */\n\t\tpos = NULL;\n\t\tcss_for_each_child(tmp, last)\n\t\t\tpos = tmp;\n\t} while (pos);\n\n\treturn last;\n}\n\nstatic struct cgroup_subsys_state *\ncss_leftmost_descendant(struct cgroup_subsys_state *pos)\n{\n\tstruct cgroup_subsys_state *last;\n\n\tdo {\n\t\tlast = pos;\n\t\tpos = css_next_child(NULL, pos);\n\t} while (pos);\n\n\treturn last;\n}\n\n/**\n * css_next_descendant_post - find the next descendant for post-order walk\n * @pos: the current position (%NULL to initiate traversal)\n * @root: css whose descendants to walk\n *\n * To be used by css_for_each_descendant_post().  Find the next descendant\n * to visit for post-order traversal of @root's descendants.  @root is\n * included in the iteration and the last node to be visited.\n *\n * While this function requires cgroup_mutex or RCU read locking, it\n * doesn't require the whole traversal to be contained in a single critical\n * section.  This function will return the correct next descendant as long\n * as both @pos and @cgroup are accessible and @pos is a descendant of\n * @cgroup.\n *\n * If a subsystem synchronizes ->css_online() and the start of iteration, a\n * css which finished ->css_online() is guaranteed to be visible in the\n * future iterations and will stay visible until the last reference is put.\n * A css which hasn't finished ->css_online() or already finished\n * ->css_offline() may show up during traversal.  It's each subsystem's\n * responsibility to synchronize against on/offlining.\n */\nstruct cgroup_subsys_state *\ncss_next_descendant_post(struct cgroup_subsys_state *pos,\n\t\t\t struct cgroup_subsys_state *root)\n{\n\tstruct cgroup_subsys_state *next;\n\n\tcgroup_assert_mutex_or_rcu_locked();\n\n\t/* if first iteration, visit leftmost descendant which may be @root */\n\tif (!pos)\n\t\treturn css_leftmost_descendant(root);\n\n\t/* if we visited @root, we're done */\n\tif (pos == root)\n\t\treturn NULL;\n\n\t/* if there's an unvisited sibling, visit its leftmost descendant */\n\tnext = css_next_child(pos, pos->parent);\n\tif (next)\n\t\treturn css_leftmost_descendant(next);\n\n\t/* no sibling left, visit parent */\n\treturn pos->parent;\n}\n\n/**\n * css_has_online_children - does a css have online children\n * @css: the target css\n *\n * Returns %true if @css has any online children; otherwise, %false.  This\n * function can be called from any context but the caller is responsible\n * for synchronizing against on/offlining as necessary.\n */\nbool css_has_online_children(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys_state *child;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tcss_for_each_child(child, css) {\n\t\tif (child->flags & CSS_ONLINE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic struct css_set *css_task_iter_next_css_set(struct css_task_iter *it)\n{\n\tstruct list_head *l;\n\tstruct cgrp_cset_link *link;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* find the next threaded cset */\n\tif (it->tcset_pos) {\n\t\tl = it->tcset_pos->next;\n\n\t\tif (l != it->tcset_head) {\n\t\t\tit->tcset_pos = l;\n\t\t\treturn container_of(l, struct css_set,\n\t\t\t\t\t    threaded_csets_node);\n\t\t}\n\n\t\tit->tcset_pos = NULL;\n\t}\n\n\t/* find the next cset */\n\tl = it->cset_pos;\n\tl = l->next;\n\tif (l == it->cset_head) {\n\t\tit->cset_pos = NULL;\n\t\treturn NULL;\n\t}\n\n\tif (it->ss) {\n\t\tcset = container_of(l, struct css_set, e_cset_node[it->ss->id]);\n\t} else {\n\t\tlink = list_entry(l, struct cgrp_cset_link, cset_link);\n\t\tcset = link->cset;\n\t}\n\n\tit->cset_pos = l;\n\n\t/* initialize threaded css_set walking */\n\tif (it->flags & CSS_TASK_ITER_THREADED) {\n\t\tif (it->cur_dcset)\n\t\t\tput_css_set_locked(it->cur_dcset);\n\t\tit->cur_dcset = cset;\n\t\tget_css_set(cset);\n\n\t\tit->tcset_head = &cset->threaded_csets;\n\t\tit->tcset_pos = &cset->threaded_csets;\n\t}\n\n\treturn cset;\n}\n\n/**\n * css_task_iter_advance_css_set - advance a task iterator to the next css_set\n * @it: the iterator to advance\n *\n * Advance @it to the next css_set to walk.\n */\nstatic void css_task_iter_advance_css_set(struct css_task_iter *it)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* Advance to the next non-empty css_set and find first non-empty tasks list*/\n\twhile ((cset = css_task_iter_next_css_set(it))) {\n\t\tif (!list_empty(&cset->tasks)) {\n\t\t\tit->cur_tasks_head = &cset->tasks;\n\t\t\tbreak;\n\t\t} else if (!list_empty(&cset->mg_tasks)) {\n\t\t\tit->cur_tasks_head = &cset->mg_tasks;\n\t\t\tbreak;\n\t\t} else if (!list_empty(&cset->dying_tasks)) {\n\t\t\tit->cur_tasks_head = &cset->dying_tasks;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cset) {\n\t\tit->task_pos = NULL;\n\t\treturn;\n\t}\n\tit->task_pos = it->cur_tasks_head->next;\n\n\t/*\n\t * We don't keep css_sets locked across iteration steps and thus\n\t * need to take steps to ensure that iteration can be resumed after\n\t * the lock is re-acquired.  Iteration is performed at two levels -\n\t * css_sets and tasks in them.\n\t *\n\t * Once created, a css_set never leaves its cgroup lists, so a\n\t * pinned css_set is guaranteed to stay put and we can resume\n\t * iteration afterwards.\n\t *\n\t * Tasks may leave @cset across iteration steps.  This is resolved\n\t * by registering each iterator with the css_set currently being\n\t * walked and making css_set_move_task() advance iterators whose\n\t * next task is leaving.\n\t */\n\tif (it->cur_cset) {\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t}\n\tget_css_set(cset);\n\tit->cur_cset = cset;\n\tlist_add(&it->iters_node, &cset->task_iters);\n}"
  },
  {
    "function_name": "cgroup_migrate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2751-2773",
    "snippet": "int cgroup_migrate(struct task_struct *leader, bool threadgroup,\n\t\t   struct cgroup_mgctx *mgctx)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Prevent freeing of tasks while we take a snapshot. Tasks that are\n\t * already PF_EXITING could be freed from underneath us unless we\n\t * take an rcu_read_lock.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_task(task, mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn cgroup_migrate_execute(mgctx);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_migrate_execute",
          "args": [
            "mgctx"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2456-2552",
          "snippet": "static int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t\t/*\n\t\t\t * If the source or destination cgroup is frozen,\n\t\t\t * the task might require to change its state.\n\t\t\t */\n\t\t\tcgroup_freezer_migrate_task(task, from_cset->dfl_cgrp,\n\t\t\t\t\t\t    to_cset->dfl_cgrp);\n\t\t\tput_css_set_locked(from_cset);\n\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t\t/*\n\t\t\t * If the source or destination cgroup is frozen,\n\t\t\t * the task might require to change its state.\n\t\t\t */\n\t\t\tcgroup_freezer_migrate_task(task, from_cset->dfl_cgrp,\n\t\t\t\t\t\t    to_cset->dfl_cgrp);\n\t\t\tput_css_set_locked(from_cset);\n\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "leader",
            "task"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_migrate_add_task",
          "args": [
            "task",
            "mgctx"
          ],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_migrate_add_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2356-2383",
          "snippet": "static void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* cgroup_threadgroup_rwsem protects racing against forks */\n\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* cgroup_threadgroup_rwsem protects racing against forks */\n\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nint cgroup_migrate(struct task_struct *leader, bool threadgroup,\n\t\t   struct cgroup_mgctx *mgctx)\n{\n\tstruct task_struct *task;\n\n\t/*\n\t * Prevent freeing of tasks while we take a snapshot. Tasks that are\n\t * already PF_EXITING could be freed from underneath us unless we\n\t * take an rcu_read_lock.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\ttask = leader;\n\tdo {\n\t\tcgroup_migrate_add_task(task, mgctx);\n\t\tif (!threadgroup)\n\t\t\tbreak;\n\t} while_each_thread(leader, task);\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn cgroup_migrate_execute(mgctx);\n}"
  },
  {
    "function_name": "cgroup_migrate_prepare_dst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2684-2731",
    "snippet": "int cgroup_migrate_prepare_dst(struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *src_cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* look up the dst cset for each src cset and link it to src */\n\tlist_for_each_entry_safe(src_cset, tmp_cset, &mgctx->preloaded_src_csets,\n\t\t\t\t mg_preload_node) {\n\t\tstruct css_set *dst_cset;\n\t\tstruct cgroup_subsys *ss;\n\t\tint ssid;\n\n\t\tdst_cset = find_css_set(src_cset, src_cset->mg_dst_cgrp);\n\t\tif (!dst_cset)\n\t\t\treturn -ENOMEM;\n\n\t\tWARN_ON_ONCE(src_cset->mg_dst_cset || dst_cset->mg_dst_cset);\n\n\t\t/*\n\t\t * If src cset equals dst, it's noop.  Drop the src.\n\t\t * cgroup_migrate() will skip the cset too.  Note that we\n\t\t * can't handle src == dst as some nodes are used by both.\n\t\t */\n\t\tif (src_cset == dst_cset) {\n\t\t\tsrc_cset->mg_src_cgrp = NULL;\n\t\t\tsrc_cset->mg_dst_cgrp = NULL;\n\t\t\tlist_del_init(&src_cset->mg_preload_node);\n\t\t\tput_css_set(src_cset);\n\t\t\tput_css_set(dst_cset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc_cset->mg_dst_cset = dst_cset;\n\n\t\tif (list_empty(&dst_cset->mg_preload_node))\n\t\t\tlist_add_tail(&dst_cset->mg_preload_node,\n\t\t\t\t      &mgctx->preloaded_dst_csets);\n\t\telse\n\t\t\tput_css_set(dst_cset);\n\n\t\tfor_each_subsys(ss, ssid)\n\t\t\tif (src_cset->subsys[ssid] != dst_cset->subsys[ssid])\n\t\t\t\tmgctx->ss_mask |= 1 << ssid;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "dst_cset"
          ],
          "line": 2723
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "955-990",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int css_set_count\t= 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&dst_cset->mg_preload_node",
            "&mgctx->preloaded_dst_csets"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dst_cset->mg_preload_node"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&src_cset->mg_preload_node"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "src_cset->mg_dst_cset || dst_cset->mg_dst_cset"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_css_set",
          "args": [
            "src_cset",
            "src_cset->mg_dst_cgrp"
          ],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "find_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1200-1301",
          "snippet": "static struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->dying_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_root_count;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int css_set_count\t= 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nstatic struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->dying_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "src_cset",
            "tmp_cset",
            "&mgctx->preloaded_src_csets",
            "mg_preload_node"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nint cgroup_migrate_prepare_dst(struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *src_cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* look up the dst cset for each src cset and link it to src */\n\tlist_for_each_entry_safe(src_cset, tmp_cset, &mgctx->preloaded_src_csets,\n\t\t\t\t mg_preload_node) {\n\t\tstruct css_set *dst_cset;\n\t\tstruct cgroup_subsys *ss;\n\t\tint ssid;\n\n\t\tdst_cset = find_css_set(src_cset, src_cset->mg_dst_cgrp);\n\t\tif (!dst_cset)\n\t\t\treturn -ENOMEM;\n\n\t\tWARN_ON_ONCE(src_cset->mg_dst_cset || dst_cset->mg_dst_cset);\n\n\t\t/*\n\t\t * If src cset equals dst, it's noop.  Drop the src.\n\t\t * cgroup_migrate() will skip the cset too.  Note that we\n\t\t * can't handle src == dst as some nodes are used by both.\n\t\t */\n\t\tif (src_cset == dst_cset) {\n\t\t\tsrc_cset->mg_src_cgrp = NULL;\n\t\t\tsrc_cset->mg_dst_cgrp = NULL;\n\t\t\tlist_del_init(&src_cset->mg_preload_node);\n\t\t\tput_css_set(src_cset);\n\t\t\tput_css_set(dst_cset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsrc_cset->mg_dst_cset = dst_cset;\n\n\t\tif (list_empty(&dst_cset->mg_preload_node))\n\t\t\tlist_add_tail(&dst_cset->mg_preload_node,\n\t\t\t\t      &mgctx->preloaded_dst_csets);\n\t\telse\n\t\t\tput_css_set(dst_cset);\n\n\t\tfor_each_subsys(ss, ssid)\n\t\t\tif (src_cset->subsys[ssid] != dst_cset->subsys[ssid])\n\t\t\t\tmgctx->ss_mask |= 1 << ssid;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_migrate_add_src",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2637-2668",
    "snippet": "void cgroup_migrate_add_src(struct css_set *src_cset,\n\t\t\t    struct cgroup *dst_cgrp,\n\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup *src_cgrp;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If ->dead, @src_set is associated with one or more dead cgroups\n\t * and doesn't contain any migratable tasks.  Ignore it early so\n\t * that the rest of migration path doesn't get confused by it.\n\t */\n\tif (src_cset->dead)\n\t\treturn;\n\n\tif (!list_empty(&src_cset->mg_preload_node))\n\t\treturn;\n\n\tsrc_cgrp = cset_cgroup_from_root(src_cset, dst_cgrp->root);\n\n\tWARN_ON(src_cset->mg_src_cgrp);\n\tWARN_ON(src_cset->mg_dst_cgrp);\n\tWARN_ON(!list_empty(&src_cset->mg_tasks));\n\tWARN_ON(!list_empty(&src_cset->mg_node));\n\n\tsrc_cset->mg_src_cgrp = src_cgrp;\n\tsrc_cset->mg_dst_cgrp = dst_cgrp;\n\tget_css_set(src_cset);\n\tlist_add_tail(&src_cset->mg_preload_node, &mgctx->preloaded_src_csets);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&src_cset->mg_preload_node",
            "&mgctx->preloaded_src_csets"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "src_cset"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "219-222",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&src_cset->mg_node)"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&src_cset->mg_node"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&src_cset->mg_tasks)"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&src_cset->mg_tasks"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "src_cset->mg_dst_cgrp"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "src_cset->mg_src_cgrp"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cset_cgroup_from_root",
          "args": [
            "src_cset",
            "dst_cgrp->root"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "cset_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1417-1444",
          "snippet": "static struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\n\nstatic struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&src_cset->mg_preload_node"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_migrate_add_src(struct css_set *src_cset,\n\t\t\t    struct cgroup *dst_cgrp,\n\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup *src_cgrp;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * If ->dead, @src_set is associated with one or more dead cgroups\n\t * and doesn't contain any migratable tasks.  Ignore it early so\n\t * that the rest of migration path doesn't get confused by it.\n\t */\n\tif (src_cset->dead)\n\t\treturn;\n\n\tif (!list_empty(&src_cset->mg_preload_node))\n\t\treturn;\n\n\tsrc_cgrp = cset_cgroup_from_root(src_cset, dst_cgrp->root);\n\n\tWARN_ON(src_cset->mg_src_cgrp);\n\tWARN_ON(src_cset->mg_dst_cgrp);\n\tWARN_ON(!list_empty(&src_cset->mg_tasks));\n\tWARN_ON(!list_empty(&src_cset->mg_node));\n\n\tsrc_cset->mg_src_cgrp = src_cgrp;\n\tsrc_cset->mg_dst_cgrp = dst_cgrp;\n\tget_css_set(src_cset);\n\tlist_add_tail(&src_cset->mg_preload_node, &mgctx->preloaded_src_csets);\n}"
  },
  {
    "function_name": "cgroup_migrate_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2598-2619",
    "snippet": "void cgroup_migrate_finish(struct cgroup_mgctx *mgctx)\n{\n\tLIST_HEAD(preloaded);\n\tstruct css_set *cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_splice_tail_init(&mgctx->preloaded_src_csets, &preloaded);\n\tlist_splice_tail_init(&mgctx->preloaded_dst_csets, &preloaded);\n\n\tlist_for_each_entry_safe(cset, tmp_cset, &preloaded, mg_preload_node) {\n\t\tcset->mg_src_cgrp = NULL;\n\t\tcset->mg_dst_cgrp = NULL;\n\t\tcset->mg_dst_cset = NULL;\n\t\tlist_del_init(&cset->mg_preload_node);\n\t\tput_css_set_locked(cset);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_css_set_locked",
          "args": [
            "cset"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "955-990",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int css_set_count\t= 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cset->mg_preload_node"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "cset",
            "tmp_cset",
            "&preloaded",
            "mg_preload_node"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&mgctx->preloaded_dst_csets",
            "&preloaded"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&mgctx->preloaded_src_csets",
            "&preloaded"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "preloaded"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_migrate_finish(struct cgroup_mgctx *mgctx)\n{\n\tLIST_HEAD(preloaded);\n\tstruct css_set *cset, *tmp_cset;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_splice_tail_init(&mgctx->preloaded_src_csets, &preloaded);\n\tlist_splice_tail_init(&mgctx->preloaded_dst_csets, &preloaded);\n\n\tlist_for_each_entry_safe(cset, tmp_cset, &preloaded, mg_preload_node) {\n\t\tcset->mg_src_cgrp = NULL;\n\t\tcset->mg_dst_cgrp = NULL;\n\t\tcset->mg_dst_cset = NULL;\n\t\tlist_del_init(&cset->mg_preload_node);\n\t\tput_css_set_locked(cset);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n}"
  },
  {
    "function_name": "cgroup_migrate_vet_dst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2563-2589",
    "snippet": "int cgroup_migrate_vet_dst(struct cgroup *dst_cgrp)\n{\n\t/* v1 doesn't have any restriction */\n\tif (!cgroup_on_dfl(dst_cgrp))\n\t\treturn 0;\n\n\t/* verify @dst_cgrp can host resources */\n\tif (!cgroup_is_valid_domain(dst_cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(dst_cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @dst_cgrp is already or can become a thread root or is\n\t * threaded, it doesn't matter.\n\t */\n\tif (cgroup_can_be_thread_root(dst_cgrp) || cgroup_is_threaded(dst_cgrp))\n\t\treturn 0;\n\n\t/* apply no-internal-process constraint */\n\tif (dst_cgrp->subtree_control)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "dst_cgrp"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "354-357",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_can_be_thread_root",
          "args": [
            "dst_cgrp"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_can_be_thread_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "371-390",
          "snippet": "static bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_mixable",
          "args": [
            "dst_cgrp"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_mixable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "360-368",
          "snippet": "static bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_valid_domain",
          "args": [
            "dst_cgrp->dom_cgrp"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_valid_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "415-430",
          "snippet": "static bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "dst_cgrp"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "313-316",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nint cgroup_migrate_vet_dst(struct cgroup *dst_cgrp)\n{\n\t/* v1 doesn't have any restriction */\n\tif (!cgroup_on_dfl(dst_cgrp))\n\t\treturn 0;\n\n\t/* verify @dst_cgrp can host resources */\n\tif (!cgroup_is_valid_domain(dst_cgrp->dom_cgrp))\n\t\treturn -EOPNOTSUPP;\n\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(dst_cgrp))\n\t\treturn 0;\n\n\t/*\n\t * If @dst_cgrp is already or can become a thread root or is\n\t * threaded, it doesn't matter.\n\t */\n\tif (cgroup_can_be_thread_root(dst_cgrp) || cgroup_is_threaded(dst_cgrp))\n\t\treturn 0;\n\n\t/* apply no-internal-process constraint */\n\tif (dst_cgrp->subtree_control)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_migrate_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2456-2552",
    "snippet": "static int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t\t/*\n\t\t\t * If the source or destination cgroup is frozen,\n\t\t\t * the task might require to change its state.\n\t\t\t */\n\t\t\tcgroup_freezer_migrate_task(task, from_cset->dfl_cgrp,\n\t\t\t\t\t\t    to_cset->dfl_cgrp);\n\t\t\tput_css_set_locked(from_cset);\n\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cset->mg_node"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&cset->mg_tasks",
            "&cset->tasks"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "cset",
            "tmp_cset",
            "&tset->src_csets",
            "mg_node"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&tset->dst_csets",
            "&tset->src_csets"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->cancel_attach",
          "args": [
            "tset"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "mgctx->ss_mask"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->attach",
          "args": [
            "tset"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "mgctx->ss_mask"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_css_set_locked",
          "args": [
            "from_cset"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "955-990",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int css_set_count\t= 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_freezer_migrate_task",
          "args": [
            "task",
            "from_cset->dfl_cgrp",
            "to_cset->dfl_cgrp"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_freezer_migrate_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/freezer.c",
          "lines": "222-258",
          "snippet": "void cgroup_freezer_migrate_task(struct task_struct *task,\n\t\t\t\t struct cgroup *src, struct cgroup *dst)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * Kernel threads are not supposed to be frozen at all.\n\t */\n\tif (task->flags & PF_KTHREAD)\n\t\treturn;\n\n\t/*\n\t * It's not necessary to do changes if both of the src and dst cgroups\n\t * are not freezing and task is not frozen.\n\t */\n\tif (!test_bit(CGRP_FREEZE, &src->flags) &&\n\t    !test_bit(CGRP_FREEZE, &dst->flags) &&\n\t    !task->frozen)\n\t\treturn;\n\n\t/*\n\t * Adjust counters of freezing and frozen tasks.\n\t * Note, that if the task is frozen, but the destination cgroup is not\n\t * frozen, we bump both counters to keep them balanced.\n\t */\n\tif (task->frozen) {\n\t\tcgroup_inc_frozen_cnt(dst);\n\t\tcgroup_dec_frozen_cnt(src);\n\t}\n\tcgroup_update_frozen(dst);\n\tcgroup_update_frozen(src);\n\n\t/*\n\t * Force the task to the desired state.\n\t */\n\tcgroup_freeze_task(task, test_bit(CGRP_FREEZE, &dst->flags));\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_freezer_migrate_task(struct task_struct *task,\n\t\t\t\t struct cgroup *src, struct cgroup *dst)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\t/*\n\t * Kernel threads are not supposed to be frozen at all.\n\t */\n\tif (task->flags & PF_KTHREAD)\n\t\treturn;\n\n\t/*\n\t * It's not necessary to do changes if both of the src and dst cgroups\n\t * are not freezing and task is not frozen.\n\t */\n\tif (!test_bit(CGRP_FREEZE, &src->flags) &&\n\t    !test_bit(CGRP_FREEZE, &dst->flags) &&\n\t    !task->frozen)\n\t\treturn;\n\n\t/*\n\t * Adjust counters of freezing and frozen tasks.\n\t * Note, that if the task is frozen, but the destination cgroup is not\n\t * frozen, we bump both counters to keep them balanced.\n\t */\n\tif (task->frozen) {\n\t\tcgroup_inc_frozen_cnt(dst);\n\t\tcgroup_dec_frozen_cnt(src);\n\t}\n\tcgroup_update_frozen(dst);\n\tcgroup_update_frozen(src);\n\n\t/*\n\t * Force the task to the desired state.\n\t */\n\tcgroup_freeze_task(task, test_bit(CGRP_FREEZE, &dst->flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_set_move_task",
          "args": [
            "task",
            "from_cset",
            "to_cset",
            "true"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_move_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "900-932",
          "snippet": "static void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\tcss_set_skip_task_iters(from_cset, task);\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit()/cgroup_free() dropping the css_set.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\tcss_set_skip_task_iters(from_cset, task);\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit()/cgroup_free() dropping the css_set.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "to_cset"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "219-222",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "task"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "task",
            "tmp_task",
            "&cset->mg_tasks",
            "cg_list"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cset",
            "&tset->src_csets",
            "mg_node"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->can_attach",
          "args": [
            "tset"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "mgctx->ss_mask"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic int cgroup_migrate_execute(struct cgroup_mgctx *mgctx)\n{\n\tstruct cgroup_taskset *tset = &mgctx->tset;\n\tstruct cgroup_subsys *ss;\n\tstruct task_struct *task, *tmp_task;\n\tstruct css_set *cset, *tmp_cset;\n\tint ssid, failed_ssid, ret;\n\n\t/* check that we can legitimately attach to the cgroup */\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->can_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tret = ss->can_attach(tset);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfailed_ssid = ssid;\n\t\t\t\t\tgoto out_cancel_attach;\n\t\t\t\t}\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\t/*\n\t * Now that we're guaranteed success, proceed to move all tasks to\n\t * the new cgroup.  There are no failure cases after here, so this\n\t * is the commit point.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(cset, &tset->src_csets, mg_node) {\n\t\tlist_for_each_entry_safe(task, tmp_task, &cset->mg_tasks, cg_list) {\n\t\t\tstruct css_set *from_cset = task_css_set(task);\n\t\t\tstruct css_set *to_cset = cset->mg_dst_cset;\n\n\t\t\tget_css_set(to_cset);\n\t\t\tto_cset->nr_tasks++;\n\t\t\tcss_set_move_task(task, from_cset, to_cset, true);\n\t\t\tfrom_cset->nr_tasks--;\n\t\t\t/*\n\t\t\t * If the source or destination cgroup is frozen,\n\t\t\t * the task might require to change its state.\n\t\t\t */\n\t\t\tcgroup_freezer_migrate_task(task, from_cset->dfl_cgrp,\n\t\t\t\t\t\t    to_cset->dfl_cgrp);\n\t\t\tput_css_set_locked(from_cset);\n\n\t\t}\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Migration is committed, all target tasks are now on dst_csets.\n\t * Nothing is sensitive to fork() after this point.  Notify\n\t * controllers that migration is complete.\n\t */\n\ttset->csets = &tset->dst_csets;\n\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ss->attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\n\n\tret = 0;\n\tgoto out_release_tset;\n\nout_cancel_attach:\n\tif (tset->nr_tasks) {\n\t\tdo_each_subsys_mask(ss, ssid, mgctx->ss_mask) {\n\t\t\tif (ssid == failed_ssid)\n\t\t\t\tbreak;\n\t\t\tif (ss->cancel_attach) {\n\t\t\t\ttset->ssid = ssid;\n\t\t\t\tss->cancel_attach(tset);\n\t\t\t}\n\t\t} while_each_subsys_mask();\n\t}\nout_release_tset:\n\tspin_lock_irq(&css_set_lock);\n\tlist_splice_init(&tset->dst_csets, &tset->src_csets);\n\tlist_for_each_entry_safe(cset, tmp_cset, &tset->src_csets, mg_node) {\n\t\tlist_splice_tail_init(&cset->mg_tasks, &cset->tasks);\n\t\tlist_del_init(&cset->mg_node);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * Re-initialize the cgroup_taskset structure in case it is reused\n\t * again in another cgroup_migrate_add_task()/cgroup_migrate_execute()\n\t * iteration.\n\t */\n\ttset->nr_tasks = 0;\n\ttset->csets    = &tset->src_csets;\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_taskset_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2409-2445",
    "snippet": "struct task_struct *cgroup_taskset_next(struct cgroup_taskset *tset,\n\t\t\t\t\tstruct cgroup_subsys_state **dst_cssp)\n{\n\tstruct css_set *cset = tset->cur_cset;\n\tstruct task_struct *task = tset->cur_task;\n\n\twhile (CGROUP_HAS_SUBSYS_CONFIG && &cset->mg_node != tset->csets) {\n\t\tif (!task)\n\t\t\ttask = list_first_entry(&cset->mg_tasks,\n\t\t\t\t\t\tstruct task_struct, cg_list);\n\t\telse\n\t\t\ttask = list_next_entry(task, cg_list);\n\n\t\tif (&task->cg_list != &cset->mg_tasks) {\n\t\t\ttset->cur_cset = cset;\n\t\t\ttset->cur_task = task;\n\n\t\t\t/*\n\t\t\t * This function may be called both before and\n\t\t\t * after cgroup_taskset_migrate().  The two cases\n\t\t\t * can be distinguished by looking at whether @cset\n\t\t\t * has its ->mg_dst_cset set.\n\t\t\t */\n\t\t\tif (cset->mg_dst_cset)\n\t\t\t\t*dst_cssp = cset->mg_dst_cset->subsys[tset->ssid];\n\t\t\telse\n\t\t\t\t*dst_cssp = cset->subsys[tset->ssid];\n\n\t\t\treturn task;\n\t\t}\n\n\t\tcset = list_next_entry(cset, mg_node);\n\t\ttask = NULL;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
    ],
    "globals_used": [
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "cset",
            "mg_node"
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "task",
            "cg_list"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&cset->mg_tasks",
            "structtask_struct",
            "cg_list"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstruct task_struct *cgroup_taskset_next(struct cgroup_taskset *tset,\n\t\t\t\t\tstruct cgroup_subsys_state **dst_cssp)\n{\n\tstruct css_set *cset = tset->cur_cset;\n\tstruct task_struct *task = tset->cur_task;\n\n\twhile (CGROUP_HAS_SUBSYS_CONFIG && &cset->mg_node != tset->csets) {\n\t\tif (!task)\n\t\t\ttask = list_first_entry(&cset->mg_tasks,\n\t\t\t\t\t\tstruct task_struct, cg_list);\n\t\telse\n\t\t\ttask = list_next_entry(task, cg_list);\n\n\t\tif (&task->cg_list != &cset->mg_tasks) {\n\t\t\ttset->cur_cset = cset;\n\t\t\ttset->cur_task = task;\n\n\t\t\t/*\n\t\t\t * This function may be called both before and\n\t\t\t * after cgroup_taskset_migrate().  The two cases\n\t\t\t * can be distinguished by looking at whether @cset\n\t\t\t * has its ->mg_dst_cset set.\n\t\t\t */\n\t\t\tif (cset->mg_dst_cset)\n\t\t\t\t*dst_cssp = cset->mg_dst_cset->subsys[tset->ssid];\n\t\t\telse\n\t\t\t\t*dst_cssp = cset->subsys[tset->ssid];\n\n\t\t\treturn task;\n\t\t}\n\n\t\tcset = list_next_entry(cset, mg_node);\n\t\ttask = NULL;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "cgroup_taskset_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2392-2399",
    "snippet": "struct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,\n\t\t\t\t\t struct cgroup_subsys_state **dst_cssp)\n{\n\ttset->cur_cset = list_first_entry(tset->csets, struct css_set, mg_node);\n\ttset->cur_task = NULL;\n\n\treturn cgroup_taskset_next(tset, dst_cssp);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_taskset_next",
          "args": [
            "tset",
            "dst_cssp"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_taskset_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2409-2445",
          "snippet": "struct task_struct *cgroup_taskset_next(struct cgroup_taskset *tset,\n\t\t\t\t\tstruct cgroup_subsys_state **dst_cssp)\n{\n\tstruct css_set *cset = tset->cur_cset;\n\tstruct task_struct *task = tset->cur_task;\n\n\twhile (CGROUP_HAS_SUBSYS_CONFIG && &cset->mg_node != tset->csets) {\n\t\tif (!task)\n\t\t\ttask = list_first_entry(&cset->mg_tasks,\n\t\t\t\t\t\tstruct task_struct, cg_list);\n\t\telse\n\t\t\ttask = list_next_entry(task, cg_list);\n\n\t\tif (&task->cg_list != &cset->mg_tasks) {\n\t\t\ttset->cur_cset = cset;\n\t\t\ttset->cur_task = task;\n\n\t\t\t/*\n\t\t\t * This function may be called both before and\n\t\t\t * after cgroup_taskset_migrate().  The two cases\n\t\t\t * can be distinguished by looking at whether @cset\n\t\t\t * has its ->mg_dst_cset set.\n\t\t\t */\n\t\t\tif (cset->mg_dst_cset)\n\t\t\t\t*dst_cssp = cset->mg_dst_cset->subsys[tset->ssid];\n\t\t\telse\n\t\t\t\t*dst_cssp = cset->subsys[tset->ssid];\n\n\t\t\treturn task;\n\t\t}\n\n\t\tcset = list_next_entry(cset, mg_node);\n\t\ttask = NULL;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstruct task_struct *cgroup_taskset_next(struct cgroup_taskset *tset,\n\t\t\t\t\tstruct cgroup_subsys_state **dst_cssp)\n{\n\tstruct css_set *cset = tset->cur_cset;\n\tstruct task_struct *task = tset->cur_task;\n\n\twhile (CGROUP_HAS_SUBSYS_CONFIG && &cset->mg_node != tset->csets) {\n\t\tif (!task)\n\t\t\ttask = list_first_entry(&cset->mg_tasks,\n\t\t\t\t\t\tstruct task_struct, cg_list);\n\t\telse\n\t\t\ttask = list_next_entry(task, cg_list);\n\n\t\tif (&task->cg_list != &cset->mg_tasks) {\n\t\t\ttset->cur_cset = cset;\n\t\t\ttset->cur_task = task;\n\n\t\t\t/*\n\t\t\t * This function may be called both before and\n\t\t\t * after cgroup_taskset_migrate().  The two cases\n\t\t\t * can be distinguished by looking at whether @cset\n\t\t\t * has its ->mg_dst_cset set.\n\t\t\t */\n\t\t\tif (cset->mg_dst_cset)\n\t\t\t\t*dst_cssp = cset->mg_dst_cset->subsys[tset->ssid];\n\t\t\telse\n\t\t\t\t*dst_cssp = cset->subsys[tset->ssid];\n\n\t\t\treturn task;\n\t\t}\n\n\t\tcset = list_next_entry(cset, mg_node);\n\t\ttask = NULL;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "tset->csets",
            "structcss_set",
            "mg_node"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,\n\t\t\t\t\t struct cgroup_subsys_state **dst_cssp)\n{\n\ttset->cur_cset = list_first_entry(tset->csets, struct css_set, mg_node);\n\ttset->cur_task = NULL;\n\n\treturn cgroup_taskset_next(tset, dst_cssp);\n}"
  },
  {
    "function_name": "cgroup_migrate_add_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2356-2383",
    "snippet": "static void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* cgroup_threadgroup_rwsem protects racing against forks */\n\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cset->mg_dst_cset->mg_node",
            "&mgctx->tset.dst_csets"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cset->mg_dst_cset->mg_node"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cset->mg_node",
            "&mgctx->tset.src_csets"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cset->mg_node"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&task->cg_list",
            "&cset->mg_tasks"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "task"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "list_empty(&task->cg_list)"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&task->cg_list"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void cgroup_migrate_add_task(struct task_struct *task,\n\t\t\t\t    struct cgroup_mgctx *mgctx)\n{\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t/* @task either already exited or can't exit until the end */\n\tif (task->flags & PF_EXITING)\n\t\treturn;\n\n\t/* cgroup_threadgroup_rwsem protects racing against forks */\n\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\tcset = task_css_set(task);\n\tif (!cset->mg_src_cgrp)\n\t\treturn;\n\n\tmgctx->tset.nr_tasks++;\n\n\tlist_move_tail(&task->cg_list, &cset->mg_tasks);\n\tif (list_empty(&cset->mg_node))\n\t\tlist_add_tail(&cset->mg_node,\n\t\t\t      &mgctx->tset.src_csets);\n\tif (list_empty(&cset->mg_dst_cset->mg_node))\n\t\tlist_add_tail(&cset->mg_dst_cset->mg_node,\n\t\t\t      &mgctx->tset.dst_csets);\n}"
  },
  {
    "function_name": "task_cgroup_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2320-2343",
    "snippet": "int task_cgroup_path(struct task_struct *task, char *buf, size_t buflen)\n{\n\tstruct cgroup_root *root;\n\tstruct cgroup *cgrp;\n\tint hierarchy_id = 1;\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\troot = idr_get_next(&cgroup_hierarchy_idr, &hierarchy_id);\n\n\tif (root) {\n\t\tcgrp = task_cgroup_from_root(task, root);\n\t\tret = cgroup_path_ns_locked(cgrp, buf, buflen, &init_cgroup_ns);\n\t} else {\n\t\t/* if no hierarchy exists, everyone is in \"/\" */\n\t\tret = strlcpy(buf, \"/\", buflen);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(cgroup_hierarchy_idr);",
      "struct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "\"/\"",
            "buflen"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_path_ns_locked",
          "args": [
            "cgrp",
            "buf",
            "buflen",
            "&init_cgroup_ns"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_path_ns_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2282-2288",
          "snippet": "int cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cgroup_from_root",
          "args": [
            "task",
            "root"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "task_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1450-1458",
          "snippet": "struct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold css_set_lock the\n\t * task can't change groups.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstruct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold css_set_lock the\n\t * task can't change groups.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_get_next",
          "args": [
            "&cgroup_hierarchy_idr",
            "&hierarchy_id"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\nstruct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint task_cgroup_path(struct task_struct *task, char *buf, size_t buflen)\n{\n\tstruct cgroup_root *root;\n\tstruct cgroup *cgrp;\n\tint hierarchy_id = 1;\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\troot = idr_get_next(&cgroup_hierarchy_idr, &hierarchy_id);\n\n\tif (root) {\n\t\tcgrp = task_cgroup_from_root(task, root);\n\t\tret = cgroup_path_ns_locked(cgrp, buf, buflen, &init_cgroup_ns);\n\t} else {\n\t\t/* if no hierarchy exists, everyone is in \"/\" */\n\t\tret = strlcpy(buf, \"/\", buflen);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_path_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2290-2304",
    "snippet": "int cgroup_path_ns(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t   struct cgroup_namespace *ns)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\tret = cgroup_path_ns_locked(cgrp, buf, buflen, ns);\n\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_path_ns_locked",
          "args": [
            "cgrp",
            "buf",
            "buflen",
            "ns"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_path_ns_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2282-2288",
          "snippet": "int cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_path_ns(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t   struct cgroup_namespace *ns)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\tret = cgroup_path_ns_locked(cgrp, buf, buflen, ns);\n\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_path_ns_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2282-2288",
    "snippet": "int cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_path_from_node",
          "args": [
            "cgrp->kn",
            "root->kn",
            "buf",
            "buflen"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cset_cgroup_from_root",
          "args": [
            "ns->root_cset",
            "cgrp->root"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "cset_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1417-1444",
          "snippet": "static struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\n\nstatic struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns)\n{\n\tstruct cgroup *root = cset_cgroup_from_root(ns->root_cset, cgrp->root);\n\n\treturn kernfs_path_from_node(cgrp->kn, root->kn, buf, buflen);\n}"
  },
  {
    "function_name": "cpuset_init_fs_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2249-2273",
    "snippet": "static int cpuset_init_fs_context(struct fs_context *fc)\n{\n\tchar *agent = kstrdup(\"/sbin/cpuset_release_agent\", GFP_USER);\n\tstruct cgroup_fs_context *ctx;\n\tint err;\n\n\terr = cgroup_init_fs_context(fc);\n\tif (err) {\n\t\tkfree(agent);\n\t\treturn err;\n\t}\n\n\tfc->ops = &cpuset_fs_context_ops;\n\n\tctx = cgroup_fc2context(fc);\n\tctx->subsys_mask = 1 << cpuset_cgrp_id;\n\tctx->flags |= CGRP_ROOT_NOPREFIX;\n\tctx->release_agent = agent;\n\n\tget_filesystem(&cgroup_fs_type);\n\tput_filesystem(fc->fs_type);\n\tfc->fs_type = &cgroup_fs_type;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct file_system_type cgroup_fs_type = {\n\t.name\t\t\t= \"cgroup\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup1_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_filesystem",
          "args": [
            "fc->fs_type"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_filesystem",
          "args": [
            "&cgroup_fs_type"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_fc2context",
          "args": [
            "fc"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_fc2context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "61-66",
          "snippet": "static inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "agent"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init_fs_context",
          "args": [
            "fc"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_init_fs_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2181-2200",
          "snippet": "static int cgroup_init_fs_context(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(struct cgroup_fs_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ns = current->nsproxy->cgroup_ns;\n\tget_cgroup_ns(ctx->ns);\n\tfc->fs_private = &ctx->kfc;\n\tif (fc->fs_type == &cgroup2_fs_type)\n\t\tfc->ops = &cgroup_fs_context_ops;\n\telse\n\t\tfc->ops = &cgroup1_fs_context_ops;\n\tput_user_ns(fc->user_ns);\n\tfc->user_ns = get_user_ns(ctx->ns->user_ns);\n\tfc->global = true;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type cgroup2_fs_type;",
            "static const struct fs_context_operations cgroup_fs_context_ops = {\n\t.free\t\t= cgroup_fs_context_free,\n\t.parse_param\t= cgroup2_parse_param,\n\t.get_tree\t= cgroup_get_tree,\n\t.reconfigure\t= cgroup_reconfigure,\n};",
            "static const struct fs_context_operations cgroup1_fs_context_ops = {\n\t.free\t\t= cgroup_fs_context_free,\n\t.parse_param\t= cgroup1_parse_param,\n\t.get_tree\t= cgroup1_get_tree,\n\t.reconfigure\t= cgroup1_reconfigure,\n};",
            "static struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct file_system_type cgroup2_fs_type;\nstatic const struct fs_context_operations cgroup_fs_context_ops = {\n\t.free\t\t= cgroup_fs_context_free,\n\t.parse_param\t= cgroup2_parse_param,\n\t.get_tree\t= cgroup_get_tree,\n\t.reconfigure\t= cgroup_reconfigure,\n};\nstatic const struct fs_context_operations cgroup1_fs_context_ops = {\n\t.free\t\t= cgroup_fs_context_free,\n\t.parse_param\t= cgroup1_parse_param,\n\t.get_tree\t= cgroup1_get_tree,\n\t.reconfigure\t= cgroup1_reconfigure,\n};\nstatic struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\n\nstatic int cgroup_init_fs_context(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(struct cgroup_fs_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ns = current->nsproxy->cgroup_ns;\n\tget_cgroup_ns(ctx->ns);\n\tfc->fs_private = &ctx->kfc;\n\tif (fc->fs_type == &cgroup2_fs_type)\n\t\tfc->ops = &cgroup_fs_context_ops;\n\telse\n\t\tfc->ops = &cgroup1_fs_context_ops;\n\tput_user_ns(fc->user_ns);\n\tfc->user_ns = get_user_ns(ctx->ns->user_ns);\n\tfc->global = true;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "\"/sbin/cpuset_release_agent\"",
            "GFP_USER"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct file_system_type cgroup_fs_type = {\n\t.name\t\t\t= \"cgroup\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup1_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\n\nstatic int cpuset_init_fs_context(struct fs_context *fc)\n{\n\tchar *agent = kstrdup(\"/sbin/cpuset_release_agent\", GFP_USER);\n\tstruct cgroup_fs_context *ctx;\n\tint err;\n\n\terr = cgroup_init_fs_context(fc);\n\tif (err) {\n\t\tkfree(agent);\n\t\treturn err;\n\t}\n\n\tfc->ops = &cpuset_fs_context_ops;\n\n\tctx = cgroup_fc2context(fc);\n\tctx->subsys_mask = 1 << cpuset_cgrp_id;\n\tctx->flags |= CGRP_ROOT_NOPREFIX;\n\tctx->release_agent = agent;\n\n\tget_filesystem(&cgroup_fs_type);\n\tput_filesystem(fc->fs_type);\n\tfc->fs_type = &cgroup_fs_type;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2202-2220",
    "snippet": "static void cgroup_kill_sb(struct super_block *sb)\n{\n\tstruct kernfs_root *kf_root = kernfs_root_from_sb(sb);\n\tstruct cgroup_root *root = cgroup_root_from_kf(kf_root);\n\n\t/*\n\t * If @root doesn't have any children, start killing it.\n\t * This prevents new mounts by disabling percpu_ref_tryget_live().\n\t *\n\t * And don't kill the default root.\n\t */\n\tif (list_empty(&root->cgrp.self.children) && root != &cgrp_dfl_root &&\n\t    !percpu_ref_is_dying(&root->cgrp.self.refcnt)) {\n\t\tcgroup_bpf_offline(&root->cgrp);\n\t\tpercpu_ref_kill(&root->cgrp.self.refcnt);\n\t}\n\tcgroup_put(&root->cgrp);\n\tkernfs_kill_sb(sb);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_kill_sb",
          "args": [
            "sb"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "&root->cgrp"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_kill",
          "args": [
            "&root->cgrp.self.refcnt"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_offline",
          "args": [
            "&root->cgrp"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_is_dying",
          "args": [
            "&root->cgrp.self.refcnt"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&root->cgrp.self.children"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_root_from_kf",
          "args": [
            "kf_root"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_root_from_kf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1303-1308",
          "snippet": "struct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_root_from_sb",
          "args": [
            "sb"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_kill_sb(struct super_block *sb)\n{\n\tstruct kernfs_root *kf_root = kernfs_root_from_sb(sb);\n\tstruct cgroup_root *root = cgroup_root_from_kf(kf_root);\n\n\t/*\n\t * If @root doesn't have any children, start killing it.\n\t * This prevents new mounts by disabling percpu_ref_tryget_live().\n\t *\n\t * And don't kill the default root.\n\t */\n\tif (list_empty(&root->cgrp.self.children) && root != &cgrp_dfl_root &&\n\t    !percpu_ref_is_dying(&root->cgrp.self.refcnt)) {\n\t\tcgroup_bpf_offline(&root->cgrp);\n\t\tpercpu_ref_kill(&root->cgrp.self.refcnt);\n\t}\n\tcgroup_put(&root->cgrp);\n\tkernfs_kill_sb(sb);\n}"
  },
  {
    "function_name": "cgroup_init_fs_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2181-2200",
    "snippet": "static int cgroup_init_fs_context(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(struct cgroup_fs_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ns = current->nsproxy->cgroup_ns;\n\tget_cgroup_ns(ctx->ns);\n\tfc->fs_private = &ctx->kfc;\n\tif (fc->fs_type == &cgroup2_fs_type)\n\t\tfc->ops = &cgroup_fs_context_ops;\n\telse\n\t\tfc->ops = &cgroup1_fs_context_ops;\n\tput_user_ns(fc->user_ns);\n\tfc->user_ns = get_user_ns(ctx->ns->user_ns);\n\tfc->global = true;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type cgroup2_fs_type;",
      "static const struct fs_context_operations cgroup_fs_context_ops = {\n\t.free\t\t= cgroup_fs_context_free,\n\t.parse_param\t= cgroup2_parse_param,\n\t.get_tree\t= cgroup_get_tree,\n\t.reconfigure\t= cgroup_reconfigure,\n};",
      "static const struct fs_context_operations cgroup1_fs_context_ops = {\n\t.free\t\t= cgroup_fs_context_free,\n\t.parse_param\t= cgroup1_parse_param,\n\t.get_tree\t= cgroup1_get_tree,\n\t.reconfigure\t= cgroup1_reconfigure,\n};",
      "static struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "ctx->ns->user_ns"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "fc->user_ns"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cgroup_ns",
          "args": [
            "ctx->ns"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct cgroup_fs_context)",
            "GFP_KERNEL"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct file_system_type cgroup2_fs_type;\nstatic const struct fs_context_operations cgroup_fs_context_ops = {\n\t.free\t\t= cgroup_fs_context_free,\n\t.parse_param\t= cgroup2_parse_param,\n\t.get_tree\t= cgroup_get_tree,\n\t.reconfigure\t= cgroup_reconfigure,\n};\nstatic const struct fs_context_operations cgroup1_fs_context_ops = {\n\t.free\t\t= cgroup_fs_context_free,\n\t.parse_param\t= cgroup1_parse_param,\n\t.get_tree\t= cgroup1_get_tree,\n\t.reconfigure\t= cgroup1_reconfigure,\n};\nstatic struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\n\nstatic int cgroup_init_fs_context(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(struct cgroup_fs_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ns = current->nsproxy->cgroup_ns;\n\tget_cgroup_ns(ctx->ns);\n\tfc->fs_private = &ctx->kfc;\n\tif (fc->fs_type == &cgroup2_fs_type)\n\t\tfc->ops = &cgroup_fs_context_ops;\n\telse\n\t\tfc->ops = &cgroup1_fs_context_ops;\n\tput_user_ns(fc->user_ns);\n\tfc->user_ns = get_user_ns(ctx->ns->user_ns);\n\tfc->global = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_get_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2148-2161",
    "snippet": "static int cgroup_get_tree(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tint ret;\n\n\tcgrp_dfl_visible = true;\n\tcgroup_get_live(&cgrp_dfl_root.cgrp);\n\tctx->root = &cgrp_dfl_root;\n\n\tret = cgroup_do_get_tree(fc);\n\tif (!ret)\n\t\tapply_cgroup_root_flags(ctx->flags);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static bool cgrp_dfl_visible;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_cgroup_root_flags",
          "args": [
            "ctx->flags"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "apply_cgroup_root_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1903-1921",
          "snippet": "static void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_LOCAL_EVENTS)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_RECURSIVE_PROT)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "struct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstruct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\n\nstatic void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_LOCAL_EVENTS)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_RECURSIVE_PROT)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_do_get_tree",
          "args": [
            "fc"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_do_get_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "2089-2132",
          "snippet": "int cgroup_do_get_tree(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tint ret;\n\n\tctx->kfc.root = ctx->root->kf_root;\n\tif (fc->fs_type == &cgroup2_fs_type)\n\t\tctx->kfc.magic = CGROUP2_SUPER_MAGIC;\n\telse\n\t\tctx->kfc.magic = CGROUP_SUPER_MAGIC;\n\tret = kernfs_get_tree(fc);\n\n\t/*\n\t * In non-init cgroup namespace, instead of root cgroup's dentry,\n\t * we return the dentry corresponding to the cgroupns->root_cgrp.\n\t */\n\tif (!ret && ctx->ns != &init_cgroup_ns) {\n\t\tstruct dentry *nsdentry;\n\t\tstruct super_block *sb = fc->root->d_sb;\n\t\tstruct cgroup *cgrp;\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tspin_lock_irq(&css_set_lock);\n\n\t\tcgrp = cset_cgroup_from_root(ctx->ns->root_cset, ctx->root);\n\n\t\tspin_unlock_irq(&css_set_lock);\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tnsdentry = kernfs_node_dentry(cgrp->kn, sb);\n\t\tdput(fc->root);\n\t\tif (IS_ERR(nsdentry)) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\tret = PTR_ERR(nsdentry);\n\t\t\tnsdentry = NULL;\n\t\t}\n\t\tfc->root = nsdentry;\n\t}\n\n\tif (!ctx->kfc.new_sb_created)\n\t\tcgroup_put(&ctx->root->cgrp);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};",
            "static struct file_system_type cgroup2_fs_type;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\nstatic struct file_system_type cgroup2_fs_type;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\n\nint cgroup_do_get_tree(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tint ret;\n\n\tctx->kfc.root = ctx->root->kf_root;\n\tif (fc->fs_type == &cgroup2_fs_type)\n\t\tctx->kfc.magic = CGROUP2_SUPER_MAGIC;\n\telse\n\t\tctx->kfc.magic = CGROUP_SUPER_MAGIC;\n\tret = kernfs_get_tree(fc);\n\n\t/*\n\t * In non-init cgroup namespace, instead of root cgroup's dentry,\n\t * we return the dentry corresponding to the cgroupns->root_cgrp.\n\t */\n\tif (!ret && ctx->ns != &init_cgroup_ns) {\n\t\tstruct dentry *nsdentry;\n\t\tstruct super_block *sb = fc->root->d_sb;\n\t\tstruct cgroup *cgrp;\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tspin_lock_irq(&css_set_lock);\n\n\t\tcgrp = cset_cgroup_from_root(ctx->ns->root_cset, ctx->root);\n\n\t\tspin_unlock_irq(&css_set_lock);\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tnsdentry = kernfs_node_dentry(cgrp->kn, sb);\n\t\tdput(fc->root);\n\t\tif (IS_ERR(nsdentry)) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\tret = PTR_ERR(nsdentry);\n\t\t\tnsdentry = NULL;\n\t\t}\n\t\tfc->root = nsdentry;\n\t}\n\n\tif (!ctx->kfc.new_sb_created)\n\t\tcgroup_put(&ctx->root->cgrp);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_get_live",
          "args": [
            "&cgrp_dfl_root.cgrp"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "613-617",
          "snippet": "static void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_fc2context",
          "args": [
            "fc"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_fc2context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "61-66",
          "snippet": "static inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic bool cgrp_dfl_visible;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic int cgroup_get_tree(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tint ret;\n\n\tcgrp_dfl_visible = true;\n\tcgroup_get_live(&cgrp_dfl_root.cgrp);\n\tctx->root = &cgrp_dfl_root;\n\n\tret = cgroup_do_get_tree(fc);\n\tif (!ret)\n\t\tapply_cgroup_root_flags(ctx->flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_fs_context_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2137-2146",
    "snippet": "static void cgroup_fs_context_free(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\n\tkfree(ctx->name);\n\tkfree(ctx->release_agent);\n\tput_cgroup_ns(ctx->ns);\n\tkernfs_free_fs_context(fc);\n\tkfree(ctx);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_free_fs_context",
          "args": [
            "fc"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "ctx->ns"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx->release_agent"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx->name"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_fc2context",
          "args": [
            "fc"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_fc2context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "61-66",
          "snippet": "static inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_fs_context_free(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\n\tkfree(ctx->name);\n\tkfree(ctx->release_agent);\n\tput_cgroup_ns(ctx->ns);\n\tkernfs_free_fs_context(fc);\n\tkfree(ctx);\n}"
  },
  {
    "function_name": "cgroup_do_get_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "2089-2132",
    "snippet": "int cgroup_do_get_tree(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tint ret;\n\n\tctx->kfc.root = ctx->root->kf_root;\n\tif (fc->fs_type == &cgroup2_fs_type)\n\t\tctx->kfc.magic = CGROUP2_SUPER_MAGIC;\n\telse\n\t\tctx->kfc.magic = CGROUP_SUPER_MAGIC;\n\tret = kernfs_get_tree(fc);\n\n\t/*\n\t * In non-init cgroup namespace, instead of root cgroup's dentry,\n\t * we return the dentry corresponding to the cgroupns->root_cgrp.\n\t */\n\tif (!ret && ctx->ns != &init_cgroup_ns) {\n\t\tstruct dentry *nsdentry;\n\t\tstruct super_block *sb = fc->root->d_sb;\n\t\tstruct cgroup *cgrp;\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tspin_lock_irq(&css_set_lock);\n\n\t\tcgrp = cset_cgroup_from_root(ctx->ns->root_cset, ctx->root);\n\n\t\tspin_unlock_irq(&css_set_lock);\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tnsdentry = kernfs_node_dentry(cgrp->kn, sb);\n\t\tdput(fc->root);\n\t\tif (IS_ERR(nsdentry)) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\tret = PTR_ERR(nsdentry);\n\t\t\tnsdentry = NULL;\n\t\t}\n\t\tfc->root = nsdentry;\n\t}\n\n\tif (!ctx->kfc.new_sb_created)\n\t\tcgroup_put(&ctx->root->cgrp);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};",
      "static struct file_system_type cgroup2_fs_type;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "&ctx->root->cgrp"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nsdentry"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nsdentry"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "fc->root"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_node_dentry",
          "args": [
            "cgrp->kn",
            "sb"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cset_cgroup_from_root",
          "args": [
            "ctx->ns->root_cset",
            "ctx->root"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "cset_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1417-1444",
          "snippet": "static struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\n\nstatic struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_tree",
          "args": [
            "fc"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_fc2context",
          "args": [
            "fc"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_fc2context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "61-66",
          "snippet": "static inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\nstatic struct file_system_type cgroup2_fs_type;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct file_system_type cgroup2_fs_type = {\n\t.name\t\t\t= \"cgroup2\",\n\t.init_fs_context\t= cgroup_init_fs_context,\n\t.parameters\t\t= cgroup2_fs_parameters,\n\t.kill_sb\t\t= cgroup_kill_sb,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\n\nint cgroup_do_get_tree(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tint ret;\n\n\tctx->kfc.root = ctx->root->kf_root;\n\tif (fc->fs_type == &cgroup2_fs_type)\n\t\tctx->kfc.magic = CGROUP2_SUPER_MAGIC;\n\telse\n\t\tctx->kfc.magic = CGROUP_SUPER_MAGIC;\n\tret = kernfs_get_tree(fc);\n\n\t/*\n\t * In non-init cgroup namespace, instead of root cgroup's dentry,\n\t * we return the dentry corresponding to the cgroupns->root_cgrp.\n\t */\n\tif (!ret && ctx->ns != &init_cgroup_ns) {\n\t\tstruct dentry *nsdentry;\n\t\tstruct super_block *sb = fc->root->d_sb;\n\t\tstruct cgroup *cgrp;\n\n\t\tmutex_lock(&cgroup_mutex);\n\t\tspin_lock_irq(&css_set_lock);\n\n\t\tcgrp = cset_cgroup_from_root(ctx->ns->root_cset, ctx->root);\n\n\t\tspin_unlock_irq(&css_set_lock);\n\t\tmutex_unlock(&cgroup_mutex);\n\n\t\tnsdentry = kernfs_node_dentry(cgrp->kn, sb);\n\t\tdput(fc->root);\n\t\tif (IS_ERR(nsdentry)) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\tret = PTR_ERR(nsdentry);\n\t\t\tnsdentry = NULL;\n\t\t}\n\t\tfc->root = nsdentry;\n\t}\n\n\tif (!ctx->kfc.new_sb_created)\n\t\tcgroup_put(&ctx->root->cgrp);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_setup_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1986-2087",
    "snippet": "int cgroup_setup_root(struct cgroup_root *root, u16 ss_mask)\n{\n\tLIST_HEAD(tmp_links);\n\tstruct cgroup *root_cgrp = &root->cgrp;\n\tstruct kernfs_syscall_ops *kf_sops;\n\tstruct css_set *cset;\n\tint i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tret = percpu_ref_init(&root_cgrp->self.refcnt, css_release,\n\t\t\t      0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * We're accessing css_set_count without locking css_set_lock here,\n\t * but that's OK - it can only be increased by someone holding\n\t * cgroup_lock, and that's us.  Later rebinding may disable\n\t * controllers on the default hierarchy and thus create new csets,\n\t * which can't be more than the existing ones.  Allocate 2x.\n\t */\n\tret = allocate_cgrp_cset_links(2 * css_set_count, &tmp_links);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tret = cgroup_init_root_id(root);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tkf_sops = root == &cgrp_dfl_root ?\n\t\t&cgroup_kf_syscall_ops : &cgroup1_kf_syscall_ops;\n\n\troot->kf_root = kernfs_create_root(kf_sops,\n\t\t\t\t\t   KERNFS_ROOT_CREATE_DEACTIVATED |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_EXPORTOP |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_USER_XATTR,\n\t\t\t\t\t   root_cgrp);\n\tif (IS_ERR(root->kf_root)) {\n\t\tret = PTR_ERR(root->kf_root);\n\t\tgoto exit_root_id;\n\t}\n\troot_cgrp->kn = root->kf_root->kn;\n\tWARN_ON_ONCE(cgroup_ino(root_cgrp) != 1);\n\troot_cgrp->ancestor_ids[0] = cgroup_id(root_cgrp);\n\n\tret = css_populate_dir(&root_cgrp->self);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = cgroup_rstat_init(root_cgrp);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = rebind_subsystems(root, ss_mask);\n\tif (ret)\n\t\tgoto exit_stats;\n\n\tret = cgroup_bpf_inherit(root_cgrp);\n\tWARN_ON_ONCE(ret);\n\n\ttrace_cgroup_setup_root(root);\n\n\t/*\n\t * There must be no failure case after here, since rebinding takes\n\t * care of subsystems' refcounts, which are explicitly dropped in\n\t * the failure exit path.\n\t */\n\tlist_add(&root->root_list, &cgroup_roots);\n\tcgroup_root_count++;\n\n\t/*\n\t * Link the root cgroup in this hierarchy into all the css_set\n\t * objects.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\thash_for_each(css_set_table, i, cset, hlist) {\n\t\tlink_css_set(&tmp_links, cset, root_cgrp);\n\t\tif (css_set_populated(cset))\n\t\t\tcgroup_update_populated(root_cgrp, true);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tBUG_ON(!list_empty(&root_cgrp->self.children));\n\tBUG_ON(atomic_read(&root->nr_cgrps) != 1);\n\n\tret = 0;\n\tgoto out;\n\nexit_stats:\n\tcgroup_rstat_exit(root_cgrp);\ndestroy_root:\n\tkernfs_destroy_root(root->kf_root);\n\troot->kf_root = NULL;\nexit_root_id:\n\tcgroup_exit_root_id(root);\ncancel_ref:\n\tpercpu_ref_exit(&root_cgrp->self.refcnt);\nout:\n\tfree_cgrp_cset_links(&tmp_links);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_root_count;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static int css_set_count\t= 1;",
      "static struct kernfs_syscall_ops cgroup_kf_syscall_ops;",
      "static struct kernfs_syscall_ops cgroup_kf_syscall_ops = {\n\t.show_options\t\t= cgroup_show_options,\n\t.mkdir\t\t\t= cgroup_mkdir,\n\t.rmdir\t\t\t= cgroup_rmdir,\n\t.show_path\t\t= cgroup_show_path,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cgrp_cset_links",
          "args": [
            "&tmp_links"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgrp_cset_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1125-1133",
          "snippet": "static void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "&root_cgrp->self.refcnt"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_exit_root_id",
          "args": [
            "root"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_exit_root_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1324-1329",
          "snippet": "static void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(cgroup_hierarchy_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\n\nstatic void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_destroy_root",
          "args": [
            "root->kf_root"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_exit",
          "args": [
            "root_cgrp"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "267-284",
          "snippet": "void cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&root->nr_cgrps) != 1"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->nr_cgrps"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&root_cgrp->self.children)"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&root_cgrp->self.children"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_update_populated",
          "args": [
            "root_cgrp",
            "true"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "820-850",
          "snippet": "static void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tTRACE_CGROUP_PATH(notify_populated, cgrp,\n\t\t\t\t  cgroup_is_populated(cgrp));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tTRACE_CGROUP_PATH(notify_populated, cgrp,\n\t\t\t\t  cgroup_is_populated(cgrp));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_set_populated",
          "args": [
            "cset"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "796-801",
          "snippet": "static bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_css_set",
          "args": [
            "&tmp_links",
            "cset",
            "root_cgrp"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "link_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1167-1190",
          "snippet": "static void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in chronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in chronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each",
          "args": [
            "css_set_table",
            "i",
            "cset",
            "hlist"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&root->root_list",
            "&cgroup_roots"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cgroup_setup_root",
          "args": [
            "root"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_inherit",
          "args": [
            "root_cgrp"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rebind_subsystems",
          "args": [
            "root",
            "ss_mask"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "rebind_subsystems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1739-1836",
          "snippet": "int rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\tu16 dfl_disable_ss_mask = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\n\t\t/*\n\t\t * Collect ssid's that need to be disabled from default\n\t\t * hierarchy.\n\t\t */\n\t\tif (ss->root == &cgrp_dfl_root)\n\t\t\tdfl_disable_ss_mask |= 1 << ssid;\n\n\t} while_each_subsys_mask();\n\n\tif (dfl_disable_ss_mask) {\n\t\tstruct cgroup *scgrp = &cgrp_dfl_root.cgrp;\n\n\t\t/*\n\t\t * Controllers from default hierarchy that need to be rebound\n\t\t * are all disabled together in one go.\n\t\t */\n\t\tcgrp_dfl_root.subsys_mask &= ~dfl_disable_ss_mask;\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\t}\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\tif (src_root != &cgrp_dfl_root) {\n\t\t\t/* disable from the source */\n\t\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\t\tcgroup_finalize_control(scgrp, 0);\n\t\t}\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\tif (ss->css_rstat_flush) {\n\t\t\tlist_del_rcu(&css->rstat_css_node);\n\t\t\tlist_add_rcu(&css->rstat_css_node,\n\t\t\t\t     &dcgrp->rstat_css_list);\n\t\t}\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};",
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nint rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\tu16 dfl_disable_ss_mask = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\n\t\t/*\n\t\t * Collect ssid's that need to be disabled from default\n\t\t * hierarchy.\n\t\t */\n\t\tif (ss->root == &cgrp_dfl_root)\n\t\t\tdfl_disable_ss_mask |= 1 << ssid;\n\n\t} while_each_subsys_mask();\n\n\tif (dfl_disable_ss_mask) {\n\t\tstruct cgroup *scgrp = &cgrp_dfl_root.cgrp;\n\n\t\t/*\n\t\t * Controllers from default hierarchy that need to be rebound\n\t\t * are all disabled together in one go.\n\t\t */\n\t\tcgrp_dfl_root.subsys_mask &= ~dfl_disable_ss_mask;\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\t}\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\tif (src_root != &cgrp_dfl_root) {\n\t\t\t/* disable from the source */\n\t\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\t\tcgroup_finalize_control(scgrp, 0);\n\t\t}\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\tif (ss->css_rstat_flush) {\n\t\t\tlist_del_rcu(&css->rstat_css_node);\n\t\t\tlist_add_rcu(&css->rstat_css_node,\n\t\t\t\t     &dcgrp->rstat_css_list);\n\t\t}\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_init",
          "args": [
            "root_cgrp"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "245-265",
          "snippet": "int cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nint cgroup_rstat_init(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\t/* the root cgrp has rstat_cpu preallocated */\n\tif (!cgrp->rstat_cpu) {\n\t\tcgrp->rstat_cpu = alloc_percpu(struct cgroup_rstat_cpu);\n\t\tif (!cgrp->rstat_cpu)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* ->updated_children list is self terminated */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\trstatc->updated_children = cgrp;\n\t\tu64_stats_init(&rstatc->bsync);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_populate_dir",
          "args": [
            "&root_cgrp->self"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "css_populate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1699-1737",
          "snippet": "static int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cftype cgroup_base_files[];",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);",
            "static struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};\n\nstatic int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_id",
          "args": [
            "root_cgrp"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cgroup_ino(root_cgrp) != 1"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_ino",
          "args": [
            "root_cgrp"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root->kf_root"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root->kf_root"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_create_root",
          "args": [
            "kf_sops",
            "KERNFS_ROOT_CREATE_DEACTIVATED |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_EXPORTOP |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_USER_XATTR",
            "root_cgrp"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_init_root_id",
          "args": [
            "root"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_init_root_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1310-1322",
          "snippet": "static int cgroup_init_root_id(struct cgroup_root *root)\n{\n\tint id;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tid = idr_alloc_cyclic(&cgroup_hierarchy_idr, root, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\troot->hierarchy_id = id;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(cgroup_hierarchy_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\n\nstatic int cgroup_init_root_id(struct cgroup_root *root)\n{\n\tint id;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tid = idr_alloc_cyclic(&cgroup_hierarchy_idr, root, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\troot->hierarchy_id = id;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_cgrp_cset_links",
          "args": [
            "2 * css_set_count",
            "&tmp_links"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_cgrp_cset_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1143-1159",
          "snippet": "static int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&root_cgrp->self.refcnt",
            "css_release",
            "0",
            "GFP_KERNEL"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp_links"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic int css_set_count\t= 1;\nstatic struct kernfs_syscall_ops cgroup_kf_syscall_ops;\nstatic struct kernfs_syscall_ops cgroup_kf_syscall_ops = {\n\t.show_options\t\t= cgroup_show_options,\n\t.mkdir\t\t\t= cgroup_mkdir,\n\t.rmdir\t\t\t= cgroup_rmdir,\n\t.show_path\t\t= cgroup_show_path,\n};\n\nint cgroup_setup_root(struct cgroup_root *root, u16 ss_mask)\n{\n\tLIST_HEAD(tmp_links);\n\tstruct cgroup *root_cgrp = &root->cgrp;\n\tstruct kernfs_syscall_ops *kf_sops;\n\tstruct css_set *cset;\n\tint i, ret;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tret = percpu_ref_init(&root_cgrp->self.refcnt, css_release,\n\t\t\t      0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * We're accessing css_set_count without locking css_set_lock here,\n\t * but that's OK - it can only be increased by someone holding\n\t * cgroup_lock, and that's us.  Later rebinding may disable\n\t * controllers on the default hierarchy and thus create new csets,\n\t * which can't be more than the existing ones.  Allocate 2x.\n\t */\n\tret = allocate_cgrp_cset_links(2 * css_set_count, &tmp_links);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tret = cgroup_init_root_id(root);\n\tif (ret)\n\t\tgoto cancel_ref;\n\n\tkf_sops = root == &cgrp_dfl_root ?\n\t\t&cgroup_kf_syscall_ops : &cgroup1_kf_syscall_ops;\n\n\troot->kf_root = kernfs_create_root(kf_sops,\n\t\t\t\t\t   KERNFS_ROOT_CREATE_DEACTIVATED |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_EXPORTOP |\n\t\t\t\t\t   KERNFS_ROOT_SUPPORT_USER_XATTR,\n\t\t\t\t\t   root_cgrp);\n\tif (IS_ERR(root->kf_root)) {\n\t\tret = PTR_ERR(root->kf_root);\n\t\tgoto exit_root_id;\n\t}\n\troot_cgrp->kn = root->kf_root->kn;\n\tWARN_ON_ONCE(cgroup_ino(root_cgrp) != 1);\n\troot_cgrp->ancestor_ids[0] = cgroup_id(root_cgrp);\n\n\tret = css_populate_dir(&root_cgrp->self);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = cgroup_rstat_init(root_cgrp);\n\tif (ret)\n\t\tgoto destroy_root;\n\n\tret = rebind_subsystems(root, ss_mask);\n\tif (ret)\n\t\tgoto exit_stats;\n\n\tret = cgroup_bpf_inherit(root_cgrp);\n\tWARN_ON_ONCE(ret);\n\n\ttrace_cgroup_setup_root(root);\n\n\t/*\n\t * There must be no failure case after here, since rebinding takes\n\t * care of subsystems' refcounts, which are explicitly dropped in\n\t * the failure exit path.\n\t */\n\tlist_add(&root->root_list, &cgroup_roots);\n\tcgroup_root_count++;\n\n\t/*\n\t * Link the root cgroup in this hierarchy into all the css_set\n\t * objects.\n\t */\n\tspin_lock_irq(&css_set_lock);\n\thash_for_each(css_set_table, i, cset, hlist) {\n\t\tlink_css_set(&tmp_links, cset, root_cgrp);\n\t\tif (css_set_populated(cset))\n\t\t\tcgroup_update_populated(root_cgrp, true);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tBUG_ON(!list_empty(&root_cgrp->self.children));\n\tBUG_ON(atomic_read(&root->nr_cgrps) != 1);\n\n\tret = 0;\n\tgoto out;\n\nexit_stats:\n\tcgroup_rstat_exit(root_cgrp);\ndestroy_root:\n\tkernfs_destroy_root(root->kf_root);\n\troot->kf_root = NULL;\nexit_root_id:\n\tcgroup_exit_root_id(root);\ncancel_ref:\n\tpercpu_ref_exit(&root_cgrp->self.refcnt);\nout:\n\tfree_cgrp_cset_links(&tmp_links);\n\treturn ret;\n}"
  },
  {
    "function_name": "init_cgroup_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1967-1984",
    "snippet": "void init_cgroup_root(struct cgroup_fs_context *ctx)\n{\n\tstruct cgroup_root *root = ctx->root;\n\tstruct cgroup *cgrp = &root->cgrp;\n\n\tINIT_LIST_HEAD(&root->root_list);\n\tatomic_set(&root->nr_cgrps, 1);\n\tcgrp->root = root;\n\tinit_cgroup_housekeeping(cgrp);\n\n\troot->flags = ctx->flags;\n\tif (ctx->release_agent)\n\t\tstrscpy(root->release_agent_path, ctx->release_agent, PATH_MAX);\n\tif (ctx->name)\n\t\tstrscpy(root->name, ctx->name, MAX_CGROUP_ROOT_NAMELEN);\n\tif (ctx->cpuset_clone_children)\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &root->cgrp.flags);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CGRP_CPUSET_CLONE_CHILDREN",
            "&root->cgrp.flags"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "root->name",
            "ctx->name",
            "MAX_CGROUP_ROOT_NAMELEN"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "root->release_agent_path",
            "ctx->release_agent",
            "PATH_MAX"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cgroup_housekeeping",
          "args": [
            "cgrp"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "init_cgroup_housekeeping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1942-1965",
          "snippet": "static void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->nr_cgrps",
            "1"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->root_list"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid init_cgroup_root(struct cgroup_fs_context *ctx)\n{\n\tstruct cgroup_root *root = ctx->root;\n\tstruct cgroup *cgrp = &root->cgrp;\n\n\tINIT_LIST_HEAD(&root->root_list);\n\tatomic_set(&root->nr_cgrps, 1);\n\tcgrp->root = root;\n\tinit_cgroup_housekeeping(cgrp);\n\n\troot->flags = ctx->flags;\n\tif (ctx->release_agent)\n\t\tstrscpy(root->release_agent_path, ctx->release_agent, PATH_MAX);\n\tif (ctx->name)\n\t\tstrscpy(root->name, ctx->name, MAX_CGROUP_ROOT_NAMELEN);\n\tif (ctx->cpuset_clone_children)\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &root->cgrp.flags);\n}"
  },
  {
    "function_name": "init_cgroup_housekeeping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1942-1965",
    "snippet": "static void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&cgrp->release_agent_work",
            "cgroup1_release_agent"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&cgrp->offline_waitq"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->e_csets[ssid]"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prev_cputime_init",
          "args": [
            "&cgrp->prev_cputime"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->rstat_css_list"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&cgrp->pidlist_mutex"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->pidlists"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->cset_links"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->self.children"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cgrp->self.sibling"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic void init_cgroup_housekeeping(struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tINIT_LIST_HEAD(&cgrp->self.sibling);\n\tINIT_LIST_HEAD(&cgrp->self.children);\n\tINIT_LIST_HEAD(&cgrp->cset_links);\n\tINIT_LIST_HEAD(&cgrp->pidlists);\n\tmutex_init(&cgrp->pidlist_mutex);\n\tcgrp->self.cgroup = cgrp;\n\tcgrp->self.flags |= CSS_ONLINE;\n\tcgrp->dom_cgrp = cgrp;\n\tcgrp->max_descendants = INT_MAX;\n\tcgrp->max_depth = INT_MAX;\n\tINIT_LIST_HEAD(&cgrp->rstat_css_list);\n\tprev_cputime_init(&cgrp->prev_cputime);\n\n\tfor_each_subsys(ss, ssid)\n\t\tINIT_LIST_HEAD(&cgrp->e_csets[ssid]);\n\n\tinit_waitqueue_head(&cgrp->offline_waitq);\n\tINIT_WORK(&cgrp->release_agent_work, cgroup1_release_agent);\n}"
  },
  {
    "function_name": "cgroup_reconfigure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1934-1940",
    "snippet": "static int cgroup_reconfigure(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\n\tapply_cgroup_root_flags(ctx->flags);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_cgroup_root_flags",
          "args": [
            "ctx->flags"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "apply_cgroup_root_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1903-1921",
          "snippet": "static void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_LOCAL_EVENTS)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_RECURSIVE_PROT)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "struct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstruct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\n\nstatic void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_LOCAL_EVENTS)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_RECURSIVE_PROT)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_fc2context",
          "args": [
            "fc"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_fc2context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "61-66",
          "snippet": "static inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_reconfigure(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\n\tapply_cgroup_root_flags(ctx->flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1923-1932",
    "snippet": "static int cgroup_show_options(struct seq_file *seq, struct kernfs_root *kf_root)\n{\n\tif (cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE)\n\t\tseq_puts(seq, \",nsdelegate\");\n\tif (cgrp_dfl_root.flags & CGRP_ROOT_MEMORY_LOCAL_EVENTS)\n\t\tseq_puts(seq, \",memory_localevents\");\n\tif (cgrp_dfl_root.flags & CGRP_ROOT_MEMORY_RECURSIVE_PROT)\n\t\tseq_puts(seq, \",memory_recursiveprot\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",memory_recursiveprot\""
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",memory_localevents\""
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",nsdelegate\""
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\n\nstatic int cgroup_show_options(struct seq_file *seq, struct kernfs_root *kf_root)\n{\n\tif (cgrp_dfl_root.flags & CGRP_ROOT_NS_DELEGATE)\n\t\tseq_puts(seq, \",nsdelegate\");\n\tif (cgrp_dfl_root.flags & CGRP_ROOT_MEMORY_LOCAL_EVENTS)\n\t\tseq_puts(seq, \",memory_localevents\");\n\tif (cgrp_dfl_root.flags & CGRP_ROOT_MEMORY_RECURSIVE_PROT)\n\t\tseq_puts(seq, \",memory_recursiveprot\");\n\treturn 0;\n}"
  },
  {
    "function_name": "apply_cgroup_root_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1903-1921",
    "snippet": "static void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_LOCAL_EVENTS)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_RECURSIVE_PROT)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "struct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstruct cgroup_namespace init_cgroup_ns = {\n\t.ns.count\t= REFCOUNT_INIT(2),\n\t.user_ns\t= &init_user_ns,\n\t.ns.ops\t\t= &cgroupns_operations,\n\t.ns.inum\t= PROC_CGROUP_INIT_INO,\n\t.root_cset\t= &init_css_set,\n};\n\nstatic void apply_cgroup_root_flags(unsigned int root_flags)\n{\n\tif (current->nsproxy->cgroup_ns == &init_cgroup_ns) {\n\t\tif (root_flags & CGRP_ROOT_NS_DELEGATE)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_NS_DELEGATE;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_NS_DELEGATE;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_LOCAL_EVENTS)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\n\t\tif (root_flags & CGRP_ROOT_MEMORY_RECURSIVE_PROT)\n\t\t\tcgrp_dfl_root.flags |= CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t\telse\n\t\t\tcgrp_dfl_root.flags &= ~CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t}\n}"
  },
  {
    "function_name": "cgroup2_parse_param",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1879-1901",
    "snippet": "static int cgroup2_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tstruct fs_parse_result result;\n\tint opt;\n\n\topt = fs_parse(fc, cgroup2_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_nsdelegate:\n\t\tctx->flags |= CGRP_ROOT_NS_DELEGATE;\n\t\treturn 0;\n\tcase Opt_memory_localevents:\n\t\tctx->flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\t\treturn 0;\n\tcase Opt_memory_recursiveprot:\n\t\tctx->flags |= CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fs_parameter_spec cgroup2_fs_parameters[] = {\n\tfsparam_flag(\"nsdelegate\",\t\tOpt_nsdelegate),\n\tfsparam_flag(\"memory_localevents\",\tOpt_memory_localevents),\n\tfsparam_flag(\"memory_recursiveprot\",\tOpt_memory_recursiveprot),\n\t{}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_parse",
          "args": [
            "fc",
            "cgroup2_fs_parameters",
            "param",
            "&result"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_fc2context",
          "args": [
            "fc"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_fc2context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "61-66",
          "snippet": "static inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic const struct fs_parameter_spec cgroup2_fs_parameters[] = {\n\tfsparam_flag(\"nsdelegate\",\t\tOpt_nsdelegate),\n\tfsparam_flag(\"memory_localevents\",\tOpt_memory_localevents),\n\tfsparam_flag(\"memory_recursiveprot\",\tOpt_memory_recursiveprot),\n\t{}\n};\n\nstatic int cgroup2_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tstruct fs_parse_result result;\n\tint opt;\n\n\topt = fs_parse(fc, cgroup2_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_nsdelegate:\n\t\tctx->flags |= CGRP_ROOT_NS_DELEGATE;\n\t\treturn 0;\n\tcase Opt_memory_localevents:\n\t\tctx->flags |= CGRP_ROOT_MEMORY_LOCAL_EVENTS;\n\t\treturn 0;\n\tcase Opt_memory_recursiveprot:\n\t\tctx->flags |= CGRP_ROOT_MEMORY_RECURSIVE_PROT;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "cgroup_show_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1838-1863",
    "snippet": "int cgroup_show_path(struct seq_file *sf, struct kernfs_node *kf_node,\n\t\t     struct kernfs_root *kf_root)\n{\n\tint len = 0;\n\tchar *buf = NULL;\n\tstruct cgroup_root *kf_cgroot = cgroup_root_from_kf(kf_root);\n\tstruct cgroup *ns_cgroup;\n\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&css_set_lock);\n\tns_cgroup = current_cgns_cgroup_from_root(kf_cgroot);\n\tlen = kernfs_path_from_node(kf_node, ns_cgroup->kn, buf, PATH_MAX);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (len >= PATH_MAX)\n\t\tlen = -ERANGE;\n\telse if (len > 0) {\n\t\tseq_escape(sf, buf, \" \\t\\n\\\\\");\n\t\tlen = 0;\n\t}\n\tkfree(buf);\n\treturn len;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "sf",
            "buf",
            "\" \\t\\n\\\\\""
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_path_from_node",
          "args": [
            "kf_node",
            "ns_cgroup->kn",
            "buf",
            "PATH_MAX"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cgns_cgroup_from_root",
          "args": [
            "kf_cgroot"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "current_cgns_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1383-1414",
          "snippet": "static struct cgroup *\ncurrent_cgns_cgroup_from_root(struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\trcu_read_lock();\n\n\tcset = current->nsproxy->cgroup_ns->root_cset;\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tBUG_ON(!res);\n\treturn res;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\n\nstatic struct cgroup *\ncurrent_cgns_cgroup_from_root(struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\trcu_read_lock();\n\n\tcset = current->nsproxy->cgroup_ns->root_cset;\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tBUG_ON(!res);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PATH_MAX",
            "GFP_KERNEL"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_root_from_kf",
          "args": [
            "kf_root"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_root_from_kf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1303-1308",
          "snippet": "struct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nint cgroup_show_path(struct seq_file *sf, struct kernfs_node *kf_node,\n\t\t     struct kernfs_root *kf_root)\n{\n\tint len = 0;\n\tchar *buf = NULL;\n\tstruct cgroup_root *kf_cgroot = cgroup_root_from_kf(kf_root);\n\tstruct cgroup *ns_cgroup;\n\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&css_set_lock);\n\tns_cgroup = current_cgns_cgroup_from_root(kf_cgroot);\n\tlen = kernfs_path_from_node(kf_node, ns_cgroup->kn, buf, PATH_MAX);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (len >= PATH_MAX)\n\t\tlen = -ERANGE;\n\telse if (len > 0) {\n\t\tseq_escape(sf, buf, \" \\t\\n\\\\\");\n\t\tlen = 0;\n\t}\n\tkfree(buf);\n\treturn len;\n}"
  },
  {
    "function_name": "rebind_subsystems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1739-1836",
    "snippet": "int rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\tu16 dfl_disable_ss_mask = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\n\t\t/*\n\t\t * Collect ssid's that need to be disabled from default\n\t\t * hierarchy.\n\t\t */\n\t\tif (ss->root == &cgrp_dfl_root)\n\t\t\tdfl_disable_ss_mask |= 1 << ssid;\n\n\t} while_each_subsys_mask();\n\n\tif (dfl_disable_ss_mask) {\n\t\tstruct cgroup *scgrp = &cgrp_dfl_root.cgrp;\n\n\t\t/*\n\t\t * Controllers from default hierarchy that need to be rebound\n\t\t * are all disabled together in one go.\n\t\t */\n\t\tcgrp_dfl_root.subsys_mask &= ~dfl_disable_ss_mask;\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\t}\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\tif (src_root != &cgrp_dfl_root) {\n\t\t\t/* disable from the source */\n\t\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\t\tcgroup_finalize_control(scgrp, 0);\n\t\t}\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\tif (ss->css_rstat_flush) {\n\t\t\tlist_del_rcu(&css->rstat_css_node);\n\t\t\tlist_add_rcu(&css->rstat_css_node,\n\t\t\t\t     &dcgrp->rstat_css_list);\n\t\t}\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};",
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_activate",
          "args": [
            "dcgrp->kn"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss->bind",
          "args": [
            "css"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"partial failure to rebind %s controller (err=%d)\\n\"",
            "ss->name",
            "ret"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control",
          "args": [
            "dcgrp"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "cgroup_subsys_on_dfl_key[ssid]"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "cgroup_subsys_on_dfl_key[ssid]"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&css->rstat_css_node",
            "&dcgrp->rstat_css_list"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&css->rstat_css_node"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&cset->e_cset_node[ss->id]",
            "&dcgrp->e_csets[ss->id]"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_for_each",
          "args": [
            "css_set_table",
            "i",
            "cset",
            "hlist"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "dcgrp->subsys[ssid]",
            "css"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "scgrp->subsys[ssid]",
            "NULL"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_finalize_control",
          "args": [
            "scgrp",
            "0"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_apply_control(scgrp)"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control",
          "args": [
            "scgrp"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!css || cgroup_css(dcgrp, ss)"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "dcgrp",
            "ss"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "481-489",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "ss_mask"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_finalize_control",
          "args": [
            "scgrp",
            "0"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cgroup_apply_control(scgrp)"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_apply_control",
          "args": [
            "scgrp"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_next_child",
          "args": [
            "NULL",
            "cgroup_css(&ss->root->cgrp, ss)"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "ss_mask"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nint rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\tu16 dfl_disable_ss_mask = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\n\t\t/*\n\t\t * Collect ssid's that need to be disabled from default\n\t\t * hierarchy.\n\t\t */\n\t\tif (ss->root == &cgrp_dfl_root)\n\t\t\tdfl_disable_ss_mask |= 1 << ssid;\n\n\t} while_each_subsys_mask();\n\n\tif (dfl_disable_ss_mask) {\n\t\tstruct cgroup *scgrp = &cgrp_dfl_root.cgrp;\n\n\t\t/*\n\t\t * Controllers from default hierarchy that need to be rebound\n\t\t * are all disabled together in one go.\n\t\t */\n\t\tcgrp_dfl_root.subsys_mask &= ~dfl_disable_ss_mask;\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\t}\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\tif (src_root != &cgrp_dfl_root) {\n\t\t\t/* disable from the source */\n\t\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\t\tcgroup_finalize_control(scgrp, 0);\n\t\t}\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\tif (ss->css_rstat_flush) {\n\t\t\tlist_del_rcu(&css->rstat_css_node);\n\t\t\tlist_add_rcu(&css->rstat_css_node,\n\t\t\t\t     &dcgrp->rstat_css_list);\n\t\t}\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}"
  },
  {
    "function_name": "css_populate_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1699-1737",
    "snippet": "static int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cftype cgroup_base_files[];",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);",
      "static struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_addrm_files",
          "args": [
            "css",
            "cgrp",
            "cfts",
            "false"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cfts",
            "&css->ss->cfts",
            "node"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_addrm_files",
          "args": [
            "css",
            "cgrp",
            "cfts",
            "true"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cfts",
            "&css->ss->cfts",
            "node"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_addrm_files",
          "args": [
            "&cgrp->self",
            "cgrp",
            "cfts",
            "true"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "313-316",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};\n\nstatic int css_populate_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts, *failed_cfts;\n\tint ret;\n\n\tif ((css->flags & CSS_VISIBLE) || !cgrp->kn)\n\t\treturn 0;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tret = cgroup_addrm_files(&cgrp->self, cgrp, cfts, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\t\tret = cgroup_addrm_files(css, cgrp, cfts, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tfailed_cfts = cfts;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tcss->flags |= CSS_VISIBLE;\n\n\treturn 0;\nerr:\n\tlist_for_each_entry(cfts, &css->ss->cfts, node) {\n\t\tif (cfts == failed_cfts)\n\t\t\tbreak;\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "css_clear_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1670-1691",
    "snippet": "static void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cftype cgroup_base_files[];",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "static int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);",
      "static struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_addrm_files",
          "args": [
            "css",
            "cgrp",
            "cfts",
            "false"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cfts",
            "&css->ss->cfts",
            "node"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_addrm_files",
          "args": [
            "css",
            "cgrp",
            "cfts",
            "false"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "313-316",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cftype cgroup_base_files[];\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int cgroup_addrm_files(struct cgroup_subsys_state *css,\n\t\t\t      struct cgroup *cgrp, struct cftype cfts[],\n\t\t\t      bool is_add);\nstatic struct cftype cgroup_base_files[] = {\n\t{\n\t\t.name = \"cgroup.type\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_type_show,\n\t\t.write = cgroup_type_write,\n\t},\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.file_offset = offsetof(struct cgroup, procs_file),\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_procs_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.threads\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.release = cgroup_procs_release,\n\t\t.seq_start = cgroup_threads_start,\n\t\t.seq_next = cgroup_procs_next,\n\t\t.seq_show = cgroup_procs_show,\n\t\t.write = cgroup_threads_write,\n\t},\n\t{\n\t\t.name = \"cgroup.controllers\",\n\t\t.seq_show = cgroup_controllers_show,\n\t},\n\t{\n\t\t.name = \"cgroup.subtree_control\",\n\t\t.flags = CFTYPE_NS_DELEGATABLE,\n\t\t.seq_show = cgroup_subtree_control_show,\n\t\t.write = cgroup_subtree_control_write,\n\t},\n\t{\n\t\t.name = \"cgroup.events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct cgroup, events_file),\n\t\t.seq_show = cgroup_events_show,\n\t},\n\t{\n\t\t.name = \"cgroup.max.descendants\",\n\t\t.seq_show = cgroup_max_descendants_show,\n\t\t.write = cgroup_max_descendants_write,\n\t},\n\t{\n\t\t.name = \"cgroup.max.depth\",\n\t\t.seq_show = cgroup_max_depth_show,\n\t\t.write = cgroup_max_depth_write,\n\t},\n\t{\n\t\t.name = \"cgroup.stat\",\n\t\t.seq_show = cgroup_stat_show,\n\t},\n\t{\n\t\t.name = \"cgroup.freeze\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cgroup_freeze_show,\n\t\t.write = cgroup_freeze_write,\n\t},\n\t{\n\t\t.name = \"cgroup.kill\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.write = cgroup_kill_write,\n\t},\n\t{\n\t\t.name = \"cpu.stat\",\n\t\t.seq_show = cpu_stat_show,\n\t},\n#ifdef CONFIG_PSI\n\t{\n\t\t.name = \"io.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_io_pressure_show,\n\t\t.write = cgroup_io_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"memory.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_memory_pressure_show,\n\t\t.write = cgroup_memory_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n\t{\n\t\t.name = \"cpu.pressure\",\n\t\t.flags = CFTYPE_PRESSURE,\n\t\t.seq_show = cgroup_cpu_pressure_show,\n\t\t.write = cgroup_cpu_pressure_write,\n\t\t.poll = cgroup_pressure_poll,\n\t\t.release = cgroup_pressure_release,\n\t},\n#endif /* CONFIG_PSI */\n\t{ }\t/* terminate */\n};\n\nstatic void css_clear_dir(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup *cgrp = css->cgroup;\n\tstruct cftype *cfts;\n\n\tif (!(css->flags & CSS_VISIBLE))\n\t\treturn;\n\n\tcss->flags &= ~CSS_VISIBLE;\n\n\tif (!css->ss) {\n\t\tif (cgroup_on_dfl(cgrp))\n\t\t\tcfts = cgroup_base_files;\n\t\telse\n\t\t\tcfts = cgroup1_base_files;\n\n\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t} else {\n\t\tlist_for_each_entry(cfts, &css->ss->cfts, node)\n\t\t\tcgroup_addrm_files(css, cgrp, cfts, false);\n\t}\n}"
  },
  {
    "function_name": "cgroup_rm_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1646-1664",
    "snippet": "static void cgroup_rm_file(struct cgroup *cgrp, const struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_subsys_state *css = cgroup_css(cgrp, cft->ss);\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = NULL;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\n\t\tdel_timer_sync(&cfile->notify_timer);\n\t}\n\n\tkernfs_remove_by_name(cgrp->kn, cgroup_file_name(cgrp, cft, name));\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_file_kn_lock);",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_remove_by_name",
          "args": [
            "cgrp->kn",
            "cgroup_file_name(cgrp, cft, name)"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_name",
          "args": [
            "cgrp",
            "cft",
            "name"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_file_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1488-1504",
          "snippet": "static char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX)) {\n\t\tconst char *dbg = (cft->flags & CFTYPE_DEBUG) ? \".__DEBUG__.\" : \"\";\n\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s%s.%s\",\n\t\t\t dbg, cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\t} else {\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX)) {\n\t\tconst char *dbg = (cft->flags & CFTYPE_DEBUG) ? \".__DEBUG__.\" : \"\";\n\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s%s.%s\",\n\t\t\t dbg, cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\t} else {\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&cfile->notify_timer"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&cgroup_file_kn_lock"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&cgroup_file_kn_lock"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "cgrp",
            "cft->ss"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "481-489",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nstatic DEFINE_SPINLOCK(cgroup_file_kn_lock);\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic void cgroup_rm_file(struct cgroup *cgrp, const struct cftype *cft)\n{\n\tchar name[CGROUP_FILE_NAME_MAX];\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (cft->file_offset) {\n\t\tstruct cgroup_subsys_state *css = cgroup_css(cgrp, cft->ss);\n\t\tstruct cgroup_file *cfile = (void *)css + cft->file_offset;\n\n\t\tspin_lock_irq(&cgroup_file_kn_lock);\n\t\tcfile->kn = NULL;\n\t\tspin_unlock_irq(&cgroup_file_kn_lock);\n\n\t\tdel_timer_sync(&cfile->notify_timer);\n\t}\n\n\tkernfs_remove_by_name(cgrp->kn, cgroup_file_name(cgrp, cft, name));\n}"
  },
  {
    "function_name": "cgroup_kn_lock_live",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1615-1644",
    "snippet": "struct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_kn_unlock",
          "args": [
            "kn"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_kn_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1583-1596",
          "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_dead",
          "args": [
            "cgrp"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "187-190",
          "snippet": "static inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_lock_and_drain_offline",
          "args": [
            "cgrp"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_break_active_protection",
          "args": [
            "kn"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_tryget",
          "args": [
            "cgrp"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cgroup_kn_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1583-1596",
    "snippet": "void cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "cgrp"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_unbreak_active_protection",
          "args": [
            "kn"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}"
  },
  {
    "function_name": "cgroup_calc_subtree_ss_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1541-1571",
    "snippet": "static u16 cgroup_calc_subtree_ss_mask(u16 subtree_control, u16 this_ss_mask)\n{\n\tu16 cur_ss_mask = subtree_control;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcur_ss_mask |= cgrp_dfl_implicit_ss_mask;\n\n\twhile (true) {\n\t\tu16 new_ss_mask = cur_ss_mask;\n\n\t\tdo_each_subsys_mask(ss, ssid, cur_ss_mask) {\n\t\t\tnew_ss_mask |= ss->depends_on;\n\t\t} while_each_subsys_mask();\n\n\t\t/*\n\t\t * Mask out subsystems which aren't available.  This can\n\t\t * happen only if some depended-upon subsystems were bound\n\t\t * to non-default hierarchies.\n\t\t */\n\t\tnew_ss_mask &= this_ss_mask;\n\n\t\tif (new_ss_mask == cur_ss_mask)\n\t\t\tbreak;\n\t\tcur_ss_mask = new_ss_mask;\n\t}\n\n\treturn cur_ss_mask;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 cgrp_dfl_implicit_ss_mask;",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_each_subsys_mask",
          "args": [],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_subsys_mask",
          "args": [
            "ss",
            "ssid",
            "cur_ss_mask"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_implicit_ss_mask;\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic u16 cgroup_calc_subtree_ss_mask(u16 subtree_control, u16 this_ss_mask)\n{\n\tu16 cur_ss_mask = subtree_control;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tcur_ss_mask |= cgrp_dfl_implicit_ss_mask;\n\n\twhile (true) {\n\t\tu16 new_ss_mask = cur_ss_mask;\n\n\t\tdo_each_subsys_mask(ss, ssid, cur_ss_mask) {\n\t\t\tnew_ss_mask |= ss->depends_on;\n\t\t} while_each_subsys_mask();\n\n\t\t/*\n\t\t * Mask out subsystems which aren't available.  This can\n\t\t * happen only if some depended-upon subsystems were bound\n\t\t * to non-default hierarchies.\n\t\t */\n\t\tnew_ss_mask &= this_ss_mask;\n\n\t\tif (new_ss_mask == cur_ss_mask)\n\t\t\tbreak;\n\t\tcur_ss_mask = new_ss_mask;\n\t}\n\n\treturn cur_ss_mask;\n}"
  },
  {
    "function_name": "cgroup_file_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1512-1527",
    "snippet": "static umode_t cgroup_file_mode(const struct cftype *cft)\n{\n\tumode_t mode = 0;\n\n\tif (cft->read_u64 || cft->read_s64 || cft->seq_show)\n\t\tmode |= S_IRUGO;\n\n\tif (cft->write_u64 || cft->write_s64 || cft->write) {\n\t\tif (cft->flags & CFTYPE_WORLD_WRITABLE)\n\t\t\tmode |= S_IWUGO;\n\t\telse\n\t\t\tmode |= S_IWUSR;\n\t}\n\n\treturn mode;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic umode_t cgroup_file_mode(const struct cftype *cft)\n{\n\tumode_t mode = 0;\n\n\tif (cft->read_u64 || cft->read_s64 || cft->seq_show)\n\t\tmode |= S_IRUGO;\n\n\tif (cft->write_u64 || cft->write_s64 || cft->write) {\n\t\tif (cft->flags & CFTYPE_WORLD_WRITABLE)\n\t\t\tmode |= S_IWUGO;\n\t\telse\n\t\t\tmode |= S_IWUSR;\n\t}\n\n\treturn mode;\n}"
  },
  {
    "function_name": "cgroup_file_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1488-1504",
    "snippet": "static char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX)) {\n\t\tconst char *dbg = (cft->flags & CFTYPE_DEBUG) ? \".__DEBUG__.\" : \"\";\n\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s%s.%s\",\n\t\t\t dbg, cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\t} else {\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\t}\n\treturn buf;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)"
    ],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "buf",
            "cft->name",
            "CGROUP_FILE_NAME_MAX"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "CGROUP_FILE_NAME_MAX",
            "\"%s%s.%s\"",
            "dbg",
            "cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name",
            "cft->name"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "313-316",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_FILE_NAME_MAX\t\t(MAX_CGROUP_TYPE_NAMELEN +\t\\\n\t\t\t\t\t MAX_CFTYPE_NAME + 2)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic char *cgroup_file_name(struct cgroup *cgrp, const struct cftype *cft,\n\t\t\t      char *buf)\n{\n\tstruct cgroup_subsys *ss = cft->ss;\n\n\tif (cft->ss && !(cft->flags & CFTYPE_NO_PREFIX) &&\n\t    !(cgrp->root->flags & CGRP_ROOT_NOPREFIX)) {\n\t\tconst char *dbg = (cft->flags & CFTYPE_DEBUG) ? \".__DEBUG__.\" : \"\";\n\n\t\tsnprintf(buf, CGROUP_FILE_NAME_MAX, \"%s%s.%s\",\n\t\t\t dbg, cgroup_on_dfl(cgrp) ? ss->name : ss->legacy_name,\n\t\t\t cft->name);\n\t} else {\n\t\tstrscpy(buf, cft->name, CGROUP_FILE_NAME_MAX);\n\t}\n\treturn buf;\n}"
  },
  {
    "function_name": "task_cgroup_from_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1450-1458",
    "snippet": "struct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold css_set_lock the\n\t * task can't change groups.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cset_cgroup_from_root",
          "args": [
            "task_css_set(task)",
            "root"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "cset_cgroup_from_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1417-1444",
          "snippet": "static struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\n\nstatic struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_set",
          "args": [
            "task"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstruct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root)\n{\n\t/*\n\t * No need to lock the task - since we hold css_set_lock the\n\t * task can't change groups.\n\t */\n\treturn cset_cgroup_from_root(task_css_set(task), root);\n}"
  },
  {
    "function_name": "cset_cgroup_from_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1417-1444",
    "snippet": "static struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!res"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&cset->cgrp_links",
            "cgrp_link"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\n\nstatic struct cgroup *cset_cgroup_from_root(struct css_set *cset,\n\t\t\t\t\t    struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG_ON(!res);\n\treturn res;\n}"
  },
  {
    "function_name": "current_cgns_cgroup_from_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1383-1414",
    "snippet": "static struct cgroup *\ncurrent_cgns_cgroup_from_root(struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\trcu_read_lock();\n\n\tcset = current->nsproxy->cgroup_ns->root_cset;\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tBUG_ON(!res);\n\treturn res;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!res"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&cset->cgrp_links",
            "cgrp_link"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\n\nstatic struct cgroup *\ncurrent_cgns_cgroup_from_root(struct cgroup_root *root)\n{\n\tstruct cgroup *res = NULL;\n\tstruct css_set *cset;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\trcu_read_lock();\n\n\tcset = current->nsproxy->cgroup_ns->root_cset;\n\tif (cset == &init_css_set) {\n\t\tres = &root->cgrp;\n\t} else if (root == &cgrp_dfl_root) {\n\t\tres = cset->dfl_cgrp;\n\t} else {\n\t\tstruct cgrp_cset_link *link;\n\n\t\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\t\tstruct cgroup *c = link->cgrp;\n\n\t\t\tif (c->root == root) {\n\t\t\t\tres = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tBUG_ON(!res);\n\treturn res;\n}"
  },
  {
    "function_name": "cgroup_destroy_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1336-1377",
    "snippet": "static void cgroup_destroy_root(struct cgroup_root *root)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\ttrace_cgroup_destroy_root(root);\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\tBUG_ON(atomic_read(&root->nr_cgrps));\n\tBUG_ON(!list_empty(&cgrp->self.children));\n\n\t/* Rebind all subsystems back to the default hierarchy */\n\tWARN_ON(rebind_subsystems(&cgrp_dfl_root, root->subsys_mask));\n\n\t/*\n\t * Release all the links from cset_links to this hierarchy's\n\t * root cgroup\n\t */\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_for_each_entry_safe(link, tmp_link, &cgrp->cset_links, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tkfree(link);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!list_empty(&root->root_list)) {\n\t\tlist_del(&root->root_list);\n\t\tcgroup_root_count--;\n\t}\n\n\tcgroup_exit_root_id(root);\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tcgroup_rstat_exit(cgrp);\n\tkernfs_destroy_root(root->kf_root);\n\tcgroup_free_root(root);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_root_count;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_free_root",
          "args": [
            "root"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_free_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1331-1334",
          "snippet": "void cgroup_free_root(struct cgroup_root *root)\n{\n\tkfree(root);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_free_root(struct cgroup_root *root)\n{\n\tkfree(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_destroy_root",
          "args": [
            "root->kf_root"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_rstat_exit",
          "args": [
            "cgrp"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_rstat_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/rstat.c",
          "lines": "267-284",
          "snippet": "void cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nstatic void cgroup_base_stat_flush(struct cgroup *cgrp, int cpu);\n\nvoid cgroup_rstat_exit(struct cgroup *cgrp)\n{\n\tint cpu;\n\n\tcgroup_rstat_flush(cgrp);\n\n\t/* sanity check */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cgroup_rstat_cpu *rstatc = cgroup_rstat_cpu(cgrp, cpu);\n\n\t\tif (WARN_ON_ONCE(rstatc->updated_children != cgrp) ||\n\t\t    WARN_ON_ONCE(rstatc->updated_next))\n\t\t\treturn;\n\t}\n\n\tfree_percpu(cgrp->rstat_cpu);\n\tcgrp->rstat_cpu = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_exit_root_id",
          "args": [
            "root"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_exit_root_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1324-1329",
          "snippet": "static void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(cgroup_hierarchy_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\n\nstatic void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&root->root_list"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&root->root_list"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&link->cgrp_link"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&link->cset_link"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "link",
            "tmp_link",
            "&cgrp->cset_links",
            "cset_link"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rebind_subsystems(&cgrp_dfl_root, root->subsys_mask)"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rebind_subsystems",
          "args": [
            "&cgrp_dfl_root",
            "root->subsys_mask"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "rebind_subsystems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1739-1836",
          "snippet": "int rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\tu16 dfl_disable_ss_mask = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\n\t\t/*\n\t\t * Collect ssid's that need to be disabled from default\n\t\t * hierarchy.\n\t\t */\n\t\tif (ss->root == &cgrp_dfl_root)\n\t\t\tdfl_disable_ss_mask |= 1 << ssid;\n\n\t} while_each_subsys_mask();\n\n\tif (dfl_disable_ss_mask) {\n\t\tstruct cgroup *scgrp = &cgrp_dfl_root.cgrp;\n\n\t\t/*\n\t\t * Controllers from default hierarchy that need to be rebound\n\t\t * are all disabled together in one go.\n\t\t */\n\t\tcgrp_dfl_root.subsys_mask &= ~dfl_disable_ss_mask;\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\t}\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\tif (src_root != &cgrp_dfl_root) {\n\t\t\t/* disable from the source */\n\t\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\t\tcgroup_finalize_control(scgrp, 0);\n\t\t}\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\tif (ss->css_rstat_flush) {\n\t\t\tlist_del_rcu(&css->rstat_css_node);\n\t\t\tlist_add_rcu(&css->rstat_css_node,\n\t\t\t\t     &dcgrp->rstat_css_list);\n\t\t}\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};",
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct static_key_true *cgroup_subsys_on_dfl_key[] = {\n#include <linux/cgroup_subsys.h>\n};\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nint rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask)\n{\n\tstruct cgroup *dcgrp = &dst_root->cgrp;\n\tstruct cgroup_subsys *ss;\n\tint ssid, i, ret;\n\tu16 dfl_disable_ss_mask = 0;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\t/*\n\t\t * If @ss has non-root csses attached to it, can't move.\n\t\t * If @ss is an implicit controller, it is exempt from this\n\t\t * rule and can be stolen.\n\t\t */\n\t\tif (css_next_child(NULL, cgroup_css(&ss->root->cgrp, ss)) &&\n\t\t    !ss->implicit_on_dfl)\n\t\t\treturn -EBUSY;\n\n\t\t/* can't move between two non-dummy roots either */\n\t\tif (ss->root != &cgrp_dfl_root && dst_root != &cgrp_dfl_root)\n\t\t\treturn -EBUSY;\n\n\t\t/*\n\t\t * Collect ssid's that need to be disabled from default\n\t\t * hierarchy.\n\t\t */\n\t\tif (ss->root == &cgrp_dfl_root)\n\t\t\tdfl_disable_ss_mask |= 1 << ssid;\n\n\t} while_each_subsys_mask();\n\n\tif (dfl_disable_ss_mask) {\n\t\tstruct cgroup *scgrp = &cgrp_dfl_root.cgrp;\n\n\t\t/*\n\t\t * Controllers from default hierarchy that need to be rebound\n\t\t * are all disabled together in one go.\n\t\t */\n\t\tcgrp_dfl_root.subsys_mask &= ~dfl_disable_ss_mask;\n\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\tcgroup_finalize_control(scgrp, 0);\n\t}\n\n\tdo_each_subsys_mask(ss, ssid, ss_mask) {\n\t\tstruct cgroup_root *src_root = ss->root;\n\t\tstruct cgroup *scgrp = &src_root->cgrp;\n\t\tstruct cgroup_subsys_state *css = cgroup_css(scgrp, ss);\n\t\tstruct css_set *cset;\n\n\t\tWARN_ON(!css || cgroup_css(dcgrp, ss));\n\n\t\tif (src_root != &cgrp_dfl_root) {\n\t\t\t/* disable from the source */\n\t\t\tsrc_root->subsys_mask &= ~(1 << ssid);\n\t\t\tWARN_ON(cgroup_apply_control(scgrp));\n\t\t\tcgroup_finalize_control(scgrp, 0);\n\t\t}\n\n\t\t/* rebind */\n\t\tRCU_INIT_POINTER(scgrp->subsys[ssid], NULL);\n\t\trcu_assign_pointer(dcgrp->subsys[ssid], css);\n\t\tss->root = dst_root;\n\t\tcss->cgroup = dcgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\thash_for_each(css_set_table, i, cset, hlist)\n\t\t\tlist_move_tail(&cset->e_cset_node[ss->id],\n\t\t\t\t       &dcgrp->e_csets[ss->id]);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\tif (ss->css_rstat_flush) {\n\t\t\tlist_del_rcu(&css->rstat_css_node);\n\t\t\tlist_add_rcu(&css->rstat_css_node,\n\t\t\t\t     &dcgrp->rstat_css_list);\n\t\t}\n\n\t\t/* default hierarchy doesn't enable controllers by default */\n\t\tdst_root->subsys_mask |= 1 << ssid;\n\t\tif (dst_root == &cgrp_dfl_root) {\n\t\t\tstatic_branch_enable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t} else {\n\t\t\tdcgrp->subtree_control |= 1 << ssid;\n\t\t\tstatic_branch_disable(cgroup_subsys_on_dfl_key[ssid]);\n\t\t}\n\n\t\tret = cgroup_apply_control(dcgrp);\n\t\tif (ret)\n\t\t\tpr_warn(\"partial failure to rebind %s controller (err=%d)\\n\",\n\t\t\t\tss->name, ret);\n\n\t\tif (ss->bind)\n\t\t\tss->bind(css);\n\t} while_each_subsys_mask();\n\n\tkernfs_activate(dcgrp->kn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&cgrp->self.children)"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cgrp->self.children"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&root->nr_cgrps)"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->nr_cgrps"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_lock_and_drain_offline",
          "args": [
            "&cgrp_dfl_root.cgrp"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cgroup_destroy_root",
          "args": [
            "root"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_destroy_root(struct cgroup_root *root)\n{\n\tstruct cgroup *cgrp = &root->cgrp;\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\ttrace_cgroup_destroy_root(root);\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\tBUG_ON(atomic_read(&root->nr_cgrps));\n\tBUG_ON(!list_empty(&cgrp->self.children));\n\n\t/* Rebind all subsystems back to the default hierarchy */\n\tWARN_ON(rebind_subsystems(&cgrp_dfl_root, root->subsys_mask));\n\n\t/*\n\t * Release all the links from cset_links to this hierarchy's\n\t * root cgroup\n\t */\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_for_each_entry_safe(link, tmp_link, &cgrp->cset_links, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tkfree(link);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!list_empty(&root->root_list)) {\n\t\tlist_del(&root->root_list);\n\t\tcgroup_root_count--;\n\t}\n\n\tcgroup_exit_root_id(root);\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tcgroup_rstat_exit(cgrp);\n\tkernfs_destroy_root(root->kf_root);\n\tcgroup_free_root(root);\n}"
  },
  {
    "function_name": "cgroup_free_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1331-1334",
    "snippet": "void cgroup_free_root(struct cgroup_root *root)\n{\n\tkfree(root);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup_free_root(struct cgroup_root *root)\n{\n\tkfree(root);\n}"
  },
  {
    "function_name": "cgroup_exit_root_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1324-1329",
    "snippet": "static void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(cgroup_hierarchy_idr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&cgroup_hierarchy_idr",
            "root->hierarchy_id"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "342-347",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\n\nstatic void cgroup_exit_root_id(struct cgroup_root *root)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tidr_remove(&cgroup_hierarchy_idr, root->hierarchy_id);\n}"
  },
  {
    "function_name": "cgroup_init_root_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1310-1322",
    "snippet": "static int cgroup_init_root_id(struct cgroup_root *root)\n{\n\tint id;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tid = idr_alloc_cyclic(&cgroup_hierarchy_idr, root, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\troot->hierarchy_id = id;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(cgroup_hierarchy_idr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "&cgroup_hierarchy_idr",
            "root",
            "0",
            "0",
            "GFP_KERNEL"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_IDR(cgroup_hierarchy_idr);\n\nstatic int cgroup_init_root_id(struct cgroup_root *root)\n{\n\tint id;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tid = idr_alloc_cyclic(&cgroup_hierarchy_idr, root, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\troot->hierarchy_id = id;\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_root_from_kf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1303-1308",
    "snippet": "struct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root)\n{\n\tstruct cgroup *root_cgrp = kf_root->kn->priv;\n\n\treturn root_cgrp->root;\n}"
  },
  {
    "function_name": "find_css_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1200-1301",
    "snippet": "static struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->dying_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_root_count;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "static int css_set_count\t= 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cset->threaded_csets_node",
            "&dcset->threaded_csets"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_css_set",
          "args": [
            "cset"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "955-990",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);",
            "static int css_set_count\t= 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_css_set",
          "args": [
            "cset",
            "cset->dfl_cgrp->dom_cgrp"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "find_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1200-1301",
          "snippet": "static struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->dying_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cset->dfl_cgrp"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "354-357",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "css"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cset->e_cset_node[ssid]",
            "&css->cgroup->e_csets[ssid]"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "css_set_table",
            "&cset->hlist",
            "key"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_hash",
          "args": [
            "cset->subsys"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "942-953",
          "snippet": "static unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&tmp_links)"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tmp_links"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_css_set",
          "args": [
            "&tmp_links",
            "cset",
            "c"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "link_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1167-1190",
          "snippet": "static void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in chronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in chronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&old_cset->cgrp_links",
            "cgrp_link"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cset->subsys",
            "template",
            "sizeof(cset->subsys)"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->mg_node"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->mg_preload_node"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->cgrp_links"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&cset->hlist"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->threaded_csets"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->task_iters"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->dying_tasks"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->mg_tasks"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cset->tasks"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&cset->refcount",
            "1"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cset"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_cgrp_cset_links",
          "args": [
            "cgroup_root_count",
            "&tmp_links"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_cgrp_cset_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1143-1159",
          "snippet": "static int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cset)",
            "GFP_KERNEL"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_css_set",
          "args": [
            "cset"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "get_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "219-222",
          "snippet": "static inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_existing_css_set",
          "args": [
            "old_cset",
            "cgrp",
            "template"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "find_existing_css_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1081-1123",
          "snippet": "static struct css_set *find_existing_css_set(struct css_set *old_cset,\n\t\t\t\t\tstruct cgroup *cgrp,\n\t\t\t\t\tstruct cgroup_subsys_state *template[])\n{\n\tstruct cgroup_root *root = cgrp->root;\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tunsigned long key;\n\tint i;\n\n\t/*\n\t * Build the set of subsystem state objects that we want to see in the\n\t * new css_set. While subsystems can change globally, the entries here\n\t * won't change, so no need for locking.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tif (root->subsys_mask & (1UL << i)) {\n\t\t\t/*\n\t\t\t * @ss is in this hierarchy, so we want the\n\t\t\t * effective css from @cgrp.\n\t\t\t */\n\t\t\ttemplate[i] = cgroup_e_css_by_mask(cgrp, ss);\n\t\t} else {\n\t\t\t/*\n\t\t\t * @ss is not in this hierarchy, so we don't want\n\t\t\t * to change the css.\n\t\t\t */\n\t\t\ttemplate[i] = old_cset->subsys[i];\n\t\t}\n\t}\n\n\tkey = css_set_hash(template);\n\thash_for_each_possible(css_set_table, cset, hlist, key) {\n\t\tif (!compare_css_sets(cset, old_cset, cgrp, template))\n\t\t\tcontinue;\n\n\t\t/* This css_set matches what we need */\n\t\treturn cset;\n\t}\n\n\t/* No existing cgroup group matched */\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct css_set *find_existing_css_set(struct css_set *old_cset,\n\t\t\t\t\tstruct cgroup *cgrp,\n\t\t\t\t\tstruct cgroup_subsys_state *template[])\n{\n\tstruct cgroup_root *root = cgrp->root;\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tunsigned long key;\n\tint i;\n\n\t/*\n\t * Build the set of subsystem state objects that we want to see in the\n\t * new css_set. While subsystems can change globally, the entries here\n\t * won't change, so no need for locking.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tif (root->subsys_mask & (1UL << i)) {\n\t\t\t/*\n\t\t\t * @ss is in this hierarchy, so we want the\n\t\t\t * effective css from @cgrp.\n\t\t\t */\n\t\t\ttemplate[i] = cgroup_e_css_by_mask(cgrp, ss);\n\t\t} else {\n\t\t\t/*\n\t\t\t * @ss is not in this hierarchy, so we don't want\n\t\t\t * to change the css.\n\t\t\t */\n\t\t\ttemplate[i] = old_cset->subsys[i];\n\t\t}\n\t}\n\n\tkey = css_set_hash(template);\n\thash_for_each_possible(css_set_table, cset, hlist, key) {\n\t\tif (!compare_css_sets(cset, old_cset, cgrp, template))\n\t\t\tcontinue;\n\n\t\t/* This css_set matches what we need */\n\t\treturn cset;\n\t}\n\n\t/* No existing cgroup group matched */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_root_count;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nstatic struct css_set *find_css_set(struct css_set *old_cset,\n\t\t\t\t    struct cgroup *cgrp)\n{\n\tstruct cgroup_subsys_state *template[CGROUP_SUBSYS_COUNT] = { };\n\tstruct css_set *cset;\n\tstruct list_head tmp_links;\n\tstruct cgrp_cset_link *link;\n\tstruct cgroup_subsys *ss;\n\tunsigned long key;\n\tint ssid;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t/* First see if we already have a cgroup group that matches\n\t * the desired set */\n\tspin_lock_irq(&css_set_lock);\n\tcset = find_existing_css_set(old_cset, cgrp, template);\n\tif (cset)\n\t\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (cset)\n\t\treturn cset;\n\n\tcset = kzalloc(sizeof(*cset), GFP_KERNEL);\n\tif (!cset)\n\t\treturn NULL;\n\n\t/* Allocate all the cgrp_cset_link objects that we'll need */\n\tif (allocate_cgrp_cset_links(cgroup_root_count, &tmp_links) < 0) {\n\t\tkfree(cset);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&cset->refcount, 1);\n\tcset->dom_cset = cset;\n\tINIT_LIST_HEAD(&cset->tasks);\n\tINIT_LIST_HEAD(&cset->mg_tasks);\n\tINIT_LIST_HEAD(&cset->dying_tasks);\n\tINIT_LIST_HEAD(&cset->task_iters);\n\tINIT_LIST_HEAD(&cset->threaded_csets);\n\tINIT_HLIST_NODE(&cset->hlist);\n\tINIT_LIST_HEAD(&cset->cgrp_links);\n\tINIT_LIST_HEAD(&cset->mg_preload_node);\n\tINIT_LIST_HEAD(&cset->mg_node);\n\n\t/* Copy the set of subsystem state objects generated in\n\t * find_existing_css_set() */\n\tmemcpy(cset->subsys, template, sizeof(cset->subsys));\n\n\tspin_lock_irq(&css_set_lock);\n\t/* Add reference counts and links from the new css_set. */\n\tlist_for_each_entry(link, &old_cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tif (c->root == cgrp->root)\n\t\t\tc = cgrp;\n\t\tlink_css_set(&tmp_links, cset, c);\n\t}\n\n\tBUG_ON(!list_empty(&tmp_links));\n\n\tcss_set_count++;\n\n\t/* Add @cset to the hash table */\n\tkey = css_set_hash(cset->subsys);\n\thash_add(css_set_table, &cset->hlist, key);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_subsys_state *css = cset->subsys[ssid];\n\n\t\tlist_add_tail(&cset->e_cset_node[ssid],\n\t\t\t      &css->cgroup->e_csets[ssid]);\n\t\tcss_get(css);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/*\n\t * If @cset should be threaded, look up the matching dom_cset and\n\t * link them up.  We first fully initialize @cset then look for the\n\t * dom_cset.  It's simpler this way and safe as @cset is guaranteed\n\t * to stay empty until we return.\n\t */\n\tif (cgroup_is_threaded(cset->dfl_cgrp)) {\n\t\tstruct css_set *dcset;\n\n\t\tdcset = find_css_set(cset, cset->dfl_cgrp->dom_cgrp);\n\t\tif (!dcset) {\n\t\t\tput_css_set(cset);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tcset->dom_cset = dcset;\n\t\tlist_add_tail(&cset->threaded_csets_node,\n\t\t\t      &dcset->threaded_csets);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\treturn cset;\n}"
  },
  {
    "function_name": "link_css_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1167-1190",
    "snippet": "static void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in chronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_get_live",
          "args": [
            "cgrp"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_live",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "613-617",
          "snippet": "static void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&link->cgrp_link",
            "&cset->cgrp_links"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&link->cset_link",
            "&cgrp->cset_links"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "tmp_links",
            "structcgrp_cset_link",
            "cset_link"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "313-316",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_empty(tmp_links)"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "tmp_links"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void link_css_set(struct list_head *tmp_links, struct css_set *cset,\n\t\t\t struct cgroup *cgrp)\n{\n\tstruct cgrp_cset_link *link;\n\n\tBUG_ON(list_empty(tmp_links));\n\n\tif (cgroup_on_dfl(cgrp))\n\t\tcset->dfl_cgrp = cgrp;\n\n\tlink = list_first_entry(tmp_links, struct cgrp_cset_link, cset_link);\n\tlink->cset = cset;\n\tlink->cgrp = cgrp;\n\n\t/*\n\t * Always add links to the tail of the lists so that the lists are\n\t * in chronological order.\n\t */\n\tlist_move_tail(&link->cset_link, &cgrp->cset_links);\n\tlist_add_tail(&link->cgrp_link, &cset->cgrp_links);\n\n\tif (cgroup_parent(cgrp))\n\t\tcgroup_get_live(cgrp);\n}"
  },
  {
    "function_name": "allocate_cgrp_cset_links",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1143-1159",
    "snippet": "static int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&link->cset_link",
            "tmp_links"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cgrp_cset_links",
          "args": [
            "tmp_links"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "free_cgrp_cset_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1125-1133",
          "snippet": "static void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*link)",
            "GFP_KERNEL"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "tmp_links"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int allocate_cgrp_cset_links(int count, struct list_head *tmp_links)\n{\n\tstruct cgrp_cset_link *link;\n\tint i;\n\n\tINIT_LIST_HEAD(tmp_links);\n\n\tfor (i = 0; i < count; i++) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlist_add(&link->cset_link, tmp_links);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "free_cgrp_cset_links",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1125-1133",
    "snippet": "static void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&link->cset_link"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "link",
            "tmp_link",
            "links_to_free",
            "cset_link"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void free_cgrp_cset_links(struct list_head *links_to_free)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\n\tlist_for_each_entry_safe(link, tmp_link, links_to_free, cset_link) {\n\t\tlist_del(&link->cset_link);\n\t\tkfree(link);\n\t}\n}"
  },
  {
    "function_name": "find_existing_css_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1081-1123",
    "snippet": "static struct css_set *find_existing_css_set(struct css_set *old_cset,\n\t\t\t\t\tstruct cgroup *cgrp,\n\t\t\t\t\tstruct cgroup_subsys_state *template[])\n{\n\tstruct cgroup_root *root = cgrp->root;\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tunsigned long key;\n\tint i;\n\n\t/*\n\t * Build the set of subsystem state objects that we want to see in the\n\t * new css_set. While subsystems can change globally, the entries here\n\t * won't change, so no need for locking.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tif (root->subsys_mask & (1UL << i)) {\n\t\t\t/*\n\t\t\t * @ss is in this hierarchy, so we want the\n\t\t\t * effective css from @cgrp.\n\t\t\t */\n\t\t\ttemplate[i] = cgroup_e_css_by_mask(cgrp, ss);\n\t\t} else {\n\t\t\t/*\n\t\t\t * @ss is not in this hierarchy, so we don't want\n\t\t\t * to change the css.\n\t\t\t */\n\t\t\ttemplate[i] = old_cset->subsys[i];\n\t\t}\n\t}\n\n\tkey = css_set_hash(template);\n\thash_for_each_possible(css_set_table, cset, hlist, key) {\n\t\tif (!compare_css_sets(cset, old_cset, cgrp, template))\n\t\t\tcontinue;\n\n\t\t/* This css_set matches what we need */\n\t\treturn cset;\n\t}\n\n\t/* No existing cgroup group matched */\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "compare_css_sets",
          "args": [
            "cset",
            "old_cset",
            "cgrp",
            "template"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "compare_css_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "1002-1073",
          "snippet": "static bool compare_css_sets(struct css_set *cset,\n\t\t\t     struct css_set *old_cset,\n\t\t\t     struct cgroup *new_cgrp,\n\t\t\t     struct cgroup_subsys_state *template[])\n{\n\tstruct cgroup *new_dfl_cgrp;\n\tstruct list_head *l1, *l2;\n\n\t/*\n\t * On the default hierarchy, there can be csets which are\n\t * associated with the same set of cgroups but different csses.\n\t * Let's first ensure that csses match.\n\t */\n\tif (memcmp(template, cset->subsys, sizeof(cset->subsys)))\n\t\treturn false;\n\n\n\t/* @cset's domain should match the default cgroup's */\n\tif (cgroup_on_dfl(new_cgrp))\n\t\tnew_dfl_cgrp = new_cgrp;\n\telse\n\t\tnew_dfl_cgrp = old_cset->dfl_cgrp;\n\n\tif (new_dfl_cgrp->dom_cgrp != cset->dom_cset->dfl_cgrp)\n\t\treturn false;\n\n\t/*\n\t * Compare cgroup pointers in order to distinguish between\n\t * different cgroups in hierarchies.  As different cgroups may\n\t * share the same effective css, this comparison is always\n\t * necessary.\n\t */\n\tl1 = &cset->cgrp_links;\n\tl2 = &old_cset->cgrp_links;\n\twhile (1) {\n\t\tstruct cgrp_cset_link *link1, *link2;\n\t\tstruct cgroup *cgrp1, *cgrp2;\n\n\t\tl1 = l1->next;\n\t\tl2 = l2->next;\n\t\t/* See if we reached the end - both lists are equal length. */\n\t\tif (l1 == &cset->cgrp_links) {\n\t\t\tBUG_ON(l2 != &old_cset->cgrp_links);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tBUG_ON(l2 == &old_cset->cgrp_links);\n\t\t}\n\t\t/* Locate the cgroups associated with these links. */\n\t\tlink1 = list_entry(l1, struct cgrp_cset_link, cgrp_link);\n\t\tlink2 = list_entry(l2, struct cgrp_cset_link, cgrp_link);\n\t\tcgrp1 = link1->cgrp;\n\t\tcgrp2 = link2->cgrp;\n\t\t/* Hierarchies should be linked in the same order. */\n\t\tBUG_ON(cgrp1->root != cgrp2->root);\n\n\t\t/*\n\t\t * If this hierarchy is the hierarchy of the cgroup\n\t\t * that's changing, then we need to check that this\n\t\t * css_set points to the new cgroup; if it's any other\n\t\t * hierarchy, then this css_set should point to the\n\t\t * same cgroup as the old css_set.\n\t\t */\n\t\tif (cgrp1->root == new_cgrp->root) {\n\t\t\tif (cgrp1 != new_cgrp)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (cgrp1 != cgrp2)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic bool compare_css_sets(struct css_set *cset,\n\t\t\t     struct css_set *old_cset,\n\t\t\t     struct cgroup *new_cgrp,\n\t\t\t     struct cgroup_subsys_state *template[])\n{\n\tstruct cgroup *new_dfl_cgrp;\n\tstruct list_head *l1, *l2;\n\n\t/*\n\t * On the default hierarchy, there can be csets which are\n\t * associated with the same set of cgroups but different csses.\n\t * Let's first ensure that csses match.\n\t */\n\tif (memcmp(template, cset->subsys, sizeof(cset->subsys)))\n\t\treturn false;\n\n\n\t/* @cset's domain should match the default cgroup's */\n\tif (cgroup_on_dfl(new_cgrp))\n\t\tnew_dfl_cgrp = new_cgrp;\n\telse\n\t\tnew_dfl_cgrp = old_cset->dfl_cgrp;\n\n\tif (new_dfl_cgrp->dom_cgrp != cset->dom_cset->dfl_cgrp)\n\t\treturn false;\n\n\t/*\n\t * Compare cgroup pointers in order to distinguish between\n\t * different cgroups in hierarchies.  As different cgroups may\n\t * share the same effective css, this comparison is always\n\t * necessary.\n\t */\n\tl1 = &cset->cgrp_links;\n\tl2 = &old_cset->cgrp_links;\n\twhile (1) {\n\t\tstruct cgrp_cset_link *link1, *link2;\n\t\tstruct cgroup *cgrp1, *cgrp2;\n\n\t\tl1 = l1->next;\n\t\tl2 = l2->next;\n\t\t/* See if we reached the end - both lists are equal length. */\n\t\tif (l1 == &cset->cgrp_links) {\n\t\t\tBUG_ON(l2 != &old_cset->cgrp_links);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tBUG_ON(l2 == &old_cset->cgrp_links);\n\t\t}\n\t\t/* Locate the cgroups associated with these links. */\n\t\tlink1 = list_entry(l1, struct cgrp_cset_link, cgrp_link);\n\t\tlink2 = list_entry(l2, struct cgrp_cset_link, cgrp_link);\n\t\tcgrp1 = link1->cgrp;\n\t\tcgrp2 = link2->cgrp;\n\t\t/* Hierarchies should be linked in the same order. */\n\t\tBUG_ON(cgrp1->root != cgrp2->root);\n\n\t\t/*\n\t\t * If this hierarchy is the hierarchy of the cgroup\n\t\t * that's changing, then we need to check that this\n\t\t * css_set points to the new cgroup; if it's any other\n\t\t * hierarchy, then this css_set should point to the\n\t\t * same cgroup as the old css_set.\n\t\t */\n\t\tif (cgrp1->root == new_cgrp->root) {\n\t\t\tif (cgrp1 != new_cgrp)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (cgrp1 != cgrp2)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "css_set_table",
            "cset",
            "hlist",
            "key"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_hash",
          "args": [
            "template"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "942-953",
          "snippet": "static unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_e_css_by_mask",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_e_css_by_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "523-542",
          "snippet": "static struct cgroup_subsys_state *cgroup_e_css_by_mask(struct cgroup *cgrp,\n\t\t\t\t\t\t\tstruct cgroup_subsys *ss)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!ss)\n\t\treturn &cgrp->self;\n\n\t/*\n\t * This function is used while updating css associations and thus\n\t * can't test the csses directly.  Test ss_mask.\n\t */\n\twhile (!(cgroup_ss_mask(cgrp) & (1 << ss->id))) {\n\t\tcgrp = cgroup_parent(cgrp);\n\t\tif (!cgrp)\n\t\t\treturn NULL;\n\t}\n\n\treturn cgroup_css(cgrp, ss);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup_subsys_state *cgroup_e_css_by_mask(struct cgroup *cgrp,\n\t\t\t\t\t\t\tstruct cgroup_subsys *ss)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!ss)\n\t\treturn &cgrp->self;\n\n\t/*\n\t * This function is used while updating css associations and thus\n\t * can't test the csses directly.  Test ss_mask.\n\t */\n\twhile (!(cgroup_ss_mask(cgrp) & (1 << ss->id))) {\n\t\tcgrp = cgroup_parent(cgrp);\n\t\tif (!cgrp)\n\t\t\treturn NULL;\n\t}\n\n\treturn cgroup_css(cgrp, ss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "i"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct css_set *find_existing_css_set(struct css_set *old_cset,\n\t\t\t\t\tstruct cgroup *cgrp,\n\t\t\t\t\tstruct cgroup_subsys_state *template[])\n{\n\tstruct cgroup_root *root = cgrp->root;\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tunsigned long key;\n\tint i;\n\n\t/*\n\t * Build the set of subsystem state objects that we want to see in the\n\t * new css_set. While subsystems can change globally, the entries here\n\t * won't change, so no need for locking.\n\t */\n\tfor_each_subsys(ss, i) {\n\t\tif (root->subsys_mask & (1UL << i)) {\n\t\t\t/*\n\t\t\t * @ss is in this hierarchy, so we want the\n\t\t\t * effective css from @cgrp.\n\t\t\t */\n\t\t\ttemplate[i] = cgroup_e_css_by_mask(cgrp, ss);\n\t\t} else {\n\t\t\t/*\n\t\t\t * @ss is not in this hierarchy, so we don't want\n\t\t\t * to change the css.\n\t\t\t */\n\t\t\ttemplate[i] = old_cset->subsys[i];\n\t\t}\n\t}\n\n\tkey = css_set_hash(template);\n\thash_for_each_possible(css_set_table, cset, hlist, key) {\n\t\tif (!compare_css_sets(cset, old_cset, cgrp, template))\n\t\t\tcontinue;\n\n\t\t/* This css_set matches what we need */\n\t\treturn cset;\n\t}\n\n\t/* No existing cgroup group matched */\n\treturn NULL;\n}"
  },
  {
    "function_name": "compare_css_sets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "1002-1073",
    "snippet": "static bool compare_css_sets(struct css_set *cset,\n\t\t\t     struct css_set *old_cset,\n\t\t\t     struct cgroup *new_cgrp,\n\t\t\t     struct cgroup_subsys_state *template[])\n{\n\tstruct cgroup *new_dfl_cgrp;\n\tstruct list_head *l1, *l2;\n\n\t/*\n\t * On the default hierarchy, there can be csets which are\n\t * associated with the same set of cgroups but different csses.\n\t * Let's first ensure that csses match.\n\t */\n\tif (memcmp(template, cset->subsys, sizeof(cset->subsys)))\n\t\treturn false;\n\n\n\t/* @cset's domain should match the default cgroup's */\n\tif (cgroup_on_dfl(new_cgrp))\n\t\tnew_dfl_cgrp = new_cgrp;\n\telse\n\t\tnew_dfl_cgrp = old_cset->dfl_cgrp;\n\n\tif (new_dfl_cgrp->dom_cgrp != cset->dom_cset->dfl_cgrp)\n\t\treturn false;\n\n\t/*\n\t * Compare cgroup pointers in order to distinguish between\n\t * different cgroups in hierarchies.  As different cgroups may\n\t * share the same effective css, this comparison is always\n\t * necessary.\n\t */\n\tl1 = &cset->cgrp_links;\n\tl2 = &old_cset->cgrp_links;\n\twhile (1) {\n\t\tstruct cgrp_cset_link *link1, *link2;\n\t\tstruct cgroup *cgrp1, *cgrp2;\n\n\t\tl1 = l1->next;\n\t\tl2 = l2->next;\n\t\t/* See if we reached the end - both lists are equal length. */\n\t\tif (l1 == &cset->cgrp_links) {\n\t\t\tBUG_ON(l2 != &old_cset->cgrp_links);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tBUG_ON(l2 == &old_cset->cgrp_links);\n\t\t}\n\t\t/* Locate the cgroups associated with these links. */\n\t\tlink1 = list_entry(l1, struct cgrp_cset_link, cgrp_link);\n\t\tlink2 = list_entry(l2, struct cgrp_cset_link, cgrp_link);\n\t\tcgrp1 = link1->cgrp;\n\t\tcgrp2 = link2->cgrp;\n\t\t/* Hierarchies should be linked in the same order. */\n\t\tBUG_ON(cgrp1->root != cgrp2->root);\n\n\t\t/*\n\t\t * If this hierarchy is the hierarchy of the cgroup\n\t\t * that's changing, then we need to check that this\n\t\t * css_set points to the new cgroup; if it's any other\n\t\t * hierarchy, then this css_set should point to the\n\t\t * same cgroup as the old css_set.\n\t\t */\n\t\tif (cgrp1->root == new_cgrp->root) {\n\t\t\tif (cgrp1 != new_cgrp)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (cgrp1 != cgrp2)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cgrp1->root != cgrp2->root"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "l2",
            "structcgrp_cset_link",
            "cgrp_link"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "l1",
            "structcgrp_cset_link",
            "cgrp_link"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "l2 == &old_cset->cgrp_links"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "l2 != &old_cset->cgrp_links"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "new_cgrp"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "313-316",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "template",
            "cset->subsys",
            "sizeof(cset->subsys)"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic bool compare_css_sets(struct css_set *cset,\n\t\t\t     struct css_set *old_cset,\n\t\t\t     struct cgroup *new_cgrp,\n\t\t\t     struct cgroup_subsys_state *template[])\n{\n\tstruct cgroup *new_dfl_cgrp;\n\tstruct list_head *l1, *l2;\n\n\t/*\n\t * On the default hierarchy, there can be csets which are\n\t * associated with the same set of cgroups but different csses.\n\t * Let's first ensure that csses match.\n\t */\n\tif (memcmp(template, cset->subsys, sizeof(cset->subsys)))\n\t\treturn false;\n\n\n\t/* @cset's domain should match the default cgroup's */\n\tif (cgroup_on_dfl(new_cgrp))\n\t\tnew_dfl_cgrp = new_cgrp;\n\telse\n\t\tnew_dfl_cgrp = old_cset->dfl_cgrp;\n\n\tif (new_dfl_cgrp->dom_cgrp != cset->dom_cset->dfl_cgrp)\n\t\treturn false;\n\n\t/*\n\t * Compare cgroup pointers in order to distinguish between\n\t * different cgroups in hierarchies.  As different cgroups may\n\t * share the same effective css, this comparison is always\n\t * necessary.\n\t */\n\tl1 = &cset->cgrp_links;\n\tl2 = &old_cset->cgrp_links;\n\twhile (1) {\n\t\tstruct cgrp_cset_link *link1, *link2;\n\t\tstruct cgroup *cgrp1, *cgrp2;\n\n\t\tl1 = l1->next;\n\t\tl2 = l2->next;\n\t\t/* See if we reached the end - both lists are equal length. */\n\t\tif (l1 == &cset->cgrp_links) {\n\t\t\tBUG_ON(l2 != &old_cset->cgrp_links);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tBUG_ON(l2 == &old_cset->cgrp_links);\n\t\t}\n\t\t/* Locate the cgroups associated with these links. */\n\t\tlink1 = list_entry(l1, struct cgrp_cset_link, cgrp_link);\n\t\tlink2 = list_entry(l2, struct cgrp_cset_link, cgrp_link);\n\t\tcgrp1 = link1->cgrp;\n\t\tcgrp2 = link2->cgrp;\n\t\t/* Hierarchies should be linked in the same order. */\n\t\tBUG_ON(cgrp1->root != cgrp2->root);\n\n\t\t/*\n\t\t * If this hierarchy is the hierarchy of the cgroup\n\t\t * that's changing, then we need to check that this\n\t\t * css_set points to the new cgroup; if it's any other\n\t\t * hierarchy, then this css_set should point to the\n\t\t * same cgroup as the old css_set.\n\t\t */\n\t\tif (cgrp1->root == new_cgrp->root) {\n\t\t\tif (cgrp1 != new_cgrp)\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (cgrp1 != cgrp2)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "put_css_set_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "955-990",
    "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "static int css_set_count\t= 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "cset",
            "rcu_head"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_css_set_locked",
          "args": [
            "cset->dom_cset"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "put_css_set_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "955-990",
          "snippet": "void put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cset->threaded_csets_node"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_threaded",
          "args": [
            "cset"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "782-785",
          "snippet": "static bool css_set_threaded(struct css_set *cset)\n{\n\treturn cset->dom_cset != cset;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic bool css_set_threaded(struct css_set *cset)\n{\n\treturn cset->dom_cset != cset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "link->cgrp"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "link->cgrp"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&link->cgrp_link"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&link->cset_link"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "link",
            "tmp_link",
            "&cset->cgrp_links",
            "cgrp_link"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&cset->hlist"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "cset->subsys[ssid]"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cset->e_cset_node[ssid]"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "ssid"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&cset->threaded_csets)"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cset->threaded_csets"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&cset->refcount"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstatic int css_set_count\t= 1;\n\nvoid put_css_set_locked(struct css_set *cset)\n{\n\tstruct cgrp_cset_link *link, *tmp_link;\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (!refcount_dec_and_test(&cset->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&cset->threaded_csets));\n\n\t/* This css_set is dead. Unlink it and release cgroup and css refs */\n\tfor_each_subsys(ss, ssid) {\n\t\tlist_del(&cset->e_cset_node[ssid]);\n\t\tcss_put(cset->subsys[ssid]);\n\t}\n\thash_del(&cset->hlist);\n\tcss_set_count--;\n\n\tlist_for_each_entry_safe(link, tmp_link, &cset->cgrp_links, cgrp_link) {\n\t\tlist_del(&link->cset_link);\n\t\tlist_del(&link->cgrp_link);\n\t\tif (cgroup_parent(link->cgrp))\n\t\t\tcgroup_put(link->cgrp);\n\t\tkfree(link);\n\t}\n\n\tif (css_set_threaded(cset)) {\n\t\tlist_del(&cset->threaded_csets_node);\n\t\tput_css_set_locked(cset->dom_cset);\n\t}\n\n\tkfree_rcu(cset, rcu_head);\n}"
  },
  {
    "function_name": "css_set_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "942-953",
    "snippet": "static unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_subsys",
          "args": [
            "ss",
            "i"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic unsigned long css_set_hash(struct cgroup_subsys_state *css[])\n{\n\tunsigned long key = 0UL;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tfor_each_subsys(ss, i)\n\t\tkey += (unsigned long)css[i];\n\tkey = (key >> 16) ^ key;\n\n\treturn key;\n}"
  },
  {
    "function_name": "css_set_move_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "900-932",
    "snippet": "static void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\tcss_set_skip_task_iters(from_cset, task);\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit()/cgroup_free() dropping the css_set.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&task->cg_list",
            "use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_move_task",
          "args": [
            "task",
            "to_cset"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "task->flags & PF_EXITING"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&task->cg_list)"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&task->cg_list"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_update_populated",
          "args": [
            "from_cset",
            "false"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_update_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "860-868",
          "snippet": "static void css_set_update_populated(struct css_set *cset, bool populated)\n{\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link)\n\t\tcgroup_update_populated(link->cgrp, populated);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void css_set_update_populated(struct css_set *cset, bool populated)\n{\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link)\n\t\tcgroup_update_populated(link->cgrp, populated);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_set_populated",
          "args": [
            "from_cset"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "796-801",
          "snippet": "static bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&task->cg_list"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_set_skip_task_iters",
          "args": [
            "from_cset",
            "task"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "css_set_skip_task_iters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "876-883",
          "snippet": "static void css_set_skip_task_iters(struct css_set *cset,\n\t\t\t\t    struct task_struct *task)\n{\n\tstruct css_task_iter *it, *pos;\n\n\tlist_for_each_entry_safe(it, pos, &cset->task_iters, iters_node)\n\t\tcss_task_iter_skip(it, task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void css_set_skip_task_iters(struct css_set *cset,\n\t\t\t\t    struct task_struct *task)\n{\n\tstruct css_task_iter *it, *pos;\n\n\tlist_for_each_entry_safe(it, pos, &cset->task_iters, iters_node)\n\t\tcss_task_iter_skip(it, task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "list_empty(&task->cg_list)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&task->cg_list"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void css_set_move_task(struct task_struct *task,\n\t\t\t      struct css_set *from_cset, struct css_set *to_cset,\n\t\t\t      bool use_mg_tasks)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (to_cset && !css_set_populated(to_cset))\n\t\tcss_set_update_populated(to_cset, true);\n\n\tif (from_cset) {\n\t\tWARN_ON_ONCE(list_empty(&task->cg_list));\n\n\t\tcss_set_skip_task_iters(from_cset, task);\n\t\tlist_del_init(&task->cg_list);\n\t\tif (!css_set_populated(from_cset))\n\t\t\tcss_set_update_populated(from_cset, false);\n\t} else {\n\t\tWARN_ON_ONCE(!list_empty(&task->cg_list));\n\t}\n\n\tif (to_cset) {\n\t\t/*\n\t\t * We are synchronized through cgroup_threadgroup_rwsem\n\t\t * against PF_EXITING setting such that we can't race\n\t\t * against cgroup_exit()/cgroup_free() dropping the css_set.\n\t\t */\n\t\tWARN_ON_ONCE(task->flags & PF_EXITING);\n\n\t\tcgroup_move_task(task, to_cset);\n\t\tlist_add_tail(&task->cg_list, use_mg_tasks ? &to_cset->mg_tasks :\n\t\t\t\t\t\t\t     &to_cset->tasks);\n\t}\n}"
  },
  {
    "function_name": "css_set_skip_task_iters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "876-883",
    "snippet": "static void css_set_skip_task_iters(struct css_set *cset,\n\t\t\t\t    struct task_struct *task)\n{\n\tstruct css_task_iter *it, *pos;\n\n\tlist_for_each_entry_safe(it, pos, &cset->task_iters, iters_node)\n\t\tcss_task_iter_skip(it, task);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_task_iter_skip",
          "args": [
            "it",
            "task"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "4625-4634",
          "snippet": "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (it->task_pos == &task->cg_list) {\n\t\tit->task_pos = it->task_pos->next;\n\t\tit->flags |= CSS_TASK_ITER_SKIPPED;\n\t}\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\tif (it->task_pos == &task->cg_list) {\n\t\tit->task_pos = it->task_pos->next;\n\t\tit->flags |= CSS_TASK_ITER_SKIPPED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "it",
            "pos",
            "&cset->task_iters",
            "iters_node"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\n\nstatic void css_set_skip_task_iters(struct css_set *cset,\n\t\t\t\t    struct task_struct *task)\n{\n\tstruct css_task_iter *it, *pos;\n\n\tlist_for_each_entry_safe(it, pos, &cset->task_iters, iters_node)\n\t\tcss_task_iter_skip(it, task);\n}"
  },
  {
    "function_name": "css_set_update_populated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "860-868",
    "snippet": "static void css_set_update_populated(struct css_set *cset, bool populated)\n{\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link)\n\t\tcgroup_update_populated(link->cgrp, populated);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_update_populated",
          "args": [
            "link->cgrp",
            "populated"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_update_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "820-850",
          "snippet": "static void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tTRACE_CGROUP_PATH(notify_populated, cgrp,\n\t\t\t\t  cgroup_is_populated(cgrp));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tTRACE_CGROUP_PATH(notify_populated, cgrp,\n\t\t\t\t  cgroup_is_populated(cgrp));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&cset->cgrp_links",
            "cgrp_link"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void css_set_update_populated(struct css_set *cset, bool populated)\n{\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link)\n\t\tcgroup_update_populated(link->cgrp, populated);\n}"
  },
  {
    "function_name": "cgroup_update_populated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "820-850",
    "snippet": "static void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tTRACE_CGROUP_PATH(notify_populated, cgrp,\n\t\t\t\t  cgroup_is_populated(cgrp));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&cgrp->events_file"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE_CGROUP_PATH",
          "args": [
            "notify_populated",
            "cgrp",
            "cgroup_is_populated(cgrp)"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "cgrp"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup1_check_for_release",
          "args": [
            "cgrp"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup1_check_for_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-v1.c",
          "lines": "741-746",
          "snippet": "void cgroup1_check_for_release(struct cgroup *cgrp)\n{\n\tif (notify_on_release(cgrp) && !cgroup_is_populated(cgrp) &&\n\t    !css_has_online_children(&cgrp->self) && !cgroup_is_dead(cgrp))\n\t\tschedule_work(&cgrp->release_agent_work);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/delay.h>",
            "#include <linux/sort.h>",
            "#include <linux/kmod.h>",
            "#include <linux/ctype.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include <linux/fs_parser.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nvoid cgroup1_check_for_release(struct cgroup *cgrp)\n{\n\tif (notify_on_release(cgrp) && !cgroup_is_populated(cgrp) &&\n\t    !css_has_online_children(&cgrp->self) && !cgroup_is_dead(cgrp))\n\t\tschedule_work(&cgrp->release_agent_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "cgrp"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "child"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "354-357",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "cgrp"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_update_populated(struct cgroup *cgrp, bool populated)\n{\n\tstruct cgroup *child = NULL;\n\tint adj = populated ? 1 : -1;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tdo {\n\t\tbool was_populated = cgroup_is_populated(cgrp);\n\n\t\tif (!child) {\n\t\t\tcgrp->nr_populated_csets += adj;\n\t\t} else {\n\t\t\tif (cgroup_is_threaded(child))\n\t\t\t\tcgrp->nr_populated_threaded_children += adj;\n\t\t\telse\n\t\t\t\tcgrp->nr_populated_domain_children += adj;\n\t\t}\n\n\t\tif (was_populated == cgroup_is_populated(cgrp))\n\t\t\tbreak;\n\n\t\tcgroup1_check_for_release(cgrp);\n\t\tTRACE_CGROUP_PATH(notify_populated, cgrp,\n\t\t\t\t  cgroup_is_populated(cgrp));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\n\t\tchild = cgrp;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n}"
  },
  {
    "function_name": "css_set_populated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "796-801",
    "snippet": "static bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cset->mg_tasks"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cset->tasks"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic bool css_set_populated(struct css_set *cset)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\treturn !list_empty(&cset->tasks) || !list_empty(&cset->mg_tasks);\n}"
  },
  {
    "function_name": "css_set_threaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "782-785",
    "snippet": "static bool css_set_threaded(struct css_set *cset)\n{\n\treturn cset->dom_cset != cset;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic bool css_set_threaded(struct css_set *cset)\n{\n\treturn cset->dom_cset != cset;\n}"
  },
  {
    "function_name": "of_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "652-669",
    "snippet": "struct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
    ],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "cgrp->subsys[cft->ss->id]"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}"
  },
  {
    "function_name": "cgroup_task_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "641-650",
    "snippet": "int cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count;\n\n\tspin_lock_irq(&css_set_lock);\n\tcount = __cgroup_task_count(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cgroup_task_count",
          "args": [
            "cgrp"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_task_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "624-635",
          "snippet": "int __cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count = 0;\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tcount += link->cset->nr_tasks;\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint __cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count = 0;\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tcount += link->cset->nr_tasks;\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&css_set_lock"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count;\n\n\tspin_lock_irq(&css_set_lock);\n\tcount = __cgroup_task_count(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "__cgroup_task_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "624-635",
    "snippet": "int __cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count = 0;\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tcount += link->cset->nr_tasks;\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "link",
            "&cgrp->cset_links",
            "cset_link"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&css_set_lock"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint __cgroup_task_count(const struct cgroup *cgrp)\n{\n\tint count = 0;\n\tstruct cgrp_cset_link *link;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\tlist_for_each_entry(link, &cgrp->cset_links, cset_link)\n\t\tcount += link->cset->nr_tasks;\n\n\treturn count;\n}"
  },
  {
    "function_name": "cgroup_get_live",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "613-617",
    "snippet": "static void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "&cgrp->self"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cgroup_is_dead(cgrp)"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_dead",
          "args": [
            "cgrp"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-internal.h",
          "lines": "187-190",
          "snippet": "static inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}",
          "includes": [
            "#include <linux/fs_parser.h>",
            "#include <linux/refcount.h>",
            "#include <linux/list.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kernfs.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_parser.h>\n#include <linux/refcount.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/kernfs.h>\n#include <linux/cgroup.h>\n\nstatic inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic void cgroup_get_live(struct cgroup *cgrp)\n{\n\tWARN_ON_ONCE(cgroup_is_dead(cgrp));\n\tcss_get(&cgrp->self);\n}"
  },
  {
    "function_name": "cgroup_get_e_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "587-610",
    "snippet": "struct cgroup_subsys_state *cgroup_get_e_css(struct cgroup *cgrp,\n\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tif (!CGROUP_HAS_SUBSYS_CONFIG)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcss = cgroup_css(cgrp, ss);\n\n\t\tif (css && css_tryget_online(css))\n\t\t\tgoto out_unlock;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n\n\tcss = init_css_set.subsys[ss->id];\n\tcss_get(css);\nout_unlock:\n\trcu_read_unlock();\n\treturn css;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
    ],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "css"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "css"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "481-489",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\n\nstruct cgroup_subsys_state *cgroup_get_e_css(struct cgroup *cgrp,\n\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tif (!CGROUP_HAS_SUBSYS_CONFIG)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcss = cgroup_css(cgrp, ss);\n\n\t\tif (css && css_tryget_online(css))\n\t\t\tgoto out_unlock;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n\n\tcss = init_css_set.subsys[ss->id];\n\tcss_get(css);\nout_unlock:\n\trcu_read_unlock();\n\treturn css;\n}"
  },
  {
    "function_name": "cgroup_e_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "557-574",
    "snippet": "struct cgroup_subsys_state *cgroup_e_css(struct cgroup *cgrp,\n\t\t\t\t\t struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tif (!CGROUP_HAS_SUBSYS_CONFIG)\n\t\treturn NULL;\n\n\tdo {\n\t\tcss = cgroup_css(cgrp, ss);\n\n\t\tif (css)\n\t\t\treturn css;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n\n\treturn init_css_set.subsys[ss->id];\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
    ],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);",
      "struct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "481-489",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\nstruct css_set init_css_set = {\n\t.refcount\t\t= REFCOUNT_INIT(1),\n\t.dom_cset\t\t= &init_css_set,\n\t.tasks\t\t\t= LIST_HEAD_INIT(init_css_set.tasks),\n\t.mg_tasks\t\t= LIST_HEAD_INIT(init_css_set.mg_tasks),\n\t.dying_tasks\t\t= LIST_HEAD_INIT(init_css_set.dying_tasks),\n\t.task_iters\t\t= LIST_HEAD_INIT(init_css_set.task_iters),\n\t.threaded_csets\t\t= LIST_HEAD_INIT(init_css_set.threaded_csets),\n\t.cgrp_links\t\t= LIST_HEAD_INIT(init_css_set.cgrp_links),\n\t.mg_preload_node\t= LIST_HEAD_INIT(init_css_set.mg_preload_node),\n\t.mg_node\t\t= LIST_HEAD_INIT(init_css_set.mg_node),\n\n\t/*\n\t * The following field is re-initialized when this cset gets linked\n\t * in cgroup_init().  However, let's initialize the field\n\t * statically too so that the default cgroup can be accessed safely\n\t * early during boot.\n\t */\n\t.dfl_cgrp\t\t= &cgrp_dfl_root.cgrp,\n};\n\nstruct cgroup_subsys_state *cgroup_e_css(struct cgroup *cgrp,\n\t\t\t\t\t struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tif (!CGROUP_HAS_SUBSYS_CONFIG)\n\t\treturn NULL;\n\n\tdo {\n\t\tcss = cgroup_css(cgrp, ss);\n\n\t\tif (css)\n\t\t\treturn css;\n\t\tcgrp = cgroup_parent(cgrp);\n\t} while (cgrp);\n\n\treturn init_css_set.subsys[ss->id];\n}"
  },
  {
    "function_name": "cgroup_e_css_by_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "523-542",
    "snippet": "static struct cgroup_subsys_state *cgroup_e_css_by_mask(struct cgroup *cgrp,\n\t\t\t\t\t\t\tstruct cgroup_subsys *ss)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!ss)\n\t\treturn &cgrp->self;\n\n\t/*\n\t * This function is used while updating css associations and thus\n\t * can't test the csses directly.  Test ss_mask.\n\t */\n\twhile (!(cgroup_ss_mask(cgrp) & (1 << ss->id))) {\n\t\tcgrp = cgroup_parent(cgrp);\n\t\tif (!cgrp)\n\t\t\treturn NULL;\n\t}\n\n\treturn cgroup_css(cgrp, ss);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "481-489",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_ss_mask",
          "args": [
            "cgrp"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_ss_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "454-468",
          "snippet": "static u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup_subsys_state *cgroup_e_css_by_mask(struct cgroup *cgrp,\n\t\t\t\t\t\t\tstruct cgroup_subsys *ss)\n{\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tif (!ss)\n\t\treturn &cgrp->self;\n\n\t/*\n\t * This function is used while updating css associations and thus\n\t * can't test the csses directly.  Test ss_mask.\n\t */\n\twhile (!(cgroup_ss_mask(cgrp) & (1 << ss->id))) {\n\t\tcgrp = cgroup_parent(cgrp);\n\t\tif (!cgrp)\n\t\t\treturn NULL;\n\t}\n\n\treturn cgroup_css(cgrp, ss);\n}"
  },
  {
    "function_name": "cgroup_tryget_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "499-511",
    "snippet": "static struct cgroup_subsys_state *cgroup_tryget_css(struct cgroup *cgrp,\n\t\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, ss);\n\tif (css && !css_tryget_online(css))\n\t\tcss = NULL;\n\trcu_read_unlock();\n\n\treturn css;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
      "static void kill_css(struct cgroup_subsys_state *css);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "css"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_css",
          "args": [
            "cgrp",
            "ss"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "481-489",
          "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstatic struct cgroup_subsys_state *cgroup_tryget_css(struct cgroup *cgrp,\n\t\t\t\t\t\t     struct cgroup_subsys *ss)\n{\n\tstruct cgroup_subsys_state *css;\n\n\trcu_read_lock();\n\tcss = cgroup_css(cgrp, ss);\n\tif (css && !css_tryget_online(css))\n\t\tcss = NULL;\n\trcu_read_unlock();\n\n\treturn css;\n}"
  },
  {
    "function_name": "cgroup_css",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "481-489",
    "snippet": "static struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
    ],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);",
      "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "cgrp->subsys[ss->id]",
            "lockdep_is_held(&cgroup_mutex)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&cgroup_mutex"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nstatic struct cgroup_subsys_state *cgroup_css(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss)\n{\n\tif (CGROUP_HAS_SUBSYS_CONFIG && ss)\n\t\treturn rcu_dereference_check(cgrp->subsys[ss->id],\n\t\t\t\t\tlockdep_is_held(&cgroup_mutex));\n\telse\n\t\treturn &cgrp->self;\n}"
  },
  {
    "function_name": "cgroup_ss_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "454-468",
    "snippet": "static u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 cgrp_dfl_threaded_ss_mask;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "354-357",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic u16 cgroup_ss_mask(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_ss_mask;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\treturn cgrp->root->subsys_mask;\n}"
  },
  {
    "function_name": "cgroup_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "433-451",
    "snippet": "static u16 cgroup_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tu16 root_ss_mask = cgrp->root->subsys_mask;\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_control;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\tif (cgroup_on_dfl(cgrp))\n\t\troot_ss_mask &= ~(cgrp_dfl_inhibit_ss_mask |\n\t\t\t\t  cgrp_dfl_implicit_ss_mask);\n\treturn root_ss_mask;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 cgrp_dfl_inhibit_ss_mask;",
      "static u16 cgrp_dfl_implicit_ss_mask;",
      "static u16 cgrp_dfl_threaded_ss_mask;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_on_dfl",
          "args": [
            "cgrp"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_on_dfl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "313-316",
          "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "354-357",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_inhibit_ss_mask;\nstatic u16 cgrp_dfl_implicit_ss_mask;\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic u16 cgroup_control(struct cgroup *cgrp)\n{\n\tstruct cgroup *parent = cgroup_parent(cgrp);\n\tu16 root_ss_mask = cgrp->root->subsys_mask;\n\n\tif (parent) {\n\t\tu16 ss_mask = parent->subtree_control;\n\n\t\t/* threaded cgroups can only have threaded controllers */\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\tss_mask &= cgrp_dfl_threaded_ss_mask;\n\t\treturn ss_mask;\n\t}\n\n\tif (cgroup_on_dfl(cgrp))\n\t\troot_ss_mask &= ~(cgrp_dfl_inhibit_ss_mask |\n\t\t\t\t  cgrp_dfl_implicit_ss_mask);\n\treturn root_ss_mask;\n}"
  },
  {
    "function_name": "cgroup_is_valid_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "415-430",
    "snippet": "static bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "354-357",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_thread_root",
          "args": [
            "cgrp"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_thread_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "393-412",
          "snippet": "bool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 cgrp_dfl_threaded_ss_mask;",
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_mixable",
          "args": [
            "cgrp"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_mixable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "360-368",
          "snippet": "static bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_valid_domain(struct cgroup *cgrp)\n{\n\t/* the cgroup itself can be a thread root */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* but the ancestors can't be unless mixable */\n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (!cgroup_is_mixable(cgrp) && cgroup_is_thread_root(cgrp))\n\t\t\treturn false;\n\t\tif (cgroup_is_threaded(cgrp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "cgroup_is_thread_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "393-412",
    "snippet": "bool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 cgrp_dfl_threaded_ss_mask;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_has_tasks",
          "args": [
            "cgrp"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_has_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "349-352",
          "snippet": "static bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "354-357",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_thread_root(struct cgroup *cgrp)\n{\n\t/* thread root should be a domain */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* a domain w/ threaded children is a thread root */\n\tif (cgrp->nr_threaded_children)\n\t\treturn true;\n\n\t/*\n\t * A domain which has tasks and explicit threaded controllers\n\t * enabled is a thread root.\n\t */\n\tif (cgroup_has_tasks(cgrp) &&\n\t    (cgrp->subtree_control & cgrp_dfl_threaded_ss_mask))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "cgroup_can_be_thread_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "371-390",
    "snippet": "static bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u16 cgrp_dfl_threaded_ss_mask;",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_is_threaded",
          "args": [
            "cgrp"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_threaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "354-357",
          "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_is_mixable",
          "args": [
            "cgrp"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_is_mixable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "360-368",
          "snippet": "static bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 cgrp_dfl_threaded_ss_mask;\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_can_be_thread_root(struct cgroup *cgrp)\n{\n\t/* mixables don't care */\n\tif (cgroup_is_mixable(cgrp))\n\t\treturn true;\n\n\t/* domain roots can't be nested under threaded */\n\tif (cgroup_is_threaded(cgrp))\n\t\treturn false;\n\n\t/* can only have either domain or threaded children */\n\tif (cgrp->nr_populated_domain_children)\n\t\treturn false;\n\n\t/* and no domain controllers can be enabled */\n\tif (cgrp->subtree_control & ~cgrp_dfl_threaded_ss_mask)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "cgroup_is_mixable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "360-368",
    "snippet": "static bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_parent",
          "args": [
            "cgrp"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_is_mixable(struct cgroup *cgrp)\n{\n\t/*\n\t * Root isn't under domain level resource control exempting it from\n\t * the no-internal-process constraint, so it can serve as a thread\n\t * root and a parent of resource domains at the same time.\n\t */\n\treturn !cgroup_parent(cgrp);\n}"
  },
  {
    "function_name": "cgroup_is_threaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "354-357",
    "snippet": "bool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_is_threaded(struct cgroup *cgrp)\n{\n\treturn cgrp->dom_cgrp != cgrp;\n}"
  },
  {
    "function_name": "cgroup_has_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "349-352",
    "snippet": "static bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstatic bool cgroup_has_tasks(struct cgroup *cgrp)\n{\n\treturn cgrp->nr_populated_csets;\n}"
  },
  {
    "function_name": "cgroup_idr_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "342-347",
    "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&cgroup_idr_lock"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "idr",
            "id"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "342-347",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&cgroup_idr_lock"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
  },
  {
    "function_name": "cgroup_idr_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "332-340",
    "snippet": "static void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_idr_lock);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&cgroup_idr_lock"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_replace",
          "args": [
            "idr",
            "ptr",
            "id"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "332-340",
          "snippet": "static void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&cgroup_idr_lock"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic void *cgroup_idr_replace(struct idr *idr, void *ptr, int id)\n{\n\tvoid *ret;\n\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_replace(idr, ptr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_idr_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "319-330",
    "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(cgroup_idr_lock);",
      "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&cgroup_idr_lock"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "idr",
            "ptr",
            "start",
            "end",
            "gfp_mask & ~__GFP_DIRECT_RECLAIM"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
          "lines": "319-330",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&cgroup_idr_lock"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "gfp_mask"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
  },
  {
    "function_name": "cgroup_on_dfl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "313-316",
    "snippet": "bool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };",
      "static int cgroup_apply_control(struct cgroup *cgrp);",
      "static int cgroup_destroy_locked(struct cgroup *cgrp);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_root cgrp_dfl_root = { .cgrp.rstat_cpu = &cgrp_dfl_root_rstat_cpu };\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nbool cgroup_on_dfl(const struct cgroup *cgrp)\n{\n\treturn cgrp->root == &cgrp_dfl_root;\n}"
  },
  {
    "function_name": "cgroup_ssid_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup.c",
    "lines": "258-264",
    "snippet": "bool cgroup_ssid_enabled(int ssid)\n{\n\tif (!CGROUP_HAS_SUBSYS_CONFIG)\n\t\treturn false;\n\n\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);\n}",
    "includes": [
      "#include <linux/cgroup_subsys.h>",
      "#include <linux/cgroup_subsys.h>",
      "#include <trace/events/cgroup.h>",
      "#include <net/sock.h>",
      "#include <linux/psi.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/file.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kthread.h>",
      "#include <linux/idr.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/string.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/mutex.h>",
      "#include <linux/magic.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init_task.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/bpf-cgroup.h>",
      "#include \"cgroup-internal.h\""
    ],
    "macros_used": [
      "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
    ],
    "globals_used": [
      "static struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "cgroup_subsys_enabled_key[ssid]"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct static_key_true *cgroup_subsys_enabled_key[] = {\n#include <linux/cgroup_subsys.h>\n};\n\nbool cgroup_ssid_enabled(int ssid)\n{\n\tif (!CGROUP_HAS_SUBSYS_CONFIG)\n\t\treturn false;\n\n\treturn static_key_enabled(cgroup_subsys_enabled_key[ssid]);\n}"
  }
]