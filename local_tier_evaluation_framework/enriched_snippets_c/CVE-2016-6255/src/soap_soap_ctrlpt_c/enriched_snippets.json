[
  {
    "function_name": "SoapGetServiceVarStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
    "lines": "821-885",
    "snippet": "int\nSoapGetServiceVarStatus( IN char *action_url,\n                         IN char *var_name,\n                         OUT char **var_value )\n{\n    const memptr host;                /* value for HOST header */\n    const memptr path;                /* ctrl path in first line in msg */\n    uri_type url;\n    membuffer request;\n    int ret_code;\n    http_parser_t response;\n    int upnp_error_code;\n    off_t content_length;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n        \"<s:Body>\\r\\n\"\n        \"<u:QueryStateVariable xmlns:u=\\\"urn:schemas-upnp-org:control-1-0\\\">\\r\\n\"\n        \"<u:varName>\";\n    const char *xml_end =\n        \"</u:varName>\\r\\n\"\n        \"</u:QueryStateVariable>\\r\\n\"\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\";\n\n    *var_value = NULL;          /* return NULL in case of an error */\n    membuffer_init( &request );\n    /* get host hdr and url path */\n    if( get_host_and_path( action_url, &host, &path, &url ) == -1 ) {\n        return UPNP_E_INVALID_URL;\n    }\n    /* make headers */\n    request.size_inc = 50;\n    content_length = (off_t)(strlen(xml_start) + strlen(var_name) +\n\tstrlen(xml_end));\n    if (http_MakeMessage(\n\t&request, 1, 1,\n\t\"Q\" \"sbc\" \"N\" \"s\" \"sc\" \"Ucc\" \"sss\",\n\tSOAPMETHOD_POST, path.buf, path.length,\n\t\"HOST: \", host.buf, host.length,\n\tcontent_length,\n\tContentTypeHeader,\n\t\"SOAPACTION: \\\"urn:schemas-upnp-org:control-1-0#QueryStateVariable\\\"\",\n\txml_start, var_name, xml_end ) != 0 ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    /* send msg and get reply */\n    ret_code = soap_request_and_response( &request, &url, &response );\n    membuffer_destroy( &request );\n    if( ret_code != UPNP_E_SUCCESS ) {\n        return ret_code;\n    }\n    /* get variable value from the response */\n    ret_code = get_response_value( &response.msg, SOAP_VAR_RESP, NULL,\n                                   &upnp_error_code, NULL, var_value );\n    httpmsg_destroy( &response.msg );\n    if( ret_code == SOAP_VAR_RESP ) {\n        return UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_VAR_RESP_ERROR ) {\n        return upnp_error_code;\n    } else {\n        return ret_code;\n    }\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"uri.h\"",
      "#include \"soaplib.h\"",
      "#include \"upnpapi.h\"",
      "#include \"parsetools.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"membuffer.h\"",
      "#include \"miniserver.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SOAP_VAR_RESP_ERROR\t4",
      "#define SOAP_VAR_RESP\t\t2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&response.msg"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_response_value",
          "args": [
            "&response.msg",
            "SOAP_VAR_RESP",
            "NULL",
            "&upnp_error_code",
            "NULL",
            "var_value"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "get_response_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "367-498",
          "snippet": "static int\nget_response_value( IN http_message_t * hmsg,\n                    IN int code,\n                    IN char *name,\n                    OUT int *upnp_error_code,\n                    OUT IXML_Node ** action_value,\n                    OUT DOMString * str_value )\n{\n\tIXML_Node *node = NULL;\n\tIXML_Node *root_node = NULL;\n\tIXML_Node *error_node = NULL;\n\tIXML_Document *doc = NULL;\n\tchar *node_str = NULL;\n\tconst char *temp_str = NULL;\n\tDOMString error_node_str = NULL;\n\tint err_code = UPNP_E_BAD_RESPONSE; /* default error */\n\tint done = FALSE;\n\tconst char *names[5];\n\tconst DOMString nodeValue;\n\n\t/* only 200 and 500 status codes are relevant */\n\tif ((hmsg->status_code != HTTP_OK &&\n\t     hmsg->status_code != HTTP_INTERNAL_SERVER_ERROR) ||\n\t    !has_xml_content_type(hmsg))\n\t\tgoto error_handler;\n\tif (ixmlParseBufferEx(hmsg->entity.buf, &doc) != IXML_SUCCESS)\n\t\tgoto error_handler;\n\troot_node = ixmlNode_getFirstChild((IXML_Node *) doc);\n\tif (root_node == NULL)\n\t\tgoto error_handler;\n\tif (code == SOAP_ACTION_RESP) {\n\t\t/* try reading soap action response */\n\t\tassert(action_value != NULL);\n\n\t\t*action_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = name;\n\t\tif (dom_find_deep_node(names, 3, root_node, &node) ==\n\t\t    UPNP_E_SUCCESS) {\n\t\t\tnode_str = ixmlPrintNode(node);\n\t\t\tif (node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t} else if (code == SOAP_VAR_RESP) {\n\t\t/* try reading var response */\n\t\tassert(str_value != NULL);\n\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"QueryStateVariableResponse\";\n\t\tnames[3] = \"return\";\n\t\tif (dom_find_deep_node(names, 4, root_node, &node)\n\t\t    == UPNP_E_SUCCESS) {\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\terr_code = SOAP_VAR_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t}\n\tif (!done) {\n\t\t/* not action or var resp; read error code and description */\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"Fault\";\n\t\tnames[3] = \"detail\";\n\t\tnames[4] = \"UPnPError\";\n\t\tif (dom_find_deep_node(names, 5, root_node, &error_node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\tif (dom_find_node(\"errorCode\", error_node, &node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\ttemp_str = get_node_value(node);\n\t\tif (!temp_str)\n\t\t\tgoto error_handler;\n\t\t*upnp_error_code = atoi(temp_str);\n\t\tif (*upnp_error_code > 400) {\n\t\t\terr_code = *upnp_error_code;\n\t\t\tgoto error_handler;\t/* bad SOAP error code */\n\t\t}\n\t\tif (code == SOAP_VAR_RESP) {\n\t\t\tif (dom_find_node(\"errorDescription\", error_node, &node)\n\t\t\t    != UPNP_E_SUCCESS) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\tif (*str_value == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_VAR_RESP_ERROR;\n\t\t} else if (code == SOAP_ACTION_RESP) {\n\t\t\terror_node_str = ixmlPrintNode(error_node);\n\t\t\tif (error_node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(error_node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP_ERROR;\n\t\t}\n\t}\n\n error_handler:\n\tixmlDocument_free(doc);\n\tixmlFreeDOMString(node_str);\n\tixmlFreeDOMString(error_node_str);\n\treturn err_code;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_VAR_RESP_ERROR\t4",
            "#define SOAP_ACTION_RESP_ERROR  3",
            "#define SOAP_VAR_RESP\t\t2",
            "#define SOAP_ACTION_RESP\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\n#define SOAP_VAR_RESP_ERROR\t4\n#define SOAP_ACTION_RESP_ERROR  3\n#define SOAP_VAR_RESP\t\t2\n#define SOAP_ACTION_RESP\t1\n\nstatic int\nget_response_value( IN http_message_t * hmsg,\n                    IN int code,\n                    IN char *name,\n                    OUT int *upnp_error_code,\n                    OUT IXML_Node ** action_value,\n                    OUT DOMString * str_value )\n{\n\tIXML_Node *node = NULL;\n\tIXML_Node *root_node = NULL;\n\tIXML_Node *error_node = NULL;\n\tIXML_Document *doc = NULL;\n\tchar *node_str = NULL;\n\tconst char *temp_str = NULL;\n\tDOMString error_node_str = NULL;\n\tint err_code = UPNP_E_BAD_RESPONSE; /* default error */\n\tint done = FALSE;\n\tconst char *names[5];\n\tconst DOMString nodeValue;\n\n\t/* only 200 and 500 status codes are relevant */\n\tif ((hmsg->status_code != HTTP_OK &&\n\t     hmsg->status_code != HTTP_INTERNAL_SERVER_ERROR) ||\n\t    !has_xml_content_type(hmsg))\n\t\tgoto error_handler;\n\tif (ixmlParseBufferEx(hmsg->entity.buf, &doc) != IXML_SUCCESS)\n\t\tgoto error_handler;\n\troot_node = ixmlNode_getFirstChild((IXML_Node *) doc);\n\tif (root_node == NULL)\n\t\tgoto error_handler;\n\tif (code == SOAP_ACTION_RESP) {\n\t\t/* try reading soap action response */\n\t\tassert(action_value != NULL);\n\n\t\t*action_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = name;\n\t\tif (dom_find_deep_node(names, 3, root_node, &node) ==\n\t\t    UPNP_E_SUCCESS) {\n\t\t\tnode_str = ixmlPrintNode(node);\n\t\t\tif (node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t} else if (code == SOAP_VAR_RESP) {\n\t\t/* try reading var response */\n\t\tassert(str_value != NULL);\n\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"QueryStateVariableResponse\";\n\t\tnames[3] = \"return\";\n\t\tif (dom_find_deep_node(names, 4, root_node, &node)\n\t\t    == UPNP_E_SUCCESS) {\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\terr_code = SOAP_VAR_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t}\n\tif (!done) {\n\t\t/* not action or var resp; read error code and description */\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"Fault\";\n\t\tnames[3] = \"detail\";\n\t\tnames[4] = \"UPnPError\";\n\t\tif (dom_find_deep_node(names, 5, root_node, &error_node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\tif (dom_find_node(\"errorCode\", error_node, &node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\ttemp_str = get_node_value(node);\n\t\tif (!temp_str)\n\t\t\tgoto error_handler;\n\t\t*upnp_error_code = atoi(temp_str);\n\t\tif (*upnp_error_code > 400) {\n\t\t\terr_code = *upnp_error_code;\n\t\t\tgoto error_handler;\t/* bad SOAP error code */\n\t\t}\n\t\tif (code == SOAP_VAR_RESP) {\n\t\t\tif (dom_find_node(\"errorDescription\", error_node, &node)\n\t\t\t    != UPNP_E_SUCCESS) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\tif (*str_value == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_VAR_RESP_ERROR;\n\t\t} else if (code == SOAP_ACTION_RESP) {\n\t\t\terror_node_str = ixmlPrintNode(error_node);\n\t\t\tif (error_node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(error_node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP_ERROR;\n\t\t}\n\t}\n\n error_handler:\n\tixmlDocument_free(doc);\n\tixmlFreeDOMString(node_str);\n\tixmlFreeDOMString(error_node_str);\n\treturn err_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&request"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "soap_request_and_response",
          "args": [
            "&request",
            "&url",
            "&response"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "soap_request_and_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "306-343",
          "snippet": "static int\nsoap_request_and_response( IN membuffer * request,\n                           IN uri_type * destination_url,\n                           OUT http_parser_t * response )\n{\n    int ret_code;\n\n    ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                        request->length,\n                                        SOAPMETHOD_POST,\n                                        UPNP_TIMEOUT, response );\n    if( ret_code != 0 ) {\n        httpmsg_destroy( &response->msg );\n        return ret_code;\n    }\n    /* method-not-allowed error */\n    if( response->msg.status_code == HTTP_METHOD_NOT_ALLOWED ) {\n        ret_code = add_man_header( request );   /* change to M-POST msg */\n        if( ret_code != 0 ) {\n            return ret_code;\n        }\n\n        httpmsg_destroy( &response->msg );  /* about to reuse response */\n\n        /* try again */\n        ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                            request->length,\n                                            HTTPMETHOD_MPOST,\n                                            UPNP_TIMEOUT,\n                                            response );\n        if( ret_code != 0 ) {\n            httpmsg_destroy( &response->msg );\n        }\n\n    }\n\n    return ret_code;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic int\nsoap_request_and_response( IN membuffer * request,\n                           IN uri_type * destination_url,\n                           OUT http_parser_t * response )\n{\n    int ret_code;\n\n    ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                        request->length,\n                                        SOAPMETHOD_POST,\n                                        UPNP_TIMEOUT, response );\n    if( ret_code != 0 ) {\n        httpmsg_destroy( &response->msg );\n        return ret_code;\n    }\n    /* method-not-allowed error */\n    if( response->msg.status_code == HTTP_METHOD_NOT_ALLOWED ) {\n        ret_code = add_man_header( request );   /* change to M-POST msg */\n        if( ret_code != 0 ) {\n            return ret_code;\n        }\n\n        httpmsg_destroy( &response->msg );  /* about to reuse response */\n\n        /* try again */\n        ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                            request->length,\n                                            HTTPMETHOD_MPOST,\n                                            UPNP_TIMEOUT,\n                                            response );\n        if( ret_code != 0 ) {\n            httpmsg_destroy( &response->msg );\n        }\n\n    }\n\n    return ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&request",
            "1",
            "1",
            "\"Q\" \"sbc\" \"N\" \"s\" \"sc\" \"Ucc\" \"sss\"",
            "SOAPMETHOD_POST",
            "path.buf",
            "path.length",
            "\"HOST: \"",
            "host.buf",
            "host.length",
            "content_length",
            "ContentTypeHeader",
            "\"SOAPACTION: \\\"urn:schemas-upnp-org:control-1-0#QueryStateVariable\\\"\"",
            "xml_start",
            "var_name",
            "xml_end"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "strlen(xml_start) + strlen(var_name) +\n\tstrlen(xml_end)"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_end"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "var_name"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_start"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_host_and_path",
          "args": [
            "action_url",
            "&host",
            "&path",
            "&url"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_and_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "217-234",
          "snippet": "static UPNP_INLINE int\nget_host_and_path( IN char *ctrl_url,\n                   OUT const memptr *host,\n                   OUT const memptr *path,\n                   OUT uri_type * url )\n{\n    if( parse_uri( ctrl_url, strlen( ctrl_url ), url ) != HTTP_SUCCESS ) {\n        return -1;\n    }\n    /* This is done to ensure that the buffer is kept const */\n    ((memptr *)host)->buf = (char *)url->hostport.text.buff;\n    ((memptr *)host)->length = url->hostport.text.size;\n\n    ((memptr *)path)->buf = (char *)url->pathquery.buff;\n    ((memptr *)path)->length = url->pathquery.size;\n\n    return 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic UPNP_INLINE int\nget_host_and_path( IN char *ctrl_url,\n                   OUT const memptr *host,\n                   OUT const memptr *path,\n                   OUT uri_type * url )\n{\n    if( parse_uri( ctrl_url, strlen( ctrl_url ), url ) != HTTP_SUCCESS ) {\n        return -1;\n    }\n    /* This is done to ensure that the buffer is kept const */\n    ((memptr *)host)->buf = (char *)url->hostport.text.buff;\n    ((memptr *)host)->length = url->hostport.text.size;\n\n    ((memptr *)path)->buf = (char *)url->pathquery.buff;\n    ((memptr *)path)->length = url->pathquery.size;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&request"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\n#define SOAP_VAR_RESP_ERROR\t4\n#define SOAP_VAR_RESP\t\t2\n\nint\nSoapGetServiceVarStatus( IN char *action_url,\n                         IN char *var_name,\n                         OUT char **var_value )\n{\n    const memptr host;                /* value for HOST header */\n    const memptr path;                /* ctrl path in first line in msg */\n    uri_type url;\n    membuffer request;\n    int ret_code;\n    http_parser_t response;\n    int upnp_error_code;\n    off_t content_length;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n        \"<s:Body>\\r\\n\"\n        \"<u:QueryStateVariable xmlns:u=\\\"urn:schemas-upnp-org:control-1-0\\\">\\r\\n\"\n        \"<u:varName>\";\n    const char *xml_end =\n        \"</u:varName>\\r\\n\"\n        \"</u:QueryStateVariable>\\r\\n\"\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\";\n\n    *var_value = NULL;          /* return NULL in case of an error */\n    membuffer_init( &request );\n    /* get host hdr and url path */\n    if( get_host_and_path( action_url, &host, &path, &url ) == -1 ) {\n        return UPNP_E_INVALID_URL;\n    }\n    /* make headers */\n    request.size_inc = 50;\n    content_length = (off_t)(strlen(xml_start) + strlen(var_name) +\n\tstrlen(xml_end));\n    if (http_MakeMessage(\n\t&request, 1, 1,\n\t\"Q\" \"sbc\" \"N\" \"s\" \"sc\" \"Ucc\" \"sss\",\n\tSOAPMETHOD_POST, path.buf, path.length,\n\t\"HOST: \", host.buf, host.length,\n\tcontent_length,\n\tContentTypeHeader,\n\t\"SOAPACTION: \\\"urn:schemas-upnp-org:control-1-0#QueryStateVariable\\\"\",\n\txml_start, var_name, xml_end ) != 0 ) {\n        return UPNP_E_OUTOF_MEMORY;\n    }\n    /* send msg and get reply */\n    ret_code = soap_request_and_response( &request, &url, &response );\n    membuffer_destroy( &request );\n    if( ret_code != UPNP_E_SUCCESS ) {\n        return ret_code;\n    }\n    /* get variable value from the response */\n    ret_code = get_response_value( &response.msg, SOAP_VAR_RESP, NULL,\n                                   &upnp_error_code, NULL, var_value );\n    httpmsg_destroy( &response.msg );\n    if( ret_code == SOAP_VAR_RESP ) {\n        return UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_VAR_RESP_ERROR ) {\n        return upnp_error_code;\n    } else {\n        return ret_code;\n    }\n}"
  },
  {
    "function_name": "SoapSendActionEx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
    "lines": "657-803",
    "snippet": "int SoapSendActionEx(\n\tIN char *action_url,\n\tIN char *service_type,\n\tIN IXML_Document * header,\n\tIN IXML_Document * action_node,\n\tOUT IXML_Document ** response_node )\n{\n    char *xml_header_str = NULL;\n    char *action_str = NULL;\n    memptr name;\n    membuffer request;\n    membuffer responsename;\n    int err_code;\n    int ret_code;\n    http_parser_t response;\n    uri_type url;\n    int upnp_error_code;\n    char *upnp_error_str;\n    int got_response = FALSE;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\";\n    const char *xml_header_start =\n        \"<s:Header>\\r\\n\";\n    const char *xml_header_end =\n        \"</s:Header>\\r\\n\";\n    const char *xml_body_start =\n        \"<s:Body>\";\n    const char *xml_end =\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\";\n    size_t xml_start_len;\n    size_t xml_header_start_len;\n    size_t xml_header_str_len;\n    size_t xml_header_end_len;\n    size_t xml_body_start_len;\n    size_t action_str_len;\n    size_t xml_end_len;\n    off_t content_length;\n\n    *response_node = NULL;      /* init */\n\n    err_code = UPNP_E_OUTOF_MEMORY; /* default error */\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"Inside SoapSendActionEx():\" );\n    /* init */\n    membuffer_init( &request );\n    membuffer_init( &responsename );\n\n    /* header string */\n    xml_header_str = ixmlPrintNode( ( IXML_Node * ) header );\n    if( xml_header_str == NULL ) {\n        goto error_handler;\n    }\n    /* print action */\n    action_str = ixmlPrintNode( ( IXML_Node * ) action_node );\n    if( action_str == NULL ) {\n        goto error_handler;\n    }\n    /* get action name */\n    if( get_action_name( action_str, &name ) != 0 ) {\n        err_code = UPNP_E_INVALID_ACTION;\n        goto error_handler;\n    }\n    /* parse url */\n    if( http_FixStrUrl( action_url, strlen( action_url ), &url ) != 0 ) {\n        err_code = UPNP_E_INVALID_URL;\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"path=%.*s, hostport=%.*s\\n\",\n        (int)url.pathquery.size,\n        url.pathquery.buff,\n        (int)url.hostport.text.size,\n        url.hostport.text.buff );\n\n    xml_start_len = strlen( xml_start );\n    xml_body_start_len = strlen( xml_body_start );\n    xml_end_len = strlen( xml_end );\n    action_str_len = strlen( action_str );\n\n    xml_header_start_len = strlen( xml_header_start );\n    xml_header_end_len = strlen( xml_header_end );\n    xml_header_str_len = strlen( xml_header_str );\n\n    /* make request msg */\n    request.size_inc = 50;\n    content_length = (off_t)(xml_start_len + xml_header_start_len +\n\txml_header_str_len + xml_header_end_len +\n        xml_body_start_len + action_str_len + xml_end_len);\n    if (http_MakeMessage(\n        &request, 1, 1,\n        \"q\" \"N\" \"s\" \"sssbsc\" \"Uc\" \"b\" \"b\" \"b\" \"b\" \"b\" \"b\" \"b\",\n        SOAPMETHOD_POST, &url,\n        content_length,\n        ContentTypeHeader,\n        \"SOAPACTION: \\\"\", service_type, \"#\", name.buf, name.length, \"\\\"\",\n        xml_start, xml_start_len,\n        xml_header_start, xml_header_start_len,\n        xml_header_str, xml_header_str_len,\n        xml_header_end, xml_header_end_len,\n        xml_body_start, xml_body_start_len,\n        action_str, action_str_len,\n        xml_end, xml_end_len ) != 0 ) {\n        goto error_handler;\n    }\n\n    ret_code = soap_request_and_response( &request, &url, &response );\n    got_response = TRUE;\n    if( ret_code != UPNP_E_SUCCESS ) {\n        err_code = ret_code;\n        goto error_handler;\n    }\n\n    if( membuffer_append( &responsename, name.buf, name.length ) != 0 ||\n        membuffer_append_str( &responsename, \"Response\" ) != 0 ) {\n        goto error_handler;\n    }\n    /* get action node from the response */\n    ret_code = get_response_value( &response.msg, SOAP_ACTION_RESP,\n                                   responsename.buf, &upnp_error_code,\n                                   ( IXML_Node ** ) response_node,\n                                   &upnp_error_str );\n\n    if( ret_code == SOAP_ACTION_RESP ) {\n        err_code = UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_ACTION_RESP_ERROR ) {\n        err_code = upnp_error_code;\n    } else {\n        err_code = ret_code;\n    }\n\n  error_handler:\n\n    ixmlFreeDOMString( action_str );\n    ixmlFreeDOMString( xml_header_str );\n    membuffer_destroy( &request );\n    membuffer_destroy( &responsename );\n    if( got_response ) {\n        httpmsg_destroy( &response.msg );\n    }\n\n    return err_code;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"uri.h\"",
      "#include \"soaplib.h\"",
      "#include \"upnpapi.h\"",
      "#include \"parsetools.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"membuffer.h\"",
      "#include \"miniserver.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SOAP_ACTION_RESP_ERROR  3",
      "#define SOAP_ACTION_RESP\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&response.msg"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&responsename"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "xml_header_str"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "action_str"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_response_value",
          "args": [
            "&response.msg",
            "SOAP_ACTION_RESP",
            "responsename.buf",
            "&upnp_error_code",
            "( IXML_Node ** ) response_node",
            "&upnp_error_str"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "get_response_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "367-498",
          "snippet": "static int\nget_response_value( IN http_message_t * hmsg,\n                    IN int code,\n                    IN char *name,\n                    OUT int *upnp_error_code,\n                    OUT IXML_Node ** action_value,\n                    OUT DOMString * str_value )\n{\n\tIXML_Node *node = NULL;\n\tIXML_Node *root_node = NULL;\n\tIXML_Node *error_node = NULL;\n\tIXML_Document *doc = NULL;\n\tchar *node_str = NULL;\n\tconst char *temp_str = NULL;\n\tDOMString error_node_str = NULL;\n\tint err_code = UPNP_E_BAD_RESPONSE; /* default error */\n\tint done = FALSE;\n\tconst char *names[5];\n\tconst DOMString nodeValue;\n\n\t/* only 200 and 500 status codes are relevant */\n\tif ((hmsg->status_code != HTTP_OK &&\n\t     hmsg->status_code != HTTP_INTERNAL_SERVER_ERROR) ||\n\t    !has_xml_content_type(hmsg))\n\t\tgoto error_handler;\n\tif (ixmlParseBufferEx(hmsg->entity.buf, &doc) != IXML_SUCCESS)\n\t\tgoto error_handler;\n\troot_node = ixmlNode_getFirstChild((IXML_Node *) doc);\n\tif (root_node == NULL)\n\t\tgoto error_handler;\n\tif (code == SOAP_ACTION_RESP) {\n\t\t/* try reading soap action response */\n\t\tassert(action_value != NULL);\n\n\t\t*action_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = name;\n\t\tif (dom_find_deep_node(names, 3, root_node, &node) ==\n\t\t    UPNP_E_SUCCESS) {\n\t\t\tnode_str = ixmlPrintNode(node);\n\t\t\tif (node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t} else if (code == SOAP_VAR_RESP) {\n\t\t/* try reading var response */\n\t\tassert(str_value != NULL);\n\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"QueryStateVariableResponse\";\n\t\tnames[3] = \"return\";\n\t\tif (dom_find_deep_node(names, 4, root_node, &node)\n\t\t    == UPNP_E_SUCCESS) {\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\terr_code = SOAP_VAR_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t}\n\tif (!done) {\n\t\t/* not action or var resp; read error code and description */\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"Fault\";\n\t\tnames[3] = \"detail\";\n\t\tnames[4] = \"UPnPError\";\n\t\tif (dom_find_deep_node(names, 5, root_node, &error_node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\tif (dom_find_node(\"errorCode\", error_node, &node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\ttemp_str = get_node_value(node);\n\t\tif (!temp_str)\n\t\t\tgoto error_handler;\n\t\t*upnp_error_code = atoi(temp_str);\n\t\tif (*upnp_error_code > 400) {\n\t\t\terr_code = *upnp_error_code;\n\t\t\tgoto error_handler;\t/* bad SOAP error code */\n\t\t}\n\t\tif (code == SOAP_VAR_RESP) {\n\t\t\tif (dom_find_node(\"errorDescription\", error_node, &node)\n\t\t\t    != UPNP_E_SUCCESS) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\tif (*str_value == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_VAR_RESP_ERROR;\n\t\t} else if (code == SOAP_ACTION_RESP) {\n\t\t\terror_node_str = ixmlPrintNode(error_node);\n\t\t\tif (error_node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(error_node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP_ERROR;\n\t\t}\n\t}\n\n error_handler:\n\tixmlDocument_free(doc);\n\tixmlFreeDOMString(node_str);\n\tixmlFreeDOMString(error_node_str);\n\treturn err_code;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_VAR_RESP_ERROR\t4",
            "#define SOAP_ACTION_RESP_ERROR  3",
            "#define SOAP_VAR_RESP\t\t2",
            "#define SOAP_ACTION_RESP\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\n#define SOAP_VAR_RESP_ERROR\t4\n#define SOAP_ACTION_RESP_ERROR  3\n#define SOAP_VAR_RESP\t\t2\n#define SOAP_ACTION_RESP\t1\n\nstatic int\nget_response_value( IN http_message_t * hmsg,\n                    IN int code,\n                    IN char *name,\n                    OUT int *upnp_error_code,\n                    OUT IXML_Node ** action_value,\n                    OUT DOMString * str_value )\n{\n\tIXML_Node *node = NULL;\n\tIXML_Node *root_node = NULL;\n\tIXML_Node *error_node = NULL;\n\tIXML_Document *doc = NULL;\n\tchar *node_str = NULL;\n\tconst char *temp_str = NULL;\n\tDOMString error_node_str = NULL;\n\tint err_code = UPNP_E_BAD_RESPONSE; /* default error */\n\tint done = FALSE;\n\tconst char *names[5];\n\tconst DOMString nodeValue;\n\n\t/* only 200 and 500 status codes are relevant */\n\tif ((hmsg->status_code != HTTP_OK &&\n\t     hmsg->status_code != HTTP_INTERNAL_SERVER_ERROR) ||\n\t    !has_xml_content_type(hmsg))\n\t\tgoto error_handler;\n\tif (ixmlParseBufferEx(hmsg->entity.buf, &doc) != IXML_SUCCESS)\n\t\tgoto error_handler;\n\troot_node = ixmlNode_getFirstChild((IXML_Node *) doc);\n\tif (root_node == NULL)\n\t\tgoto error_handler;\n\tif (code == SOAP_ACTION_RESP) {\n\t\t/* try reading soap action response */\n\t\tassert(action_value != NULL);\n\n\t\t*action_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = name;\n\t\tif (dom_find_deep_node(names, 3, root_node, &node) ==\n\t\t    UPNP_E_SUCCESS) {\n\t\t\tnode_str = ixmlPrintNode(node);\n\t\t\tif (node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t} else if (code == SOAP_VAR_RESP) {\n\t\t/* try reading var response */\n\t\tassert(str_value != NULL);\n\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"QueryStateVariableResponse\";\n\t\tnames[3] = \"return\";\n\t\tif (dom_find_deep_node(names, 4, root_node, &node)\n\t\t    == UPNP_E_SUCCESS) {\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\terr_code = SOAP_VAR_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t}\n\tif (!done) {\n\t\t/* not action or var resp; read error code and description */\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"Fault\";\n\t\tnames[3] = \"detail\";\n\t\tnames[4] = \"UPnPError\";\n\t\tif (dom_find_deep_node(names, 5, root_node, &error_node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\tif (dom_find_node(\"errorCode\", error_node, &node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\ttemp_str = get_node_value(node);\n\t\tif (!temp_str)\n\t\t\tgoto error_handler;\n\t\t*upnp_error_code = atoi(temp_str);\n\t\tif (*upnp_error_code > 400) {\n\t\t\terr_code = *upnp_error_code;\n\t\t\tgoto error_handler;\t/* bad SOAP error code */\n\t\t}\n\t\tif (code == SOAP_VAR_RESP) {\n\t\t\tif (dom_find_node(\"errorDescription\", error_node, &node)\n\t\t\t    != UPNP_E_SUCCESS) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\tif (*str_value == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_VAR_RESP_ERROR;\n\t\t} else if (code == SOAP_ACTION_RESP) {\n\t\t\terror_node_str = ixmlPrintNode(error_node);\n\t\t\tif (error_node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(error_node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP_ERROR;\n\t\t}\n\t}\n\n error_handler:\n\tixmlDocument_free(doc);\n\tixmlFreeDOMString(node_str);\n\tixmlFreeDOMString(error_node_str);\n\treturn err_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_append_str",
          "args": [
            "&responsename",
            "\"Response\""
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "207-210",
          "snippet": "int membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_append",
          "args": [
            "&responsename",
            "name.buf",
            "name.length"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "200-205",
          "snippet": "int membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "soap_request_and_response",
          "args": [
            "&request",
            "&url",
            "&response"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "soap_request_and_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "306-343",
          "snippet": "static int\nsoap_request_and_response( IN membuffer * request,\n                           IN uri_type * destination_url,\n                           OUT http_parser_t * response )\n{\n    int ret_code;\n\n    ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                        request->length,\n                                        SOAPMETHOD_POST,\n                                        UPNP_TIMEOUT, response );\n    if( ret_code != 0 ) {\n        httpmsg_destroy( &response->msg );\n        return ret_code;\n    }\n    /* method-not-allowed error */\n    if( response->msg.status_code == HTTP_METHOD_NOT_ALLOWED ) {\n        ret_code = add_man_header( request );   /* change to M-POST msg */\n        if( ret_code != 0 ) {\n            return ret_code;\n        }\n\n        httpmsg_destroy( &response->msg );  /* about to reuse response */\n\n        /* try again */\n        ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                            request->length,\n                                            HTTPMETHOD_MPOST,\n                                            UPNP_TIMEOUT,\n                                            response );\n        if( ret_code != 0 ) {\n            httpmsg_destroy( &response->msg );\n        }\n\n    }\n\n    return ret_code;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic int\nsoap_request_and_response( IN membuffer * request,\n                           IN uri_type * destination_url,\n                           OUT http_parser_t * response )\n{\n    int ret_code;\n\n    ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                        request->length,\n                                        SOAPMETHOD_POST,\n                                        UPNP_TIMEOUT, response );\n    if( ret_code != 0 ) {\n        httpmsg_destroy( &response->msg );\n        return ret_code;\n    }\n    /* method-not-allowed error */\n    if( response->msg.status_code == HTTP_METHOD_NOT_ALLOWED ) {\n        ret_code = add_man_header( request );   /* change to M-POST msg */\n        if( ret_code != 0 ) {\n            return ret_code;\n        }\n\n        httpmsg_destroy( &response->msg );  /* about to reuse response */\n\n        /* try again */\n        ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                            request->length,\n                                            HTTPMETHOD_MPOST,\n                                            UPNP_TIMEOUT,\n                                            response );\n        if( ret_code != 0 ) {\n            httpmsg_destroy( &response->msg );\n        }\n\n    }\n\n    return ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&request",
            "1",
            "1",
            "\"q\" \"N\" \"s\" \"sssbsc\" \"Uc\" \"b\" \"b\" \"b\" \"b\" \"b\" \"b\" \"b\"",
            "SOAPMETHOD_POST",
            "&url",
            "content_length",
            "ContentTypeHeader",
            "\"SOAPACTION: \\\"\"",
            "service_type",
            "\"#\"",
            "name.buf",
            "name.length",
            "\"\\\"\"",
            "xml_start",
            "xml_start_len",
            "xml_header_start",
            "xml_header_start_len",
            "xml_header_str",
            "xml_header_str_len",
            "xml_header_end",
            "xml_header_end_len",
            "xml_body_start",
            "xml_body_start_len",
            "action_str",
            "action_str_len",
            "xml_end",
            "xml_end_len"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "xml_start_len + xml_header_start_len +\n\txml_header_str_len + xml_header_end_len +\n        xml_body_start_len + action_str_len + xml_end_len"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_header_str"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_header_end"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_header_start"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "action_str"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_end"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_body_start"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_start"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "SOAP",
            "__FILE__",
            "__LINE__",
            "\"path=%.*s, hostport=%.*s\\n\"",
            "(int)url.pathquery.size",
            "url.pathquery.buff",
            "(int)url.hostport.text.size",
            "url.hostport.text.buff"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_FixStrUrl",
          "args": [
            "action_url",
            "strlen( action_url )",
            "&url"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "http_FixStrUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "259-271",
          "snippet": "int http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "action_url"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_action_name",
          "args": [
            "action_str",
            "&name"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "get_action_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "250-261",
          "snippet": "static UPNP_INLINE int\nget_action_name( IN char *action,\n                 OUT memptr * name )\n{\n    memptr dummy;\n    int ret_code;\n\n    ret_code =\n        matchstr( action, strlen( action ), \" <%s:%s\", &dummy, name );\n\n    return ret_code == PARSE_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic UPNP_INLINE int\nget_action_name( IN char *action,\n                 OUT memptr * name )\n{\n    memptr dummy;\n    int ret_code;\n\n    ret_code =\n        matchstr( action, strlen( action ), \" <%s:%s\", &dummy, name );\n\n    return ret_code == PARSE_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "( IXML_Node * ) action_node"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "( IXML_Node * ) header"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&responsename"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\n#define SOAP_ACTION_RESP_ERROR  3\n#define SOAP_ACTION_RESP\t1\n\nint SoapSendActionEx(\n\tIN char *action_url,\n\tIN char *service_type,\n\tIN IXML_Document * header,\n\tIN IXML_Document * action_node,\n\tOUT IXML_Document ** response_node )\n{\n    char *xml_header_str = NULL;\n    char *action_str = NULL;\n    memptr name;\n    membuffer request;\n    membuffer responsename;\n    int err_code;\n    int ret_code;\n    http_parser_t response;\n    uri_type url;\n    int upnp_error_code;\n    char *upnp_error_str;\n    int got_response = FALSE;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\";\n    const char *xml_header_start =\n        \"<s:Header>\\r\\n\";\n    const char *xml_header_end =\n        \"</s:Header>\\r\\n\";\n    const char *xml_body_start =\n        \"<s:Body>\";\n    const char *xml_end =\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\";\n    size_t xml_start_len;\n    size_t xml_header_start_len;\n    size_t xml_header_str_len;\n    size_t xml_header_end_len;\n    size_t xml_body_start_len;\n    size_t action_str_len;\n    size_t xml_end_len;\n    off_t content_length;\n\n    *response_node = NULL;      /* init */\n\n    err_code = UPNP_E_OUTOF_MEMORY; /* default error */\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"Inside SoapSendActionEx():\" );\n    /* init */\n    membuffer_init( &request );\n    membuffer_init( &responsename );\n\n    /* header string */\n    xml_header_str = ixmlPrintNode( ( IXML_Node * ) header );\n    if( xml_header_str == NULL ) {\n        goto error_handler;\n    }\n    /* print action */\n    action_str = ixmlPrintNode( ( IXML_Node * ) action_node );\n    if( action_str == NULL ) {\n        goto error_handler;\n    }\n    /* get action name */\n    if( get_action_name( action_str, &name ) != 0 ) {\n        err_code = UPNP_E_INVALID_ACTION;\n        goto error_handler;\n    }\n    /* parse url */\n    if( http_FixStrUrl( action_url, strlen( action_url ), &url ) != 0 ) {\n        err_code = UPNP_E_INVALID_URL;\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"path=%.*s, hostport=%.*s\\n\",\n        (int)url.pathquery.size,\n        url.pathquery.buff,\n        (int)url.hostport.text.size,\n        url.hostport.text.buff );\n\n    xml_start_len = strlen( xml_start );\n    xml_body_start_len = strlen( xml_body_start );\n    xml_end_len = strlen( xml_end );\n    action_str_len = strlen( action_str );\n\n    xml_header_start_len = strlen( xml_header_start );\n    xml_header_end_len = strlen( xml_header_end );\n    xml_header_str_len = strlen( xml_header_str );\n\n    /* make request msg */\n    request.size_inc = 50;\n    content_length = (off_t)(xml_start_len + xml_header_start_len +\n\txml_header_str_len + xml_header_end_len +\n        xml_body_start_len + action_str_len + xml_end_len);\n    if (http_MakeMessage(\n        &request, 1, 1,\n        \"q\" \"N\" \"s\" \"sssbsc\" \"Uc\" \"b\" \"b\" \"b\" \"b\" \"b\" \"b\" \"b\",\n        SOAPMETHOD_POST, &url,\n        content_length,\n        ContentTypeHeader,\n        \"SOAPACTION: \\\"\", service_type, \"#\", name.buf, name.length, \"\\\"\",\n        xml_start, xml_start_len,\n        xml_header_start, xml_header_start_len,\n        xml_header_str, xml_header_str_len,\n        xml_header_end, xml_header_end_len,\n        xml_body_start, xml_body_start_len,\n        action_str, action_str_len,\n        xml_end, xml_end_len ) != 0 ) {\n        goto error_handler;\n    }\n\n    ret_code = soap_request_and_response( &request, &url, &response );\n    got_response = TRUE;\n    if( ret_code != UPNP_E_SUCCESS ) {\n        err_code = ret_code;\n        goto error_handler;\n    }\n\n    if( membuffer_append( &responsename, name.buf, name.length ) != 0 ||\n        membuffer_append_str( &responsename, \"Response\" ) != 0 ) {\n        goto error_handler;\n    }\n    /* get action node from the response */\n    ret_code = get_response_value( &response.msg, SOAP_ACTION_RESP,\n                                   responsename.buf, &upnp_error_code,\n                                   ( IXML_Node ** ) response_node,\n                                   &upnp_error_str );\n\n    if( ret_code == SOAP_ACTION_RESP ) {\n        err_code = UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_ACTION_RESP_ERROR ) {\n        err_code = upnp_error_code;\n    } else {\n        err_code = ret_code;\n    }\n\n  error_handler:\n\n    ixmlFreeDOMString( action_str );\n    ixmlFreeDOMString( xml_header_str );\n    membuffer_destroy( &request );\n    membuffer_destroy( &responsename );\n    if( got_response ) {\n        httpmsg_destroy( &response.msg );\n    }\n\n    return err_code;\n}"
  },
  {
    "function_name": "SoapSendAction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
    "lines": "517-635",
    "snippet": "int\nSoapSendAction( IN char *action_url,\n                IN char *service_type,\n                IN IXML_Document * action_node,\n                OUT IXML_Document ** response_node )\n{\n    char *action_str = NULL;\n    memptr name;\n    membuffer request;\n    membuffer responsename;\n    int err_code;\n    int ret_code;\n    http_parser_t response;\n    uri_type url;\n    int upnp_error_code;\n    char *upnp_error_str;\n    int got_response = FALSE;\n\n    off_t content_length;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n        \"<s:Body>\";\n    const char *xml_end =\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\\r\\n\";\n    size_t xml_start_len;\n    size_t xml_end_len;\n    size_t action_str_len;\n\n    *response_node = NULL;      /* init */\n\n    err_code = UPNP_E_OUTOF_MEMORY; /* default error */\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"Inside SoapSendAction():\" );\n    /* init */\n    membuffer_init( &request );\n    membuffer_init( &responsename );\n\n    /* print action */\n    action_str = ixmlPrintNode( ( IXML_Node * ) action_node );\n    if( action_str == NULL ) {\n        goto error_handler;\n    }\n    /* get action name */\n    if( get_action_name( action_str, &name ) != 0 ) {\n        err_code = UPNP_E_INVALID_ACTION;\n        goto error_handler;\n    }\n    /* parse url */\n    if( http_FixStrUrl( action_url, strlen( action_url ), &url ) != 0 ) {\n        err_code = UPNP_E_INVALID_URL;\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"path=%.*s, hostport=%.*s\\n\",\n        (int)url.pathquery.size,\n        url.pathquery.buff,\n        (int)url.hostport.text.size,\n        url.hostport.text.buff );\n\n    xml_start_len = strlen( xml_start );\n    xml_end_len = strlen( xml_end );\n    action_str_len = strlen( action_str );\n\n    /* make request msg */\n    request.size_inc = 50;\n    content_length = (off_t)(xml_start_len + action_str_len + xml_end_len);\n    if (http_MakeMessage(\n       \t&request, 1, 1,\n        \"q\" \"N\" \"s\" \"sssbsc\" \"Uc\" \"b\" \"b\" \"b\",\n        SOAPMETHOD_POST, &url, \n        content_length,\n        ContentTypeHeader,\n        \"SOAPACTION: \\\"\", service_type, \"#\", name.buf, name.length, \"\\\"\",\n        xml_start, xml_start_len,\n        action_str, action_str_len,\n        xml_end, xml_end_len ) != 0 ) {\n        goto error_handler;\n    }\n\n    ret_code = soap_request_and_response( &request, &url, &response );\n    got_response = TRUE;\n    if( ret_code != UPNP_E_SUCCESS ) {\n        err_code = ret_code;\n        goto error_handler;\n    }\n\n    if( membuffer_append( &responsename, name.buf, name.length ) != 0 ||\n        membuffer_append_str( &responsename, \"Response\" ) != 0 ) {\n        goto error_handler;\n    }\n    /* get action node from the response */\n    ret_code = get_response_value( &response.msg, SOAP_ACTION_RESP,\n                                   responsename.buf, &upnp_error_code,\n                                   ( IXML_Node ** ) response_node,\n                                   &upnp_error_str );\n\n    if( ret_code == SOAP_ACTION_RESP ) {\n        err_code = UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_ACTION_RESP_ERROR ) {\n        err_code = upnp_error_code;\n    } else {\n        err_code = ret_code;\n    }\n\nerror_handler:\n    ixmlFreeDOMString( action_str );\n    membuffer_destroy( &request );\n    membuffer_destroy( &responsename );\n    if( got_response ) {\n        httpmsg_destroy( &response.msg );\n    }\n\n    return err_code;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"uri.h\"",
      "#include \"soaplib.h\"",
      "#include \"upnpapi.h\"",
      "#include \"parsetools.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"membuffer.h\"",
      "#include \"miniserver.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SOAP_ACTION_RESP_ERROR  3",
      "#define SOAP_ACTION_RESP\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&response.msg"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&responsename"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "action_str"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_response_value",
          "args": [
            "&response.msg",
            "SOAP_ACTION_RESP",
            "responsename.buf",
            "&upnp_error_code",
            "( IXML_Node ** ) response_node",
            "&upnp_error_str"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "get_response_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "367-498",
          "snippet": "static int\nget_response_value( IN http_message_t * hmsg,\n                    IN int code,\n                    IN char *name,\n                    OUT int *upnp_error_code,\n                    OUT IXML_Node ** action_value,\n                    OUT DOMString * str_value )\n{\n\tIXML_Node *node = NULL;\n\tIXML_Node *root_node = NULL;\n\tIXML_Node *error_node = NULL;\n\tIXML_Document *doc = NULL;\n\tchar *node_str = NULL;\n\tconst char *temp_str = NULL;\n\tDOMString error_node_str = NULL;\n\tint err_code = UPNP_E_BAD_RESPONSE; /* default error */\n\tint done = FALSE;\n\tconst char *names[5];\n\tconst DOMString nodeValue;\n\n\t/* only 200 and 500 status codes are relevant */\n\tif ((hmsg->status_code != HTTP_OK &&\n\t     hmsg->status_code != HTTP_INTERNAL_SERVER_ERROR) ||\n\t    !has_xml_content_type(hmsg))\n\t\tgoto error_handler;\n\tif (ixmlParseBufferEx(hmsg->entity.buf, &doc) != IXML_SUCCESS)\n\t\tgoto error_handler;\n\troot_node = ixmlNode_getFirstChild((IXML_Node *) doc);\n\tif (root_node == NULL)\n\t\tgoto error_handler;\n\tif (code == SOAP_ACTION_RESP) {\n\t\t/* try reading soap action response */\n\t\tassert(action_value != NULL);\n\n\t\t*action_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = name;\n\t\tif (dom_find_deep_node(names, 3, root_node, &node) ==\n\t\t    UPNP_E_SUCCESS) {\n\t\t\tnode_str = ixmlPrintNode(node);\n\t\t\tif (node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t} else if (code == SOAP_VAR_RESP) {\n\t\t/* try reading var response */\n\t\tassert(str_value != NULL);\n\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"QueryStateVariableResponse\";\n\t\tnames[3] = \"return\";\n\t\tif (dom_find_deep_node(names, 4, root_node, &node)\n\t\t    == UPNP_E_SUCCESS) {\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\terr_code = SOAP_VAR_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t}\n\tif (!done) {\n\t\t/* not action or var resp; read error code and description */\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"Fault\";\n\t\tnames[3] = \"detail\";\n\t\tnames[4] = \"UPnPError\";\n\t\tif (dom_find_deep_node(names, 5, root_node, &error_node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\tif (dom_find_node(\"errorCode\", error_node, &node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\ttemp_str = get_node_value(node);\n\t\tif (!temp_str)\n\t\t\tgoto error_handler;\n\t\t*upnp_error_code = atoi(temp_str);\n\t\tif (*upnp_error_code > 400) {\n\t\t\terr_code = *upnp_error_code;\n\t\t\tgoto error_handler;\t/* bad SOAP error code */\n\t\t}\n\t\tif (code == SOAP_VAR_RESP) {\n\t\t\tif (dom_find_node(\"errorDescription\", error_node, &node)\n\t\t\t    != UPNP_E_SUCCESS) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\tif (*str_value == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_VAR_RESP_ERROR;\n\t\t} else if (code == SOAP_ACTION_RESP) {\n\t\t\terror_node_str = ixmlPrintNode(error_node);\n\t\t\tif (error_node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(error_node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP_ERROR;\n\t\t}\n\t}\n\n error_handler:\n\tixmlDocument_free(doc);\n\tixmlFreeDOMString(node_str);\n\tixmlFreeDOMString(error_node_str);\n\treturn err_code;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_VAR_RESP_ERROR\t4",
            "#define SOAP_ACTION_RESP_ERROR  3",
            "#define SOAP_VAR_RESP\t\t2",
            "#define SOAP_ACTION_RESP\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\n#define SOAP_VAR_RESP_ERROR\t4\n#define SOAP_ACTION_RESP_ERROR  3\n#define SOAP_VAR_RESP\t\t2\n#define SOAP_ACTION_RESP\t1\n\nstatic int\nget_response_value( IN http_message_t * hmsg,\n                    IN int code,\n                    IN char *name,\n                    OUT int *upnp_error_code,\n                    OUT IXML_Node ** action_value,\n                    OUT DOMString * str_value )\n{\n\tIXML_Node *node = NULL;\n\tIXML_Node *root_node = NULL;\n\tIXML_Node *error_node = NULL;\n\tIXML_Document *doc = NULL;\n\tchar *node_str = NULL;\n\tconst char *temp_str = NULL;\n\tDOMString error_node_str = NULL;\n\tint err_code = UPNP_E_BAD_RESPONSE; /* default error */\n\tint done = FALSE;\n\tconst char *names[5];\n\tconst DOMString nodeValue;\n\n\t/* only 200 and 500 status codes are relevant */\n\tif ((hmsg->status_code != HTTP_OK &&\n\t     hmsg->status_code != HTTP_INTERNAL_SERVER_ERROR) ||\n\t    !has_xml_content_type(hmsg))\n\t\tgoto error_handler;\n\tif (ixmlParseBufferEx(hmsg->entity.buf, &doc) != IXML_SUCCESS)\n\t\tgoto error_handler;\n\troot_node = ixmlNode_getFirstChild((IXML_Node *) doc);\n\tif (root_node == NULL)\n\t\tgoto error_handler;\n\tif (code == SOAP_ACTION_RESP) {\n\t\t/* try reading soap action response */\n\t\tassert(action_value != NULL);\n\n\t\t*action_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = name;\n\t\tif (dom_find_deep_node(names, 3, root_node, &node) ==\n\t\t    UPNP_E_SUCCESS) {\n\t\t\tnode_str = ixmlPrintNode(node);\n\t\t\tif (node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t} else if (code == SOAP_VAR_RESP) {\n\t\t/* try reading var response */\n\t\tassert(str_value != NULL);\n\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"QueryStateVariableResponse\";\n\t\tnames[3] = \"return\";\n\t\tif (dom_find_deep_node(names, 4, root_node, &node)\n\t\t    == UPNP_E_SUCCESS) {\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\terr_code = SOAP_VAR_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t}\n\tif (!done) {\n\t\t/* not action or var resp; read error code and description */\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"Fault\";\n\t\tnames[3] = \"detail\";\n\t\tnames[4] = \"UPnPError\";\n\t\tif (dom_find_deep_node(names, 5, root_node, &error_node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\tif (dom_find_node(\"errorCode\", error_node, &node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\ttemp_str = get_node_value(node);\n\t\tif (!temp_str)\n\t\t\tgoto error_handler;\n\t\t*upnp_error_code = atoi(temp_str);\n\t\tif (*upnp_error_code > 400) {\n\t\t\terr_code = *upnp_error_code;\n\t\t\tgoto error_handler;\t/* bad SOAP error code */\n\t\t}\n\t\tif (code == SOAP_VAR_RESP) {\n\t\t\tif (dom_find_node(\"errorDescription\", error_node, &node)\n\t\t\t    != UPNP_E_SUCCESS) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\tif (*str_value == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_VAR_RESP_ERROR;\n\t\t} else if (code == SOAP_ACTION_RESP) {\n\t\t\terror_node_str = ixmlPrintNode(error_node);\n\t\t\tif (error_node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(error_node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP_ERROR;\n\t\t}\n\t}\n\n error_handler:\n\tixmlDocument_free(doc);\n\tixmlFreeDOMString(node_str);\n\tixmlFreeDOMString(error_node_str);\n\treturn err_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_append_str",
          "args": [
            "&responsename",
            "\"Response\""
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "207-210",
          "snippet": "int membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_append",
          "args": [
            "&responsename",
            "name.buf",
            "name.length"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "200-205",
          "snippet": "int membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "soap_request_and_response",
          "args": [
            "&request",
            "&url",
            "&response"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "soap_request_and_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "306-343",
          "snippet": "static int\nsoap_request_and_response( IN membuffer * request,\n                           IN uri_type * destination_url,\n                           OUT http_parser_t * response )\n{\n    int ret_code;\n\n    ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                        request->length,\n                                        SOAPMETHOD_POST,\n                                        UPNP_TIMEOUT, response );\n    if( ret_code != 0 ) {\n        httpmsg_destroy( &response->msg );\n        return ret_code;\n    }\n    /* method-not-allowed error */\n    if( response->msg.status_code == HTTP_METHOD_NOT_ALLOWED ) {\n        ret_code = add_man_header( request );   /* change to M-POST msg */\n        if( ret_code != 0 ) {\n            return ret_code;\n        }\n\n        httpmsg_destroy( &response->msg );  /* about to reuse response */\n\n        /* try again */\n        ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                            request->length,\n                                            HTTPMETHOD_MPOST,\n                                            UPNP_TIMEOUT,\n                                            response );\n        if( ret_code != 0 ) {\n            httpmsg_destroy( &response->msg );\n        }\n\n    }\n\n    return ret_code;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic int\nsoap_request_and_response( IN membuffer * request,\n                           IN uri_type * destination_url,\n                           OUT http_parser_t * response )\n{\n    int ret_code;\n\n    ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                        request->length,\n                                        SOAPMETHOD_POST,\n                                        UPNP_TIMEOUT, response );\n    if( ret_code != 0 ) {\n        httpmsg_destroy( &response->msg );\n        return ret_code;\n    }\n    /* method-not-allowed error */\n    if( response->msg.status_code == HTTP_METHOD_NOT_ALLOWED ) {\n        ret_code = add_man_header( request );   /* change to M-POST msg */\n        if( ret_code != 0 ) {\n            return ret_code;\n        }\n\n        httpmsg_destroy( &response->msg );  /* about to reuse response */\n\n        /* try again */\n        ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                            request->length,\n                                            HTTPMETHOD_MPOST,\n                                            UPNP_TIMEOUT,\n                                            response );\n        if( ret_code != 0 ) {\n            httpmsg_destroy( &response->msg );\n        }\n\n    }\n\n    return ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&request",
            "1",
            "1",
            "\"q\" \"N\" \"s\" \"sssbsc\" \"Uc\" \"b\" \"b\" \"b\"",
            "SOAPMETHOD_POST",
            "&url",
            "content_length",
            "ContentTypeHeader",
            "\"SOAPACTION: \\\"\"",
            "service_type",
            "\"#\"",
            "name.buf",
            "name.length",
            "\"\\\"\"",
            "xml_start",
            "xml_start_len",
            "action_str",
            "action_str_len",
            "xml_end",
            "xml_end_len"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "xml_start_len + action_str_len + xml_end_len"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "action_str"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_end"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_start"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "SOAP",
            "__FILE__",
            "__LINE__",
            "\"path=%.*s, hostport=%.*s\\n\"",
            "(int)url.pathquery.size",
            "url.pathquery.buff",
            "(int)url.hostport.text.size",
            "url.hostport.text.buff"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_FixStrUrl",
          "args": [
            "action_url",
            "strlen( action_url )",
            "&url"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "http_FixStrUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "259-271",
          "snippet": "int http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "action_url"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_action_name",
          "args": [
            "action_str",
            "&name"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "get_action_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "250-261",
          "snippet": "static UPNP_INLINE int\nget_action_name( IN char *action,\n                 OUT memptr * name )\n{\n    memptr dummy;\n    int ret_code;\n\n    ret_code =\n        matchstr( action, strlen( action ), \" <%s:%s\", &dummy, name );\n\n    return ret_code == PARSE_OK ? 0 : -1;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic UPNP_INLINE int\nget_action_name( IN char *action,\n                 OUT memptr * name )\n{\n    memptr dummy;\n    int ret_code;\n\n    ret_code =\n        matchstr( action, strlen( action ), \" <%s:%s\", &dummy, name );\n\n    return ret_code == PARSE_OK ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "( IXML_Node * ) action_node"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&responsename"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\n#define SOAP_ACTION_RESP_ERROR  3\n#define SOAP_ACTION_RESP\t1\n\nint\nSoapSendAction( IN char *action_url,\n                IN char *service_type,\n                IN IXML_Document * action_node,\n                OUT IXML_Document ** response_node )\n{\n    char *action_str = NULL;\n    memptr name;\n    membuffer request;\n    membuffer responsename;\n    int err_code;\n    int ret_code;\n    http_parser_t response;\n    uri_type url;\n    int upnp_error_code;\n    char *upnp_error_str;\n    int got_response = FALSE;\n\n    off_t content_length;\n    const char *xml_start =\n        \"<s:Envelope \"\n        \"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n        \"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\r\\n\"\n        \"<s:Body>\";\n    const char *xml_end =\n        \"</s:Body>\\r\\n\"\n        \"</s:Envelope>\\r\\n\\r\\n\";\n    size_t xml_start_len;\n    size_t xml_end_len;\n    size_t action_str_len;\n\n    *response_node = NULL;      /* init */\n\n    err_code = UPNP_E_OUTOF_MEMORY; /* default error */\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"Inside SoapSendAction():\" );\n    /* init */\n    membuffer_init( &request );\n    membuffer_init( &responsename );\n\n    /* print action */\n    action_str = ixmlPrintNode( ( IXML_Node * ) action_node );\n    if( action_str == NULL ) {\n        goto error_handler;\n    }\n    /* get action name */\n    if( get_action_name( action_str, &name ) != 0 ) {\n        err_code = UPNP_E_INVALID_ACTION;\n        goto error_handler;\n    }\n    /* parse url */\n    if( http_FixStrUrl( action_url, strlen( action_url ), &url ) != 0 ) {\n        err_code = UPNP_E_INVALID_URL;\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, SOAP, __FILE__, __LINE__,\n        \"path=%.*s, hostport=%.*s\\n\",\n        (int)url.pathquery.size,\n        url.pathquery.buff,\n        (int)url.hostport.text.size,\n        url.hostport.text.buff );\n\n    xml_start_len = strlen( xml_start );\n    xml_end_len = strlen( xml_end );\n    action_str_len = strlen( action_str );\n\n    /* make request msg */\n    request.size_inc = 50;\n    content_length = (off_t)(xml_start_len + action_str_len + xml_end_len);\n    if (http_MakeMessage(\n       \t&request, 1, 1,\n        \"q\" \"N\" \"s\" \"sssbsc\" \"Uc\" \"b\" \"b\" \"b\",\n        SOAPMETHOD_POST, &url, \n        content_length,\n        ContentTypeHeader,\n        \"SOAPACTION: \\\"\", service_type, \"#\", name.buf, name.length, \"\\\"\",\n        xml_start, xml_start_len,\n        action_str, action_str_len,\n        xml_end, xml_end_len ) != 0 ) {\n        goto error_handler;\n    }\n\n    ret_code = soap_request_and_response( &request, &url, &response );\n    got_response = TRUE;\n    if( ret_code != UPNP_E_SUCCESS ) {\n        err_code = ret_code;\n        goto error_handler;\n    }\n\n    if( membuffer_append( &responsename, name.buf, name.length ) != 0 ||\n        membuffer_append_str( &responsename, \"Response\" ) != 0 ) {\n        goto error_handler;\n    }\n    /* get action node from the response */\n    ret_code = get_response_value( &response.msg, SOAP_ACTION_RESP,\n                                   responsename.buf, &upnp_error_code,\n                                   ( IXML_Node ** ) response_node,\n                                   &upnp_error_str );\n\n    if( ret_code == SOAP_ACTION_RESP ) {\n        err_code = UPNP_E_SUCCESS;\n    } else if( ret_code == SOAP_ACTION_RESP_ERROR ) {\n        err_code = upnp_error_code;\n    } else {\n        err_code = ret_code;\n    }\n\nerror_handler:\n    ixmlFreeDOMString( action_str );\n    membuffer_destroy( &request );\n    membuffer_destroy( &responsename );\n    if( got_response ) {\n        httpmsg_destroy( &response.msg );\n    }\n\n    return err_code;\n}"
  },
  {
    "function_name": "get_response_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
    "lines": "367-498",
    "snippet": "static int\nget_response_value( IN http_message_t * hmsg,\n                    IN int code,\n                    IN char *name,\n                    OUT int *upnp_error_code,\n                    OUT IXML_Node ** action_value,\n                    OUT DOMString * str_value )\n{\n\tIXML_Node *node = NULL;\n\tIXML_Node *root_node = NULL;\n\tIXML_Node *error_node = NULL;\n\tIXML_Document *doc = NULL;\n\tchar *node_str = NULL;\n\tconst char *temp_str = NULL;\n\tDOMString error_node_str = NULL;\n\tint err_code = UPNP_E_BAD_RESPONSE; /* default error */\n\tint done = FALSE;\n\tconst char *names[5];\n\tconst DOMString nodeValue;\n\n\t/* only 200 and 500 status codes are relevant */\n\tif ((hmsg->status_code != HTTP_OK &&\n\t     hmsg->status_code != HTTP_INTERNAL_SERVER_ERROR) ||\n\t    !has_xml_content_type(hmsg))\n\t\tgoto error_handler;\n\tif (ixmlParseBufferEx(hmsg->entity.buf, &doc) != IXML_SUCCESS)\n\t\tgoto error_handler;\n\troot_node = ixmlNode_getFirstChild((IXML_Node *) doc);\n\tif (root_node == NULL)\n\t\tgoto error_handler;\n\tif (code == SOAP_ACTION_RESP) {\n\t\t/* try reading soap action response */\n\t\tassert(action_value != NULL);\n\n\t\t*action_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = name;\n\t\tif (dom_find_deep_node(names, 3, root_node, &node) ==\n\t\t    UPNP_E_SUCCESS) {\n\t\t\tnode_str = ixmlPrintNode(node);\n\t\t\tif (node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t} else if (code == SOAP_VAR_RESP) {\n\t\t/* try reading var response */\n\t\tassert(str_value != NULL);\n\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"QueryStateVariableResponse\";\n\t\tnames[3] = \"return\";\n\t\tif (dom_find_deep_node(names, 4, root_node, &node)\n\t\t    == UPNP_E_SUCCESS) {\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\terr_code = SOAP_VAR_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t}\n\tif (!done) {\n\t\t/* not action or var resp; read error code and description */\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"Fault\";\n\t\tnames[3] = \"detail\";\n\t\tnames[4] = \"UPnPError\";\n\t\tif (dom_find_deep_node(names, 5, root_node, &error_node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\tif (dom_find_node(\"errorCode\", error_node, &node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\ttemp_str = get_node_value(node);\n\t\tif (!temp_str)\n\t\t\tgoto error_handler;\n\t\t*upnp_error_code = atoi(temp_str);\n\t\tif (*upnp_error_code > 400) {\n\t\t\terr_code = *upnp_error_code;\n\t\t\tgoto error_handler;\t/* bad SOAP error code */\n\t\t}\n\t\tif (code == SOAP_VAR_RESP) {\n\t\t\tif (dom_find_node(\"errorDescription\", error_node, &node)\n\t\t\t    != UPNP_E_SUCCESS) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\tif (*str_value == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_VAR_RESP_ERROR;\n\t\t} else if (code == SOAP_ACTION_RESP) {\n\t\t\terror_node_str = ixmlPrintNode(error_node);\n\t\t\tif (error_node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(error_node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP_ERROR;\n\t\t}\n\t}\n\n error_handler:\n\tixmlDocument_free(doc);\n\tixmlFreeDOMString(node_str);\n\tixmlFreeDOMString(error_node_str);\n\treturn err_code;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"uri.h\"",
      "#include \"soaplib.h\"",
      "#include \"upnpapi.h\"",
      "#include \"parsetools.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"membuffer.h\"",
      "#include \"miniserver.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SOAP_VAR_RESP_ERROR\t4",
      "#define SOAP_ACTION_RESP_ERROR  3",
      "#define SOAP_VAR_RESP\t\t2",
      "#define SOAP_ACTION_RESP\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "error_node_str"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "node_str"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "doc"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "error_node_str",
            "(IXML_Document **) action_value"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "error_node"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlCloneDOMString",
          "args": [
            "nodeValue"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_value",
          "args": [
            "node"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "185-198",
          "snippet": "static const DOMString\nget_node_value( IN IXML_Node * node )\n{\n    IXML_Node *text_node = NULL;\n    const DOMString text_value = NULL;\n\n    text_node = ixmlNode_getFirstChild( node );\n    if( text_node == NULL ) {\n        return NULL;\n    }\n\n    text_value = ixmlNode_getNodeValue( text_node );\n    return text_value;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic const DOMString\nget_node_value( IN IXML_Node * node )\n{\n    IXML_Node *text_node = NULL;\n    const DOMString text_value = NULL;\n\n    text_node = ixmlNode_getFirstChild( node );\n    if( text_node == NULL ) {\n        return NULL;\n    }\n\n    text_value = ixmlNode_getNodeValue( text_node );\n    return text_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dom_find_node",
          "args": [
            "\"errorDescription\"",
            "error_node",
            "&node"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "dom_find_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "102-127",
          "snippet": "static int dom_find_node(\n\t/* [in] name of the node. */\n\tconst char *node_name,\n\t/* [in] complete xml node. */\n\tIXML_Node *start_node,\n\t/* [out] matched node. */\n\tIXML_Node **matching_node)\n{\n\tIXML_Node *node;\n\n\t/* invalid args */\n\tif (!node_name || !start_node)\n\t\treturn UPNP_E_NOT_FOUND;\n\tnode = ixmlNode_getFirstChild(start_node);\n\twhile (node != NULL) {\n\t\t/* match name */\n\t\tif (dom_cmp_name(node_name, node) == 0) {\n\t\t\t*matching_node = node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t\t/* free and next node */\n\t\tnode = ixmlNode_getNextSibling(node);\n\t}\n\n\treturn UPNP_E_NOT_FOUND;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic int dom_find_node(\n\t/* [in] name of the node. */\n\tconst char *node_name,\n\t/* [in] complete xml node. */\n\tIXML_Node *start_node,\n\t/* [out] matched node. */\n\tIXML_Node **matching_node)\n{\n\tIXML_Node *node;\n\n\t/* invalid args */\n\tif (!node_name || !start_node)\n\t\treturn UPNP_E_NOT_FOUND;\n\tnode = ixmlNode_getFirstChild(start_node);\n\twhile (node != NULL) {\n\t\t/* match name */\n\t\tif (dom_cmp_name(node_name, node) == 0) {\n\t\t\t*matching_node = node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t\t/* free and next node */\n\t\tnode = ixmlNode_getNextSibling(node);\n\t}\n\n\treturn UPNP_E_NOT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "temp_str"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dom_find_deep_node",
          "args": [
            "names",
            "5",
            "root_node",
            "&error_node"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "dom_find_deep_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "134-170",
          "snippet": "static int dom_find_deep_node(\n\t/* [in] array of names. */\n\tconst char *names[],\n\t/* [in] size of array. */\n\tint num_names,\n\t/* [in] Node from where it should should be searched. */\n\tIXML_Node *start_node,\n\t/* [out] Node that matches the last name of the array. */\n\tIXML_Node **matching_node)\n{\n\tint i;\n\tIXML_Node *node;\n\tIXML_Node *match_node;\n\n\tassert(num_names > 0);\n\n\tnode = start_node;\n\tif (dom_cmp_name(names[0], start_node) == 0) {\n\t\tif (num_names == 1) {\n\t\t\t*matching_node = start_node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t}\n\tfor (i = 1; i < num_names; i++) {\n\t\tif (dom_find_node(names[i], node, &match_node) != UPNP_E_SUCCESS)\n\t\t\treturn UPNP_E_NOT_FOUND;\n\t\tif (i == num_names - 1) {\n\t\t\t*matching_node = match_node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t\t/* try again */\n\t\tnode = match_node;\n\t}\n\n\t/* this line not reached */\n\treturn UPNP_E_NOT_FOUND;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic int dom_find_deep_node(\n\t/* [in] array of names. */\n\tconst char *names[],\n\t/* [in] size of array. */\n\tint num_names,\n\t/* [in] Node from where it should should be searched. */\n\tIXML_Node *start_node,\n\t/* [out] Node that matches the last name of the array. */\n\tIXML_Node **matching_node)\n{\n\tint i;\n\tIXML_Node *node;\n\tIXML_Node *match_node;\n\n\tassert(num_names > 0);\n\n\tnode = start_node;\n\tif (dom_cmp_name(names[0], start_node) == 0) {\n\t\tif (num_names == 1) {\n\t\t\t*matching_node = start_node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t}\n\tfor (i = 1; i < num_names; i++) {\n\t\tif (dom_find_node(names[i], node, &match_node) != UPNP_E_SUCCESS)\n\t\t\treturn UPNP_E_NOT_FOUND;\n\t\tif (i == num_names - 1) {\n\t\t\t*matching_node = match_node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t\t/* try again */\n\t\tnode = match_node;\n\t}\n\n\t/* this line not reached */\n\treturn UPNP_E_NOT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlCloneDOMString",
          "args": [
            "nodeValue"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str_value != NULL"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "node_str",
            "(IXML_Document **) action_value"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "node"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "action_value != NULL"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "(IXML_Node *) doc"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "hmsg->entity.buf",
            "&doc"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_xml_content_type",
          "args": [
            "hmsg"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "has_xml_content_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/parsetools.c",
          "lines": "48-64",
          "snippet": "int has_xml_content_type(http_message_t *hmsg)\n{\n\tmemptr hdr_value;\n\n\tassert(hmsg);\n\n\t/* find 'content-type' header which must have text/xml */\n\tif (httpmsg_find_hdr(hmsg, HDR_CONTENT_TYPE, &hdr_value)) {\n\t\tswitch (matchstr(hdr_value.buf, hdr_value.length, \"%itext%w/%wxml\" )) {\n\t\tcase PARSE_OK:\n\t\t\treturn TRUE;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn FALSE;\n}",
          "includes": [
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnputil.h\"",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"upnputil.h\"\n#include <assert.h>\n#include \"config.h\"\n\nint has_xml_content_type(http_message_t *hmsg)\n{\n\tmemptr hdr_value;\n\n\tassert(hmsg);\n\n\t/* find 'content-type' header which must have text/xml */\n\tif (httpmsg_find_hdr(hmsg, HDR_CONTENT_TYPE, &hdr_value)) {\n\t\tswitch (matchstr(hdr_value.buf, hdr_value.length, \"%itext%w/%wxml\" )) {\n\t\tcase PARSE_OK:\n\t\t\treturn TRUE;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn FALSE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\n#define SOAP_VAR_RESP_ERROR\t4\n#define SOAP_ACTION_RESP_ERROR  3\n#define SOAP_VAR_RESP\t\t2\n#define SOAP_ACTION_RESP\t1\n\nstatic int\nget_response_value( IN http_message_t * hmsg,\n                    IN int code,\n                    IN char *name,\n                    OUT int *upnp_error_code,\n                    OUT IXML_Node ** action_value,\n                    OUT DOMString * str_value )\n{\n\tIXML_Node *node = NULL;\n\tIXML_Node *root_node = NULL;\n\tIXML_Node *error_node = NULL;\n\tIXML_Document *doc = NULL;\n\tchar *node_str = NULL;\n\tconst char *temp_str = NULL;\n\tDOMString error_node_str = NULL;\n\tint err_code = UPNP_E_BAD_RESPONSE; /* default error */\n\tint done = FALSE;\n\tconst char *names[5];\n\tconst DOMString nodeValue;\n\n\t/* only 200 and 500 status codes are relevant */\n\tif ((hmsg->status_code != HTTP_OK &&\n\t     hmsg->status_code != HTTP_INTERNAL_SERVER_ERROR) ||\n\t    !has_xml_content_type(hmsg))\n\t\tgoto error_handler;\n\tif (ixmlParseBufferEx(hmsg->entity.buf, &doc) != IXML_SUCCESS)\n\t\tgoto error_handler;\n\troot_node = ixmlNode_getFirstChild((IXML_Node *) doc);\n\tif (root_node == NULL)\n\t\tgoto error_handler;\n\tif (code == SOAP_ACTION_RESP) {\n\t\t/* try reading soap action response */\n\t\tassert(action_value != NULL);\n\n\t\t*action_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = name;\n\t\tif (dom_find_deep_node(names, 3, root_node, &node) ==\n\t\t    UPNP_E_SUCCESS) {\n\t\t\tnode_str = ixmlPrintNode(node);\n\t\t\tif (node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t} else if (code == SOAP_VAR_RESP) {\n\t\t/* try reading var response */\n\t\tassert(str_value != NULL);\n\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"QueryStateVariableResponse\";\n\t\tnames[3] = \"return\";\n\t\tif (dom_find_deep_node(names, 4, root_node, &node)\n\t\t    == UPNP_E_SUCCESS) {\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\terr_code = SOAP_VAR_RESP;\n\t\t\tdone = TRUE;\n\t\t}\n\t}\n\tif (!done) {\n\t\t/* not action or var resp; read error code and description */\n\t\t*str_value = NULL;\n\t\tnames[0] = \"Envelope\";\n\t\tnames[1] = \"Body\";\n\t\tnames[2] = \"Fault\";\n\t\tnames[3] = \"detail\";\n\t\tnames[4] = \"UPnPError\";\n\t\tif (dom_find_deep_node(names, 5, root_node, &error_node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\tif (dom_find_node(\"errorCode\", error_node, &node) !=\n\t\t    UPNP_E_SUCCESS)\n\t\t\tgoto error_handler;\n\t\ttemp_str = get_node_value(node);\n\t\tif (!temp_str)\n\t\t\tgoto error_handler;\n\t\t*upnp_error_code = atoi(temp_str);\n\t\tif (*upnp_error_code > 400) {\n\t\t\terr_code = *upnp_error_code;\n\t\t\tgoto error_handler;\t/* bad SOAP error code */\n\t\t}\n\t\tif (code == SOAP_VAR_RESP) {\n\t\t\tif (dom_find_node(\"errorDescription\", error_node, &node)\n\t\t\t    != UPNP_E_SUCCESS) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tnodeValue = get_node_value(node);\n\t\t\tif (nodeValue == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t*str_value = ixmlCloneDOMString(nodeValue);\n\t\t\tif (*str_value == NULL) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_VAR_RESP_ERROR;\n\t\t} else if (code == SOAP_ACTION_RESP) {\n\t\t\terror_node_str = ixmlPrintNode(error_node);\n\t\t\tif (error_node_str == NULL) {\n\t\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (ixmlParseBufferEx(error_node_str,\n\t\t\t\t\t      (IXML_Document **) action_value)\n\t\t\t    != IXML_SUCCESS) {\n\t\t\t\terr_code = UPNP_E_BAD_RESPONSE;\n\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\terr_code = SOAP_ACTION_RESP_ERROR;\n\t\t}\n\t}\n\n error_handler:\n\tixmlDocument_free(doc);\n\tixmlFreeDOMString(node_str);\n\tixmlFreeDOMString(error_node_str);\n\treturn err_code;\n}"
  },
  {
    "function_name": "soap_request_and_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
    "lines": "306-343",
    "snippet": "static int\nsoap_request_and_response( IN membuffer * request,\n                           IN uri_type * destination_url,\n                           OUT http_parser_t * response )\n{\n    int ret_code;\n\n    ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                        request->length,\n                                        SOAPMETHOD_POST,\n                                        UPNP_TIMEOUT, response );\n    if( ret_code != 0 ) {\n        httpmsg_destroy( &response->msg );\n        return ret_code;\n    }\n    /* method-not-allowed error */\n    if( response->msg.status_code == HTTP_METHOD_NOT_ALLOWED ) {\n        ret_code = add_man_header( request );   /* change to M-POST msg */\n        if( ret_code != 0 ) {\n            return ret_code;\n        }\n\n        httpmsg_destroy( &response->msg );  /* about to reuse response */\n\n        /* try again */\n        ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                            request->length,\n                                            HTTPMETHOD_MPOST,\n                                            UPNP_TIMEOUT,\n                                            response );\n        if( ret_code != 0 ) {\n            httpmsg_destroy( &response->msg );\n        }\n\n    }\n\n    return ret_code;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"uri.h\"",
      "#include \"soaplib.h\"",
      "#include \"upnpapi.h\"",
      "#include \"parsetools.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"membuffer.h\"",
      "#include \"miniserver.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&response->msg"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_RequestAndResponse",
          "args": [
            "destination_url",
            "request->buf",
            "request->length",
            "HTTPMETHOD_MPOST",
            "UPNP_TIMEOUT",
            "response"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "http_RequestAndResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "638-690",
          "snippet": "int http_RequestAndResponse(\n\tIN uri_type *destination,\n\tIN const char *request,\n\tIN size_t request_length,\n\tIN http_method_t req_method,\n\tIN int timeout_secs,\n\tOUT http_parser_t *response)\n{\n\tSOCKET tcp_connection;\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tint http_error_code;\n\tSOCKINFO info;\n\n\ttcp_connection = socket(\n\t\t(int)destination->hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tparser_response_init(response, req_method);\n\t\treturn UPNP_E_SOCKET_ERROR;\n\t}\n\tif (sock_init(&info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto end_function;\n\t}\n\t/* connect */\n\tsockaddr_len = destination->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(info.socket,\n\t\t(struct sockaddr *)&(destination->hostport.IPaddress),\n\t\t(socklen_t)sockaddr_len);\n\tif (ret_code == -1) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto end_function;\n\t}\n\t/* send request */\n\tret_code = http_SendMessage(&info, &timeout_secs, \"b\",\n\t\trequest, request_length);\n\tif (ret_code != 0) {\n\t\tparser_response_init(response, req_method);\n\t\tgoto end_function;\n\t}\n\t/* recv response */\n\tret_code = http_RecvMessage(&info, response, req_method,\n\t\t&timeout_secs, &http_error_code);\n\nend_function:\n\t/* should shutdown completely */\n\tsock_destroy(&info, SD_BOTH);\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_RequestAndResponse(\n\tIN uri_type *destination,\n\tIN const char *request,\n\tIN size_t request_length,\n\tIN http_method_t req_method,\n\tIN int timeout_secs,\n\tOUT http_parser_t *response)\n{\n\tSOCKET tcp_connection;\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tint http_error_code;\n\tSOCKINFO info;\n\n\ttcp_connection = socket(\n\t\t(int)destination->hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tparser_response_init(response, req_method);\n\t\treturn UPNP_E_SOCKET_ERROR;\n\t}\n\tif (sock_init(&info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto end_function;\n\t}\n\t/* connect */\n\tsockaddr_len = destination->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(info.socket,\n\t\t(struct sockaddr *)&(destination->hostport.IPaddress),\n\t\t(socklen_t)sockaddr_len);\n\tif (ret_code == -1) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto end_function;\n\t}\n\t/* send request */\n\tret_code = http_SendMessage(&info, &timeout_secs, \"b\",\n\t\trequest, request_length);\n\tif (ret_code != 0) {\n\t\tparser_response_init(response, req_method);\n\t\tgoto end_function;\n\t}\n\t/* recv response */\n\tret_code = http_RecvMessage(&info, response, req_method,\n\t\t&timeout_secs, &http_error_code);\n\nend_function:\n\t/* should shutdown completely */\n\tsock_destroy(&info, SD_BOTH);\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_man_header",
          "args": [
            "request"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "add_man_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "268-289",
          "snippet": "static UPNP_INLINE int add_man_header(\n\t/* [in,out] HTTP header. */\n\tmembuffer *headers)\n{\n\tsize_t n;\n\tchar *soap_action_hdr;\n\tconst char *man_hdr =\n\t\t\"MAN: \\\"http://schemas.xmlsoap.org/soap/envelope/\\\"; ns=01\\r\\n01-\";\n\n\t/* change POST to M-POST */\n\tif (membuffer_insert(headers, \"M-\", 2, 0) != 0)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tsoap_action_hdr = strstr(headers->buf, \"SOAPACTION:\");\n\t/* can't fail */\n\tassert(soap_action_hdr != NULL);\n\t/* insert MAN header */\n\tn = (size_t)(soap_action_hdr - headers->buf);\n\tif (membuffer_insert(headers, man_hdr, strlen(man_hdr), n))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic UPNP_INLINE int add_man_header(\n\t/* [in,out] HTTP header. */\n\tmembuffer *headers)\n{\n\tsize_t n;\n\tchar *soap_action_hdr;\n\tconst char *man_hdr =\n\t\t\"MAN: \\\"http://schemas.xmlsoap.org/soap/envelope/\\\"; ns=01\\r\\n01-\";\n\n\t/* change POST to M-POST */\n\tif (membuffer_insert(headers, \"M-\", 2, 0) != 0)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tsoap_action_hdr = strstr(headers->buf, \"SOAPACTION:\");\n\t/* can't fail */\n\tassert(soap_action_hdr != NULL);\n\t/* insert MAN header */\n\tn = (size_t)(soap_action_hdr - headers->buf);\n\tif (membuffer_insert(headers, man_hdr, strlen(man_hdr), n))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic int\nsoap_request_and_response( IN membuffer * request,\n                           IN uri_type * destination_url,\n                           OUT http_parser_t * response )\n{\n    int ret_code;\n\n    ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                        request->length,\n                                        SOAPMETHOD_POST,\n                                        UPNP_TIMEOUT, response );\n    if( ret_code != 0 ) {\n        httpmsg_destroy( &response->msg );\n        return ret_code;\n    }\n    /* method-not-allowed error */\n    if( response->msg.status_code == HTTP_METHOD_NOT_ALLOWED ) {\n        ret_code = add_man_header( request );   /* change to M-POST msg */\n        if( ret_code != 0 ) {\n            return ret_code;\n        }\n\n        httpmsg_destroy( &response->msg );  /* about to reuse response */\n\n        /* try again */\n        ret_code = http_RequestAndResponse( destination_url, request->buf,\n                                            request->length,\n                                            HTTPMETHOD_MPOST,\n                                            UPNP_TIMEOUT,\n                                            response );\n        if( ret_code != 0 ) {\n            httpmsg_destroy( &response->msg );\n        }\n\n    }\n\n    return ret_code;\n}"
  },
  {
    "function_name": "add_man_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
    "lines": "268-289",
    "snippet": "static UPNP_INLINE int add_man_header(\n\t/* [in,out] HTTP header. */\n\tmembuffer *headers)\n{\n\tsize_t n;\n\tchar *soap_action_hdr;\n\tconst char *man_hdr =\n\t\t\"MAN: \\\"http://schemas.xmlsoap.org/soap/envelope/\\\"; ns=01\\r\\n01-\";\n\n\t/* change POST to M-POST */\n\tif (membuffer_insert(headers, \"M-\", 2, 0) != 0)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tsoap_action_hdr = strstr(headers->buf, \"SOAPACTION:\");\n\t/* can't fail */\n\tassert(soap_action_hdr != NULL);\n\t/* insert MAN header */\n\tn = (size_t)(soap_action_hdr - headers->buf);\n\tif (membuffer_insert(headers, man_hdr, strlen(man_hdr), n))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"uri.h\"",
      "#include \"soaplib.h\"",
      "#include \"upnpapi.h\"",
      "#include \"parsetools.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"membuffer.h\"",
      "#include \"miniserver.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_insert",
          "args": [
            "headers",
            "man_hdr",
            "strlen(man_hdr)",
            "n"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "212-238",
          "snippet": "int membuffer_insert(membuffer * m, const void *buf, size_t buf_len,\n\t\t     size_t index)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\tif (index > m->length)\n\t\treturn UPNP_E_OUTOF_BOUNDS;\n\tif (!buf || !buf_len) {\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, m->length + buf_len);\n\tif (return_code) {\n\t\treturn return_code;\n\t}\n\t/* insert data */\n\t/* move data to right of insertion point */\n\tmemmove(m->buf + index + buf_len, m->buf + index, m->length - index);\n\tmemcpy(m->buf + index, buf, buf_len);\n\tm->length += buf_len;\n\t/* null-terminate */\n\tm->buf[m->length] = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_insert(membuffer * m, const void *buf, size_t buf_len,\n\t\t     size_t index)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\tif (index > m->length)\n\t\treturn UPNP_E_OUTOF_BOUNDS;\n\tif (!buf || !buf_len) {\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, m->length + buf_len);\n\tif (return_code) {\n\t\treturn return_code;\n\t}\n\t/* insert data */\n\t/* move data to right of insertion point */\n\tmemmove(m->buf + index + buf_len, m->buf + index, m->length - index);\n\tmemcpy(m->buf + index, buf, buf_len);\n\tm->length += buf_len;\n\t/* null-terminate */\n\tm->buf[m->length] = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "man_hdr"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "soap_action_hdr != NULL"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "headers->buf",
            "\"SOAPACTION:\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic UPNP_INLINE int add_man_header(\n\t/* [in,out] HTTP header. */\n\tmembuffer *headers)\n{\n\tsize_t n;\n\tchar *soap_action_hdr;\n\tconst char *man_hdr =\n\t\t\"MAN: \\\"http://schemas.xmlsoap.org/soap/envelope/\\\"; ns=01\\r\\n01-\";\n\n\t/* change POST to M-POST */\n\tif (membuffer_insert(headers, \"M-\", 2, 0) != 0)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tsoap_action_hdr = strstr(headers->buf, \"SOAPACTION:\");\n\t/* can't fail */\n\tassert(soap_action_hdr != NULL);\n\t/* insert MAN header */\n\tn = (size_t)(soap_action_hdr - headers->buf);\n\tif (membuffer_insert(headers, man_hdr, strlen(man_hdr), n))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_action_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
    "lines": "250-261",
    "snippet": "static UPNP_INLINE int\nget_action_name( IN char *action,\n                 OUT memptr * name )\n{\n    memptr dummy;\n    int ret_code;\n\n    ret_code =\n        matchstr( action, strlen( action ), \" <%s:%s\", &dummy, name );\n\n    return ret_code == PARSE_OK ? 0 : -1;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"uri.h\"",
      "#include \"soaplib.h\"",
      "#include \"upnpapi.h\"",
      "#include \"parsetools.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"membuffer.h\"",
      "#include \"miniserver.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "matchstr",
          "args": [
            "action",
            "strlen( action )",
            "\" <%s:%s\"",
            "&dummy",
            "name"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "matchstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1168-1203",
          "snippet": "parse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "action"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic UPNP_INLINE int\nget_action_name( IN char *action,\n                 OUT memptr * name )\n{\n    memptr dummy;\n    int ret_code;\n\n    ret_code =\n        matchstr( action, strlen( action ), \" <%s:%s\", &dummy, name );\n\n    return ret_code == PARSE_OK ? 0 : -1;\n}"
  },
  {
    "function_name": "get_host_and_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
    "lines": "217-234",
    "snippet": "static UPNP_INLINE int\nget_host_and_path( IN char *ctrl_url,\n                   OUT const memptr *host,\n                   OUT const memptr *path,\n                   OUT uri_type * url )\n{\n    if( parse_uri( ctrl_url, strlen( ctrl_url ), url ) != HTTP_SUCCESS ) {\n        return -1;\n    }\n    /* This is done to ensure that the buffer is kept const */\n    ((memptr *)host)->buf = (char *)url->hostport.text.buff;\n    ((memptr *)host)->length = url->hostport.text.size;\n\n    ((memptr *)path)->buf = (char *)url->pathquery.buff;\n    ((memptr *)path)->length = url->pathquery.size;\n\n    return 0;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"uri.h\"",
      "#include \"soaplib.h\"",
      "#include \"upnpapi.h\"",
      "#include \"parsetools.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"membuffer.h\"",
      "#include \"miniserver.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_uri",
          "args": [
            "ctrl_url",
            "strlen( ctrl_url )",
            "url"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uri_and_unescape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "759-775",
          "snippet": "int parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ctrl_url"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic UPNP_INLINE int\nget_host_and_path( IN char *ctrl_url,\n                   OUT const memptr *host,\n                   OUT const memptr *path,\n                   OUT uri_type * url )\n{\n    if( parse_uri( ctrl_url, strlen( ctrl_url ), url ) != HTTP_SUCCESS ) {\n        return -1;\n    }\n    /* This is done to ensure that the buffer is kept const */\n    ((memptr *)host)->buf = (char *)url->hostport.text.buff;\n    ((memptr *)host)->length = url->hostport.text.size;\n\n    ((memptr *)path)->buf = (char *)url->pathquery.buff;\n    ((memptr *)path)->length = url->pathquery.size;\n\n    return 0;\n}"
  },
  {
    "function_name": "get_node_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
    "lines": "185-198",
    "snippet": "static const DOMString\nget_node_value( IN IXML_Node * node )\n{\n    IXML_Node *text_node = NULL;\n    const DOMString text_value = NULL;\n\n    text_node = ixmlNode_getFirstChild( node );\n    if( text_node == NULL ) {\n        return NULL;\n    }\n\n    text_value = ixmlNode_getNodeValue( text_node );\n    return text_value;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"uri.h\"",
      "#include \"soaplib.h\"",
      "#include \"upnpapi.h\"",
      "#include \"parsetools.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"membuffer.h\"",
      "#include \"miniserver.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ixmlNode_getNodeValue",
          "args": [
            "text_node"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "node"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic const DOMString\nget_node_value( IN IXML_Node * node )\n{\n    IXML_Node *text_node = NULL;\n    const DOMString text_value = NULL;\n\n    text_node = ixmlNode_getFirstChild( node );\n    if( text_node == NULL ) {\n        return NULL;\n    }\n\n    text_value = ixmlNode_getNodeValue( text_node );\n    return text_value;\n}"
  },
  {
    "function_name": "dom_find_deep_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
    "lines": "134-170",
    "snippet": "static int dom_find_deep_node(\n\t/* [in] array of names. */\n\tconst char *names[],\n\t/* [in] size of array. */\n\tint num_names,\n\t/* [in] Node from where it should should be searched. */\n\tIXML_Node *start_node,\n\t/* [out] Node that matches the last name of the array. */\n\tIXML_Node **matching_node)\n{\n\tint i;\n\tIXML_Node *node;\n\tIXML_Node *match_node;\n\n\tassert(num_names > 0);\n\n\tnode = start_node;\n\tif (dom_cmp_name(names[0], start_node) == 0) {\n\t\tif (num_names == 1) {\n\t\t\t*matching_node = start_node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t}\n\tfor (i = 1; i < num_names; i++) {\n\t\tif (dom_find_node(names[i], node, &match_node) != UPNP_E_SUCCESS)\n\t\t\treturn UPNP_E_NOT_FOUND;\n\t\tif (i == num_names - 1) {\n\t\t\t*matching_node = match_node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t\t/* try again */\n\t\tnode = match_node;\n\t}\n\n\t/* this line not reached */\n\treturn UPNP_E_NOT_FOUND;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"uri.h\"",
      "#include \"soaplib.h\"",
      "#include \"upnpapi.h\"",
      "#include \"parsetools.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"membuffer.h\"",
      "#include \"miniserver.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dom_find_node",
          "args": [
            "names[i]",
            "node",
            "&match_node"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "dom_find_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "102-127",
          "snippet": "static int dom_find_node(\n\t/* [in] name of the node. */\n\tconst char *node_name,\n\t/* [in] complete xml node. */\n\tIXML_Node *start_node,\n\t/* [out] matched node. */\n\tIXML_Node **matching_node)\n{\n\tIXML_Node *node;\n\n\t/* invalid args */\n\tif (!node_name || !start_node)\n\t\treturn UPNP_E_NOT_FOUND;\n\tnode = ixmlNode_getFirstChild(start_node);\n\twhile (node != NULL) {\n\t\t/* match name */\n\t\tif (dom_cmp_name(node_name, node) == 0) {\n\t\t\t*matching_node = node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t\t/* free and next node */\n\t\tnode = ixmlNode_getNextSibling(node);\n\t}\n\n\treturn UPNP_E_NOT_FOUND;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic int dom_find_node(\n\t/* [in] name of the node. */\n\tconst char *node_name,\n\t/* [in] complete xml node. */\n\tIXML_Node *start_node,\n\t/* [out] matched node. */\n\tIXML_Node **matching_node)\n{\n\tIXML_Node *node;\n\n\t/* invalid args */\n\tif (!node_name || !start_node)\n\t\treturn UPNP_E_NOT_FOUND;\n\tnode = ixmlNode_getFirstChild(start_node);\n\twhile (node != NULL) {\n\t\t/* match name */\n\t\tif (dom_cmp_name(node_name, node) == 0) {\n\t\t\t*matching_node = node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t\t/* free and next node */\n\t\tnode = ixmlNode_getNextSibling(node);\n\t}\n\n\treturn UPNP_E_NOT_FOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dom_cmp_name",
          "args": [
            "names[0]",
            "start_node"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "dom_cmp_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "66-94",
          "snippet": "static int dom_cmp_name(\n\t/* [in] lookup name. */\n\tconst char *name,\n\t/* [in] xml node. */\n\tIXML_Node *node)\n{\n\tconst DOMString node_name = NULL;\n\tmemptr nameptr;\n\tmemptr dummy;\n\tint ret_code;\n\n\tassert(name);\n\tassert(node);\n\n\tnode_name = ixmlNode_getNodeName(node);\n\tif (node_name == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tif (strcmp(name, node_name) == 0)\n\t\tret_code = 0;\n\telse if (matchstr((char *)node_name, strlen(node_name),\n\t\t\t  \"%s:%s%0\", &dummy, &nameptr) == PARSE_OK &&\n\t\t strcmp(nameptr.buf, name) == 0)\n\t\tret_code = 0;\n\telse\n\t\t/* names are not the same */\n\t\tret_code = 1;\n\n\treturn ret_code;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic int dom_cmp_name(\n\t/* [in] lookup name. */\n\tconst char *name,\n\t/* [in] xml node. */\n\tIXML_Node *node)\n{\n\tconst DOMString node_name = NULL;\n\tmemptr nameptr;\n\tmemptr dummy;\n\tint ret_code;\n\n\tassert(name);\n\tassert(node);\n\n\tnode_name = ixmlNode_getNodeName(node);\n\tif (node_name == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tif (strcmp(name, node_name) == 0)\n\t\tret_code = 0;\n\telse if (matchstr((char *)node_name, strlen(node_name),\n\t\t\t  \"%s:%s%0\", &dummy, &nameptr) == PARSE_OK &&\n\t\t strcmp(nameptr.buf, name) == 0)\n\t\tret_code = 0;\n\telse\n\t\t/* names are not the same */\n\t\tret_code = 1;\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "num_names > 0"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic int dom_find_deep_node(\n\t/* [in] array of names. */\n\tconst char *names[],\n\t/* [in] size of array. */\n\tint num_names,\n\t/* [in] Node from where it should should be searched. */\n\tIXML_Node *start_node,\n\t/* [out] Node that matches the last name of the array. */\n\tIXML_Node **matching_node)\n{\n\tint i;\n\tIXML_Node *node;\n\tIXML_Node *match_node;\n\n\tassert(num_names > 0);\n\n\tnode = start_node;\n\tif (dom_cmp_name(names[0], start_node) == 0) {\n\t\tif (num_names == 1) {\n\t\t\t*matching_node = start_node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t}\n\tfor (i = 1; i < num_names; i++) {\n\t\tif (dom_find_node(names[i], node, &match_node) != UPNP_E_SUCCESS)\n\t\t\treturn UPNP_E_NOT_FOUND;\n\t\tif (i == num_names - 1) {\n\t\t\t*matching_node = match_node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t\t/* try again */\n\t\tnode = match_node;\n\t}\n\n\t/* this line not reached */\n\treturn UPNP_E_NOT_FOUND;\n}"
  },
  {
    "function_name": "dom_find_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
    "lines": "102-127",
    "snippet": "static int dom_find_node(\n\t/* [in] name of the node. */\n\tconst char *node_name,\n\t/* [in] complete xml node. */\n\tIXML_Node *start_node,\n\t/* [out] matched node. */\n\tIXML_Node **matching_node)\n{\n\tIXML_Node *node;\n\n\t/* invalid args */\n\tif (!node_name || !start_node)\n\t\treturn UPNP_E_NOT_FOUND;\n\tnode = ixmlNode_getFirstChild(start_node);\n\twhile (node != NULL) {\n\t\t/* match name */\n\t\tif (dom_cmp_name(node_name, node) == 0) {\n\t\t\t*matching_node = node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t\t/* free and next node */\n\t\tnode = ixmlNode_getNextSibling(node);\n\t}\n\n\treturn UPNP_E_NOT_FOUND;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"uri.h\"",
      "#include \"soaplib.h\"",
      "#include \"upnpapi.h\"",
      "#include \"parsetools.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"membuffer.h\"",
      "#include \"miniserver.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ixmlNode_getNextSibling",
          "args": [
            "node"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dom_cmp_name",
          "args": [
            "node_name",
            "node"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "dom_cmp_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
          "lines": "66-94",
          "snippet": "static int dom_cmp_name(\n\t/* [in] lookup name. */\n\tconst char *name,\n\t/* [in] xml node. */\n\tIXML_Node *node)\n{\n\tconst DOMString node_name = NULL;\n\tmemptr nameptr;\n\tmemptr dummy;\n\tint ret_code;\n\n\tassert(name);\n\tassert(node);\n\n\tnode_name = ixmlNode_getNodeName(node);\n\tif (node_name == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tif (strcmp(name, node_name) == 0)\n\t\tret_code = 0;\n\telse if (matchstr((char *)node_name, strlen(node_name),\n\t\t\t  \"%s:%s%0\", &dummy, &nameptr) == PARSE_OK &&\n\t\t strcmp(nameptr.buf, name) == 0)\n\t\tret_code = 0;\n\telse\n\t\t/* names are not the same */\n\t\tret_code = 1;\n\n\treturn ret_code;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"uri.h\"",
            "#include \"soaplib.h\"",
            "#include \"upnpapi.h\"",
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"miniserver.h\"",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic int dom_cmp_name(\n\t/* [in] lookup name. */\n\tconst char *name,\n\t/* [in] xml node. */\n\tIXML_Node *node)\n{\n\tconst DOMString node_name = NULL;\n\tmemptr nameptr;\n\tmemptr dummy;\n\tint ret_code;\n\n\tassert(name);\n\tassert(node);\n\n\tnode_name = ixmlNode_getNodeName(node);\n\tif (node_name == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tif (strcmp(name, node_name) == 0)\n\t\tret_code = 0;\n\telse if (matchstr((char *)node_name, strlen(node_name),\n\t\t\t  \"%s:%s%0\", &dummy, &nameptr) == PARSE_OK &&\n\t\t strcmp(nameptr.buf, name) == 0)\n\t\tret_code = 0;\n\telse\n\t\t/* names are not the same */\n\t\tret_code = 1;\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "start_node"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic int dom_find_node(\n\t/* [in] name of the node. */\n\tconst char *node_name,\n\t/* [in] complete xml node. */\n\tIXML_Node *start_node,\n\t/* [out] matched node. */\n\tIXML_Node **matching_node)\n{\n\tIXML_Node *node;\n\n\t/* invalid args */\n\tif (!node_name || !start_node)\n\t\treturn UPNP_E_NOT_FOUND;\n\tnode = ixmlNode_getFirstChild(start_node);\n\twhile (node != NULL) {\n\t\t/* match name */\n\t\tif (dom_cmp_name(node_name, node) == 0) {\n\t\t\t*matching_node = node;\n\t\t\treturn UPNP_E_SUCCESS;\n\t\t}\n\t\t/* free and next node */\n\t\tnode = ixmlNode_getNextSibling(node);\n\t}\n\n\treturn UPNP_E_NOT_FOUND;\n}"
  },
  {
    "function_name": "dom_cmp_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_ctrlpt.c",
    "lines": "66-94",
    "snippet": "static int dom_cmp_name(\n\t/* [in] lookup name. */\n\tconst char *name,\n\t/* [in] xml node. */\n\tIXML_Node *node)\n{\n\tconst DOMString node_name = NULL;\n\tmemptr nameptr;\n\tmemptr dummy;\n\tint ret_code;\n\n\tassert(name);\n\tassert(node);\n\n\tnode_name = ixmlNode_getNodeName(node);\n\tif (node_name == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tif (strcmp(name, node_name) == 0)\n\t\tret_code = 0;\n\telse if (matchstr((char *)node_name, strlen(node_name),\n\t\t\t  \"%s:%s%0\", &dummy, &nameptr) == PARSE_OK &&\n\t\t strcmp(nameptr.buf, name) == 0)\n\t\tret_code = 0;\n\telse\n\t\t/* names are not the same */\n\t\tret_code = 1;\n\n\treturn ret_code;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"uri.h\"",
      "#include \"soaplib.h\"",
      "#include \"upnpapi.h\"",
      "#include \"parsetools.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"membuffer.h\"",
      "#include \"miniserver.h\"",
      "#include <stdarg.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "nameptr.buf",
            "name"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matchstr",
          "args": [
            "(char *)node_name",
            "strlen(node_name)",
            "\"%s:%s%0\"",
            "&dummy",
            "&nameptr"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "matchstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1168-1203",
          "snippet": "parse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "node_name"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "node_name"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNodeName",
          "args": [
            "node"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "node"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"uri.h\"\n#include \"soaplib.h\"\n#include \"upnpapi.h\"\n#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"miniserver.h\"\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic int dom_cmp_name(\n\t/* [in] lookup name. */\n\tconst char *name,\n\t/* [in] xml node. */\n\tIXML_Node *node)\n{\n\tconst DOMString node_name = NULL;\n\tmemptr nameptr;\n\tmemptr dummy;\n\tint ret_code;\n\n\tassert(name);\n\tassert(node);\n\n\tnode_name = ixmlNode_getNodeName(node);\n\tif (node_name == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tif (strcmp(name, node_name) == 0)\n\t\tret_code = 0;\n\telse if (matchstr((char *)node_name, strlen(node_name),\n\t\t\t  \"%s:%s%0\", &dummy, &nameptr) == PARSE_OK &&\n\t\t strcmp(nameptr.buf, name) == 0)\n\t\tret_code = 0;\n\telse\n\t\t/* names are not the same */\n\t\tret_code = 1;\n\n\treturn ret_code;\n}"
  }
]