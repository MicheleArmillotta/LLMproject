[
  {
    "function_name": "web_server_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "1466-1548",
    "snippet": "void web_server_callback(http_parser_t *parser, INOUT http_message_t *req,\n\tSOCKINFO *info)\n{\n\tint ret;\n\tint timeout = -1;\n\tenum resp_type rtype = 0;\n\tmembuffer headers;\n\tmembuffer filename;\n\tstruct xml_alias_t xmldoc;\n\tstruct SendInstruction RespInstr;\n\n\t/*Initialize instruction header. */\n\tRespInstr.IsVirtualFile = 0;\n\tRespInstr.IsChunkActive = 0;\n\tRespInstr.IsRangeActive = 0;\n\tRespInstr.IsTrailers = 0;\n\tmemset(RespInstr.AcceptLanguageHeader, 0,\n\t       sizeof(RespInstr.AcceptLanguageHeader));\n\t/* init */\n\tmembuffer_init(&headers);\n\tmembuffer_init(&filename);\n\n\t/*Process request should create the different kind of header depending on the */\n\t/*the type of request. */\n\tret = process_request(req, &rtype, &headers, &filename, &xmldoc,\n\t\t&RespInstr);\n\tif (ret != HTTP_OK) {\n\t\t/* send error code */\n\t\thttp_SendStatusResponse(info, ret, req->major_version,\n\t\t\treq->minor_version);\n\t} else {\n\t\t/* send response */\n\t\tswitch (rtype) {\n\t\tcase RESP_FILEDOC:\n\t\t\thttp_SendMessage(info, &timeout, \"Ibf\",\n\t\t\t\t\t &RespInstr,\n\t\t\t\t\t headers.buf, headers.length,\n\t\t\t\t\t filename.buf);\n\t\t\tbreak;\n\t\tcase RESP_XMLDOC:\n\t\t\thttp_SendMessage(info, &timeout, \"Ibb\",\n\t\t\t\t&RespInstr,\n\t\t\t\theaders.buf, headers.length,\n\t\t\t\txmldoc.doc.buf, xmldoc.doc.length);\n\t\t\talias_release(&xmldoc);\n\t\t\tbreak;\n\t\tcase RESP_WEBDOC:\n\t\t\t/*http_SendVirtualDirDoc(info, &timeout, \"Ibf\",\n\t\t\t\t&RespInstr,\n\t\t\t\theaders.buf, headers.length,\n\t\t\t\tfilename.buf);*/\n\t\t\thttp_SendMessage(info, &timeout, \"Ibf\",\n\t\t\t\t&RespInstr,\n\t\t\t\theaders.buf, headers.length,\n\t\t\t\tfilename.buf);\n\t\t\tbreak;\n\t\tcase RESP_HEADERS:\n\t\t\t/* headers only */\n\t\t\thttp_SendMessage(info, &timeout, \"b\",\n\t\t\t\theaders.buf, headers.length);\n\t\t\tbreak;\n\t\tcase RESP_POST:\n\t\t\t/* headers only */\n\t\t\tret = http_RecvPostMessage(parser, info, filename.buf,\n\t\t\t\t&RespInstr);\n\t\t\t/* Send response. */\n\t\t\thttp_MakeMessage(&headers, 1, 1,\n\t\t\t\t\"RTLSXcCc\",\n\t\t\t\tret, \"text/html\", &RespInstr, X_USER_AGENT);\n\t\t\thttp_SendMessage(info, &timeout, \"b\",\n\t\t\t\theaders.buf, headers.length);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"webserver: Invalid response type received.\\n\");\n\t\t\tassert(0);\n\t\t}\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"webserver: request processed...\\n\");\n\tmembuffer_destroy(&headers);\n\tmembuffer_destroy(&filename);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&filename"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "HTTP",
            "__FILE__",
            "__LINE__",
            "\"webserver: request processed...\\n\""
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_SendMessage",
          "args": [
            "info",
            "&timeout",
            "\"b\"",
            "headers.buf",
            "headers.length"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "437-613",
          "snippet": "int http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CHUNK_TAIL_SIZE (size_t)10",
            "#define CHUNK_HEADER_SIZE (size_t)10",
            "#define snprintf _snprintf",
            "#define fseeko fseek"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n#define snprintf _snprintf\n#define fseeko fseek\n\nint http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&headers",
            "1",
            "1",
            "\"RTLSXcCc\"",
            "ret",
            "\"text/html\"",
            "&RespInstr",
            "X_USER_AGENT"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_RecvPostMessage",
          "args": [
            "parser",
            "info",
            "filename.buf",
            "&RespInstr"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "http_RecvPostMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "1346-1464",
          "snippet": "static int http_RecvPostMessage(\n\t/*! HTTP Parser object. */\n\thttp_parser_t *parser,\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! File where received data is copied to. */\n\tchar *filename,\n\t/*! Send Instruction object which gives information whether the file\n\t * is a virtual file or not. */\n\tstruct SendInstruction *Instr)\n{\n\tsize_t Data_Buf_Size = 1024;\n\tchar Buf[1024];\n\tint Timeout = -1;\n\tFILE *Fp;\n\tparse_status_t status = PARSE_OK;\n\tint ok_on_close = FALSE;\n\tsize_t entity_offset = 0;\n\tint num_read = 0;\n\tint ret_code = HTTP_OK;\n\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tFp = (virtualDirCallback.open) (filename, UPNP_WRITE);\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t} else {\n\t\tFp = fopen(filename, \"wb\");\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\tparser->position = POS_ENTITY;\n\tdo {\n\t\t/* first parse what has already been gotten */\n\t\tif (parser->position != POS_COMPLETE)\n\t\t\tstatus = parser_parse_entity(parser);\n\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t/* read until close */\n\t\t\tok_on_close = TRUE;\n\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t/* error */\n\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t\t/* read more if necessary entity */\n\t\twhile (entity_offset + Data_Buf_Size > parser->msg.entity.length &&\n\t\t       parser->position != POS_COMPLETE) {\n\t\t\tnum_read = sock_read(info, Buf, sizeof(Buf), &Timeout);\n\t\t\tif (num_read > 0) {\n\t\t\t\t/* append data to buffer */\n\t\t\t\tif (membuffer_append(&parser->msg.msg,\n\t\t\t\t\tBuf, (size_t)num_read) != 0) {\n\t\t\t\t\t/* set failure status */\n\t\t\t\t\tparser->http_error_code =\n\t\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tstatus = parser_parse_entity(parser);\n\t\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t\t/* read until close */\n\t\t\t\t\tok_on_close = TRUE;\n\t\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else if (num_read == 0) {\n\t\t\t\tif (ok_on_close) {\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t\tparser->msg.msg.buf);\n\t\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\t\tparser->position = POS_COMPLETE;\n\t\t\t\t} else {\n\t\t\t\t\t/* partial msg or response */\n\t\t\t\t\tparser->http_error_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret_code = HTTP_SERVICE_UNAVAILABLE;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t\tif ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {\n\t\t\tData_Buf_Size =\n\t\t\t    parser->msg.entity.length - entity_offset;\n\t\t}\n\t\tmemcpy(Buf,\n\t\t       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],\n\t\t       Data_Buf_Size);\n\t\tentity_offset += Data_Buf_Size;\n\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\tint n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);\n\t\t\tif (n < 0) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\tsize_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);\n\t\t\tif (n != Data_Buf_Size) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t} while (parser->position != POS_COMPLETE ||\n\t\t entity_offset != parser->msg.entity.length);\nExitFunction:\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tvirtualDirCallback.close(Fp);\n\t} else {\n\t\tfclose(Fp);\n\t}\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic int http_RecvPostMessage(\n\t/*! HTTP Parser object. */\n\thttp_parser_t *parser,\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! File where received data is copied to. */\n\tchar *filename,\n\t/*! Send Instruction object which gives information whether the file\n\t * is a virtual file or not. */\n\tstruct SendInstruction *Instr)\n{\n\tsize_t Data_Buf_Size = 1024;\n\tchar Buf[1024];\n\tint Timeout = -1;\n\tFILE *Fp;\n\tparse_status_t status = PARSE_OK;\n\tint ok_on_close = FALSE;\n\tsize_t entity_offset = 0;\n\tint num_read = 0;\n\tint ret_code = HTTP_OK;\n\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tFp = (virtualDirCallback.open) (filename, UPNP_WRITE);\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t} else {\n\t\tFp = fopen(filename, \"wb\");\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\tparser->position = POS_ENTITY;\n\tdo {\n\t\t/* first parse what has already been gotten */\n\t\tif (parser->position != POS_COMPLETE)\n\t\t\tstatus = parser_parse_entity(parser);\n\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t/* read until close */\n\t\t\tok_on_close = TRUE;\n\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t/* error */\n\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t\t/* read more if necessary entity */\n\t\twhile (entity_offset + Data_Buf_Size > parser->msg.entity.length &&\n\t\t       parser->position != POS_COMPLETE) {\n\t\t\tnum_read = sock_read(info, Buf, sizeof(Buf), &Timeout);\n\t\t\tif (num_read > 0) {\n\t\t\t\t/* append data to buffer */\n\t\t\t\tif (membuffer_append(&parser->msg.msg,\n\t\t\t\t\tBuf, (size_t)num_read) != 0) {\n\t\t\t\t\t/* set failure status */\n\t\t\t\t\tparser->http_error_code =\n\t\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tstatus = parser_parse_entity(parser);\n\t\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t\t/* read until close */\n\t\t\t\t\tok_on_close = TRUE;\n\t\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else if (num_read == 0) {\n\t\t\t\tif (ok_on_close) {\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t\tparser->msg.msg.buf);\n\t\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\t\tparser->position = POS_COMPLETE;\n\t\t\t\t} else {\n\t\t\t\t\t/* partial msg or response */\n\t\t\t\t\tparser->http_error_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret_code = HTTP_SERVICE_UNAVAILABLE;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t\tif ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {\n\t\t\tData_Buf_Size =\n\t\t\t    parser->msg.entity.length - entity_offset;\n\t\t}\n\t\tmemcpy(Buf,\n\t\t       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],\n\t\t       Data_Buf_Size);\n\t\tentity_offset += Data_Buf_Size;\n\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\tint n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);\n\t\t\tif (n < 0) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\tsize_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);\n\t\t\tif (n != Data_Buf_Size) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t} while (parser->position != POS_COMPLETE ||\n\t\t entity_offset != parser->msg.entity.length);\nExitFunction:\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tvirtualDirCallback.close(Fp);\n\t} else {\n\t\tfclose(Fp);\n\t}\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alias_release",
          "args": [
            "&xmldoc"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "alias_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "401-419",
          "snippet": "static void alias_release(\n\t/*! [in] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\t/* ignore invalid alias */\n\tif (!is_valid_alias(alias)) {\n\t\tithread_mutex_unlock(&gWebMutex);\n\t\treturn;\n\t}\n\tassert(*alias->ct > 0);\n\t*alias->ct -= 1;\n\tif (*alias->ct <= 0) {\n\t\tmembuffer_destroy(&alias->doc);\n\t\tmembuffer_destroy(&alias->name);\n\t\tfree(alias->ct);\n\t}\n\tithread_mutex_unlock(&gWebMutex);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic void alias_release(\n\t/*! [in] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\t/* ignore invalid alias */\n\tif (!is_valid_alias(alias)) {\n\t\tithread_mutex_unlock(&gWebMutex);\n\t\treturn;\n\t}\n\tassert(*alias->ct > 0);\n\t*alias->ct -= 1;\n\tif (*alias->ct <= 0) {\n\t\tmembuffer_destroy(&alias->doc);\n\t\tmembuffer_destroy(&alias->name);\n\t\tfree(alias->ct);\n\t}\n\tithread_mutex_unlock(&gWebMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_SendStatusResponse",
          "args": [
            "info",
            "ret",
            "req->major_version",
            "req->minor_version"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendStatusResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1445-1468",
          "snippet": "int http_SendStatusResponse(IN SOCKINFO *info, IN int http_status_code,\n\tIN int request_major_version, IN int request_minor_version)\n{\n\tint response_major, response_minor;\n\tmembuffer membuf;\n\tint ret;\n\tint timeout;\n\n\thttp_CalcResponseVersion(request_major_version, request_minor_version,\n\t\t\t\t &response_major, &response_minor);\n\tmembuffer_init(&membuf);\n\tmembuf.size_inc = (size_t)70;\n\t/* response start line */\n\tret = http_MakeMessage(&membuf, response_major, response_minor, \"RSCB\",\n\t\t\t       http_status_code, http_status_code);\n\tif (ret == 0) {\n\t\ttimeout = HTTP_DEFAULT_TIMEOUT;\n\t\tret = http_SendMessage(info, &timeout, \"b\",\n\t\t       membuf.buf, membuf.length);\n\t}\n\tmembuffer_destroy(&membuf);\n\n\treturn ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_SendStatusResponse(IN SOCKINFO *info, IN int http_status_code,\n\tIN int request_major_version, IN int request_minor_version)\n{\n\tint response_major, response_minor;\n\tmembuffer membuf;\n\tint ret;\n\tint timeout;\n\n\thttp_CalcResponseVersion(request_major_version, request_minor_version,\n\t\t\t\t &response_major, &response_minor);\n\tmembuffer_init(&membuf);\n\tmembuf.size_inc = (size_t)70;\n\t/* response start line */\n\tret = http_MakeMessage(&membuf, response_major, response_minor, \"RSCB\",\n\t\t\t       http_status_code, http_status_code);\n\tif (ret == 0) {\n\t\ttimeout = HTTP_DEFAULT_TIMEOUT;\n\t\tret = http_SendMessage(info, &timeout, \"b\",\n\t\t       membuf.buf, membuf.length);\n\t}\n\tmembuffer_destroy(&membuf);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_request",
          "args": [
            "req",
            "&rtype",
            "&headers",
            "&filename",
            "&xmldoc",
            "&RespInstr"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "process_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "1026-1334",
          "snippet": "static int process_request(\n\t/*! [in] HTTP Request message. */\n\thttp_message_t *req,\n\t/*! [out] Tpye of response. */\n\tenum resp_type *rtype,\n\t/*! [out] Headers. */\n\tmembuffer *headers,\n\t/*! [out] Get filename from request document. */\n\tmembuffer *filename,\n\t/*! [out] Xml alias document from the request document. */\n\tstruct xml_alias_t *alias,\n\t/*! [out] Send Instruction object where the response is set up. */\n\tstruct SendInstruction *RespInstr)\n{\n\tint code;\n\tint err_code;\n\n\tchar *request_doc;\n\tUpnpFileInfo *finfo;\n\ttime_t aux_LastModified;\n\tint using_alias;\n\tint using_virtual_dir;\n\turi_type *url;\n\tconst char *temp_str;\n\tint resp_major;\n\tint resp_minor;\n\tint alias_grabbed;\n\tsize_t dummy;\n\tconst char *extra_headers = NULL;\n\n\tprint_http_headers(req);\n\turl = &req->uri;\n\tassert(req->method == HTTPMETHOD_GET ||\n\t       req->method == HTTPMETHOD_HEAD ||\n\t       req->method == HTTPMETHOD_POST ||\n\t       req->method == HTTPMETHOD_SIMPLEGET);\n\t/* init */\n\tmemset(&finfo, 0, sizeof(finfo));\n\trequest_doc = NULL;\n\tfinfo = UpnpFileInfo_new();\n\talias_grabbed = FALSE;\n\terr_code = HTTP_INTERNAL_SERVER_ERROR;\t/* default error */\n\tusing_virtual_dir = FALSE;\n\tusing_alias = FALSE;\n\n\thttp_CalcResponseVersion(req->major_version, req->minor_version,\n\t\t\t\t &resp_major, &resp_minor);\n\t/* */\n\t/* remove dots */\n\t/* */\n\trequest_doc = malloc(url->pathquery.size + 1);\n\tif (request_doc == NULL) {\n\t\tgoto error_handler;\t/* out of mem */\n\t}\n\tmemcpy(request_doc, url->pathquery.buff, url->pathquery.size);\n\trequest_doc[url->pathquery.size] = '\\0';\n\tdummy = url->pathquery.size;\n\tremove_escaped_chars(request_doc, &dummy);\n\tcode = remove_dots(request_doc, url->pathquery.size);\n\tif (code != 0) {\n\t\terr_code = HTTP_FORBIDDEN;\n\t\tgoto error_handler;\n\t}\n\tif (*request_doc != '/') {\n\t\t/* no slash */\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\tif (isFileInVirtualDir(request_doc)) {\n\t\tusing_virtual_dir = TRUE;\n\t\tRespInstr->IsVirtualFile = 1;\n\t\tif (membuffer_assign_str(filename, request_doc) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* try using alias */\n\t\tif (is_valid_alias(&gAliasDoc)) {\n\t\t\talias_grab(alias);\n\t\t\talias_grabbed = TRUE;\n\t\t\tusing_alias = get_alias(request_doc, alias, finfo);\n\t\t\tif (using_alias == TRUE) {\n\t\t\t\tUpnpFileInfo_set_ContentType(finfo,\n\t\t\t\t\t\"text/xml; charset=\\\"utf-8\\\"\");\n\t\t\t\tif (UpnpFileInfo_get_ContentType(finfo) == NULL) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (using_virtual_dir) {\n\t\tif (req->method != HTTPMETHOD_POST) {\n\t\t\t/* get file info */\n\t\t\tif (virtualDirCallback.\n\t\t\t    get_info(filename->buf, finfo) != 0) {\n\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* try index.html if req is a dir */\n\t\t\tif (UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\tif (filename->buf[filename->length - 1] == '/') {\n\t\t\t\t\ttemp_str = \"index.html\";\n\t\t\t\t} else {\n\t\t\t\t\ttemp_str = \"/index.html\";\n\t\t\t\t}\n\t\t\t\tif (membuffer_append_str(filename, temp_str) !=\n\t\t\t\t    0) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t\t/* get info */\n\t\t\t\tif (virtualDirCallback.get_info(filename->buf, finfo) != UPNP_E_SUCCESS ||\n\t\t\t\t    UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* not readable */\n\t\t\tif (!UpnpFileInfo_get_IsReadable(finfo)) {\n\t\t\t\terr_code = HTTP_FORBIDDEN;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* finally, get content type */\n\t\t\t/* if ( get_content_type(filename->buf, &content_type) != 0 ) */\n\t\t\t/*{ */\n\t\t\t/*  goto error_handler; */\n\t\t\t/* } */\n\t\t}\n\t} else if (!using_alias) {\n\t\tif (gDocumentRootDir.length == 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* */\n\t\t/* get file name */\n\t\t/* */\n\n\t\t/* filename str */\n\t\tif (membuffer_assign_str(filename, gDocumentRootDir.buf) != 0 ||\n\t\t    membuffer_append_str(filename, request_doc) != 0) {\n\t\t\tgoto error_handler;\t/* out of mem */\n\t\t}\n\t\t/* remove trailing slashes */\n\t\twhile (filename->length > 0 &&\n\t\t       filename->buf[filename->length - 1] == '/') {\n\t\t\tmembuffer_delete(filename, filename->length - 1, 1);\n\t\t}\n\t\tif (req->method != HTTPMETHOD_POST) {\n\t\t\t/* get info on file */\n\t\t\tif (get_file_info(filename->buf, finfo) != 0) {\n\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* try index.html if req is a dir */\n\t\t\tif (UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\tif (filename->buf[filename->length - 1] == '/') {\n\t\t\t\t\ttemp_str = \"index.html\";\n\t\t\t\t} else {\n\t\t\t\t\ttemp_str = \"/index.html\";\n\t\t\t\t}\n\t\t\t\tif (membuffer_append_str(filename, temp_str) !=\n\t\t\t\t    0) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t\t/* get info */\n\t\t\t\tif (get_file_info(filename->buf, finfo) != 0 ||\n\t\t\t\t    UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* not readable */\n\t\t\tif (!UpnpFileInfo_get_IsReadable(finfo)) {\n\t\t\t\terr_code = HTTP_FORBIDDEN;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\t/* finally, get content type */\n\t\t/*      if ( get_content_type(filename->buf, &content_type) != 0 ) */\n\t\t/*      { */\n\t\t/*          goto error_handler; */\n\t\t/*      } */\n\t}\n\tRespInstr->ReadSendSize = UpnpFileInfo_get_FileLength(finfo);\n\t/* Check other header field. */\n\tcode = CheckOtherHTTPHeaders(req, RespInstr,\n\t\tUpnpFileInfo_get_FileLength(finfo));\n\tif (code != HTTP_OK) {\n\t\terr_code = code;\n\t\tgoto error_handler;\n\t}\n\tif (req->method == HTTPMETHOD_POST) {\n\t\t*rtype = RESP_POST;\n\t\terr_code = HTTP_OK;\n\t\tgoto error_handler;\n\t}\n\textra_headers = UpnpFileInfo_get_ExtraHeaders(finfo);\n\tif (!extra_headers) {\n\t\textra_headers = \"\";\n\t}\n\n\t/* Check if chunked encoding should be used. */\n\tif (using_virtual_dir && UpnpFileInfo_get_FileLength(finfo) == UPNP_USING_CHUNKED) {\n\t\t/* Chunked encoding is only supported by HTTP 1.1 clients */\n\t\tif (resp_major == 1 && resp_minor == 1) {\n\t\t\tRespInstr->IsChunkActive = 1;\n\t\t} else {\n\t\t\t/* The virtual callback indicates that we should use\n\t\t\t * chunked encoding however the client doesn't support\n\t\t\t * it. Return with an internal server error. */\n\t\t\terr_code = HTTP_NOT_ACCEPTABLE;\n\t\t\tgoto error_handler;\n\t\t}\n\t}\n\n\taux_LastModified = UpnpFileInfo_get_LastModified(finfo);\n\tif (RespInstr->IsRangeActive && RespInstr->IsChunkActive) {\n\t\t/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\t\t/* Transfer-Encoding: chunked */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"R\" \"T\" \"GKLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_PARTIAL_CONTENT,\t/* status code */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* range info */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else if (RespInstr->IsRangeActive && !RespInstr->IsChunkActive) {\n\t\t/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"R\" \"N\" \"T\" \"GLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_PARTIAL_CONTENT,\t/* status code */\n\t\t    RespInstr->ReadSendSize,\t/* content length */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* range info */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else if (!RespInstr->IsRangeActive && RespInstr->IsChunkActive) {\n\t\t/* Transfer-Encoding: chunked */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"RK\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_OK,\t/* status code */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* !RespInstr->IsRangeActive && !RespInstr->IsChunkActive */\n\t\tif (RespInstr->ReadSendSize >= 0) {\n\t\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t\t    \"R\" \"N\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t\t    HTTP_OK,\t/* status code */\n\t\t\t    RespInstr->ReadSendSize,\t/* content length */\n\t\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t\t    RespInstr,\t/* language info */\n\t\t\t    \"LAST-MODIFIED: \",\n\t\t\t    &aux_LastModified,\n\t\t\t    X_USER_AGENT,\n\t\t\t    extra_headers) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else {\n\t\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t\t    \"R\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t\t    HTTP_OK,\t/* status code */\n\t\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t\t    RespInstr,\t/* language info */\n\t\t\t    \"LAST-MODIFIED: \",\n\t\t\t    &aux_LastModified,\n\t\t\t    X_USER_AGENT,\n\t\t\t    extra_headers) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t}\n\tif (req->method == HTTPMETHOD_HEAD) {\n\t\t*rtype = RESP_HEADERS;\n\t} else if (using_alias) {\n\t\t/* GET xml */\n\t\t*rtype = RESP_XMLDOC;\n\t} else if (using_virtual_dir) {\n\t\t*rtype = RESP_WEBDOC;\n\t} else {\n\t\t/* GET filename */\n\t\t*rtype = RESP_FILEDOC;\n\t}\n\t/* simple get http 0.9 as specified in http 1.0 */\n\t/* don't send headers */\n\tif (req->method == HTTPMETHOD_SIMPLEGET) {\n\t\tmembuffer_destroy(headers);\n\t}\n\terr_code = HTTP_OK;\n\n error_handler:\n\tfree(request_doc);\n\tUpnpFileInfo_delete(finfo);\n\tif (err_code != HTTP_OK && alias_grabbed) {\n\t\talias_release(alias);\n\t}\n\n\treturn err_code;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic int process_request(\n\t/*! [in] HTTP Request message. */\n\thttp_message_t *req,\n\t/*! [out] Tpye of response. */\n\tenum resp_type *rtype,\n\t/*! [out] Headers. */\n\tmembuffer *headers,\n\t/*! [out] Get filename from request document. */\n\tmembuffer *filename,\n\t/*! [out] Xml alias document from the request document. */\n\tstruct xml_alias_t *alias,\n\t/*! [out] Send Instruction object where the response is set up. */\n\tstruct SendInstruction *RespInstr)\n{\n\tint code;\n\tint err_code;\n\n\tchar *request_doc;\n\tUpnpFileInfo *finfo;\n\ttime_t aux_LastModified;\n\tint using_alias;\n\tint using_virtual_dir;\n\turi_type *url;\n\tconst char *temp_str;\n\tint resp_major;\n\tint resp_minor;\n\tint alias_grabbed;\n\tsize_t dummy;\n\tconst char *extra_headers = NULL;\n\n\tprint_http_headers(req);\n\turl = &req->uri;\n\tassert(req->method == HTTPMETHOD_GET ||\n\t       req->method == HTTPMETHOD_HEAD ||\n\t       req->method == HTTPMETHOD_POST ||\n\t       req->method == HTTPMETHOD_SIMPLEGET);\n\t/* init */\n\tmemset(&finfo, 0, sizeof(finfo));\n\trequest_doc = NULL;\n\tfinfo = UpnpFileInfo_new();\n\talias_grabbed = FALSE;\n\terr_code = HTTP_INTERNAL_SERVER_ERROR;\t/* default error */\n\tusing_virtual_dir = FALSE;\n\tusing_alias = FALSE;\n\n\thttp_CalcResponseVersion(req->major_version, req->minor_version,\n\t\t\t\t &resp_major, &resp_minor);\n\t/* */\n\t/* remove dots */\n\t/* */\n\trequest_doc = malloc(url->pathquery.size + 1);\n\tif (request_doc == NULL) {\n\t\tgoto error_handler;\t/* out of mem */\n\t}\n\tmemcpy(request_doc, url->pathquery.buff, url->pathquery.size);\n\trequest_doc[url->pathquery.size] = '\\0';\n\tdummy = url->pathquery.size;\n\tremove_escaped_chars(request_doc, &dummy);\n\tcode = remove_dots(request_doc, url->pathquery.size);\n\tif (code != 0) {\n\t\terr_code = HTTP_FORBIDDEN;\n\t\tgoto error_handler;\n\t}\n\tif (*request_doc != '/') {\n\t\t/* no slash */\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\tif (isFileInVirtualDir(request_doc)) {\n\t\tusing_virtual_dir = TRUE;\n\t\tRespInstr->IsVirtualFile = 1;\n\t\tif (membuffer_assign_str(filename, request_doc) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* try using alias */\n\t\tif (is_valid_alias(&gAliasDoc)) {\n\t\t\talias_grab(alias);\n\t\t\talias_grabbed = TRUE;\n\t\t\tusing_alias = get_alias(request_doc, alias, finfo);\n\t\t\tif (using_alias == TRUE) {\n\t\t\t\tUpnpFileInfo_set_ContentType(finfo,\n\t\t\t\t\t\"text/xml; charset=\\\"utf-8\\\"\");\n\t\t\t\tif (UpnpFileInfo_get_ContentType(finfo) == NULL) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (using_virtual_dir) {\n\t\tif (req->method != HTTPMETHOD_POST) {\n\t\t\t/* get file info */\n\t\t\tif (virtualDirCallback.\n\t\t\t    get_info(filename->buf, finfo) != 0) {\n\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* try index.html if req is a dir */\n\t\t\tif (UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\tif (filename->buf[filename->length - 1] == '/') {\n\t\t\t\t\ttemp_str = \"index.html\";\n\t\t\t\t} else {\n\t\t\t\t\ttemp_str = \"/index.html\";\n\t\t\t\t}\n\t\t\t\tif (membuffer_append_str(filename, temp_str) !=\n\t\t\t\t    0) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t\t/* get info */\n\t\t\t\tif (virtualDirCallback.get_info(filename->buf, finfo) != UPNP_E_SUCCESS ||\n\t\t\t\t    UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* not readable */\n\t\t\tif (!UpnpFileInfo_get_IsReadable(finfo)) {\n\t\t\t\terr_code = HTTP_FORBIDDEN;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* finally, get content type */\n\t\t\t/* if ( get_content_type(filename->buf, &content_type) != 0 ) */\n\t\t\t/*{ */\n\t\t\t/*  goto error_handler; */\n\t\t\t/* } */\n\t\t}\n\t} else if (!using_alias) {\n\t\tif (gDocumentRootDir.length == 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* */\n\t\t/* get file name */\n\t\t/* */\n\n\t\t/* filename str */\n\t\tif (membuffer_assign_str(filename, gDocumentRootDir.buf) != 0 ||\n\t\t    membuffer_append_str(filename, request_doc) != 0) {\n\t\t\tgoto error_handler;\t/* out of mem */\n\t\t}\n\t\t/* remove trailing slashes */\n\t\twhile (filename->length > 0 &&\n\t\t       filename->buf[filename->length - 1] == '/') {\n\t\t\tmembuffer_delete(filename, filename->length - 1, 1);\n\t\t}\n\t\tif (req->method != HTTPMETHOD_POST) {\n\t\t\t/* get info on file */\n\t\t\tif (get_file_info(filename->buf, finfo) != 0) {\n\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* try index.html if req is a dir */\n\t\t\tif (UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\tif (filename->buf[filename->length - 1] == '/') {\n\t\t\t\t\ttemp_str = \"index.html\";\n\t\t\t\t} else {\n\t\t\t\t\ttemp_str = \"/index.html\";\n\t\t\t\t}\n\t\t\t\tif (membuffer_append_str(filename, temp_str) !=\n\t\t\t\t    0) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t\t/* get info */\n\t\t\t\tif (get_file_info(filename->buf, finfo) != 0 ||\n\t\t\t\t    UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* not readable */\n\t\t\tif (!UpnpFileInfo_get_IsReadable(finfo)) {\n\t\t\t\terr_code = HTTP_FORBIDDEN;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\t/* finally, get content type */\n\t\t/*      if ( get_content_type(filename->buf, &content_type) != 0 ) */\n\t\t/*      { */\n\t\t/*          goto error_handler; */\n\t\t/*      } */\n\t}\n\tRespInstr->ReadSendSize = UpnpFileInfo_get_FileLength(finfo);\n\t/* Check other header field. */\n\tcode = CheckOtherHTTPHeaders(req, RespInstr,\n\t\tUpnpFileInfo_get_FileLength(finfo));\n\tif (code != HTTP_OK) {\n\t\terr_code = code;\n\t\tgoto error_handler;\n\t}\n\tif (req->method == HTTPMETHOD_POST) {\n\t\t*rtype = RESP_POST;\n\t\terr_code = HTTP_OK;\n\t\tgoto error_handler;\n\t}\n\textra_headers = UpnpFileInfo_get_ExtraHeaders(finfo);\n\tif (!extra_headers) {\n\t\textra_headers = \"\";\n\t}\n\n\t/* Check if chunked encoding should be used. */\n\tif (using_virtual_dir && UpnpFileInfo_get_FileLength(finfo) == UPNP_USING_CHUNKED) {\n\t\t/* Chunked encoding is only supported by HTTP 1.1 clients */\n\t\tif (resp_major == 1 && resp_minor == 1) {\n\t\t\tRespInstr->IsChunkActive = 1;\n\t\t} else {\n\t\t\t/* The virtual callback indicates that we should use\n\t\t\t * chunked encoding however the client doesn't support\n\t\t\t * it. Return with an internal server error. */\n\t\t\terr_code = HTTP_NOT_ACCEPTABLE;\n\t\t\tgoto error_handler;\n\t\t}\n\t}\n\n\taux_LastModified = UpnpFileInfo_get_LastModified(finfo);\n\tif (RespInstr->IsRangeActive && RespInstr->IsChunkActive) {\n\t\t/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\t\t/* Transfer-Encoding: chunked */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"R\" \"T\" \"GKLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_PARTIAL_CONTENT,\t/* status code */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* range info */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else if (RespInstr->IsRangeActive && !RespInstr->IsChunkActive) {\n\t\t/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"R\" \"N\" \"T\" \"GLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_PARTIAL_CONTENT,\t/* status code */\n\t\t    RespInstr->ReadSendSize,\t/* content length */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* range info */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else if (!RespInstr->IsRangeActive && RespInstr->IsChunkActive) {\n\t\t/* Transfer-Encoding: chunked */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"RK\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_OK,\t/* status code */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* !RespInstr->IsRangeActive && !RespInstr->IsChunkActive */\n\t\tif (RespInstr->ReadSendSize >= 0) {\n\t\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t\t    \"R\" \"N\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t\t    HTTP_OK,\t/* status code */\n\t\t\t    RespInstr->ReadSendSize,\t/* content length */\n\t\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t\t    RespInstr,\t/* language info */\n\t\t\t    \"LAST-MODIFIED: \",\n\t\t\t    &aux_LastModified,\n\t\t\t    X_USER_AGENT,\n\t\t\t    extra_headers) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else {\n\t\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t\t    \"R\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t\t    HTTP_OK,\t/* status code */\n\t\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t\t    RespInstr,\t/* language info */\n\t\t\t    \"LAST-MODIFIED: \",\n\t\t\t    &aux_LastModified,\n\t\t\t    X_USER_AGENT,\n\t\t\t    extra_headers) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t}\n\tif (req->method == HTTPMETHOD_HEAD) {\n\t\t*rtype = RESP_HEADERS;\n\t} else if (using_alias) {\n\t\t/* GET xml */\n\t\t*rtype = RESP_XMLDOC;\n\t} else if (using_virtual_dir) {\n\t\t*rtype = RESP_WEBDOC;\n\t} else {\n\t\t/* GET filename */\n\t\t*rtype = RESP_FILEDOC;\n\t}\n\t/* simple get http 0.9 as specified in http 1.0 */\n\t/* don't send headers */\n\tif (req->method == HTTPMETHOD_SIMPLEGET) {\n\t\tmembuffer_destroy(headers);\n\t}\n\terr_code = HTTP_OK;\n\n error_handler:\n\tfree(request_doc);\n\tUpnpFileInfo_delete(finfo);\n\tif (err_code != HTTP_OK && alias_grabbed) {\n\t\talias_release(alias);\n\t}\n\n\treturn err_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&filename"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "RespInstr.AcceptLanguageHeader",
            "0",
            "sizeof(RespInstr.AcceptLanguageHeader)"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nvoid web_server_callback(http_parser_t *parser, INOUT http_message_t *req,\n\tSOCKINFO *info)\n{\n\tint ret;\n\tint timeout = -1;\n\tenum resp_type rtype = 0;\n\tmembuffer headers;\n\tmembuffer filename;\n\tstruct xml_alias_t xmldoc;\n\tstruct SendInstruction RespInstr;\n\n\t/*Initialize instruction header. */\n\tRespInstr.IsVirtualFile = 0;\n\tRespInstr.IsChunkActive = 0;\n\tRespInstr.IsRangeActive = 0;\n\tRespInstr.IsTrailers = 0;\n\tmemset(RespInstr.AcceptLanguageHeader, 0,\n\t       sizeof(RespInstr.AcceptLanguageHeader));\n\t/* init */\n\tmembuffer_init(&headers);\n\tmembuffer_init(&filename);\n\n\t/*Process request should create the different kind of header depending on the */\n\t/*the type of request. */\n\tret = process_request(req, &rtype, &headers, &filename, &xmldoc,\n\t\t&RespInstr);\n\tif (ret != HTTP_OK) {\n\t\t/* send error code */\n\t\thttp_SendStatusResponse(info, ret, req->major_version,\n\t\t\treq->minor_version);\n\t} else {\n\t\t/* send response */\n\t\tswitch (rtype) {\n\t\tcase RESP_FILEDOC:\n\t\t\thttp_SendMessage(info, &timeout, \"Ibf\",\n\t\t\t\t\t &RespInstr,\n\t\t\t\t\t headers.buf, headers.length,\n\t\t\t\t\t filename.buf);\n\t\t\tbreak;\n\t\tcase RESP_XMLDOC:\n\t\t\thttp_SendMessage(info, &timeout, \"Ibb\",\n\t\t\t\t&RespInstr,\n\t\t\t\theaders.buf, headers.length,\n\t\t\t\txmldoc.doc.buf, xmldoc.doc.length);\n\t\t\talias_release(&xmldoc);\n\t\t\tbreak;\n\t\tcase RESP_WEBDOC:\n\t\t\t/*http_SendVirtualDirDoc(info, &timeout, \"Ibf\",\n\t\t\t\t&RespInstr,\n\t\t\t\theaders.buf, headers.length,\n\t\t\t\tfilename.buf);*/\n\t\t\thttp_SendMessage(info, &timeout, \"Ibf\",\n\t\t\t\t&RespInstr,\n\t\t\t\theaders.buf, headers.length,\n\t\t\t\tfilename.buf);\n\t\t\tbreak;\n\t\tcase RESP_HEADERS:\n\t\t\t/* headers only */\n\t\t\thttp_SendMessage(info, &timeout, \"b\",\n\t\t\t\theaders.buf, headers.length);\n\t\t\tbreak;\n\t\tcase RESP_POST:\n\t\t\t/* headers only */\n\t\t\tret = http_RecvPostMessage(parser, info, filename.buf,\n\t\t\t\t&RespInstr);\n\t\t\t/* Send response. */\n\t\t\thttp_MakeMessage(&headers, 1, 1,\n\t\t\t\t\"RTLSXcCc\",\n\t\t\t\tret, \"text/html\", &RespInstr, X_USER_AGENT);\n\t\t\thttp_SendMessage(info, &timeout, \"b\",\n\t\t\t\theaders.buf, headers.length);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"webserver: Invalid response type received.\\n\");\n\t\t\tassert(0);\n\t\t}\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"webserver: request processed...\\n\");\n\tmembuffer_destroy(&headers);\n\tmembuffer_destroy(&filename);\n}"
  },
  {
    "function_name": "http_RecvPostMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "1346-1464",
    "snippet": "static int http_RecvPostMessage(\n\t/*! HTTP Parser object. */\n\thttp_parser_t *parser,\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! File where received data is copied to. */\n\tchar *filename,\n\t/*! Send Instruction object which gives information whether the file\n\t * is a virtual file or not. */\n\tstruct SendInstruction *Instr)\n{\n\tsize_t Data_Buf_Size = 1024;\n\tchar Buf[1024];\n\tint Timeout = -1;\n\tFILE *Fp;\n\tparse_status_t status = PARSE_OK;\n\tint ok_on_close = FALSE;\n\tsize_t entity_offset = 0;\n\tint num_read = 0;\n\tint ret_code = HTTP_OK;\n\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tFp = (virtualDirCallback.open) (filename, UPNP_WRITE);\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t} else {\n\t\tFp = fopen(filename, \"wb\");\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\tparser->position = POS_ENTITY;\n\tdo {\n\t\t/* first parse what has already been gotten */\n\t\tif (parser->position != POS_COMPLETE)\n\t\t\tstatus = parser_parse_entity(parser);\n\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t/* read until close */\n\t\t\tok_on_close = TRUE;\n\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t/* error */\n\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t\t/* read more if necessary entity */\n\t\twhile (entity_offset + Data_Buf_Size > parser->msg.entity.length &&\n\t\t       parser->position != POS_COMPLETE) {\n\t\t\tnum_read = sock_read(info, Buf, sizeof(Buf), &Timeout);\n\t\t\tif (num_read > 0) {\n\t\t\t\t/* append data to buffer */\n\t\t\t\tif (membuffer_append(&parser->msg.msg,\n\t\t\t\t\tBuf, (size_t)num_read) != 0) {\n\t\t\t\t\t/* set failure status */\n\t\t\t\t\tparser->http_error_code =\n\t\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tstatus = parser_parse_entity(parser);\n\t\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t\t/* read until close */\n\t\t\t\t\tok_on_close = TRUE;\n\t\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else if (num_read == 0) {\n\t\t\t\tif (ok_on_close) {\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t\tparser->msg.msg.buf);\n\t\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\t\tparser->position = POS_COMPLETE;\n\t\t\t\t} else {\n\t\t\t\t\t/* partial msg or response */\n\t\t\t\t\tparser->http_error_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret_code = HTTP_SERVICE_UNAVAILABLE;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t\tif ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {\n\t\t\tData_Buf_Size =\n\t\t\t    parser->msg.entity.length - entity_offset;\n\t\t}\n\t\tmemcpy(Buf,\n\t\t       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],\n\t\t       Data_Buf_Size);\n\t\tentity_offset += Data_Buf_Size;\n\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\tint n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);\n\t\t\tif (n < 0) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\tsize_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);\n\t\t\tif (n != Data_Buf_Size) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t} while (parser->position != POS_COMPLETE ||\n\t\t entity_offset != parser->msg.entity.length);\nExitFunction:\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tvirtualDirCallback.close(Fp);\n\t} else {\n\t\tfclose(Fp);\n\t}\n\n\treturn ret_code;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "Fp"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virtualDirCallback.close",
          "args": [
            "Fp"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "Buf",
            "1",
            "Data_Buf_Size",
            "Fp"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virtualDirCallback.write",
          "args": [
            "Fp",
            "Buf",
            "Data_Buf_Size"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "Buf",
            "&parser->msg.msg.buf[parser->entity_start_position + entity_offset]",
            "Data_Buf_Size"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_http_headers",
          "args": [
            "&parser->msg"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "print_http_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "2197-2227",
          "snippet": "void print_http_headers(http_message_t *hmsg)\n{\n    ListNode *node;\n    /* NNS:  dlist_node *node; */\n    http_header_t *header;\n\n    /* print start line */\n    if( hmsg->is_request ) {\n        printf( \"method = %d, version = %d.%d, url = %.*s\\n\", \n            hmsg->method, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->uri.pathquery.size, hmsg->uri.pathquery.buff);\n    } else {\n        printf( \"resp status = %d, version = %d.%d, status msg = %.*s\\n\",\n            hmsg->status_code, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->status_msg.length, hmsg->status_msg.buf);\n    }\n\n    /* print headers */\n    node = ListHead( &hmsg->headers );\n    /* NNS: node = dlist_first_node( &hmsg->headers ); */\n    while( node != NULL ) {\n        header = ( http_header_t * ) node->item;\n        /* NNS: header = (http_header_t *)node->data; */\n        printf( \"hdr name: %.*s, value: %.*s\\n\", \n            (int)header->name.length, header->name.buf,\n            (int)header->value.length, header->value.buf );\n\n        node = ListNext( &hmsg->headers, node );\n        /* NNS: node = dlist_next( &hmsg->headers, node ); */\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid print_http_headers(http_message_t *hmsg)\n{\n    ListNode *node;\n    /* NNS:  dlist_node *node; */\n    http_header_t *header;\n\n    /* print start line */\n    if( hmsg->is_request ) {\n        printf( \"method = %d, version = %d.%d, url = %.*s\\n\", \n            hmsg->method, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->uri.pathquery.size, hmsg->uri.pathquery.buff);\n    } else {\n        printf( \"resp status = %d, version = %d.%d, status msg = %.*s\\n\",\n            hmsg->status_code, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->status_msg.length, hmsg->status_msg.buf);\n    }\n\n    /* print headers */\n    node = ListHead( &hmsg->headers );\n    /* NNS: node = dlist_first_node( &hmsg->headers ); */\n    while( node != NULL ) {\n        header = ( http_header_t * ) node->item;\n        /* NNS: header = (http_header_t *)node->data; */\n        printf( \"hdr name: %.*s, value: %.*s\\n\", \n            (int)header->name.length, header->name.buf,\n            (int)header->value.length, header->value.buf );\n\n        node = ListNext( &hmsg->headers, node );\n        /* NNS: node = dlist_next( &hmsg->headers, node ); */\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "HTTP",
            "__FILE__",
            "__LINE__",
            "\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\"",
            "parser->msg.msg.buf"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse_entity",
          "args": [
            "parser"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1911-1952",
          "snippet": "UPNP_INLINE parse_status_t\nparser_parse_entity( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    assert( parser->position == POS_ENTITY );\n\n    do {\n        switch ( parser->ent_position ) {\n            case ENTREAD_USING_CLEN:\n                status = parser_parse_entity_using_clen( parser );\n                break;\n\n            case ENTREAD_USING_CHUNKED:\n                status = parser_parse_chunky_entity( parser );\n                break;\n\n            case ENTREAD_CHUNKY_BODY:\n                status = parser_parse_chunky_body( parser );\n                break;\n\n            case ENTREAD_CHUNKY_HEADERS:\n                status = parser_parse_chunky_headers( parser );\n                break;\n\n            case ENTREAD_UNTIL_CLOSE:\n                status = parser_parse_entity_until_close( parser );\n                break;\n\n            case ENTREAD_DETERMINE_READ_METHOD:\n                status = parser_get_entity_read_method( parser );\n                break;\n\n            default:\n\t\tstatus = PARSE_FAILURE;\n                assert( 0 );\n        }\n\n    } while( status == ( parse_status_t ) PARSE_CONTINUE_1 );\n\n    return status;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nUPNP_INLINE parse_status_t\nparser_parse_entity( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    assert( parser->position == POS_ENTITY );\n\n    do {\n        switch ( parser->ent_position ) {\n            case ENTREAD_USING_CLEN:\n                status = parser_parse_entity_using_clen( parser );\n                break;\n\n            case ENTREAD_USING_CHUNKED:\n                status = parser_parse_chunky_entity( parser );\n                break;\n\n            case ENTREAD_CHUNKY_BODY:\n                status = parser_parse_chunky_body( parser );\n                break;\n\n            case ENTREAD_CHUNKY_HEADERS:\n                status = parser_parse_chunky_headers( parser );\n                break;\n\n            case ENTREAD_UNTIL_CLOSE:\n                status = parser_parse_entity_until_close( parser );\n                break;\n\n            case ENTREAD_DETERMINE_READ_METHOD:\n                status = parser_get_entity_read_method( parser );\n                break;\n\n            default:\n\t\tstatus = PARSE_FAILURE;\n                assert( 0 );\n        }\n\n    } while( status == ( parse_status_t ) PARSE_CONTINUE_1 );\n\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_append",
          "args": [
            "&parser->msg.msg",
            "Buf",
            "(size_t)num_read"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "200-205",
          "snippet": "int membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_read",
          "args": [
            "info",
            "Buf",
            "sizeof(Buf)",
            "&Timeout"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "sock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "266-269",
          "snippet": "int sock_read(SOCKINFO *info, char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\treturn sock_read_write(info, buffer, bufsize, timeoutSecs, TRUE);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_read(SOCKINFO *info, char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\treturn sock_read_write(info, buffer, bufsize, timeoutSecs, TRUE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "filename",
            "\"wb\""
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "filename",
            "UPNP_WRITE"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic int http_RecvPostMessage(\n\t/*! HTTP Parser object. */\n\thttp_parser_t *parser,\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! File where received data is copied to. */\n\tchar *filename,\n\t/*! Send Instruction object which gives information whether the file\n\t * is a virtual file or not. */\n\tstruct SendInstruction *Instr)\n{\n\tsize_t Data_Buf_Size = 1024;\n\tchar Buf[1024];\n\tint Timeout = -1;\n\tFILE *Fp;\n\tparse_status_t status = PARSE_OK;\n\tint ok_on_close = FALSE;\n\tsize_t entity_offset = 0;\n\tint num_read = 0;\n\tint ret_code = HTTP_OK;\n\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tFp = (virtualDirCallback.open) (filename, UPNP_WRITE);\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t} else {\n\t\tFp = fopen(filename, \"wb\");\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\tparser->position = POS_ENTITY;\n\tdo {\n\t\t/* first parse what has already been gotten */\n\t\tif (parser->position != POS_COMPLETE)\n\t\t\tstatus = parser_parse_entity(parser);\n\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t/* read until close */\n\t\t\tok_on_close = TRUE;\n\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t/* error */\n\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t\t/* read more if necessary entity */\n\t\twhile (entity_offset + Data_Buf_Size > parser->msg.entity.length &&\n\t\t       parser->position != POS_COMPLETE) {\n\t\t\tnum_read = sock_read(info, Buf, sizeof(Buf), &Timeout);\n\t\t\tif (num_read > 0) {\n\t\t\t\t/* append data to buffer */\n\t\t\t\tif (membuffer_append(&parser->msg.msg,\n\t\t\t\t\tBuf, (size_t)num_read) != 0) {\n\t\t\t\t\t/* set failure status */\n\t\t\t\t\tparser->http_error_code =\n\t\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tstatus = parser_parse_entity(parser);\n\t\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t\t/* read until close */\n\t\t\t\t\tok_on_close = TRUE;\n\t\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else if (num_read == 0) {\n\t\t\t\tif (ok_on_close) {\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t\tparser->msg.msg.buf);\n\t\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\t\tparser->position = POS_COMPLETE;\n\t\t\t\t} else {\n\t\t\t\t\t/* partial msg or response */\n\t\t\t\t\tparser->http_error_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret_code = HTTP_SERVICE_UNAVAILABLE;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t\tif ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {\n\t\t\tData_Buf_Size =\n\t\t\t    parser->msg.entity.length - entity_offset;\n\t\t}\n\t\tmemcpy(Buf,\n\t\t       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],\n\t\t       Data_Buf_Size);\n\t\tentity_offset += Data_Buf_Size;\n\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\tint n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);\n\t\t\tif (n < 0) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\tsize_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);\n\t\t\tif (n != Data_Buf_Size) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t} while (parser->position != POS_COMPLETE ||\n\t\t entity_offset != parser->msg.entity.length);\nExitFunction:\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tvirtualDirCallback.close(Fp);\n\t} else {\n\t\tfclose(Fp);\n\t}\n\n\treturn ret_code;\n}"
  },
  {
    "function_name": "process_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "1026-1334",
    "snippet": "static int process_request(\n\t/*! [in] HTTP Request message. */\n\thttp_message_t *req,\n\t/*! [out] Tpye of response. */\n\tenum resp_type *rtype,\n\t/*! [out] Headers. */\n\tmembuffer *headers,\n\t/*! [out] Get filename from request document. */\n\tmembuffer *filename,\n\t/*! [out] Xml alias document from the request document. */\n\tstruct xml_alias_t *alias,\n\t/*! [out] Send Instruction object where the response is set up. */\n\tstruct SendInstruction *RespInstr)\n{\n\tint code;\n\tint err_code;\n\n\tchar *request_doc;\n\tUpnpFileInfo *finfo;\n\ttime_t aux_LastModified;\n\tint using_alias;\n\tint using_virtual_dir;\n\turi_type *url;\n\tconst char *temp_str;\n\tint resp_major;\n\tint resp_minor;\n\tint alias_grabbed;\n\tsize_t dummy;\n\tconst char *extra_headers = NULL;\n\n\tprint_http_headers(req);\n\turl = &req->uri;\n\tassert(req->method == HTTPMETHOD_GET ||\n\t       req->method == HTTPMETHOD_HEAD ||\n\t       req->method == HTTPMETHOD_POST ||\n\t       req->method == HTTPMETHOD_SIMPLEGET);\n\t/* init */\n\tmemset(&finfo, 0, sizeof(finfo));\n\trequest_doc = NULL;\n\tfinfo = UpnpFileInfo_new();\n\talias_grabbed = FALSE;\n\terr_code = HTTP_INTERNAL_SERVER_ERROR;\t/* default error */\n\tusing_virtual_dir = FALSE;\n\tusing_alias = FALSE;\n\n\thttp_CalcResponseVersion(req->major_version, req->minor_version,\n\t\t\t\t &resp_major, &resp_minor);\n\t/* */\n\t/* remove dots */\n\t/* */\n\trequest_doc = malloc(url->pathquery.size + 1);\n\tif (request_doc == NULL) {\n\t\tgoto error_handler;\t/* out of mem */\n\t}\n\tmemcpy(request_doc, url->pathquery.buff, url->pathquery.size);\n\trequest_doc[url->pathquery.size] = '\\0';\n\tdummy = url->pathquery.size;\n\tremove_escaped_chars(request_doc, &dummy);\n\tcode = remove_dots(request_doc, url->pathquery.size);\n\tif (code != 0) {\n\t\terr_code = HTTP_FORBIDDEN;\n\t\tgoto error_handler;\n\t}\n\tif (*request_doc != '/') {\n\t\t/* no slash */\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\tif (isFileInVirtualDir(request_doc)) {\n\t\tusing_virtual_dir = TRUE;\n\t\tRespInstr->IsVirtualFile = 1;\n\t\tif (membuffer_assign_str(filename, request_doc) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* try using alias */\n\t\tif (is_valid_alias(&gAliasDoc)) {\n\t\t\talias_grab(alias);\n\t\t\talias_grabbed = TRUE;\n\t\t\tusing_alias = get_alias(request_doc, alias, finfo);\n\t\t\tif (using_alias == TRUE) {\n\t\t\t\tUpnpFileInfo_set_ContentType(finfo,\n\t\t\t\t\t\"text/xml; charset=\\\"utf-8\\\"\");\n\t\t\t\tif (UpnpFileInfo_get_ContentType(finfo) == NULL) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (using_virtual_dir) {\n\t\tif (req->method != HTTPMETHOD_POST) {\n\t\t\t/* get file info */\n\t\t\tif (virtualDirCallback.\n\t\t\t    get_info(filename->buf, finfo) != 0) {\n\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* try index.html if req is a dir */\n\t\t\tif (UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\tif (filename->buf[filename->length - 1] == '/') {\n\t\t\t\t\ttemp_str = \"index.html\";\n\t\t\t\t} else {\n\t\t\t\t\ttemp_str = \"/index.html\";\n\t\t\t\t}\n\t\t\t\tif (membuffer_append_str(filename, temp_str) !=\n\t\t\t\t    0) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t\t/* get info */\n\t\t\t\tif (virtualDirCallback.get_info(filename->buf, finfo) != UPNP_E_SUCCESS ||\n\t\t\t\t    UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* not readable */\n\t\t\tif (!UpnpFileInfo_get_IsReadable(finfo)) {\n\t\t\t\terr_code = HTTP_FORBIDDEN;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* finally, get content type */\n\t\t\t/* if ( get_content_type(filename->buf, &content_type) != 0 ) */\n\t\t\t/*{ */\n\t\t\t/*  goto error_handler; */\n\t\t\t/* } */\n\t\t}\n\t} else if (!using_alias) {\n\t\tif (gDocumentRootDir.length == 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* */\n\t\t/* get file name */\n\t\t/* */\n\n\t\t/* filename str */\n\t\tif (membuffer_assign_str(filename, gDocumentRootDir.buf) != 0 ||\n\t\t    membuffer_append_str(filename, request_doc) != 0) {\n\t\t\tgoto error_handler;\t/* out of mem */\n\t\t}\n\t\t/* remove trailing slashes */\n\t\twhile (filename->length > 0 &&\n\t\t       filename->buf[filename->length - 1] == '/') {\n\t\t\tmembuffer_delete(filename, filename->length - 1, 1);\n\t\t}\n\t\tif (req->method != HTTPMETHOD_POST) {\n\t\t\t/* get info on file */\n\t\t\tif (get_file_info(filename->buf, finfo) != 0) {\n\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* try index.html if req is a dir */\n\t\t\tif (UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\tif (filename->buf[filename->length - 1] == '/') {\n\t\t\t\t\ttemp_str = \"index.html\";\n\t\t\t\t} else {\n\t\t\t\t\ttemp_str = \"/index.html\";\n\t\t\t\t}\n\t\t\t\tif (membuffer_append_str(filename, temp_str) !=\n\t\t\t\t    0) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t\t/* get info */\n\t\t\t\tif (get_file_info(filename->buf, finfo) != 0 ||\n\t\t\t\t    UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* not readable */\n\t\t\tif (!UpnpFileInfo_get_IsReadable(finfo)) {\n\t\t\t\terr_code = HTTP_FORBIDDEN;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\t/* finally, get content type */\n\t\t/*      if ( get_content_type(filename->buf, &content_type) != 0 ) */\n\t\t/*      { */\n\t\t/*          goto error_handler; */\n\t\t/*      } */\n\t}\n\tRespInstr->ReadSendSize = UpnpFileInfo_get_FileLength(finfo);\n\t/* Check other header field. */\n\tcode = CheckOtherHTTPHeaders(req, RespInstr,\n\t\tUpnpFileInfo_get_FileLength(finfo));\n\tif (code != HTTP_OK) {\n\t\terr_code = code;\n\t\tgoto error_handler;\n\t}\n\tif (req->method == HTTPMETHOD_POST) {\n\t\t*rtype = RESP_POST;\n\t\terr_code = HTTP_OK;\n\t\tgoto error_handler;\n\t}\n\textra_headers = UpnpFileInfo_get_ExtraHeaders(finfo);\n\tif (!extra_headers) {\n\t\textra_headers = \"\";\n\t}\n\n\t/* Check if chunked encoding should be used. */\n\tif (using_virtual_dir && UpnpFileInfo_get_FileLength(finfo) == UPNP_USING_CHUNKED) {\n\t\t/* Chunked encoding is only supported by HTTP 1.1 clients */\n\t\tif (resp_major == 1 && resp_minor == 1) {\n\t\t\tRespInstr->IsChunkActive = 1;\n\t\t} else {\n\t\t\t/* The virtual callback indicates that we should use\n\t\t\t * chunked encoding however the client doesn't support\n\t\t\t * it. Return with an internal server error. */\n\t\t\terr_code = HTTP_NOT_ACCEPTABLE;\n\t\t\tgoto error_handler;\n\t\t}\n\t}\n\n\taux_LastModified = UpnpFileInfo_get_LastModified(finfo);\n\tif (RespInstr->IsRangeActive && RespInstr->IsChunkActive) {\n\t\t/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\t\t/* Transfer-Encoding: chunked */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"R\" \"T\" \"GKLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_PARTIAL_CONTENT,\t/* status code */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* range info */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else if (RespInstr->IsRangeActive && !RespInstr->IsChunkActive) {\n\t\t/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"R\" \"N\" \"T\" \"GLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_PARTIAL_CONTENT,\t/* status code */\n\t\t    RespInstr->ReadSendSize,\t/* content length */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* range info */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else if (!RespInstr->IsRangeActive && RespInstr->IsChunkActive) {\n\t\t/* Transfer-Encoding: chunked */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"RK\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_OK,\t/* status code */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* !RespInstr->IsRangeActive && !RespInstr->IsChunkActive */\n\t\tif (RespInstr->ReadSendSize >= 0) {\n\t\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t\t    \"R\" \"N\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t\t    HTTP_OK,\t/* status code */\n\t\t\t    RespInstr->ReadSendSize,\t/* content length */\n\t\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t\t    RespInstr,\t/* language info */\n\t\t\t    \"LAST-MODIFIED: \",\n\t\t\t    &aux_LastModified,\n\t\t\t    X_USER_AGENT,\n\t\t\t    extra_headers) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else {\n\t\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t\t    \"R\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t\t    HTTP_OK,\t/* status code */\n\t\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t\t    RespInstr,\t/* language info */\n\t\t\t    \"LAST-MODIFIED: \",\n\t\t\t    &aux_LastModified,\n\t\t\t    X_USER_AGENT,\n\t\t\t    extra_headers) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t}\n\tif (req->method == HTTPMETHOD_HEAD) {\n\t\t*rtype = RESP_HEADERS;\n\t} else if (using_alias) {\n\t\t/* GET xml */\n\t\t*rtype = RESP_XMLDOC;\n\t} else if (using_virtual_dir) {\n\t\t*rtype = RESP_WEBDOC;\n\t} else {\n\t\t/* GET filename */\n\t\t*rtype = RESP_FILEDOC;\n\t}\n\t/* simple get http 0.9 as specified in http 1.0 */\n\t/* don't send headers */\n\tif (req->method == HTTPMETHOD_SIMPLEGET) {\n\t\tmembuffer_destroy(headers);\n\t}\n\terr_code = HTTP_OK;\n\n error_handler:\n\tfree(request_doc);\n\tUpnpFileInfo_delete(finfo);\n\tif (err_code != HTTP_OK && alias_grabbed) {\n\t\talias_release(alias);\n\t}\n\n\treturn err_code;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alias_release",
          "args": [
            "alias"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "alias_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "401-419",
          "snippet": "static void alias_release(\n\t/*! [in] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\t/* ignore invalid alias */\n\tif (!is_valid_alias(alias)) {\n\t\tithread_mutex_unlock(&gWebMutex);\n\t\treturn;\n\t}\n\tassert(*alias->ct > 0);\n\t*alias->ct -= 1;\n\tif (*alias->ct <= 0) {\n\t\tmembuffer_destroy(&alias->doc);\n\t\tmembuffer_destroy(&alias->name);\n\t\tfree(alias->ct);\n\t}\n\tithread_mutex_unlock(&gWebMutex);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic void alias_release(\n\t/*! [in] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\t/* ignore invalid alias */\n\tif (!is_valid_alias(alias)) {\n\t\tithread_mutex_unlock(&gWebMutex);\n\t\treturn;\n\t}\n\tassert(*alias->ct > 0);\n\t*alias->ct -= 1;\n\tif (*alias->ct <= 0) {\n\t\tmembuffer_destroy(&alias->doc);\n\t\tmembuffer_destroy(&alias->name);\n\t\tfree(alias->ct);\n\t}\n\tithread_mutex_unlock(&gWebMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_delete",
          "args": [
            "finfo"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "request_doc"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "headers"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "headers",
            "resp_major",
            "resp_minor",
            "\"R\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\"",
            "HTTP_OK",
            "/* status code */UpnpFileInfo_get_ContentType(finfo)",
            "/* content type */RespInstr",
            "/* language info */\"LAST-MODIFIED: \"",
            "&aux_LastModified",
            "X_USER_AGENT",
            "extra_headers"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_ContentType",
          "args": [
            "finfo"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_ContentType",
          "args": [
            "finfo"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_ContentType",
          "args": [
            "finfo"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_ContentType",
          "args": [
            "finfo"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_ContentType",
          "args": [
            "finfo"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_LastModified",
          "args": [
            "finfo"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_FileLength",
          "args": [
            "finfo"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_ExtraHeaders",
          "args": [
            "finfo"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CheckOtherHTTPHeaders",
          "args": [
            "req",
            "RespInstr",
            "UpnpFileInfo_get_FileLength(finfo)"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "CheckOtherHTTPHeaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "900-1012",
          "snippet": "static int CheckOtherHTTPHeaders(\n\t/*! [in] HTTP Request message. */\n\thttp_message_t *Req,\n\t/*! [out] Send Instruction object to data for the response. */\n\tstruct SendInstruction *RespInstr,\n\t/*! Size of the file containing the request document. */\n\toff_t FileSize)\n{\n\thttp_header_t *header;\n\tListNode *node;\n\t/*NNS: dlist_node* node; */\n\tint index, RetCode = HTTP_OK;\n\tchar *TmpBuf;\n\tsize_t TmpBufSize = LINE_SIZE;\n\n\tTmpBuf = (char *)malloc(TmpBufSize);\n\tif (!TmpBuf)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\tnode = ListHead(&Req->headers);\n\twhile (node != NULL) {\n\t\theader = (http_header_t *) node->item;\n\t\t/* find header type. */\n\t\tindex = map_str_to_int((const char *)header->name.buf,\n\t\t\t\theader->name.length, Http_Header_Names,\n\t\t\t\tNUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (header->value.length >= TmpBufSize) {\n\t\t\tfree(TmpBuf);\n\t\t\tTmpBufSize = header->value.length + 1;\n\t\t\tTmpBuf = (char *)malloc(TmpBufSize);\n\t\t\tif (!TmpBuf)\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t\tmemcpy(TmpBuf, header->value.buf, header->value.length);\n\t\tTmpBuf[header->value.length] = '\\0';\n\t\tif (index >= 0) {\n\t\t\tswitch (Http_Header_Names[index].id) {\n\t\t\tcase HDR_TE: {\n\t\t\t\t/* Request */\n\t\t\t\tRespInstr->IsChunkActive = 1;\n\n\t\t\t\tif (strlen(TmpBuf) > strlen(\"gzip\")) {\n\t\t\t\t\t/* means client will accept trailer. */\n\t\t\t\t\tif (StrStr(TmpBuf, \"trailers\") != NULL) {\n\t\t\t\t\t\tRespInstr->IsTrailers = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase HDR_CONTENT_LENGTH:\n\t\t\t\tRespInstr->RecvWriteSize = atoi(TmpBuf);\n\t\t\t\tbreak;\n\t\t\tcase HDR_RANGE:\n\t\t\t\tRetCode = CreateHTTPRangeResponseHeader(TmpBuf,\n\t\t\t\t\tFileSize, RespInstr);\n\t\t\t\tif (RetCode != HTTP_OK) {\n\t\t\t\t\tfree(TmpBuf);\n\t\t\t\t\treturn RetCode;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase HDR_ACCEPT_LANGUAGE:\n\t\t\t\tif (header->value.length + 1 > sizeof(RespInstr->AcceptLanguageHeader)) {\n\t\t\t\t\tsize_t length = sizeof(RespInstr->AcceptLanguageHeader) - 1;\n\t\t\t\t\tmemcpy(RespInstr->AcceptLanguageHeader, TmpBuf, length);\n\t\t\t\t\tRespInstr->AcceptLanguageHeader[length] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(RespInstr->AcceptLanguageHeader, TmpBuf,\n\t\t\t\t\t\theader->value.length + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t   TODO\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t   header.value is the value.\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t   case HDR_CONTENT_TYPE: return 1;\n\t\t\t\t   case HDR_CONTENT_LANGUAGE:return 1;\n\t\t\t\t   case HDR_LOCATION: return 1;\n\t\t\t\t   case HDR_CONTENT_LOCATION:return 1;\n\t\t\t\t   case HDR_ACCEPT: return 1;\n\t\t\t\t   case HDR_ACCEPT_CHARSET: return 1;\n\t\t\t\t   case HDR_USER_AGENT: return 1;\n\t\t\t\t */\n\n\t\t\t\t/*Header check for encoding */\n\t\t\t\t/*\n\t\t\t\t   case HDR_ACCEPT_RANGE:\n\t\t\t\t   case HDR_CONTENT_RANGE:\n\t\t\t\t   case HDR_IF_RANGE:\n\t\t\t\t */\n\n\t\t\t\t/*Header check for encoding */\n\t\t\t\t/*\n\t\t\t\t   case HDR_ACCEPT_ENCODING:\n\t\t\t\t   if(StrStr(TmpBuf, \"identity\"))\n\t\t\t\t   {\n\t\t\t\t   break;\n\t\t\t\t   }\n\t\t\t\t   else return -1;\n\t\t\t\t   case HDR_CONTENT_ENCODING:\n\t\t\t\t   case HDR_TRANSFER_ENCODING:\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnode = ListNext(&Req->headers, node);\n\t}\n\tfree(TmpBuf);\n\n\treturn RetCode;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HTTP_HEADER_NAMES 33"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define NUM_HTTP_HEADER_NAMES 33\n\nstatic int CheckOtherHTTPHeaders(\n\t/*! [in] HTTP Request message. */\n\thttp_message_t *Req,\n\t/*! [out] Send Instruction object to data for the response. */\n\tstruct SendInstruction *RespInstr,\n\t/*! Size of the file containing the request document. */\n\toff_t FileSize)\n{\n\thttp_header_t *header;\n\tListNode *node;\n\t/*NNS: dlist_node* node; */\n\tint index, RetCode = HTTP_OK;\n\tchar *TmpBuf;\n\tsize_t TmpBufSize = LINE_SIZE;\n\n\tTmpBuf = (char *)malloc(TmpBufSize);\n\tif (!TmpBuf)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\tnode = ListHead(&Req->headers);\n\twhile (node != NULL) {\n\t\theader = (http_header_t *) node->item;\n\t\t/* find header type. */\n\t\tindex = map_str_to_int((const char *)header->name.buf,\n\t\t\t\theader->name.length, Http_Header_Names,\n\t\t\t\tNUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (header->value.length >= TmpBufSize) {\n\t\t\tfree(TmpBuf);\n\t\t\tTmpBufSize = header->value.length + 1;\n\t\t\tTmpBuf = (char *)malloc(TmpBufSize);\n\t\t\tif (!TmpBuf)\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t\tmemcpy(TmpBuf, header->value.buf, header->value.length);\n\t\tTmpBuf[header->value.length] = '\\0';\n\t\tif (index >= 0) {\n\t\t\tswitch (Http_Header_Names[index].id) {\n\t\t\tcase HDR_TE: {\n\t\t\t\t/* Request */\n\t\t\t\tRespInstr->IsChunkActive = 1;\n\n\t\t\t\tif (strlen(TmpBuf) > strlen(\"gzip\")) {\n\t\t\t\t\t/* means client will accept trailer. */\n\t\t\t\t\tif (StrStr(TmpBuf, \"trailers\") != NULL) {\n\t\t\t\t\t\tRespInstr->IsTrailers = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase HDR_CONTENT_LENGTH:\n\t\t\t\tRespInstr->RecvWriteSize = atoi(TmpBuf);\n\t\t\t\tbreak;\n\t\t\tcase HDR_RANGE:\n\t\t\t\tRetCode = CreateHTTPRangeResponseHeader(TmpBuf,\n\t\t\t\t\tFileSize, RespInstr);\n\t\t\t\tif (RetCode != HTTP_OK) {\n\t\t\t\t\tfree(TmpBuf);\n\t\t\t\t\treturn RetCode;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase HDR_ACCEPT_LANGUAGE:\n\t\t\t\tif (header->value.length + 1 > sizeof(RespInstr->AcceptLanguageHeader)) {\n\t\t\t\t\tsize_t length = sizeof(RespInstr->AcceptLanguageHeader) - 1;\n\t\t\t\t\tmemcpy(RespInstr->AcceptLanguageHeader, TmpBuf, length);\n\t\t\t\t\tRespInstr->AcceptLanguageHeader[length] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(RespInstr->AcceptLanguageHeader, TmpBuf,\n\t\t\t\t\t\theader->value.length + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t   TODO\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t   header.value is the value.\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t   case HDR_CONTENT_TYPE: return 1;\n\t\t\t\t   case HDR_CONTENT_LANGUAGE:return 1;\n\t\t\t\t   case HDR_LOCATION: return 1;\n\t\t\t\t   case HDR_CONTENT_LOCATION:return 1;\n\t\t\t\t   case HDR_ACCEPT: return 1;\n\t\t\t\t   case HDR_ACCEPT_CHARSET: return 1;\n\t\t\t\t   case HDR_USER_AGENT: return 1;\n\t\t\t\t */\n\n\t\t\t\t/*Header check for encoding */\n\t\t\t\t/*\n\t\t\t\t   case HDR_ACCEPT_RANGE:\n\t\t\t\t   case HDR_CONTENT_RANGE:\n\t\t\t\t   case HDR_IF_RANGE:\n\t\t\t\t */\n\n\t\t\t\t/*Header check for encoding */\n\t\t\t\t/*\n\t\t\t\t   case HDR_ACCEPT_ENCODING:\n\t\t\t\t   if(StrStr(TmpBuf, \"identity\"))\n\t\t\t\t   {\n\t\t\t\t   break;\n\t\t\t\t   }\n\t\t\t\t   else return -1;\n\t\t\t\t   case HDR_CONTENT_ENCODING:\n\t\t\t\t   case HDR_TRANSFER_ENCODING:\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnode = ListNext(&Req->headers, node);\n\t}\n\tfree(TmpBuf);\n\n\treturn RetCode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_FileLength",
          "args": [
            "finfo"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_FileLength",
          "args": [
            "finfo"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_IsReadable",
          "args": [
            "finfo"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_IsDirectory",
          "args": [
            "finfo"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file_info",
          "args": [
            "filename->buf",
            "finfo"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "get_file_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "517-560",
          "snippet": "static int get_file_info(\n\t/*! [in] Filename having the description document. */\n\tconst char *filename,\n\t/*! [out] File information object having file attributes such as filelength,\n\t * when was the file last modified, whether a file or a directory and\n\t * whether the file or directory is readable. */\n\tOUT UpnpFileInfo *info)\n{\n\tint code;\n\tstruct stat s;\n\tFILE *fp;\n\tint rc = 0;\n\ttime_t aux_LastModified;\n\tstruct tm date;\n\tchar buffer[ASCTIME_R_BUFFER_SIZE];\n\n\tUpnpFileInfo_set_ContentType(info, NULL);\n\tcode = stat(filename, &s);\n\tif (code == -1)\n\t\treturn -1;\n\tif (S_ISDIR(s.st_mode))\n\t\tUpnpFileInfo_set_IsDirectory(info, TRUE);\n\telse if (S_ISREG(s.st_mode))\n\t\tUpnpFileInfo_set_IsDirectory(info, FALSE);\n\telse\n\t\treturn -1;\n\t/* check readable */\n\tfp = fopen(filename, \"r\");\n\tUpnpFileInfo_set_IsReadable(info, fp != NULL);\n\tif (fp)\n\t\tfclose(fp);\n\tUpnpFileInfo_set_FileLength(info, s.st_size);\n\tUpnpFileInfo_set_LastModified(info, s.st_mtime);\n\trc = get_content_type(filename, info);\n\taux_LastModified = UpnpFileInfo_get_LastModified(info);\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\"file info: %s, length: %lld, last_mod=%s readable=%d\\n\",\n\t\tfilename,\n\t\t(long long)UpnpFileInfo_get_FileLength(info),\n\t\tweb_server_asctime_r(http_gmtime_r(&aux_LastModified, &date), buffer),\n\t\tUpnpFileInfo_get_IsReadable(info));\n\n\treturn rc;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define web_server_asctime_r asctime_r",
            "#define ASCTIME_R_BUFFER_SIZE 26"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define web_server_asctime_r asctime_r\n#define ASCTIME_R_BUFFER_SIZE 26\n\nstatic int get_file_info(\n\t/*! [in] Filename having the description document. */\n\tconst char *filename,\n\t/*! [out] File information object having file attributes such as filelength,\n\t * when was the file last modified, whether a file or a directory and\n\t * whether the file or directory is readable. */\n\tOUT UpnpFileInfo *info)\n{\n\tint code;\n\tstruct stat s;\n\tFILE *fp;\n\tint rc = 0;\n\ttime_t aux_LastModified;\n\tstruct tm date;\n\tchar buffer[ASCTIME_R_BUFFER_SIZE];\n\n\tUpnpFileInfo_set_ContentType(info, NULL);\n\tcode = stat(filename, &s);\n\tif (code == -1)\n\t\treturn -1;\n\tif (S_ISDIR(s.st_mode))\n\t\tUpnpFileInfo_set_IsDirectory(info, TRUE);\n\telse if (S_ISREG(s.st_mode))\n\t\tUpnpFileInfo_set_IsDirectory(info, FALSE);\n\telse\n\t\treturn -1;\n\t/* check readable */\n\tfp = fopen(filename, \"r\");\n\tUpnpFileInfo_set_IsReadable(info, fp != NULL);\n\tif (fp)\n\t\tfclose(fp);\n\tUpnpFileInfo_set_FileLength(info, s.st_size);\n\tUpnpFileInfo_set_LastModified(info, s.st_mtime);\n\trc = get_content_type(filename, info);\n\taux_LastModified = UpnpFileInfo_get_LastModified(info);\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\"file info: %s, length: %lld, last_mod=%s readable=%d\\n\",\n\t\tfilename,\n\t\t(long long)UpnpFileInfo_get_FileLength(info),\n\t\tweb_server_asctime_r(http_gmtime_r(&aux_LastModified, &date), buffer),\n\t\tUpnpFileInfo_get_IsReadable(info));\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_append_str",
          "args": [
            "filename",
            "temp_str"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "207-210",
          "snippet": "int membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_IsDirectory",
          "args": [
            "finfo"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_delete",
          "args": [
            "filename",
            "filename->length - 1",
            "1"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "240-271",
          "snippet": "void membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_assign_str",
          "args": [
            "filename",
            "gDocumentRootDir.buf"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_assign_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "195-198",
          "snippet": "int membuffer_assign_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_assign(m, c_str, strlen(c_str));\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_assign_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_assign(m, c_str, strlen(c_str));\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_IsReadable",
          "args": [
            "finfo"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_IsDirectory",
          "args": [
            "finfo"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virtualDirCallback.get_info",
          "args": [
            "filename->buf",
            "finfo"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_IsDirectory",
          "args": [
            "finfo"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virtualDirCallback.\n\t\t\t    get_info",
          "args": [
            "filename->buf",
            "finfo"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_ContentType",
          "args": [
            "finfo"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_ContentType",
          "args": [
            "finfo",
            "\"text/xml; charset=\\\"utf-8\\\"\""
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_alias",
          "args": [
            "request_doc",
            "alias",
            "finfo"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "get_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "588-606",
          "snippet": "static UPNP_INLINE int get_alias(\n\t/*! [in] request file passed in to be compared with. */\n\tconst char *request_file,\n\t/*! [out] xml alias object which has a file name stored. */\n\tstruct xml_alias_t *alias,\n\t/*! [out] File information object which will be filled up if the file\n\t * comparison succeeds. */\n\tUpnpFileInfo *info)\n{\n\tint cmp = strcmp(alias->name.buf, request_file);\n\tif (cmp == 0) {\n\t\tUpnpFileInfo_set_FileLength(info, (off_t)alias->doc.length);\n\t\tUpnpFileInfo_set_IsDirectory(info, FALSE);\n\t\tUpnpFileInfo_set_IsReadable(info, TRUE);\n\t\tUpnpFileInfo_set_LastModified(info, alias->last_modified);\n\t}\n\n\treturn cmp == 0;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int get_alias(\n\t/*! [in] request file passed in to be compared with. */\n\tconst char *request_file,\n\t/*! [out] xml alias object which has a file name stored. */\n\tstruct xml_alias_t *alias,\n\t/*! [out] File information object which will be filled up if the file\n\t * comparison succeeds. */\n\tUpnpFileInfo *info)\n{\n\tint cmp = strcmp(alias->name.buf, request_file);\n\tif (cmp == 0) {\n\t\tUpnpFileInfo_set_FileLength(info, (off_t)alias->doc.length);\n\t\tUpnpFileInfo_set_IsDirectory(info, FALSE);\n\t\tUpnpFileInfo_set_IsReadable(info, TRUE);\n\t\tUpnpFileInfo_set_LastModified(info, alias->last_modified);\n\t}\n\n\treturn cmp == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alias_grab",
          "args": [
            "alias"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "alias_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "386-395",
          "snippet": "static void alias_grab(\n\t/*! [out] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\tassert(is_valid_alias(&gAliasDoc));\n\tmemcpy(alias, &gAliasDoc, sizeof(struct xml_alias_t));\n\t*alias->ct = *alias->ct + 1;\n\tithread_mutex_unlock(&gWebMutex);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic void alias_grab(\n\t/*! [out] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\tassert(is_valid_alias(&gAliasDoc));\n\tmemcpy(alias, &gAliasDoc, sizeof(struct xml_alias_t));\n\t*alias->ct = *alias->ct + 1;\n\tithread_mutex_unlock(&gWebMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_valid_alias",
          "args": [
            "&gAliasDoc"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "is_valid_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "375-380",
          "snippet": "static UPNP_INLINE int is_valid_alias(\n\t/*! [in] XML alias object. */\n\tconst struct xml_alias_t *alias)\n{\n\treturn alias->doc.buf != NULL;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int is_valid_alias(\n\t/*! [in] XML alias object. */\n\tconst struct xml_alias_t *alias)\n{\n\treturn alias->doc.buf != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isFileInVirtualDir",
          "args": [
            "request_doc"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "isFileInVirtualDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "614-642",
          "snippet": "static int isFileInVirtualDir(\n\t/*! [in] Directory path to be tested for virtual directory. */\n\tchar *filePath)\n{\n\tvirtualDirList *pCurVirtualDir;\n\tsize_t webDirLen;\n\n\tpCurVirtualDir = pVirtualDirList;\n\twhile (pCurVirtualDir != NULL) {\n\t\twebDirLen = strlen(pCurVirtualDir->dirName);\n\t\tif (webDirLen) {\n\t\t\tif (pCurVirtualDir->dirName[webDirLen - 1] == '/') {\n\t\t\t\tif (strncmp(pCurVirtualDir->dirName, filePath,\n\t\t\t\t\t\twebDirLen) == 0)\n\t\t\t\t\treturn !0;\n\t\t\t} else {\n\t\t\t\tif (strncmp(pCurVirtualDir->dirName, filePath,\n\t\t\t\t\t\twebDirLen) == 0 &&\n\t\t\t\t    (filePath[webDirLen] == '/' ||\n\t\t\t\t     filePath[webDirLen] == '\\0' ||\n\t\t\t\t     filePath[webDirLen] == '?'))\n\t\t\t\t\treturn !0;\n\t\t\t}\n\t\t}\n\t\tpCurVirtualDir = pCurVirtualDir->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic int isFileInVirtualDir(\n\t/*! [in] Directory path to be tested for virtual directory. */\n\tchar *filePath)\n{\n\tvirtualDirList *pCurVirtualDir;\n\tsize_t webDirLen;\n\n\tpCurVirtualDir = pVirtualDirList;\n\twhile (pCurVirtualDir != NULL) {\n\t\twebDirLen = strlen(pCurVirtualDir->dirName);\n\t\tif (webDirLen) {\n\t\t\tif (pCurVirtualDir->dirName[webDirLen - 1] == '/') {\n\t\t\t\tif (strncmp(pCurVirtualDir->dirName, filePath,\n\t\t\t\t\t\twebDirLen) == 0)\n\t\t\t\t\treturn !0;\n\t\t\t} else {\n\t\t\t\tif (strncmp(pCurVirtualDir->dirName, filePath,\n\t\t\t\t\t\twebDirLen) == 0 &&\n\t\t\t\t    (filePath[webDirLen] == '/' ||\n\t\t\t\t     filePath[webDirLen] == '\\0' ||\n\t\t\t\t     filePath[webDirLen] == '?'))\n\t\t\t\t\treturn !0;\n\t\t\t}\n\t\t}\n\t\tpCurVirtualDir = pCurVirtualDir->next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_dots",
          "args": [
            "request_doc",
            "url->pathquery.size"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "remove_dots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "527-590",
          "snippet": "int remove_dots(char *buf, size_t size)\n{\n    char *in = buf;\n    char *out = buf;\n    char *max = buf + size;\n\n    while (!is_end_path(in[0])) {\n\tassert (buf <= out);\n\tassert (out <= in);\n\tassert (in < max);\n\n        /* case 2.A: */\n        if (strncmp(in, \"./\", 2) == 0) {\n            in += 2;\n        } else if (strncmp(in, \"../\", 3) == 0) {\n            in += 3;\n        /* case 2.B: */\n        } else if (strncmp(in, \"/./\", 3) == 0) {\n            in += 2;\n        } else if (strncmp(in, \"/.\", 2) == 0 && is_end_path(in[2])) {\n            in += 1;\n\t    in[0] = '/';\n        /* case 2.C: */\n        } else if (strncmp(in, \"/../\", 4) == 0 || (strncmp(in, \"/..\", 3) == 0 && is_end_path(in[3]))) {\n            /* Make the next character in the input buffer a '/': */\n            if (is_end_path(in[3])) { /* terminating \"/..\" case */\n                in += 2;\n                in[0] = '/';\n            } else { /* \"/../\" prefix case */\n                in += 3;\n            }\n            /* Trim the last component from the output buffer, or empty it. */\n            while (buf < out)\n\t\tif (*--out == '/')\n\t\t    break;\n#ifdef DEBUG\n\t    if (out < in)\n\t\tout[0] = '\\0';\n#endif\n        /* case 2.D: */\n        } else if (strncmp(in, \".\", 1) == 0 && is_end_path(in[1])) {\n            in += 1;\n\t} else if (strncmp(in, \"..\", 2) == 0 && is_end_path(in[2])) {\n            in += 2;\n        /* case 2.E */\n        } else {\n            /* move initial '/' character (if any) */\n            if (in[0] == '/')\n\t\t*out++ = *in++;\n\t    /* move first segment up to, but not including, the next '/' character */\n\t    while (in < max && in[0] != '/' && !is_end_path(in[0]))\n\t\t*out++ = *in++;\n#ifdef DEBUG\n\t    if (out < in)\n\t\tout[0] = '\\0';\n#endif\n        }\n    }\n    while (in < max)\n\t*out++ = *in++;\n    if (out < max)\n\tout[0] = '\\0';\n    return UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint remove_dots(char *buf, size_t size)\n{\n    char *in = buf;\n    char *out = buf;\n    char *max = buf + size;\n\n    while (!is_end_path(in[0])) {\n\tassert (buf <= out);\n\tassert (out <= in);\n\tassert (in < max);\n\n        /* case 2.A: */\n        if (strncmp(in, \"./\", 2) == 0) {\n            in += 2;\n        } else if (strncmp(in, \"../\", 3) == 0) {\n            in += 3;\n        /* case 2.B: */\n        } else if (strncmp(in, \"/./\", 3) == 0) {\n            in += 2;\n        } else if (strncmp(in, \"/.\", 2) == 0 && is_end_path(in[2])) {\n            in += 1;\n\t    in[0] = '/';\n        /* case 2.C: */\n        } else if (strncmp(in, \"/../\", 4) == 0 || (strncmp(in, \"/..\", 3) == 0 && is_end_path(in[3]))) {\n            /* Make the next character in the input buffer a '/': */\n            if (is_end_path(in[3])) { /* terminating \"/..\" case */\n                in += 2;\n                in[0] = '/';\n            } else { /* \"/../\" prefix case */\n                in += 3;\n            }\n            /* Trim the last component from the output buffer, or empty it. */\n            while (buf < out)\n\t\tif (*--out == '/')\n\t\t    break;\n#ifdef DEBUG\n\t    if (out < in)\n\t\tout[0] = '\\0';\n#endif\n        /* case 2.D: */\n        } else if (strncmp(in, \".\", 1) == 0 && is_end_path(in[1])) {\n            in += 1;\n\t} else if (strncmp(in, \"..\", 2) == 0 && is_end_path(in[2])) {\n            in += 2;\n        /* case 2.E */\n        } else {\n            /* move initial '/' character (if any) */\n            if (in[0] == '/')\n\t\t*out++ = *in++;\n\t    /* move first segment up to, but not including, the next '/' character */\n\t    while (in < max && in[0] != '/' && !is_end_path(in[0]))\n\t\t*out++ = *in++;\n#ifdef DEBUG\n\t    if (out < in)\n\t\tout[0] = '\\0';\n#endif\n        }\n    }\n    while (in < max)\n\t*out++ = *in++;\n    if (out < max)\n\tout[0] = '\\0';\n    return UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_escaped_chars",
          "args": [
            "request_doc",
            "&dummy"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "remove_escaped_chars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "502-511",
          "snippet": "int remove_escaped_chars(INOUT char *in, INOUT size_t *size)\n{\n\tsize_t i = (size_t)0;\n\n\tfor (i = (size_t)0; i < *size; i++) {\n\t\treplace_escaped(in, i, size);\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint remove_escaped_chars(INOUT char *in, INOUT size_t *size)\n{\n\tsize_t i = (size_t)0;\n\n\tfor (i = (size_t)0; i < *size; i++) {\n\t\treplace_escaped(in, i, size);\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "request_doc",
            "url->pathquery.buff",
            "url->pathquery.size"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "url->pathquery.size + 1"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_CalcResponseVersion",
          "args": [
            "req->major_version",
            "req->minor_version",
            "&resp_major",
            "&resp_minor"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "http_CalcResponseVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1720-1733",
          "snippet": "void http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nvoid http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_new",
          "args": [],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&finfo",
            "0",
            "sizeof(finfo)"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "req->method == HTTPMETHOD_GET ||\n\t       req->method == HTTPMETHOD_HEAD ||\n\t       req->method == HTTPMETHOD_POST ||\n\t       req->method == HTTPMETHOD_SIMPLEGET"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_http_headers",
          "args": [
            "req"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "print_http_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "2197-2227",
          "snippet": "void print_http_headers(http_message_t *hmsg)\n{\n    ListNode *node;\n    /* NNS:  dlist_node *node; */\n    http_header_t *header;\n\n    /* print start line */\n    if( hmsg->is_request ) {\n        printf( \"method = %d, version = %d.%d, url = %.*s\\n\", \n            hmsg->method, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->uri.pathquery.size, hmsg->uri.pathquery.buff);\n    } else {\n        printf( \"resp status = %d, version = %d.%d, status msg = %.*s\\n\",\n            hmsg->status_code, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->status_msg.length, hmsg->status_msg.buf);\n    }\n\n    /* print headers */\n    node = ListHead( &hmsg->headers );\n    /* NNS: node = dlist_first_node( &hmsg->headers ); */\n    while( node != NULL ) {\n        header = ( http_header_t * ) node->item;\n        /* NNS: header = (http_header_t *)node->data; */\n        printf( \"hdr name: %.*s, value: %.*s\\n\", \n            (int)header->name.length, header->name.buf,\n            (int)header->value.length, header->value.buf );\n\n        node = ListNext( &hmsg->headers, node );\n        /* NNS: node = dlist_next( &hmsg->headers, node ); */\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid print_http_headers(http_message_t *hmsg)\n{\n    ListNode *node;\n    /* NNS:  dlist_node *node; */\n    http_header_t *header;\n\n    /* print start line */\n    if( hmsg->is_request ) {\n        printf( \"method = %d, version = %d.%d, url = %.*s\\n\", \n            hmsg->method, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->uri.pathquery.size, hmsg->uri.pathquery.buff);\n    } else {\n        printf( \"resp status = %d, version = %d.%d, status msg = %.*s\\n\",\n            hmsg->status_code, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->status_msg.length, hmsg->status_msg.buf);\n    }\n\n    /* print headers */\n    node = ListHead( &hmsg->headers );\n    /* NNS: node = dlist_first_node( &hmsg->headers ); */\n    while( node != NULL ) {\n        header = ( http_header_t * ) node->item;\n        /* NNS: header = (http_header_t *)node->data; */\n        printf( \"hdr name: %.*s, value: %.*s\\n\", \n            (int)header->name.length, header->name.buf,\n            (int)header->value.length, header->value.buf );\n\n        node = ListNext( &hmsg->headers, node );\n        /* NNS: node = dlist_next( &hmsg->headers, node ); */\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic int process_request(\n\t/*! [in] HTTP Request message. */\n\thttp_message_t *req,\n\t/*! [out] Tpye of response. */\n\tenum resp_type *rtype,\n\t/*! [out] Headers. */\n\tmembuffer *headers,\n\t/*! [out] Get filename from request document. */\n\tmembuffer *filename,\n\t/*! [out] Xml alias document from the request document. */\n\tstruct xml_alias_t *alias,\n\t/*! [out] Send Instruction object where the response is set up. */\n\tstruct SendInstruction *RespInstr)\n{\n\tint code;\n\tint err_code;\n\n\tchar *request_doc;\n\tUpnpFileInfo *finfo;\n\ttime_t aux_LastModified;\n\tint using_alias;\n\tint using_virtual_dir;\n\turi_type *url;\n\tconst char *temp_str;\n\tint resp_major;\n\tint resp_minor;\n\tint alias_grabbed;\n\tsize_t dummy;\n\tconst char *extra_headers = NULL;\n\n\tprint_http_headers(req);\n\turl = &req->uri;\n\tassert(req->method == HTTPMETHOD_GET ||\n\t       req->method == HTTPMETHOD_HEAD ||\n\t       req->method == HTTPMETHOD_POST ||\n\t       req->method == HTTPMETHOD_SIMPLEGET);\n\t/* init */\n\tmemset(&finfo, 0, sizeof(finfo));\n\trequest_doc = NULL;\n\tfinfo = UpnpFileInfo_new();\n\talias_grabbed = FALSE;\n\terr_code = HTTP_INTERNAL_SERVER_ERROR;\t/* default error */\n\tusing_virtual_dir = FALSE;\n\tusing_alias = FALSE;\n\n\thttp_CalcResponseVersion(req->major_version, req->minor_version,\n\t\t\t\t &resp_major, &resp_minor);\n\t/* */\n\t/* remove dots */\n\t/* */\n\trequest_doc = malloc(url->pathquery.size + 1);\n\tif (request_doc == NULL) {\n\t\tgoto error_handler;\t/* out of mem */\n\t}\n\tmemcpy(request_doc, url->pathquery.buff, url->pathquery.size);\n\trequest_doc[url->pathquery.size] = '\\0';\n\tdummy = url->pathquery.size;\n\tremove_escaped_chars(request_doc, &dummy);\n\tcode = remove_dots(request_doc, url->pathquery.size);\n\tif (code != 0) {\n\t\terr_code = HTTP_FORBIDDEN;\n\t\tgoto error_handler;\n\t}\n\tif (*request_doc != '/') {\n\t\t/* no slash */\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\tif (isFileInVirtualDir(request_doc)) {\n\t\tusing_virtual_dir = TRUE;\n\t\tRespInstr->IsVirtualFile = 1;\n\t\tif (membuffer_assign_str(filename, request_doc) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* try using alias */\n\t\tif (is_valid_alias(&gAliasDoc)) {\n\t\t\talias_grab(alias);\n\t\t\talias_grabbed = TRUE;\n\t\t\tusing_alias = get_alias(request_doc, alias, finfo);\n\t\t\tif (using_alias == TRUE) {\n\t\t\t\tUpnpFileInfo_set_ContentType(finfo,\n\t\t\t\t\t\"text/xml; charset=\\\"utf-8\\\"\");\n\t\t\t\tif (UpnpFileInfo_get_ContentType(finfo) == NULL) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (using_virtual_dir) {\n\t\tif (req->method != HTTPMETHOD_POST) {\n\t\t\t/* get file info */\n\t\t\tif (virtualDirCallback.\n\t\t\t    get_info(filename->buf, finfo) != 0) {\n\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* try index.html if req is a dir */\n\t\t\tif (UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\tif (filename->buf[filename->length - 1] == '/') {\n\t\t\t\t\ttemp_str = \"index.html\";\n\t\t\t\t} else {\n\t\t\t\t\ttemp_str = \"/index.html\";\n\t\t\t\t}\n\t\t\t\tif (membuffer_append_str(filename, temp_str) !=\n\t\t\t\t    0) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t\t/* get info */\n\t\t\t\tif (virtualDirCallback.get_info(filename->buf, finfo) != UPNP_E_SUCCESS ||\n\t\t\t\t    UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* not readable */\n\t\t\tif (!UpnpFileInfo_get_IsReadable(finfo)) {\n\t\t\t\terr_code = HTTP_FORBIDDEN;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* finally, get content type */\n\t\t\t/* if ( get_content_type(filename->buf, &content_type) != 0 ) */\n\t\t\t/*{ */\n\t\t\t/*  goto error_handler; */\n\t\t\t/* } */\n\t\t}\n\t} else if (!using_alias) {\n\t\tif (gDocumentRootDir.length == 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* */\n\t\t/* get file name */\n\t\t/* */\n\n\t\t/* filename str */\n\t\tif (membuffer_assign_str(filename, gDocumentRootDir.buf) != 0 ||\n\t\t    membuffer_append_str(filename, request_doc) != 0) {\n\t\t\tgoto error_handler;\t/* out of mem */\n\t\t}\n\t\t/* remove trailing slashes */\n\t\twhile (filename->length > 0 &&\n\t\t       filename->buf[filename->length - 1] == '/') {\n\t\t\tmembuffer_delete(filename, filename->length - 1, 1);\n\t\t}\n\t\tif (req->method != HTTPMETHOD_POST) {\n\t\t\t/* get info on file */\n\t\t\tif (get_file_info(filename->buf, finfo) != 0) {\n\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\t/* try index.html if req is a dir */\n\t\t\tif (UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\tif (filename->buf[filename->length - 1] == '/') {\n\t\t\t\t\ttemp_str = \"index.html\";\n\t\t\t\t} else {\n\t\t\t\t\ttemp_str = \"/index.html\";\n\t\t\t\t}\n\t\t\t\tif (membuffer_append_str(filename, temp_str) !=\n\t\t\t\t    0) {\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t\t/* get info */\n\t\t\t\tif (get_file_info(filename->buf, finfo) != 0 ||\n\t\t\t\t    UpnpFileInfo_get_IsDirectory(finfo)) {\n\t\t\t\t\terr_code = HTTP_NOT_FOUND;\n\t\t\t\t\tgoto error_handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* not readable */\n\t\t\tif (!UpnpFileInfo_get_IsReadable(finfo)) {\n\t\t\t\terr_code = HTTP_FORBIDDEN;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\t/* finally, get content type */\n\t\t/*      if ( get_content_type(filename->buf, &content_type) != 0 ) */\n\t\t/*      { */\n\t\t/*          goto error_handler; */\n\t\t/*      } */\n\t}\n\tRespInstr->ReadSendSize = UpnpFileInfo_get_FileLength(finfo);\n\t/* Check other header field. */\n\tcode = CheckOtherHTTPHeaders(req, RespInstr,\n\t\tUpnpFileInfo_get_FileLength(finfo));\n\tif (code != HTTP_OK) {\n\t\terr_code = code;\n\t\tgoto error_handler;\n\t}\n\tif (req->method == HTTPMETHOD_POST) {\n\t\t*rtype = RESP_POST;\n\t\terr_code = HTTP_OK;\n\t\tgoto error_handler;\n\t}\n\textra_headers = UpnpFileInfo_get_ExtraHeaders(finfo);\n\tif (!extra_headers) {\n\t\textra_headers = \"\";\n\t}\n\n\t/* Check if chunked encoding should be used. */\n\tif (using_virtual_dir && UpnpFileInfo_get_FileLength(finfo) == UPNP_USING_CHUNKED) {\n\t\t/* Chunked encoding is only supported by HTTP 1.1 clients */\n\t\tif (resp_major == 1 && resp_minor == 1) {\n\t\t\tRespInstr->IsChunkActive = 1;\n\t\t} else {\n\t\t\t/* The virtual callback indicates that we should use\n\t\t\t * chunked encoding however the client doesn't support\n\t\t\t * it. Return with an internal server error. */\n\t\t\terr_code = HTTP_NOT_ACCEPTABLE;\n\t\t\tgoto error_handler;\n\t\t}\n\t}\n\n\taux_LastModified = UpnpFileInfo_get_LastModified(finfo);\n\tif (RespInstr->IsRangeActive && RespInstr->IsChunkActive) {\n\t\t/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\t\t/* Transfer-Encoding: chunked */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"R\" \"T\" \"GKLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_PARTIAL_CONTENT,\t/* status code */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* range info */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else if (RespInstr->IsRangeActive && !RespInstr->IsChunkActive) {\n\t\t/* Content-Range: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"R\" \"N\" \"T\" \"GLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_PARTIAL_CONTENT,\t/* status code */\n\t\t    RespInstr->ReadSendSize,\t/* content length */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* range info */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else if (!RespInstr->IsRangeActive && RespInstr->IsChunkActive) {\n\t\t/* Transfer-Encoding: chunked */\n\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t    \"RK\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t    HTTP_OK,\t/* status code */\n\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t    RespInstr,\t/* language info */\n\t\t    \"LAST-MODIFIED: \",\n\t\t    &aux_LastModified,\n\t\t    X_USER_AGENT, extra_headers) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* !RespInstr->IsRangeActive && !RespInstr->IsChunkActive */\n\t\tif (RespInstr->ReadSendSize >= 0) {\n\t\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t\t    \"R\" \"N\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t\t    HTTP_OK,\t/* status code */\n\t\t\t    RespInstr->ReadSendSize,\t/* content length */\n\t\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t\t    RespInstr,\t/* language info */\n\t\t\t    \"LAST-MODIFIED: \",\n\t\t\t    &aux_LastModified,\n\t\t\t    X_USER_AGENT,\n\t\t\t    extra_headers) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else {\n\t\t\tif (http_MakeMessage(headers, resp_major, resp_minor,\n\t\t\t    \"R\" \"TLD\" \"s\" \"tcS\" \"Xc\" \"sCc\",\n\t\t\t    HTTP_OK,\t/* status code */\n\t\t\t    UpnpFileInfo_get_ContentType(finfo), /* content type */\n\t\t\t    RespInstr,\t/* language info */\n\t\t\t    \"LAST-MODIFIED: \",\n\t\t\t    &aux_LastModified,\n\t\t\t    X_USER_AGENT,\n\t\t\t    extra_headers) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t}\n\tif (req->method == HTTPMETHOD_HEAD) {\n\t\t*rtype = RESP_HEADERS;\n\t} else if (using_alias) {\n\t\t/* GET xml */\n\t\t*rtype = RESP_XMLDOC;\n\t} else if (using_virtual_dir) {\n\t\t*rtype = RESP_WEBDOC;\n\t} else {\n\t\t/* GET filename */\n\t\t*rtype = RESP_FILEDOC;\n\t}\n\t/* simple get http 0.9 as specified in http 1.0 */\n\t/* don't send headers */\n\tif (req->method == HTTPMETHOD_SIMPLEGET) {\n\t\tmembuffer_destroy(headers);\n\t}\n\terr_code = HTTP_OK;\n\n error_handler:\n\tfree(request_doc);\n\tUpnpFileInfo_delete(finfo);\n\tif (err_code != HTTP_OK && alias_grabbed) {\n\t\talias_release(alias);\n\t}\n\n\treturn err_code;\n}"
  },
  {
    "function_name": "CheckOtherHTTPHeaders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "900-1012",
    "snippet": "static int CheckOtherHTTPHeaders(\n\t/*! [in] HTTP Request message. */\n\thttp_message_t *Req,\n\t/*! [out] Send Instruction object to data for the response. */\n\tstruct SendInstruction *RespInstr,\n\t/*! Size of the file containing the request document. */\n\toff_t FileSize)\n{\n\thttp_header_t *header;\n\tListNode *node;\n\t/*NNS: dlist_node* node; */\n\tint index, RetCode = HTTP_OK;\n\tchar *TmpBuf;\n\tsize_t TmpBufSize = LINE_SIZE;\n\n\tTmpBuf = (char *)malloc(TmpBufSize);\n\tif (!TmpBuf)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\tnode = ListHead(&Req->headers);\n\twhile (node != NULL) {\n\t\theader = (http_header_t *) node->item;\n\t\t/* find header type. */\n\t\tindex = map_str_to_int((const char *)header->name.buf,\n\t\t\t\theader->name.length, Http_Header_Names,\n\t\t\t\tNUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (header->value.length >= TmpBufSize) {\n\t\t\tfree(TmpBuf);\n\t\t\tTmpBufSize = header->value.length + 1;\n\t\t\tTmpBuf = (char *)malloc(TmpBufSize);\n\t\t\tif (!TmpBuf)\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t\tmemcpy(TmpBuf, header->value.buf, header->value.length);\n\t\tTmpBuf[header->value.length] = '\\0';\n\t\tif (index >= 0) {\n\t\t\tswitch (Http_Header_Names[index].id) {\n\t\t\tcase HDR_TE: {\n\t\t\t\t/* Request */\n\t\t\t\tRespInstr->IsChunkActive = 1;\n\n\t\t\t\tif (strlen(TmpBuf) > strlen(\"gzip\")) {\n\t\t\t\t\t/* means client will accept trailer. */\n\t\t\t\t\tif (StrStr(TmpBuf, \"trailers\") != NULL) {\n\t\t\t\t\t\tRespInstr->IsTrailers = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase HDR_CONTENT_LENGTH:\n\t\t\t\tRespInstr->RecvWriteSize = atoi(TmpBuf);\n\t\t\t\tbreak;\n\t\t\tcase HDR_RANGE:\n\t\t\t\tRetCode = CreateHTTPRangeResponseHeader(TmpBuf,\n\t\t\t\t\tFileSize, RespInstr);\n\t\t\t\tif (RetCode != HTTP_OK) {\n\t\t\t\t\tfree(TmpBuf);\n\t\t\t\t\treturn RetCode;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase HDR_ACCEPT_LANGUAGE:\n\t\t\t\tif (header->value.length + 1 > sizeof(RespInstr->AcceptLanguageHeader)) {\n\t\t\t\t\tsize_t length = sizeof(RespInstr->AcceptLanguageHeader) - 1;\n\t\t\t\t\tmemcpy(RespInstr->AcceptLanguageHeader, TmpBuf, length);\n\t\t\t\t\tRespInstr->AcceptLanguageHeader[length] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(RespInstr->AcceptLanguageHeader, TmpBuf,\n\t\t\t\t\t\theader->value.length + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t   TODO\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t   header.value is the value.\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t   case HDR_CONTENT_TYPE: return 1;\n\t\t\t\t   case HDR_CONTENT_LANGUAGE:return 1;\n\t\t\t\t   case HDR_LOCATION: return 1;\n\t\t\t\t   case HDR_CONTENT_LOCATION:return 1;\n\t\t\t\t   case HDR_ACCEPT: return 1;\n\t\t\t\t   case HDR_ACCEPT_CHARSET: return 1;\n\t\t\t\t   case HDR_USER_AGENT: return 1;\n\t\t\t\t */\n\n\t\t\t\t/*Header check for encoding */\n\t\t\t\t/*\n\t\t\t\t   case HDR_ACCEPT_RANGE:\n\t\t\t\t   case HDR_CONTENT_RANGE:\n\t\t\t\t   case HDR_IF_RANGE:\n\t\t\t\t */\n\n\t\t\t\t/*Header check for encoding */\n\t\t\t\t/*\n\t\t\t\t   case HDR_ACCEPT_ENCODING:\n\t\t\t\t   if(StrStr(TmpBuf, \"identity\"))\n\t\t\t\t   {\n\t\t\t\t   break;\n\t\t\t\t   }\n\t\t\t\t   else return -1;\n\t\t\t\t   case HDR_CONTENT_ENCODING:\n\t\t\t\t   case HDR_TRANSFER_ENCODING:\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnode = ListNext(&Req->headers, node);\n\t}\n\tfree(TmpBuf);\n\n\treturn RetCode;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NUM_HTTP_HEADER_NAMES 33"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "TmpBuf"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "ListNext",
          "args": [
            "&Req->headers",
            "node"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "RespInstr->AcceptLanguageHeader",
            "TmpBuf",
            "header->value.length + 1"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CreateHTTPRangeResponseHeader",
          "args": [
            "TmpBuf",
            "FileSize",
            "RespInstr"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "CreateHTTPRangeResponseHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "782-888",
          "snippet": "static int CreateHTTPRangeResponseHeader(\n\t/*! String containing the range. */\n\tchar *ByteRangeSpecifier,\n\t/*! Length of the file. */\n\toff_t FileLength,\n\t/*! [out] SendInstruction object where the range operations will be stored. */\n\tstruct SendInstruction *Instr)\n{\n\toff_t FirstByte, LastByte;\n\tchar *RangeInput;\n\tchar *Ptr;\n\tint rc = 0;\n\n\tInstr->IsRangeActive = 1;\n\tInstr->ReadSendSize = FileLength;\n\tif (!ByteRangeSpecifier)\n\t\treturn HTTP_BAD_REQUEST;\n\tRangeInput = strdup(ByteRangeSpecifier);\n\tif (!RangeInput)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t/* CONTENT-RANGE: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\tif (StrStr(RangeInput, \"bytes\") == NULL ||\n\t    (Ptr = StrStr(RangeInput, \"=\")) == NULL) {\n\t\tfree(RangeInput);\n\t\tInstr->IsRangeActive = 0;\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\t/* Jump = */\n\tPtr = Ptr + 1;\n\tif (FileLength < 0) {\n\t\tfree(RangeInput);\n\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t}\n\tif (GetNextRange(&Ptr, &FirstByte, &LastByte) != -1) {\n\t\tif (FileLength < FirstByte) {\n\t\t\tfree(RangeInput);\n\t\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t\t}\n\t\tif (FirstByte >= 0 && LastByte >= 0 && LastByte >= FirstByte) {\n\t\t\tif (LastByte >= FileLength)\n\t\t\t\tLastByte = FileLength - 1;\n\t\t\tInstr->RangeOffset = FirstByte;\n\t\t\tInstr->ReadSendSize = LastByte - FirstByte + 1;\n\t\t\t/* Data between two range. */\n\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t(int64_t)FirstByte,\n\t\t\t\t(int64_t)LastByte,\n\t\t\t\t(int64_t)FileLength);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else if (FirstByte >= 0 && LastByte == -1\n\t\t\t   && FirstByte < FileLength) {\n\t\t\tInstr->RangeOffset = FirstByte;\n\t\t\tInstr->ReadSendSize = FileLength - FirstByte;\n\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t(int64_t)FirstByte,\n\t\t\t\t(int64_t)(FileLength - 1),\n\t\t\t\t(int64_t)FileLength);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else if (FirstByte == -1 && LastByte > 0) {\n\t\t\tif (LastByte >= FileLength) {\n\t\t\t\tInstr->RangeOffset = 0;\n\t\t\t\tInstr->ReadSendSize = FileLength;\n\t\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\t\"CONTENT-RANGE: bytes 0-%\" PRId64\n\t\t\t\t\t\"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t\t(int64_t)(FileLength - 1),\n\t\t\t\t\t(int64_t)FileLength);\n\t\t\t} else {\n\t\t\t\tInstr->RangeOffset = FileLength - LastByte;\n\t\t\t\tInstr->ReadSendSize = LastByte;\n\t\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t\t(int64_t)(FileLength - LastByte),\n\t\t\t\t\t(int64_t)FileLength - 1,\n\t\t\t\t\t(int64_t)FileLength);\n\t\t\t}\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\tfree(RangeInput);\n\t\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t\t}\n\t} else {\n\t\tfree(RangeInput);\n\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t}\n\n\tfree(RangeInput);\n\treturn HTTP_OK;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic int CreateHTTPRangeResponseHeader(\n\t/*! String containing the range. */\n\tchar *ByteRangeSpecifier,\n\t/*! Length of the file. */\n\toff_t FileLength,\n\t/*! [out] SendInstruction object where the range operations will be stored. */\n\tstruct SendInstruction *Instr)\n{\n\toff_t FirstByte, LastByte;\n\tchar *RangeInput;\n\tchar *Ptr;\n\tint rc = 0;\n\n\tInstr->IsRangeActive = 1;\n\tInstr->ReadSendSize = FileLength;\n\tif (!ByteRangeSpecifier)\n\t\treturn HTTP_BAD_REQUEST;\n\tRangeInput = strdup(ByteRangeSpecifier);\n\tif (!RangeInput)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t/* CONTENT-RANGE: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\tif (StrStr(RangeInput, \"bytes\") == NULL ||\n\t    (Ptr = StrStr(RangeInput, \"=\")) == NULL) {\n\t\tfree(RangeInput);\n\t\tInstr->IsRangeActive = 0;\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\t/* Jump = */\n\tPtr = Ptr + 1;\n\tif (FileLength < 0) {\n\t\tfree(RangeInput);\n\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t}\n\tif (GetNextRange(&Ptr, &FirstByte, &LastByte) != -1) {\n\t\tif (FileLength < FirstByte) {\n\t\t\tfree(RangeInput);\n\t\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t\t}\n\t\tif (FirstByte >= 0 && LastByte >= 0 && LastByte >= FirstByte) {\n\t\t\tif (LastByte >= FileLength)\n\t\t\t\tLastByte = FileLength - 1;\n\t\t\tInstr->RangeOffset = FirstByte;\n\t\t\tInstr->ReadSendSize = LastByte - FirstByte + 1;\n\t\t\t/* Data between two range. */\n\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t(int64_t)FirstByte,\n\t\t\t\t(int64_t)LastByte,\n\t\t\t\t(int64_t)FileLength);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else if (FirstByte >= 0 && LastByte == -1\n\t\t\t   && FirstByte < FileLength) {\n\t\t\tInstr->RangeOffset = FirstByte;\n\t\t\tInstr->ReadSendSize = FileLength - FirstByte;\n\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t(int64_t)FirstByte,\n\t\t\t\t(int64_t)(FileLength - 1),\n\t\t\t\t(int64_t)FileLength);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else if (FirstByte == -1 && LastByte > 0) {\n\t\t\tif (LastByte >= FileLength) {\n\t\t\t\tInstr->RangeOffset = 0;\n\t\t\t\tInstr->ReadSendSize = FileLength;\n\t\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\t\"CONTENT-RANGE: bytes 0-%\" PRId64\n\t\t\t\t\t\"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t\t(int64_t)(FileLength - 1),\n\t\t\t\t\t(int64_t)FileLength);\n\t\t\t} else {\n\t\t\t\tInstr->RangeOffset = FileLength - LastByte;\n\t\t\t\tInstr->ReadSendSize = LastByte;\n\t\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t\t(int64_t)(FileLength - LastByte),\n\t\t\t\t\t(int64_t)FileLength - 1,\n\t\t\t\t\t(int64_t)FileLength);\n\t\t\t}\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\tfree(RangeInput);\n\t\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t\t}\n\t} else {\n\t\tfree(RangeInput);\n\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t}\n\n\tfree(RangeInput);\n\treturn HTTP_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "TmpBuf"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StrStr",
          "args": [
            "TmpBuf",
            "\"trailers\""
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "StrStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "662-692",
          "snippet": "static char *StrStr(\n\t/*! Input string. */\n\tchar *s1,\n\t/*! Input sub-string. */\n\tconst char *s2)\n{\n\tchar *Str1;\n\tchar *Str2;\n\tconst char *Ptr;\n\tchar *ret = NULL;\n\n\tStr1 = strdup(s1);\n\tif (!Str1)\n\t\tgoto error1;\n\tStr2 = strdup(s2);\n\tif (!Str2)\n\t\tgoto error2;\n\tToUpperCase(Str1);\n\tToUpperCase(Str2);\n\tPtr = strstr(Str1, Str2);\n\tif (!Ptr)\n\t\tret = NULL;\n\telse\n\t\tret = s1 + (Ptr - Str1);\n\n\tfree(Str2);\nerror2:\n\tfree(Str1);\nerror1:\n\treturn ret;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic char *StrStr(\n\t/*! Input string. */\n\tchar *s1,\n\t/*! Input sub-string. */\n\tconst char *s2)\n{\n\tchar *Str1;\n\tchar *Str2;\n\tconst char *Ptr;\n\tchar *ret = NULL;\n\n\tStr1 = strdup(s1);\n\tif (!Str1)\n\t\tgoto error1;\n\tStr2 = strdup(s2);\n\tif (!Str2)\n\t\tgoto error2;\n\tToUpperCase(Str1);\n\tToUpperCase(Str2);\n\tPtr = strstr(Str1, Str2);\n\tif (!Ptr)\n\t\tret = NULL;\n\telse\n\t\tret = s1 + (Ptr - Str1);\n\n\tfree(Str2);\nerror2:\n\tfree(Str1);\nerror1:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"gzip\""
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TmpBuf"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "TmpBufSize"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_str_to_int",
          "args": [
            "(const char *)header->name.buf",
            "header->name.length",
            "Http_Header_Names",
            "NUM_HTTP_HEADER_NAMES",
            "FALSE"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "map_str_to_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/strintmap.c",
          "lines": "63-103",
          "snippet": "int\nmap_str_to_int( IN const char *name,\n                IN size_t name_len,\n                IN str_int_entry * table,\n                IN int num_entries,\n                IN int case_sensitive )\n{\n    int top,\n      mid,\n      bot;\n    int cmp;\n    memptr name_ptr;\n\n    name_ptr.buf = ( char * )name;\n    name_ptr.length = name_len;\n\n    top = 0;\n    bot = num_entries - 1;\n\n    while( top <= bot ) {\n        mid = ( top + bot ) / 2;\n        if( case_sensitive ) {\n            /*cmp = strcmp( name, table[mid].name ); */\n            cmp = memptr_cmp( &name_ptr, table[mid].name );\n        } else {\n            /*cmp = strcasecmp( name, table[mid].name ); */\n            cmp = memptr_cmp_nocase( &name_ptr, table[mid].name );\n        }\n\n        if( cmp > 0 ) {\n            top = mid + 1;      /* look below mid */\n        } else if( cmp < 0 ) {\n            bot = mid - 1;      /* look above mid */\n        } else                  /* cmp == 0 */\n        {\n            return mid;         /* match; return table index */\n        }\n    }\n\n    return -1;                  /* header name not found */\n}",
          "includes": [
            "#include \"membuffer.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"membuffer.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nint\nmap_str_to_int( IN const char *name,\n                IN size_t name_len,\n                IN str_int_entry * table,\n                IN int num_entries,\n                IN int case_sensitive )\n{\n    int top,\n      mid,\n      bot;\n    int cmp;\n    memptr name_ptr;\n\n    name_ptr.buf = ( char * )name;\n    name_ptr.length = name_len;\n\n    top = 0;\n    bot = num_entries - 1;\n\n    while( top <= bot ) {\n        mid = ( top + bot ) / 2;\n        if( case_sensitive ) {\n            /*cmp = strcmp( name, table[mid].name ); */\n            cmp = memptr_cmp( &name_ptr, table[mid].name );\n        } else {\n            /*cmp = strcasecmp( name, table[mid].name ); */\n            cmp = memptr_cmp_nocase( &name_ptr, table[mid].name );\n        }\n\n        if( cmp > 0 ) {\n            top = mid + 1;      /* look below mid */\n        } else if( cmp < 0 ) {\n            bot = mid - 1;      /* look above mid */\n        } else                  /* cmp == 0 */\n        {\n            return mid;         /* match; return table index */\n        }\n    }\n\n    return -1;                  /* header name not found */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ListHead",
          "args": [
            "&Req->headers"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "TmpBufSize"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define NUM_HTTP_HEADER_NAMES 33\n\nstatic int CheckOtherHTTPHeaders(\n\t/*! [in] HTTP Request message. */\n\thttp_message_t *Req,\n\t/*! [out] Send Instruction object to data for the response. */\n\tstruct SendInstruction *RespInstr,\n\t/*! Size of the file containing the request document. */\n\toff_t FileSize)\n{\n\thttp_header_t *header;\n\tListNode *node;\n\t/*NNS: dlist_node* node; */\n\tint index, RetCode = HTTP_OK;\n\tchar *TmpBuf;\n\tsize_t TmpBufSize = LINE_SIZE;\n\n\tTmpBuf = (char *)malloc(TmpBufSize);\n\tif (!TmpBuf)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\tnode = ListHead(&Req->headers);\n\twhile (node != NULL) {\n\t\theader = (http_header_t *) node->item;\n\t\t/* find header type. */\n\t\tindex = map_str_to_int((const char *)header->name.buf,\n\t\t\t\theader->name.length, Http_Header_Names,\n\t\t\t\tNUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (header->value.length >= TmpBufSize) {\n\t\t\tfree(TmpBuf);\n\t\t\tTmpBufSize = header->value.length + 1;\n\t\t\tTmpBuf = (char *)malloc(TmpBufSize);\n\t\t\tif (!TmpBuf)\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t\tmemcpy(TmpBuf, header->value.buf, header->value.length);\n\t\tTmpBuf[header->value.length] = '\\0';\n\t\tif (index >= 0) {\n\t\t\tswitch (Http_Header_Names[index].id) {\n\t\t\tcase HDR_TE: {\n\t\t\t\t/* Request */\n\t\t\t\tRespInstr->IsChunkActive = 1;\n\n\t\t\t\tif (strlen(TmpBuf) > strlen(\"gzip\")) {\n\t\t\t\t\t/* means client will accept trailer. */\n\t\t\t\t\tif (StrStr(TmpBuf, \"trailers\") != NULL) {\n\t\t\t\t\t\tRespInstr->IsTrailers = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase HDR_CONTENT_LENGTH:\n\t\t\t\tRespInstr->RecvWriteSize = atoi(TmpBuf);\n\t\t\t\tbreak;\n\t\t\tcase HDR_RANGE:\n\t\t\t\tRetCode = CreateHTTPRangeResponseHeader(TmpBuf,\n\t\t\t\t\tFileSize, RespInstr);\n\t\t\t\tif (RetCode != HTTP_OK) {\n\t\t\t\t\tfree(TmpBuf);\n\t\t\t\t\treturn RetCode;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase HDR_ACCEPT_LANGUAGE:\n\t\t\t\tif (header->value.length + 1 > sizeof(RespInstr->AcceptLanguageHeader)) {\n\t\t\t\t\tsize_t length = sizeof(RespInstr->AcceptLanguageHeader) - 1;\n\t\t\t\t\tmemcpy(RespInstr->AcceptLanguageHeader, TmpBuf, length);\n\t\t\t\t\tRespInstr->AcceptLanguageHeader[length] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(RespInstr->AcceptLanguageHeader, TmpBuf,\n\t\t\t\t\t\theader->value.length + 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t   TODO\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t   header.value is the value.\n\t\t\t\t */\n\t\t\t\t/*\n\t\t\t\t   case HDR_CONTENT_TYPE: return 1;\n\t\t\t\t   case HDR_CONTENT_LANGUAGE:return 1;\n\t\t\t\t   case HDR_LOCATION: return 1;\n\t\t\t\t   case HDR_CONTENT_LOCATION:return 1;\n\t\t\t\t   case HDR_ACCEPT: return 1;\n\t\t\t\t   case HDR_ACCEPT_CHARSET: return 1;\n\t\t\t\t   case HDR_USER_AGENT: return 1;\n\t\t\t\t */\n\n\t\t\t\t/*Header check for encoding */\n\t\t\t\t/*\n\t\t\t\t   case HDR_ACCEPT_RANGE:\n\t\t\t\t   case HDR_CONTENT_RANGE:\n\t\t\t\t   case HDR_IF_RANGE:\n\t\t\t\t */\n\n\t\t\t\t/*Header check for encoding */\n\t\t\t\t/*\n\t\t\t\t   case HDR_ACCEPT_ENCODING:\n\t\t\t\t   if(StrStr(TmpBuf, \"identity\"))\n\t\t\t\t   {\n\t\t\t\t   break;\n\t\t\t\t   }\n\t\t\t\t   else return -1;\n\t\t\t\t   case HDR_CONTENT_ENCODING:\n\t\t\t\t   case HDR_TRANSFER_ENCODING:\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnode = ListNext(&Req->headers, node);\n\t}\n\tfree(TmpBuf);\n\n\treturn RetCode;\n}"
  },
  {
    "function_name": "CreateHTTPRangeResponseHeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "782-888",
    "snippet": "static int CreateHTTPRangeResponseHeader(\n\t/*! String containing the range. */\n\tchar *ByteRangeSpecifier,\n\t/*! Length of the file. */\n\toff_t FileLength,\n\t/*! [out] SendInstruction object where the range operations will be stored. */\n\tstruct SendInstruction *Instr)\n{\n\toff_t FirstByte, LastByte;\n\tchar *RangeInput;\n\tchar *Ptr;\n\tint rc = 0;\n\n\tInstr->IsRangeActive = 1;\n\tInstr->ReadSendSize = FileLength;\n\tif (!ByteRangeSpecifier)\n\t\treturn HTTP_BAD_REQUEST;\n\tRangeInput = strdup(ByteRangeSpecifier);\n\tif (!RangeInput)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t/* CONTENT-RANGE: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\tif (StrStr(RangeInput, \"bytes\") == NULL ||\n\t    (Ptr = StrStr(RangeInput, \"=\")) == NULL) {\n\t\tfree(RangeInput);\n\t\tInstr->IsRangeActive = 0;\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\t/* Jump = */\n\tPtr = Ptr + 1;\n\tif (FileLength < 0) {\n\t\tfree(RangeInput);\n\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t}\n\tif (GetNextRange(&Ptr, &FirstByte, &LastByte) != -1) {\n\t\tif (FileLength < FirstByte) {\n\t\t\tfree(RangeInput);\n\t\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t\t}\n\t\tif (FirstByte >= 0 && LastByte >= 0 && LastByte >= FirstByte) {\n\t\t\tif (LastByte >= FileLength)\n\t\t\t\tLastByte = FileLength - 1;\n\t\t\tInstr->RangeOffset = FirstByte;\n\t\t\tInstr->ReadSendSize = LastByte - FirstByte + 1;\n\t\t\t/* Data between two range. */\n\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t(int64_t)FirstByte,\n\t\t\t\t(int64_t)LastByte,\n\t\t\t\t(int64_t)FileLength);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else if (FirstByte >= 0 && LastByte == -1\n\t\t\t   && FirstByte < FileLength) {\n\t\t\tInstr->RangeOffset = FirstByte;\n\t\t\tInstr->ReadSendSize = FileLength - FirstByte;\n\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t(int64_t)FirstByte,\n\t\t\t\t(int64_t)(FileLength - 1),\n\t\t\t\t(int64_t)FileLength);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else if (FirstByte == -1 && LastByte > 0) {\n\t\t\tif (LastByte >= FileLength) {\n\t\t\t\tInstr->RangeOffset = 0;\n\t\t\t\tInstr->ReadSendSize = FileLength;\n\t\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\t\"CONTENT-RANGE: bytes 0-%\" PRId64\n\t\t\t\t\t\"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t\t(int64_t)(FileLength - 1),\n\t\t\t\t\t(int64_t)FileLength);\n\t\t\t} else {\n\t\t\t\tInstr->RangeOffset = FileLength - LastByte;\n\t\t\t\tInstr->ReadSendSize = LastByte;\n\t\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t\t(int64_t)(FileLength - LastByte),\n\t\t\t\t\t(int64_t)FileLength - 1,\n\t\t\t\t\t(int64_t)FileLength);\n\t\t\t}\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\tfree(RangeInput);\n\t\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t\t}\n\t} else {\n\t\tfree(RangeInput);\n\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t}\n\n\tfree(RangeInput);\n\treturn HTTP_OK;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "RangeInput"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "Instr->RangeHeader",
            "sizeof(Instr->RangeHeader)",
            "\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\"",
            "(int64_t)(FileLength - LastByte)",
            "(int64_t)FileLength - 1",
            "(int64_t)FileLength"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "Instr->RangeHeader",
            "sizeof(Instr->RangeHeader)",
            "\"CONTENT-RANGE: bytes 0-%\" PRId64\n\t\t\t\t\t\"/%\" PRId64 \"\\r\\n\"",
            "(int64_t)(FileLength - 1)",
            "(int64_t)FileLength"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "Instr->RangeHeader",
            "sizeof(Instr->RangeHeader)",
            "\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\"",
            "(int64_t)FirstByte",
            "(int64_t)(FileLength - 1)",
            "(int64_t)FileLength"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "Instr->RangeHeader",
            "sizeof(Instr->RangeHeader)",
            "\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\"",
            "(int64_t)FirstByte",
            "(int64_t)LastByte",
            "(int64_t)FileLength"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNextRange",
          "args": [
            "&Ptr",
            "&FirstByte",
            "&LastByte"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "GetNextRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "728-770",
          "snippet": "static int GetNextRange(\n\t/*! string containing the token / range. */\n\tchar **SrcRangeStr,\n\t/*! gets the first byte of the token. */\n\toff_t *FirstByte,\n\t/*! gets the last byte of the token. */\n\toff_t *LastByte)\n{\n\tchar *Ptr;\n\tchar *Tok;\n\tint i;\n\tint64_t F = -1;\n\tint64_t L = -1;\n\tint Is_Suffix_byte_Range = 1;\n\n\tif (*SrcRangeStr == NULL)\n\t\treturn -1;\n\tTok = StrTok(SrcRangeStr, \",\");\n\tif ((Ptr = strstr(Tok, \"-\")) == NULL)\n\t\treturn -1;\n\t*Ptr = ' ';\n\tsscanf(Tok, \"%\" SCNd64 \"%\" SCNd64, &F, &L);\n\tif (F == -1 || L == -1) {\n\t\t*Ptr = '-';\n\t\tfor (i = 0; i < (int)strlen(Tok); i++) {\n\t\t\tif (Tok[i] == '-') {\n\t\t\t\tbreak;\n\t\t\t} else if (isdigit(Tok[i])) {\n\t\t\t\tIs_Suffix_byte_Range = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (Is_Suffix_byte_Range) {\n\t\t\t*FirstByte = (off_t) L;\n\t\t\t*LastByte = (off_t) F;\n\t\t\treturn 1;\n\t\t}\n\t}\n\t*FirstByte = (off_t) F;\n\t*LastByte = (off_t) L;\n\n\treturn 1;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic int GetNextRange(\n\t/*! string containing the token / range. */\n\tchar **SrcRangeStr,\n\t/*! gets the first byte of the token. */\n\toff_t *FirstByte,\n\t/*! gets the last byte of the token. */\n\toff_t *LastByte)\n{\n\tchar *Ptr;\n\tchar *Tok;\n\tint i;\n\tint64_t F = -1;\n\tint64_t L = -1;\n\tint Is_Suffix_byte_Range = 1;\n\n\tif (*SrcRangeStr == NULL)\n\t\treturn -1;\n\tTok = StrTok(SrcRangeStr, \",\");\n\tif ((Ptr = strstr(Tok, \"-\")) == NULL)\n\t\treturn -1;\n\t*Ptr = ' ';\n\tsscanf(Tok, \"%\" SCNd64 \"%\" SCNd64, &F, &L);\n\tif (F == -1 || L == -1) {\n\t\t*Ptr = '-';\n\t\tfor (i = 0; i < (int)strlen(Tok); i++) {\n\t\t\tif (Tok[i] == '-') {\n\t\t\t\tbreak;\n\t\t\t} else if (isdigit(Tok[i])) {\n\t\t\t\tIs_Suffix_byte_Range = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (Is_Suffix_byte_Range) {\n\t\t\t*FirstByte = (off_t) L;\n\t\t\t*LastByte = (off_t) F;\n\t\t\treturn 1;\n\t\t}\n\t}\n\t*FirstByte = (off_t) F;\n\t*LastByte = (off_t) L;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "StrStr",
          "args": [
            "RangeInput",
            "\"=\""
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "StrStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "662-692",
          "snippet": "static char *StrStr(\n\t/*! Input string. */\n\tchar *s1,\n\t/*! Input sub-string. */\n\tconst char *s2)\n{\n\tchar *Str1;\n\tchar *Str2;\n\tconst char *Ptr;\n\tchar *ret = NULL;\n\n\tStr1 = strdup(s1);\n\tif (!Str1)\n\t\tgoto error1;\n\tStr2 = strdup(s2);\n\tif (!Str2)\n\t\tgoto error2;\n\tToUpperCase(Str1);\n\tToUpperCase(Str2);\n\tPtr = strstr(Str1, Str2);\n\tif (!Ptr)\n\t\tret = NULL;\n\telse\n\t\tret = s1 + (Ptr - Str1);\n\n\tfree(Str2);\nerror2:\n\tfree(Str1);\nerror1:\n\treturn ret;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic char *StrStr(\n\t/*! Input string. */\n\tchar *s1,\n\t/*! Input sub-string. */\n\tconst char *s2)\n{\n\tchar *Str1;\n\tchar *Str2;\n\tconst char *Ptr;\n\tchar *ret = NULL;\n\n\tStr1 = strdup(s1);\n\tif (!Str1)\n\t\tgoto error1;\n\tStr2 = strdup(s2);\n\tif (!Str2)\n\t\tgoto error2;\n\tToUpperCase(Str1);\n\tToUpperCase(Str2);\n\tPtr = strstr(Str1, Str2);\n\tif (!Ptr)\n\t\tret = NULL;\n\telse\n\t\tret = s1 + (Ptr - Str1);\n\n\tfree(Str2);\nerror2:\n\tfree(Str1);\nerror1:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ByteRangeSpecifier"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic int CreateHTTPRangeResponseHeader(\n\t/*! String containing the range. */\n\tchar *ByteRangeSpecifier,\n\t/*! Length of the file. */\n\toff_t FileLength,\n\t/*! [out] SendInstruction object where the range operations will be stored. */\n\tstruct SendInstruction *Instr)\n{\n\toff_t FirstByte, LastByte;\n\tchar *RangeInput;\n\tchar *Ptr;\n\tint rc = 0;\n\n\tInstr->IsRangeActive = 1;\n\tInstr->ReadSendSize = FileLength;\n\tif (!ByteRangeSpecifier)\n\t\treturn HTTP_BAD_REQUEST;\n\tRangeInput = strdup(ByteRangeSpecifier);\n\tif (!RangeInput)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t/* CONTENT-RANGE: bytes 222-3333/4000  HTTP_PARTIAL_CONTENT */\n\tif (StrStr(RangeInput, \"bytes\") == NULL ||\n\t    (Ptr = StrStr(RangeInput, \"=\")) == NULL) {\n\t\tfree(RangeInput);\n\t\tInstr->IsRangeActive = 0;\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\t/* Jump = */\n\tPtr = Ptr + 1;\n\tif (FileLength < 0) {\n\t\tfree(RangeInput);\n\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t}\n\tif (GetNextRange(&Ptr, &FirstByte, &LastByte) != -1) {\n\t\tif (FileLength < FirstByte) {\n\t\t\tfree(RangeInput);\n\t\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t\t}\n\t\tif (FirstByte >= 0 && LastByte >= 0 && LastByte >= FirstByte) {\n\t\t\tif (LastByte >= FileLength)\n\t\t\t\tLastByte = FileLength - 1;\n\t\t\tInstr->RangeOffset = FirstByte;\n\t\t\tInstr->ReadSendSize = LastByte - FirstByte + 1;\n\t\t\t/* Data between two range. */\n\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t(int64_t)FirstByte,\n\t\t\t\t(int64_t)LastByte,\n\t\t\t\t(int64_t)FileLength);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else if (FirstByte >= 0 && LastByte == -1\n\t\t\t   && FirstByte < FileLength) {\n\t\t\tInstr->RangeOffset = FirstByte;\n\t\t\tInstr->ReadSendSize = FileLength - FirstByte;\n\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t(int64_t)FirstByte,\n\t\t\t\t(int64_t)(FileLength - 1),\n\t\t\t\t(int64_t)FileLength);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else if (FirstByte == -1 && LastByte > 0) {\n\t\t\tif (LastByte >= FileLength) {\n\t\t\t\tInstr->RangeOffset = 0;\n\t\t\t\tInstr->ReadSendSize = FileLength;\n\t\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\t\"CONTENT-RANGE: bytes 0-%\" PRId64\n\t\t\t\t\t\"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t\t(int64_t)(FileLength - 1),\n\t\t\t\t\t(int64_t)FileLength);\n\t\t\t} else {\n\t\t\t\tInstr->RangeOffset = FileLength - LastByte;\n\t\t\t\tInstr->ReadSendSize = LastByte;\n\t\t\t\trc = snprintf(Instr->RangeHeader,\n\t\t\t\t\tsizeof(Instr->RangeHeader),\n\t\t\t\t\t\"CONTENT-RANGE: bytes %\" PRId64\n\t\t\t\t\t\"-%\" PRId64 \"/%\" PRId64 \"\\r\\n\",\n\t\t\t\t\t(int64_t)(FileLength - LastByte),\n\t\t\t\t\t(int64_t)FileLength - 1,\n\t\t\t\t\t(int64_t)FileLength);\n\t\t\t}\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Instr->RangeHeader)) {\n\t\t\t\tfree(RangeInput);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\tfree(RangeInput);\n\t\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t\t}\n\t} else {\n\t\tfree(RangeInput);\n\t\treturn HTTP_REQUEST_RANGE_NOT_SATISFIABLE;\n\t}\n\n\tfree(RangeInput);\n\treturn HTTP_OK;\n}"
  },
  {
    "function_name": "GetNextRange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "728-770",
    "snippet": "static int GetNextRange(\n\t/*! string containing the token / range. */\n\tchar **SrcRangeStr,\n\t/*! gets the first byte of the token. */\n\toff_t *FirstByte,\n\t/*! gets the last byte of the token. */\n\toff_t *LastByte)\n{\n\tchar *Ptr;\n\tchar *Tok;\n\tint i;\n\tint64_t F = -1;\n\tint64_t L = -1;\n\tint Is_Suffix_byte_Range = 1;\n\n\tif (*SrcRangeStr == NULL)\n\t\treturn -1;\n\tTok = StrTok(SrcRangeStr, \",\");\n\tif ((Ptr = strstr(Tok, \"-\")) == NULL)\n\t\treturn -1;\n\t*Ptr = ' ';\n\tsscanf(Tok, \"%\" SCNd64 \"%\" SCNd64, &F, &L);\n\tif (F == -1 || L == -1) {\n\t\t*Ptr = '-';\n\t\tfor (i = 0; i < (int)strlen(Tok); i++) {\n\t\t\tif (Tok[i] == '-') {\n\t\t\t\tbreak;\n\t\t\t} else if (isdigit(Tok[i])) {\n\t\t\t\tIs_Suffix_byte_Range = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (Is_Suffix_byte_Range) {\n\t\t\t*FirstByte = (off_t) L;\n\t\t\t*LastByte = (off_t) F;\n\t\t\treturn 1;\n\t\t}\n\t}\n\t*FirstByte = (off_t) F;\n\t*LastByte = (off_t) L;\n\n\treturn 1;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "Tok[i]"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "Tok"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "Tok",
            "\"%\" SCNd64 \"%\" SCNd64",
            "&F",
            "&L"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "Tok",
            "\"-\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StrTok",
          "args": [
            "SrcRangeStr",
            "\",\""
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "StrTok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "699-721",
          "snippet": "static char *StrTok(\n\t/*! String containing the token. */\n\tchar **Src,\n\t/*! Set of delimiter characters. */\n\tconst char *Del)\n{\n\tchar *TmpPtr;\n\tchar *RetPtr;\n\n\tif (*Src != NULL) {\n\t\tRetPtr = *Src;\n\t\tTmpPtr = strstr(*Src, Del);\n\t\tif (TmpPtr != NULL) {\n\t\t\t*TmpPtr = '\\0';\n\t\t\t*Src = TmpPtr + strlen(Del);\n\t\t} else\n\t\t\t*Src = NULL;\n\n\t\treturn RetPtr;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic char *StrTok(\n\t/*! String containing the token. */\n\tchar **Src,\n\t/*! Set of delimiter characters. */\n\tconst char *Del)\n{\n\tchar *TmpPtr;\n\tchar *RetPtr;\n\n\tif (*Src != NULL) {\n\t\tRetPtr = *Src;\n\t\tTmpPtr = strstr(*Src, Del);\n\t\tif (TmpPtr != NULL) {\n\t\t\t*TmpPtr = '\\0';\n\t\t\t*Src = TmpPtr + strlen(Del);\n\t\t} else\n\t\t\t*Src = NULL;\n\n\t\treturn RetPtr;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic int GetNextRange(\n\t/*! string containing the token / range. */\n\tchar **SrcRangeStr,\n\t/*! gets the first byte of the token. */\n\toff_t *FirstByte,\n\t/*! gets the last byte of the token. */\n\toff_t *LastByte)\n{\n\tchar *Ptr;\n\tchar *Tok;\n\tint i;\n\tint64_t F = -1;\n\tint64_t L = -1;\n\tint Is_Suffix_byte_Range = 1;\n\n\tif (*SrcRangeStr == NULL)\n\t\treturn -1;\n\tTok = StrTok(SrcRangeStr, \",\");\n\tif ((Ptr = strstr(Tok, \"-\")) == NULL)\n\t\treturn -1;\n\t*Ptr = ' ';\n\tsscanf(Tok, \"%\" SCNd64 \"%\" SCNd64, &F, &L);\n\tif (F == -1 || L == -1) {\n\t\t*Ptr = '-';\n\t\tfor (i = 0; i < (int)strlen(Tok); i++) {\n\t\t\tif (Tok[i] == '-') {\n\t\t\t\tbreak;\n\t\t\t} else if (isdigit(Tok[i])) {\n\t\t\t\tIs_Suffix_byte_Range = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (Is_Suffix_byte_Range) {\n\t\t\t*FirstByte = (off_t) L;\n\t\t\t*LastByte = (off_t) F;\n\t\t\treturn 1;\n\t\t}\n\t}\n\t*FirstByte = (off_t) F;\n\t*LastByte = (off_t) L;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "StrTok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "699-721",
    "snippet": "static char *StrTok(\n\t/*! String containing the token. */\n\tchar **Src,\n\t/*! Set of delimiter characters. */\n\tconst char *Del)\n{\n\tchar *TmpPtr;\n\tchar *RetPtr;\n\n\tif (*Src != NULL) {\n\t\tRetPtr = *Src;\n\t\tTmpPtr = strstr(*Src, Del);\n\t\tif (TmpPtr != NULL) {\n\t\t\t*TmpPtr = '\\0';\n\t\t\t*Src = TmpPtr + strlen(Del);\n\t\t} else\n\t\t\t*Src = NULL;\n\n\t\treturn RetPtr;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "Del"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "*Src",
            "Del"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic char *StrTok(\n\t/*! String containing the token. */\n\tchar **Src,\n\t/*! Set of delimiter characters. */\n\tconst char *Del)\n{\n\tchar *TmpPtr;\n\tchar *RetPtr;\n\n\tif (*Src != NULL) {\n\t\tRetPtr = *Src;\n\t\tTmpPtr = strstr(*Src, Del);\n\t\tif (TmpPtr != NULL) {\n\t\t\t*TmpPtr = '\\0';\n\t\t\t*Src = TmpPtr + strlen(Del);\n\t\t} else\n\t\t\t*Src = NULL;\n\n\t\treturn RetPtr;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "StrStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "662-692",
    "snippet": "static char *StrStr(\n\t/*! Input string. */\n\tchar *s1,\n\t/*! Input sub-string. */\n\tconst char *s2)\n{\n\tchar *Str1;\n\tchar *Str2;\n\tconst char *Ptr;\n\tchar *ret = NULL;\n\n\tStr1 = strdup(s1);\n\tif (!Str1)\n\t\tgoto error1;\n\tStr2 = strdup(s2);\n\tif (!Str2)\n\t\tgoto error2;\n\tToUpperCase(Str1);\n\tToUpperCase(Str2);\n\tPtr = strstr(Str1, Str2);\n\tif (!Ptr)\n\t\tret = NULL;\n\telse\n\t\tret = s1 + (Ptr - Str1);\n\n\tfree(Str2);\nerror2:\n\tfree(Str1);\nerror1:\n\treturn ret;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "Str1"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "Str1",
            "Str2"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ToUpperCase",
          "args": [
            "Str2"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "ToUpperCase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "647-655",
          "snippet": "static void ToUpperCase(\n\t/*! Input string to be converted. */\n\tchar *s)\n{\n\twhile (*s) {\n\t\t*s = (char)toupper(*s);\n\t\t++s;\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic void ToUpperCase(\n\t/*! Input string to be converted. */\n\tchar *s)\n{\n\twhile (*s) {\n\t\t*s = (char)toupper(*s);\n\t\t++s;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s2"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s1"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic char *StrStr(\n\t/*! Input string. */\n\tchar *s1,\n\t/*! Input sub-string. */\n\tconst char *s2)\n{\n\tchar *Str1;\n\tchar *Str2;\n\tconst char *Ptr;\n\tchar *ret = NULL;\n\n\tStr1 = strdup(s1);\n\tif (!Str1)\n\t\tgoto error1;\n\tStr2 = strdup(s2);\n\tif (!Str2)\n\t\tgoto error2;\n\tToUpperCase(Str1);\n\tToUpperCase(Str2);\n\tPtr = strstr(Str1, Str2);\n\tif (!Ptr)\n\t\tret = NULL;\n\telse\n\t\tret = s1 + (Ptr - Str1);\n\n\tfree(Str2);\nerror2:\n\tfree(Str1);\nerror1:\n\treturn ret;\n}"
  },
  {
    "function_name": "ToUpperCase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "647-655",
    "snippet": "static void ToUpperCase(\n\t/*! Input string to be converted. */\n\tchar *s)\n{\n\twhile (*s) {\n\t\t*s = (char)toupper(*s);\n\t\t++s;\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "*s"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic void ToUpperCase(\n\t/*! Input string to be converted. */\n\tchar *s)\n{\n\twhile (*s) {\n\t\t*s = (char)toupper(*s);\n\t\t++s;\n\t}\n}"
  },
  {
    "function_name": "isFileInVirtualDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "614-642",
    "snippet": "static int isFileInVirtualDir(\n\t/*! [in] Directory path to be tested for virtual directory. */\n\tchar *filePath)\n{\n\tvirtualDirList *pCurVirtualDir;\n\tsize_t webDirLen;\n\n\tpCurVirtualDir = pVirtualDirList;\n\twhile (pCurVirtualDir != NULL) {\n\t\twebDirLen = strlen(pCurVirtualDir->dirName);\n\t\tif (webDirLen) {\n\t\t\tif (pCurVirtualDir->dirName[webDirLen - 1] == '/') {\n\t\t\t\tif (strncmp(pCurVirtualDir->dirName, filePath,\n\t\t\t\t\t\twebDirLen) == 0)\n\t\t\t\t\treturn !0;\n\t\t\t} else {\n\t\t\t\tif (strncmp(pCurVirtualDir->dirName, filePath,\n\t\t\t\t\t\twebDirLen) == 0 &&\n\t\t\t\t    (filePath[webDirLen] == '/' ||\n\t\t\t\t     filePath[webDirLen] == '\\0' ||\n\t\t\t\t     filePath[webDirLen] == '?'))\n\t\t\t\t\treturn !0;\n\t\t\t}\n\t\t}\n\t\tpCurVirtualDir = pCurVirtualDir->next;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "pCurVirtualDir->dirName",
            "filePath",
            "webDirLen"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "pCurVirtualDir->dirName",
            "filePath",
            "webDirLen"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pCurVirtualDir->dirName"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic int isFileInVirtualDir(\n\t/*! [in] Directory path to be tested for virtual directory. */\n\tchar *filePath)\n{\n\tvirtualDirList *pCurVirtualDir;\n\tsize_t webDirLen;\n\n\tpCurVirtualDir = pVirtualDirList;\n\twhile (pCurVirtualDir != NULL) {\n\t\twebDirLen = strlen(pCurVirtualDir->dirName);\n\t\tif (webDirLen) {\n\t\t\tif (pCurVirtualDir->dirName[webDirLen - 1] == '/') {\n\t\t\t\tif (strncmp(pCurVirtualDir->dirName, filePath,\n\t\t\t\t\t\twebDirLen) == 0)\n\t\t\t\t\treturn !0;\n\t\t\t} else {\n\t\t\t\tif (strncmp(pCurVirtualDir->dirName, filePath,\n\t\t\t\t\t\twebDirLen) == 0 &&\n\t\t\t\t    (filePath[webDirLen] == '/' ||\n\t\t\t\t     filePath[webDirLen] == '\\0' ||\n\t\t\t\t     filePath[webDirLen] == '?'))\n\t\t\t\t\treturn !0;\n\t\t\t}\n\t\t}\n\t\tpCurVirtualDir = pCurVirtualDir->next;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "588-606",
    "snippet": "static UPNP_INLINE int get_alias(\n\t/*! [in] request file passed in to be compared with. */\n\tconst char *request_file,\n\t/*! [out] xml alias object which has a file name stored. */\n\tstruct xml_alias_t *alias,\n\t/*! [out] File information object which will be filled up if the file\n\t * comparison succeeds. */\n\tUpnpFileInfo *info)\n{\n\tint cmp = strcmp(alias->name.buf, request_file);\n\tif (cmp == 0) {\n\t\tUpnpFileInfo_set_FileLength(info, (off_t)alias->doc.length);\n\t\tUpnpFileInfo_set_IsDirectory(info, FALSE);\n\t\tUpnpFileInfo_set_IsReadable(info, TRUE);\n\t\tUpnpFileInfo_set_LastModified(info, alias->last_modified);\n\t}\n\n\treturn cmp == 0;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_LastModified",
          "args": [
            "info",
            "alias->last_modified"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_IsReadable",
          "args": [
            "info",
            "TRUE"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_IsDirectory",
          "args": [
            "info",
            "FALSE"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_FileLength",
          "args": [
            "info",
            "(off_t)alias->doc.length"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "alias->name.buf",
            "request_file"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int get_alias(\n\t/*! [in] request file passed in to be compared with. */\n\tconst char *request_file,\n\t/*! [out] xml alias object which has a file name stored. */\n\tstruct xml_alias_t *alias,\n\t/*! [out] File information object which will be filled up if the file\n\t * comparison succeeds. */\n\tUpnpFileInfo *info)\n{\n\tint cmp = strcmp(alias->name.buf, request_file);\n\tif (cmp == 0) {\n\t\tUpnpFileInfo_set_FileLength(info, (off_t)alias->doc.length);\n\t\tUpnpFileInfo_set_IsDirectory(info, FALSE);\n\t\tUpnpFileInfo_set_IsReadable(info, TRUE);\n\t\tUpnpFileInfo_set_LastModified(info, alias->last_modified);\n\t}\n\n\treturn cmp == 0;\n}"
  },
  {
    "function_name": "web_server_set_root_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "562-578",
    "snippet": "int web_server_set_root_dir(const char *root_dir)\n{\n\tsize_t index;\n\tint ret;\n\n\tret = membuffer_assign_str(&gDocumentRootDir, root_dir);\n\tif (ret != 0)\n\t\treturn ret;\n\t/* remove trailing '/', if any */\n\tif (gDocumentRootDir.length > 0) {\n\t\tindex = gDocumentRootDir.length - 1;\t/* last char */\n\t\tif (gDocumentRootDir.buf[index] == '/')\n\t\t\tmembuffer_delete(&gDocumentRootDir, index, 1);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_delete",
          "args": [
            "&gDocumentRootDir",
            "index",
            "1"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "240-271",
          "snippet": "void membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_assign_str",
          "args": [
            "&gDocumentRootDir",
            "root_dir"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_assign_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "195-198",
          "snippet": "int membuffer_assign_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_assign(m, c_str, strlen(c_str));\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_assign_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_assign(m, c_str, strlen(c_str));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nint web_server_set_root_dir(const char *root_dir)\n{\n\tsize_t index;\n\tint ret;\n\n\tret = membuffer_assign_str(&gDocumentRootDir, root_dir);\n\tif (ret != 0)\n\t\treturn ret;\n\t/* remove trailing '/', if any */\n\tif (gDocumentRootDir.length > 0) {\n\t\tindex = gDocumentRootDir.length - 1;\t/* last char */\n\t\tif (gDocumentRootDir.buf[index] == '/')\n\t\t\tmembuffer_delete(&gDocumentRootDir, index, 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_file_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "517-560",
    "snippet": "static int get_file_info(\n\t/*! [in] Filename having the description document. */\n\tconst char *filename,\n\t/*! [out] File information object having file attributes such as filelength,\n\t * when was the file last modified, whether a file or a directory and\n\t * whether the file or directory is readable. */\n\tOUT UpnpFileInfo *info)\n{\n\tint code;\n\tstruct stat s;\n\tFILE *fp;\n\tint rc = 0;\n\ttime_t aux_LastModified;\n\tstruct tm date;\n\tchar buffer[ASCTIME_R_BUFFER_SIZE];\n\n\tUpnpFileInfo_set_ContentType(info, NULL);\n\tcode = stat(filename, &s);\n\tif (code == -1)\n\t\treturn -1;\n\tif (S_ISDIR(s.st_mode))\n\t\tUpnpFileInfo_set_IsDirectory(info, TRUE);\n\telse if (S_ISREG(s.st_mode))\n\t\tUpnpFileInfo_set_IsDirectory(info, FALSE);\n\telse\n\t\treturn -1;\n\t/* check readable */\n\tfp = fopen(filename, \"r\");\n\tUpnpFileInfo_set_IsReadable(info, fp != NULL);\n\tif (fp)\n\t\tfclose(fp);\n\tUpnpFileInfo_set_FileLength(info, s.st_size);\n\tUpnpFileInfo_set_LastModified(info, s.st_mtime);\n\trc = get_content_type(filename, info);\n\taux_LastModified = UpnpFileInfo_get_LastModified(info);\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\"file info: %s, length: %lld, last_mod=%s readable=%d\\n\",\n\t\tfilename,\n\t\t(long long)UpnpFileInfo_get_FileLength(info),\n\t\tweb_server_asctime_r(http_gmtime_r(&aux_LastModified, &date), buffer),\n\t\tUpnpFileInfo_get_IsReadable(info));\n\n\treturn rc;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define web_server_asctime_r asctime_r",
      "#define ASCTIME_R_BUFFER_SIZE 26"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "HTTP",
            "__FILE__",
            "__LINE__",
            "\"file info: %s, length: %lld, last_mod=%s readable=%d\\n\"",
            "filename",
            "(long long)UpnpFileInfo_get_FileLength(info)",
            "web_server_asctime_r(http_gmtime_r(&aux_LastModified, &date), buffer)",
            "UpnpFileInfo_get_IsReadable(info)"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_IsReadable",
          "args": [
            "info"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "web_server_asctime_r",
          "args": [
            "http_gmtime_r(&aux_LastModified, &date)",
            "buffer"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "web_server_asctime_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "139-146",
          "snippet": "static char *web_server_asctime_r(const struct tm *tm, char *buf)\n{\n\tif (tm == NULL || buf == NULL)\n\t\treturn NULL;\n\n\tasctime_s(buf, ASCTIME_R_BUFFER_SIZE, tm);\n\treturn buf;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define web_server_asctime_r asctime_r",
            "#define ASCTIME_R_BUFFER_SIZE 26"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define web_server_asctime_r asctime_r\n#define ASCTIME_R_BUFFER_SIZE 26\n\nstatic char *web_server_asctime_r(const struct tm *tm, char *buf)\n{\n\tif (tm == NULL || buf == NULL)\n\t\treturn NULL;\n\n\tasctime_s(buf, ASCTIME_R_BUFFER_SIZE, tm);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_gmtime_r",
          "args": [
            "&aux_LastModified",
            "&date"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "http_gmtime_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "168-176",
          "snippet": "struct tm *http_gmtime_r(const time_t *clock, struct tm *result)\n{\n\tif (clock == NULL || *clock < 0 || result == NULL)\n\t\treturn NULL;\n\n\t/* gmtime in VC runtime is thread safe. */\n\t*result = *gmtime(clock);\n\treturn result;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstruct tm *http_gmtime_r(const time_t *clock, struct tm *result)\n{\n\tif (clock == NULL || *clock < 0 || result == NULL)\n\t\treturn NULL;\n\n\t/* gmtime in VC runtime is thread safe. */\n\t*result = *gmtime(clock);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_FileLength",
          "args": [
            "info"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_LastModified",
          "args": [
            "info"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_content_type",
          "args": [
            "filename",
            "info"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "get_content_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "314-354",
          "snippet": "static UPNP_INLINE int get_content_type(\n\t/*! [in] . */\n\tconst char *filename,\n\t/*! [out] . */\n\tOUT UpnpFileInfo *fileInfo)\n{\n\tconst char *extension;\n\tconst char *type;\n\tconst char *subtype;\n\tint ctype_found = FALSE;\n\tchar *temp = NULL;\n\tsize_t length = 0;\n\tint rc = 0;\n\n\tUpnpFileInfo_set_ContentType(fileInfo, NULL);\n\t/* get ext */\n\textension = strrchr(filename, '.');\n\tif (extension != NULL)\n\t\tif (search_extension(extension + 1, &type, &subtype) == 0)\n\t\t\tctype_found = TRUE;\n\tif (!ctype_found) {\n\t\t/* unknown content type */\n\t\ttype = gMediaTypes[APPLICATION_INDEX];\n\t\tsubtype = \"octet-stream\";\n\t}\n\tlength = strlen(type) + strlen(\"/\") + strlen(subtype) + 1;\n\ttemp = malloc(length);\n\tif (!temp)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\trc = snprintf(temp, length, \"%s/%s\", type, subtype);\n\tif (rc < 0 || (unsigned int) rc >= length) {\n\t\tfree(temp);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tUpnpFileInfo_set_ContentType(fileInfo, temp);\n\tfree(temp);\n\tif (!UpnpFileInfo_get_ContentType(fileInfo))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_INDEX 4",
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_INDEX 4\n#define snprintf _snprintf\n\nstatic UPNP_INLINE int get_content_type(\n\t/*! [in] . */\n\tconst char *filename,\n\t/*! [out] . */\n\tOUT UpnpFileInfo *fileInfo)\n{\n\tconst char *extension;\n\tconst char *type;\n\tconst char *subtype;\n\tint ctype_found = FALSE;\n\tchar *temp = NULL;\n\tsize_t length = 0;\n\tint rc = 0;\n\n\tUpnpFileInfo_set_ContentType(fileInfo, NULL);\n\t/* get ext */\n\textension = strrchr(filename, '.');\n\tif (extension != NULL)\n\t\tif (search_extension(extension + 1, &type, &subtype) == 0)\n\t\t\tctype_found = TRUE;\n\tif (!ctype_found) {\n\t\t/* unknown content type */\n\t\ttype = gMediaTypes[APPLICATION_INDEX];\n\t\tsubtype = \"octet-stream\";\n\t}\n\tlength = strlen(type) + strlen(\"/\") + strlen(subtype) + 1;\n\ttemp = malloc(length);\n\tif (!temp)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\trc = snprintf(temp, length, \"%s/%s\", type, subtype);\n\tif (rc < 0 || (unsigned int) rc >= length) {\n\t\tfree(temp);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tUpnpFileInfo_set_ContentType(fileInfo, temp);\n\tfree(temp);\n\tif (!UpnpFileInfo_get_ContentType(fileInfo))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_LastModified",
          "args": [
            "info",
            "s.st_mtime"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_FileLength",
          "args": [
            "info",
            "s.st_size"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_IsReadable",
          "args": [
            "info",
            "fp != NULL"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "filename",
            "\"r\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_IsDirectory",
          "args": [
            "info",
            "FALSE"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "s.st_mode"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_IsDirectory",
          "args": [
            "info",
            "TRUE"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "filename",
            "&s"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_ContentType",
          "args": [
            "info",
            "NULL"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define web_server_asctime_r asctime_r\n#define ASCTIME_R_BUFFER_SIZE 26\n\nstatic int get_file_info(\n\t/*! [in] Filename having the description document. */\n\tconst char *filename,\n\t/*! [out] File information object having file attributes such as filelength,\n\t * when was the file last modified, whether a file or a directory and\n\t * whether the file or directory is readable. */\n\tOUT UpnpFileInfo *info)\n{\n\tint code;\n\tstruct stat s;\n\tFILE *fp;\n\tint rc = 0;\n\ttime_t aux_LastModified;\n\tstruct tm date;\n\tchar buffer[ASCTIME_R_BUFFER_SIZE];\n\n\tUpnpFileInfo_set_ContentType(info, NULL);\n\tcode = stat(filename, &s);\n\tif (code == -1)\n\t\treturn -1;\n\tif (S_ISDIR(s.st_mode))\n\t\tUpnpFileInfo_set_IsDirectory(info, TRUE);\n\telse if (S_ISREG(s.st_mode))\n\t\tUpnpFileInfo_set_IsDirectory(info, FALSE);\n\telse\n\t\treturn -1;\n\t/* check readable */\n\tfp = fopen(filename, \"r\");\n\tUpnpFileInfo_set_IsReadable(info, fp != NULL);\n\tif (fp)\n\t\tfclose(fp);\n\tUpnpFileInfo_set_FileLength(info, s.st_size);\n\tUpnpFileInfo_set_LastModified(info, s.st_mtime);\n\trc = get_content_type(filename, info);\n\taux_LastModified = UpnpFileInfo_get_LastModified(info);\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\"file info: %s, length: %lld, last_mod=%s readable=%d\\n\",\n\t\tfilename,\n\t\t(long long)UpnpFileInfo_get_FileLength(info),\n\t\tweb_server_asctime_r(http_gmtime_r(&aux_LastModified, &date), buffer),\n\t\tUpnpFileInfo_get_IsReadable(info));\n\n\treturn rc;\n}"
  },
  {
    "function_name": "web_server_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "495-508",
    "snippet": "void web_server_destroy(void)\n{\n\tif (bWebServerState == WEB_SERVER_ENABLED) {\n\t\tmembuffer_destroy(&gDocumentRootDir);\n\t\talias_release(&gAliasDoc);\n\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tmemset(&gAliasDoc, 0, sizeof(struct xml_alias_t));\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\tithread_mutex_destroy(&gWebMutex);\n\t\tbWebServerState = WEB_SERVER_DISABLED;\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ithread_mutex_destroy",
          "args": [
            "&gWebMutex"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ithread_mutex_unlock",
          "args": [
            "&gWebMutex"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&gAliasDoc",
            "0",
            "sizeof(struct xml_alias_t)"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ithread_mutex_lock",
          "args": [
            "&gWebMutex"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alias_release",
          "args": [
            "&gAliasDoc"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "alias_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "401-419",
          "snippet": "static void alias_release(\n\t/*! [in] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\t/* ignore invalid alias */\n\tif (!is_valid_alias(alias)) {\n\t\tithread_mutex_unlock(&gWebMutex);\n\t\treturn;\n\t}\n\tassert(*alias->ct > 0);\n\t*alias->ct -= 1;\n\tif (*alias->ct <= 0) {\n\t\tmembuffer_destroy(&alias->doc);\n\t\tmembuffer_destroy(&alias->name);\n\t\tfree(alias->ct);\n\t}\n\tithread_mutex_unlock(&gWebMutex);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic void alias_release(\n\t/*! [in] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\t/* ignore invalid alias */\n\tif (!is_valid_alias(alias)) {\n\t\tithread_mutex_unlock(&gWebMutex);\n\t\treturn;\n\t}\n\tassert(*alias->ct > 0);\n\t*alias->ct -= 1;\n\tif (*alias->ct <= 0) {\n\t\tmembuffer_destroy(&alias->doc);\n\t\tmembuffer_destroy(&alias->name);\n\t\tfree(alias->ct);\n\t}\n\tithread_mutex_unlock(&gWebMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&gDocumentRootDir"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nvoid web_server_destroy(void)\n{\n\tif (bWebServerState == WEB_SERVER_ENABLED) {\n\t\tmembuffer_destroy(&gDocumentRootDir);\n\t\talias_release(&gAliasDoc);\n\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tmemset(&gAliasDoc, 0, sizeof(struct xml_alias_t));\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\tithread_mutex_destroy(&gWebMutex);\n\t\tbWebServerState = WEB_SERVER_DISABLED;\n\t}\n}"
  },
  {
    "function_name": "web_server_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "467-493",
    "snippet": "int web_server_init()\n{\n\tint ret = 0;\n\n\tif (bWebServerState == WEB_SERVER_DISABLED) {\n\t\t/* decode media list */\n\t\tmedia_list_init();\n\t\tmembuffer_init(&gDocumentRootDir);\n\t\tglob_alias_init();\n\t\tpVirtualDirList = NULL;\n\n\t\t/* Initialize callbacks */\n\t\tvirtualDirCallback.get_info = NULL;\n\t\tvirtualDirCallback.open = NULL;\n\t\tvirtualDirCallback.read = NULL;\n\t\tvirtualDirCallback.write = NULL;\n\t\tvirtualDirCallback.seek = NULL;\n\t\tvirtualDirCallback.close = NULL;\n\n\t\tif (ithread_mutex_init(&gWebMutex, NULL) == -1)\n\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\telse\n\t\t\tbWebServerState = WEB_SERVER_ENABLED;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ithread_mutex_init",
          "args": [
            "&gWebMutex",
            "NULL"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glob_alias_init",
          "args": [],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "glob_alias_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "360-368",
          "snippet": "static UPNP_INLINE void glob_alias_init(void)\n{\n\tstruct xml_alias_t *alias = &gAliasDoc;\n\n\tmembuffer_init(&alias->doc);\n\tmembuffer_init(&alias->name);\n\talias->ct = NULL;\n\talias->last_modified = 0;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void glob_alias_init(void)\n{\n\tstruct xml_alias_t *alias = &gAliasDoc;\n\n\tmembuffer_init(&alias->doc);\n\tmembuffer_init(&alias->name);\n\talias->ct = NULL;\n\talias->last_modified = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&gDocumentRootDir"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "media_list_init",
          "args": [],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "media_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "242-261",
          "snippet": "static UPNP_INLINE void media_list_init(void)\n{\n\tint i;\n\tconst char *s = gEncodedMediaTypes;\n\tstruct document_type_t *doc_type;\n\n\tfor (i = 0; *s != '\\0'; i++) {\n\t\tdoc_type = &gMediaTypeList[i];\n\t\tdoc_type->file_ext = s;\n\t\t/* point to type. */\n\t\ts += strlen(s) + 1;\n\t\tdoc_type->content_type = gMediaTypes[(int)*s];\n\t\t/* point to subtype. */\n\t\ts++;\n\t\tdoc_type->content_subtype = s;\n\t\t/* next entry. */\n\t\ts += strlen(s) + 1;\n\t}\n\tassert(i == NUM_MEDIA_TYPES);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_MEDIA_TYPES       70"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define NUM_MEDIA_TYPES       70\n\nstatic UPNP_INLINE void media_list_init(void)\n{\n\tint i;\n\tconst char *s = gEncodedMediaTypes;\n\tstruct document_type_t *doc_type;\n\n\tfor (i = 0; *s != '\\0'; i++) {\n\t\tdoc_type = &gMediaTypeList[i];\n\t\tdoc_type->file_ext = s;\n\t\t/* point to type. */\n\t\ts += strlen(s) + 1;\n\t\tdoc_type->content_type = gMediaTypes[(int)*s];\n\t\t/* point to subtype. */\n\t\ts++;\n\t\tdoc_type->content_subtype = s;\n\t\t/* next entry. */\n\t\ts += strlen(s) + 1;\n\t}\n\tassert(i == NUM_MEDIA_TYPES);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nint web_server_init()\n{\n\tint ret = 0;\n\n\tif (bWebServerState == WEB_SERVER_DISABLED) {\n\t\t/* decode media list */\n\t\tmedia_list_init();\n\t\tmembuffer_init(&gDocumentRootDir);\n\t\tglob_alias_init();\n\t\tpVirtualDirList = NULL;\n\n\t\t/* Initialize callbacks */\n\t\tvirtualDirCallback.get_info = NULL;\n\t\tvirtualDirCallback.open = NULL;\n\t\tvirtualDirCallback.read = NULL;\n\t\tvirtualDirCallback.write = NULL;\n\t\tvirtualDirCallback.seek = NULL;\n\t\tvirtualDirCallback.close = NULL;\n\n\t\tif (ithread_mutex_init(&gWebMutex, NULL) == -1)\n\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\telse\n\t\t\tbWebServerState = WEB_SERVER_ENABLED;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "web_server_set_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "421-465",
    "snippet": "int web_server_set_alias(const char *alias_name, \n\tconst char *alias_content, size_t alias_content_length,\n\ttime_t last_modified)\n{\n\tint ret_code;\n\tstruct xml_alias_t alias;\n\n\talias_release(&gAliasDoc);\n\tif (alias_name == NULL) {\n\t\t/* don't serve aliased doc anymore */\n\t\treturn 0;\n\t}\n\tassert(alias_content != NULL);\n\tmembuffer_init(&alias.doc);\n\tmembuffer_init(&alias.name);\n\talias.ct = NULL;\n\tdo {\n\t\t/* insert leading /, if missing */\n\t\tif (*alias_name != '/')\n\t\t\tif (membuffer_assign_str(&alias.name, \"/\") != 0)\n\t\t\t\tbreak;\t/* error; out of mem */\n\t\tret_code = membuffer_append_str(&alias.name, alias_name);\n\t\tif (ret_code != 0)\n\t\t\tbreak;\t/* error */\n\t\tif ((alias.ct = (int *)malloc(sizeof(int))) == NULL)\n\t\t\tbreak;\t/* error */\n\t\t*alias.ct = 1;\n\t\tmembuffer_attach(&alias.doc, (char *)alias_content,\n\t\t\t\t alias_content_length);\n\t\talias.last_modified = last_modified;\n\t\t/* save in module var */\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tgAliasDoc = alias;\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\treturn 0;\n\t} while (FALSE);\n\t/* error handler */\n\t/* free temp alias */\n\tmembuffer_destroy(&alias.name);\n\tmembuffer_destroy(&alias.doc);\n\tfree(alias.ct);\n\n\treturn UPNP_E_OUTOF_MEMORY;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "alias.ct"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&alias.doc"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ithread_mutex_unlock",
          "args": [
            "&gWebMutex"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ithread_mutex_lock",
          "args": [
            "&gWebMutex"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_attach",
          "args": [
            "&alias.doc",
            "(char *)alias_content",
            "alias_content_length"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "287-295",
          "snippet": "void membuffer_attach(membuffer *m, char *new_buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\tmembuffer_destroy(m);\n\tm->buf = new_buf;\n\tm->length = buf_len;\n\tm->capacity = buf_len;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_attach(membuffer *m, char *new_buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\tmembuffer_destroy(m);\n\tm->buf = new_buf;\n\tm->length = buf_len;\n\tm->capacity = buf_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(int)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_append_str",
          "args": [
            "&alias.name",
            "alias_name"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "207-210",
          "snippet": "int membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_assign_str",
          "args": [
            "&alias.name",
            "\"/\""
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_assign_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "195-198",
          "snippet": "int membuffer_assign_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_assign(m, c_str, strlen(c_str));\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_assign_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_assign(m, c_str, strlen(c_str));\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&alias.name"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "alias_content != NULL"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alias_release",
          "args": [
            "&gAliasDoc"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "alias_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "401-419",
          "snippet": "static void alias_release(\n\t/*! [in] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\t/* ignore invalid alias */\n\tif (!is_valid_alias(alias)) {\n\t\tithread_mutex_unlock(&gWebMutex);\n\t\treturn;\n\t}\n\tassert(*alias->ct > 0);\n\t*alias->ct -= 1;\n\tif (*alias->ct <= 0) {\n\t\tmembuffer_destroy(&alias->doc);\n\t\tmembuffer_destroy(&alias->name);\n\t\tfree(alias->ct);\n\t}\n\tithread_mutex_unlock(&gWebMutex);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic void alias_release(\n\t/*! [in] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\t/* ignore invalid alias */\n\tif (!is_valid_alias(alias)) {\n\t\tithread_mutex_unlock(&gWebMutex);\n\t\treturn;\n\t}\n\tassert(*alias->ct > 0);\n\t*alias->ct -= 1;\n\tif (*alias->ct <= 0) {\n\t\tmembuffer_destroy(&alias->doc);\n\t\tmembuffer_destroy(&alias->name);\n\t\tfree(alias->ct);\n\t}\n\tithread_mutex_unlock(&gWebMutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nint web_server_set_alias(const char *alias_name, \n\tconst char *alias_content, size_t alias_content_length,\n\ttime_t last_modified)\n{\n\tint ret_code;\n\tstruct xml_alias_t alias;\n\n\talias_release(&gAliasDoc);\n\tif (alias_name == NULL) {\n\t\t/* don't serve aliased doc anymore */\n\t\treturn 0;\n\t}\n\tassert(alias_content != NULL);\n\tmembuffer_init(&alias.doc);\n\tmembuffer_init(&alias.name);\n\talias.ct = NULL;\n\tdo {\n\t\t/* insert leading /, if missing */\n\t\tif (*alias_name != '/')\n\t\t\tif (membuffer_assign_str(&alias.name, \"/\") != 0)\n\t\t\t\tbreak;\t/* error; out of mem */\n\t\tret_code = membuffer_append_str(&alias.name, alias_name);\n\t\tif (ret_code != 0)\n\t\t\tbreak;\t/* error */\n\t\tif ((alias.ct = (int *)malloc(sizeof(int))) == NULL)\n\t\t\tbreak;\t/* error */\n\t\t*alias.ct = 1;\n\t\tmembuffer_attach(&alias.doc, (char *)alias_content,\n\t\t\t\t alias_content_length);\n\t\talias.last_modified = last_modified;\n\t\t/* save in module var */\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tgAliasDoc = alias;\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\treturn 0;\n\t} while (FALSE);\n\t/* error handler */\n\t/* free temp alias */\n\tmembuffer_destroy(&alias.name);\n\tmembuffer_destroy(&alias.doc);\n\tfree(alias.ct);\n\n\treturn UPNP_E_OUTOF_MEMORY;\n}"
  },
  {
    "function_name": "alias_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "401-419",
    "snippet": "static void alias_release(\n\t/*! [in] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\t/* ignore invalid alias */\n\tif (!is_valid_alias(alias)) {\n\t\tithread_mutex_unlock(&gWebMutex);\n\t\treturn;\n\t}\n\tassert(*alias->ct > 0);\n\t*alias->ct -= 1;\n\tif (*alias->ct <= 0) {\n\t\tmembuffer_destroy(&alias->doc);\n\t\tmembuffer_destroy(&alias->name);\n\t\tfree(alias->ct);\n\t}\n\tithread_mutex_unlock(&gWebMutex);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ithread_mutex_unlock",
          "args": [
            "&gWebMutex"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "alias->ct"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&alias->name"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "*alias->ct > 0"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ithread_mutex_unlock",
          "args": [
            "&gWebMutex"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_valid_alias",
          "args": [
            "alias"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "is_valid_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "375-380",
          "snippet": "static UPNP_INLINE int is_valid_alias(\n\t/*! [in] XML alias object. */\n\tconst struct xml_alias_t *alias)\n{\n\treturn alias->doc.buf != NULL;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int is_valid_alias(\n\t/*! [in] XML alias object. */\n\tconst struct xml_alias_t *alias)\n{\n\treturn alias->doc.buf != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ithread_mutex_lock",
          "args": [
            "&gWebMutex"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic void alias_release(\n\t/*! [in] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\t/* ignore invalid alias */\n\tif (!is_valid_alias(alias)) {\n\t\tithread_mutex_unlock(&gWebMutex);\n\t\treturn;\n\t}\n\tassert(*alias->ct > 0);\n\t*alias->ct -= 1;\n\tif (*alias->ct <= 0) {\n\t\tmembuffer_destroy(&alias->doc);\n\t\tmembuffer_destroy(&alias->name);\n\t\tfree(alias->ct);\n\t}\n\tithread_mutex_unlock(&gWebMutex);\n}"
  },
  {
    "function_name": "alias_grab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "386-395",
    "snippet": "static void alias_grab(\n\t/*! [out] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\tassert(is_valid_alias(&gAliasDoc));\n\tmemcpy(alias, &gAliasDoc, sizeof(struct xml_alias_t));\n\t*alias->ct = *alias->ct + 1;\n\tithread_mutex_unlock(&gWebMutex);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ithread_mutex_unlock",
          "args": [
            "&gWebMutex"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "alias",
            "&gAliasDoc",
            "sizeof(struct xml_alias_t)"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "is_valid_alias(&gAliasDoc)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_valid_alias",
          "args": [
            "&gAliasDoc"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "is_valid_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "375-380",
          "snippet": "static UPNP_INLINE int is_valid_alias(\n\t/*! [in] XML alias object. */\n\tconst struct xml_alias_t *alias)\n{\n\treturn alias->doc.buf != NULL;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int is_valid_alias(\n\t/*! [in] XML alias object. */\n\tconst struct xml_alias_t *alias)\n{\n\treturn alias->doc.buf != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ithread_mutex_lock",
          "args": [
            "&gWebMutex"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic void alias_grab(\n\t/*! [out] XML alias object. */\n\tstruct xml_alias_t *alias)\n{\n\tithread_mutex_lock(&gWebMutex);\n\tassert(is_valid_alias(&gAliasDoc));\n\tmemcpy(alias, &gAliasDoc, sizeof(struct xml_alias_t));\n\t*alias->ct = *alias->ct + 1;\n\tithread_mutex_unlock(&gWebMutex);\n}"
  },
  {
    "function_name": "is_valid_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "375-380",
    "snippet": "static UPNP_INLINE int is_valid_alias(\n\t/*! [in] XML alias object. */\n\tconst struct xml_alias_t *alias)\n{\n\treturn alias->doc.buf != NULL;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int is_valid_alias(\n\t/*! [in] XML alias object. */\n\tconst struct xml_alias_t *alias)\n{\n\treturn alias->doc.buf != NULL;\n}"
  },
  {
    "function_name": "glob_alias_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "360-368",
    "snippet": "static UPNP_INLINE void glob_alias_init(void)\n{\n\tstruct xml_alias_t *alias = &gAliasDoc;\n\n\tmembuffer_init(&alias->doc);\n\tmembuffer_init(&alias->name);\n\talias->ct = NULL;\n\talias->last_modified = 0;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&alias->name"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE void glob_alias_init(void)\n{\n\tstruct xml_alias_t *alias = &gAliasDoc;\n\n\tmembuffer_init(&alias->doc);\n\tmembuffer_init(&alias->name);\n\talias->ct = NULL;\n\talias->last_modified = 0;\n}"
  },
  {
    "function_name": "get_content_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "314-354",
    "snippet": "static UPNP_INLINE int get_content_type(\n\t/*! [in] . */\n\tconst char *filename,\n\t/*! [out] . */\n\tOUT UpnpFileInfo *fileInfo)\n{\n\tconst char *extension;\n\tconst char *type;\n\tconst char *subtype;\n\tint ctype_found = FALSE;\n\tchar *temp = NULL;\n\tsize_t length = 0;\n\tint rc = 0;\n\n\tUpnpFileInfo_set_ContentType(fileInfo, NULL);\n\t/* get ext */\n\textension = strrchr(filename, '.');\n\tif (extension != NULL)\n\t\tif (search_extension(extension + 1, &type, &subtype) == 0)\n\t\t\tctype_found = TRUE;\n\tif (!ctype_found) {\n\t\t/* unknown content type */\n\t\ttype = gMediaTypes[APPLICATION_INDEX];\n\t\tsubtype = \"octet-stream\";\n\t}\n\tlength = strlen(type) + strlen(\"/\") + strlen(subtype) + 1;\n\ttemp = malloc(length);\n\tif (!temp)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\trc = snprintf(temp, length, \"%s/%s\", type, subtype);\n\tif (rc < 0 || (unsigned int) rc >= length) {\n\t\tfree(temp);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tUpnpFileInfo_set_ContentType(fileInfo, temp);\n\tfree(temp);\n\tif (!UpnpFileInfo_get_ContentType(fileInfo))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define APPLICATION_INDEX 4",
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpFileInfo_get_ContentType",
          "args": [
            "fileInfo"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "temp"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_ContentType",
          "args": [
            "fileInfo",
            "temp"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "temp",
            "length",
            "\"%s/%s\"",
            "type",
            "subtype"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "length"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "subtype"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "type"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_extension",
          "args": [
            "extension + 1",
            "&type",
            "&subtype"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "search_extension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "271-303",
          "snippet": "static UPNP_INLINE int search_extension(\n\t/*! [in] . */\n\tconst char *extension,\n\t/*! [out] . */\n\tconst char **con_type,\n\t/*! [out] . */\n\tconst char **con_subtype)\n{\n\tint top, mid, bot;\n\tint cmp;\n\n\ttop = 0;\n\tbot = NUM_MEDIA_TYPES - 1;\n\n\twhile (top <= bot) {\n\t\tmid = (top + bot) / 2;\n\t\tcmp = strcasecmp(extension, gMediaTypeList[mid].file_ext);\n\t\tif (cmp > 0) {\n\t\t\t/* look below mid. */\n\t\t\ttop = mid + 1;\n\t\t} else if (cmp < 0) {\n\t\t\t/* look above mid. */\n\t\t\tbot = mid - 1;\n\t\t} else {\n\t\t\t/* cmp == 0 */\n\t\t\t*con_type = gMediaTypeList[mid].content_type;\n\t\t\t*con_subtype = gMediaTypeList[mid].content_subtype;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_MEDIA_TYPES       70"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define NUM_MEDIA_TYPES       70\n\nstatic UPNP_INLINE int search_extension(\n\t/*! [in] . */\n\tconst char *extension,\n\t/*! [out] . */\n\tconst char **con_type,\n\t/*! [out] . */\n\tconst char **con_subtype)\n{\n\tint top, mid, bot;\n\tint cmp;\n\n\ttop = 0;\n\tbot = NUM_MEDIA_TYPES - 1;\n\n\twhile (top <= bot) {\n\t\tmid = (top + bot) / 2;\n\t\tcmp = strcasecmp(extension, gMediaTypeList[mid].file_ext);\n\t\tif (cmp > 0) {\n\t\t\t/* look below mid. */\n\t\t\ttop = mid + 1;\n\t\t} else if (cmp < 0) {\n\t\t\t/* look above mid. */\n\t\t\tbot = mid - 1;\n\t\t} else {\n\t\t\t/* cmp == 0 */\n\t\t\t*con_type = gMediaTypeList[mid].content_type;\n\t\t\t*con_subtype = gMediaTypeList[mid].content_subtype;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "filename",
            "'.'"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpFileInfo_set_ContentType",
          "args": [
            "fileInfo",
            "NULL"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_INDEX 4\n#define snprintf _snprintf\n\nstatic UPNP_INLINE int get_content_type(\n\t/*! [in] . */\n\tconst char *filename,\n\t/*! [out] . */\n\tOUT UpnpFileInfo *fileInfo)\n{\n\tconst char *extension;\n\tconst char *type;\n\tconst char *subtype;\n\tint ctype_found = FALSE;\n\tchar *temp = NULL;\n\tsize_t length = 0;\n\tint rc = 0;\n\n\tUpnpFileInfo_set_ContentType(fileInfo, NULL);\n\t/* get ext */\n\textension = strrchr(filename, '.');\n\tif (extension != NULL)\n\t\tif (search_extension(extension + 1, &type, &subtype) == 0)\n\t\t\tctype_found = TRUE;\n\tif (!ctype_found) {\n\t\t/* unknown content type */\n\t\ttype = gMediaTypes[APPLICATION_INDEX];\n\t\tsubtype = \"octet-stream\";\n\t}\n\tlength = strlen(type) + strlen(\"/\") + strlen(subtype) + 1;\n\ttemp = malloc(length);\n\tif (!temp)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\trc = snprintf(temp, length, \"%s/%s\", type, subtype);\n\tif (rc < 0 || (unsigned int) rc >= length) {\n\t\tfree(temp);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\tUpnpFileInfo_set_ContentType(fileInfo, temp);\n\tfree(temp);\n\tif (!UpnpFileInfo_get_ContentType(fileInfo))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "search_extension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "271-303",
    "snippet": "static UPNP_INLINE int search_extension(\n\t/*! [in] . */\n\tconst char *extension,\n\t/*! [out] . */\n\tconst char **con_type,\n\t/*! [out] . */\n\tconst char **con_subtype)\n{\n\tint top, mid, bot;\n\tint cmp;\n\n\ttop = 0;\n\tbot = NUM_MEDIA_TYPES - 1;\n\n\twhile (top <= bot) {\n\t\tmid = (top + bot) / 2;\n\t\tcmp = strcasecmp(extension, gMediaTypeList[mid].file_ext);\n\t\tif (cmp > 0) {\n\t\t\t/* look below mid. */\n\t\t\ttop = mid + 1;\n\t\t} else if (cmp < 0) {\n\t\t\t/* look above mid. */\n\t\t\tbot = mid - 1;\n\t\t} else {\n\t\t\t/* cmp == 0 */\n\t\t\t*con_type = gMediaTypeList[mid].content_type;\n\t\t\t*con_subtype = gMediaTypeList[mid].content_subtype;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NUM_MEDIA_TYPES       70"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "extension",
            "gMediaTypeList[mid].file_ext"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define NUM_MEDIA_TYPES       70\n\nstatic UPNP_INLINE int search_extension(\n\t/*! [in] . */\n\tconst char *extension,\n\t/*! [out] . */\n\tconst char **con_type,\n\t/*! [out] . */\n\tconst char **con_subtype)\n{\n\tint top, mid, bot;\n\tint cmp;\n\n\ttop = 0;\n\tbot = NUM_MEDIA_TYPES - 1;\n\n\twhile (top <= bot) {\n\t\tmid = (top + bot) / 2;\n\t\tcmp = strcasecmp(extension, gMediaTypeList[mid].file_ext);\n\t\tif (cmp > 0) {\n\t\t\t/* look below mid. */\n\t\t\ttop = mid + 1;\n\t\t} else if (cmp < 0) {\n\t\t\t/* look above mid. */\n\t\t\tbot = mid - 1;\n\t\t} else {\n\t\t\t/* cmp == 0 */\n\t\t\t*con_type = gMediaTypeList[mid].content_type;\n\t\t\t*con_subtype = gMediaTypeList[mid].content_subtype;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "media_list_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "242-261",
    "snippet": "static UPNP_INLINE void media_list_init(void)\n{\n\tint i;\n\tconst char *s = gEncodedMediaTypes;\n\tstruct document_type_t *doc_type;\n\n\tfor (i = 0; *s != '\\0'; i++) {\n\t\tdoc_type = &gMediaTypeList[i];\n\t\tdoc_type->file_ext = s;\n\t\t/* point to type. */\n\t\ts += strlen(s) + 1;\n\t\tdoc_type->content_type = gMediaTypes[(int)*s];\n\t\t/* point to subtype. */\n\t\ts++;\n\t\tdoc_type->content_subtype = s;\n\t\t/* next entry. */\n\t\ts += strlen(s) + 1;\n\t}\n\tassert(i == NUM_MEDIA_TYPES);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define NUM_MEDIA_TYPES       70"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "i == NUM_MEDIA_TYPES"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define NUM_MEDIA_TYPES       70\n\nstatic UPNP_INLINE void media_list_init(void)\n{\n\tint i;\n\tconst char *s = gEncodedMediaTypes;\n\tstruct document_type_t *doc_type;\n\n\tfor (i = 0; *s != '\\0'; i++) {\n\t\tdoc_type = &gMediaTypeList[i];\n\t\tdoc_type->file_ext = s;\n\t\t/* point to type. */\n\t\ts += strlen(s) + 1;\n\t\tdoc_type->content_type = gMediaTypes[(int)*s];\n\t\t/* point to subtype. */\n\t\ts++;\n\t\tdoc_type->content_subtype = s;\n\t\t/* next entry. */\n\t\ts += strlen(s) + 1;\n\t}\n\tassert(i == NUM_MEDIA_TYPES);\n}"
  },
  {
    "function_name": "web_server_asctime_r",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
    "lines": "139-146",
    "snippet": "static char *web_server_asctime_r(const struct tm *tm, char *buf)\n{\n\tif (tm == NULL || buf == NULL)\n\t\treturn NULL;\n\n\tasctime_s(buf, ASCTIME_R_BUFFER_SIZE, tm);\n\treturn buf;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <assert.h>",
      "#include \"VirtualDir.h\"",
      "#include \"upnputil.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"strintmap.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"membuffer.h\"",
      "#include \"ithread.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"FileInfo.h\"",
      "#include \"webserver.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define web_server_asctime_r asctime_r",
      "#define ASCTIME_R_BUFFER_SIZE 26"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "asctime_s",
          "args": [
            "buf",
            "ASCTIME_R_BUFFER_SIZE",
            "tm"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\n#define web_server_asctime_r asctime_r\n#define ASCTIME_R_BUFFER_SIZE 26\n\nstatic char *web_server_asctime_r(const struct tm *tm, char *buf)\n{\n\tif (tm == NULL || buf == NULL)\n\t\treturn NULL;\n\n\tasctime_s(buf, ASCTIME_R_BUFFER_SIZE, tm);\n\treturn buf;\n}"
  }
]