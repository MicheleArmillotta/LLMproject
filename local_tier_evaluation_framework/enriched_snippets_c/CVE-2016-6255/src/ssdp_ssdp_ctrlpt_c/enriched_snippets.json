[
  {
    "function_name": "SearchByTarget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_ctrlpt.c",
    "lines": "510-674",
    "snippet": "int SearchByTarget(int Mx, char *St, void *Cookie)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tint *id = NULL;\n\tint ret = 0;\n\tchar ReqBufv4[BUFSIZE];\n#ifdef UPNP_ENABLE_IPV6\n\tchar ReqBufv6[BUFSIZE];\n\tchar ReqBufv6UlaGua[BUFSIZE];\n#endif\n\tstruct sockaddr_storage __ss_v4;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n#endif\n\tstruct sockaddr_in *destAddr4 = (struct sockaddr_in *)&__ss_v4;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_in6 *destAddr6 = (struct sockaddr_in6 *)&__ss_v6;\n#endif\n\tfd_set wrSet;\n\tSsdpSearchArg *newArg = NULL;\n\tint timeTillRead = 0;\n\tint handle;\n\tstruct Handle_Info *ctrlpt_info = NULL;\n\tenum SsdpSearchType requestType;\n\tunsigned long addrv4 = inet_addr(gIF_IPV4);\n\tSOCKET max_fd = 0;\n\tint retVal;\n\n\t/*ThreadData *ThData; */\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\trequestType = ssdp_request_type1(St);\n\tif (requestType == SSDP_SERROR)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t   \"Inside SearchByTarget\\n\");\n\ttimeTillRead = Mx;\n\tif (timeTillRead < MIN_SEARCH_TIME)\n\t\ttimeTillRead = MIN_SEARCH_TIME;\n\telse if (timeTillRead > MAX_SEARCH_TIME)\n\t\ttimeTillRead = MAX_SEARCH_TIME;\n\tretVal = CreateClientRequestPacket(ReqBufv4, sizeof(ReqBufv4), timeTillRead, St, AF_INET);\n\tif (retVal != UPNP_E_SUCCESS)\n\t\treturn retVal;\n#ifdef UPNP_ENABLE_IPV6\n\tretVal = CreateClientRequestPacket(ReqBufv6, sizeof(ReqBufv6), timeTillRead, St, AF_INET6);\n\tif (retVal != UPNP_E_SUCCESS)\n\t\treturn retVal;\n\tretVal = CreateClientRequestPacketUlaGua(ReqBufv6UlaGua, sizeof(ReqBufv6UlaGua), timeTillRead, St, AF_INET6);\n\tif (retVal != UPNP_E_SUCCESS)\n\t\treturn retVal;\n#endif\n\n\tmemset(&__ss_v4, 0, sizeof(__ss_v4));\n\tdestAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, SSDP_IP, &destAddr4->sin_addr);\n\tdestAddr4->sin_port = htons(SSDP_PORT);\n\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof(__ss_v6));\n\tdestAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, SSDP_IPV6_SITELOCAL, &destAddr6->sin6_addr);\n\tdestAddr6->sin6_port = htons(SSDP_PORT);\n\tdestAddr6->sin6_scope_id = gIF_INDEX;\n#endif\n\n\t/* add search criteria to list */\n\tHandleLock();\n\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n\tnewArg = (SsdpSearchArg *) malloc(sizeof(SsdpSearchArg));\n\tnewArg->searchTarget = strdup(St);\n\tnewArg->cookie = Cookie;\n\tnewArg->requestType = requestType;\n\tid = (int *)malloc(sizeof(int));\n\tTPJobInit(&job, (start_routine) searchExpired, id);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\tTPJobSetFreeFunction(&job, (free_routine) free);\n\t/* Schedule a timeout event to remove search Arg */\n\tTimerThreadSchedule(&gTimerThread, timeTillRead,\n\t\t\t    REL_SEC, &job, SHORT_TERM, id);\n\tnewArg->timeoutEventId = *id;\n\tListAddTail(&ctrlpt_info->SsdpSearchList, newArg);\n\tHandleUnlock();\n\t/* End of lock */\n\n\tFD_ZERO(&wrSet);\n\tif (gSsdpReqSocket4 != INVALID_SOCKET) {\n\t\tsetsockopt(gSsdpReqSocket4, IPPROTO_IP, IP_MULTICAST_IF,\n\t\t\t   (char *)&addrv4, sizeof(addrv4));\n\t\tFD_SET(gSsdpReqSocket4, &wrSet);\n\t\tmax_fd = max(max_fd, gSsdpReqSocket4);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (gSsdpReqSocket6 != INVALID_SOCKET) {\n\t\tsetsockopt(gSsdpReqSocket6, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n\t\t\t   (char *)&gIF_INDEX, sizeof(gIF_INDEX));\n\t\tFD_SET(gSsdpReqSocket6, &wrSet);\n\t\tmax_fd = max(max_fd, gSsdpReqSocket6);\n\t}\n#endif\n\tret = select(max_fd + 1, NULL, &wrSet, NULL, NULL);\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"SSDP_LIB: Error in select(): %s\\n\", errorBuffer);\n\t\tUpnpCloseSocket(gSsdpReqSocket4);\n#ifdef UPNP_ENABLE_IPV6\n\t\tUpnpCloseSocket(gSsdpReqSocket6);\n#endif\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (gSsdpReqSocket6 != INVALID_SOCKET &&\n\t    FD_ISSET(gSsdpReqSocket6, &wrSet)) {\n\t\tint NumCopy = 0;\n\n\t\twhile (NumCopy < NUM_SSDP_COPY) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \">>> SSDP SEND M-SEARCH >>>\\n%s\\n\",\n\t\t\t\t   ReqBufv6UlaGua);\n\t\t\tsendto(gSsdpReqSocket6,\n\t\t\t       ReqBufv6UlaGua, strlen(ReqBufv6UlaGua), 0,\n\t\t\t       (struct sockaddr *)&__ss_v6,\n\t\t\t       sizeof(struct sockaddr_in6));\n\t\t\tNumCopy++;\n\t\t\timillisleep(SSDP_PAUSE);\n\t\t}\n\t\tNumCopy = 0;\n\t\tinet_pton(AF_INET6, SSDP_IPV6_LINKLOCAL, &destAddr6->sin6_addr);\n\t\twhile (NumCopy < NUM_SSDP_COPY) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \">>> SSDP SEND M-SEARCH >>>\\n%s\\n\",\n\t\t\t\t   ReqBufv6);\n\t\t\tsendto(gSsdpReqSocket6,\n\t\t\t       ReqBufv6, strlen(ReqBufv6), 0,\n\t\t\t       (struct sockaddr *)&__ss_v6,\n\t\t\t       sizeof(struct sockaddr_in6));\n\t\t\tNumCopy++;\n\t\t\timillisleep(SSDP_PAUSE);\n\t\t}\n\t}\n#endif /* IPv6 */\n\tif (gSsdpReqSocket4 != INVALID_SOCKET &&\n\t    FD_ISSET(gSsdpReqSocket4, &wrSet)) {\n\t\tint NumCopy = 0;\n\t\twhile (NumCopy < NUM_SSDP_COPY) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \">>> SSDP SEND M-SEARCH >>>\\n%s\\n\",\n\t\t\t\t   ReqBufv4);\n\t\t\tsendto(gSsdpReqSocket4,\n\t\t\t       ReqBufv4, strlen(ReqBufv4), 0,\n\t\t\t       (struct sockaddr *)&__ss_v4,\n\t\t\t       sizeof(struct sockaddr_in));\n\t\t\tNumCopy++;\n\t\t\timillisleep(SSDP_PAUSE);\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"ThreadPool.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ssdp_ResultData.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"upnputil.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "imillisleep",
          "args": [
            "SSDP_PAUSE"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendto",
          "args": [
            "gSsdpReqSocket4",
            "ReqBufv4",
            "strlen(ReqBufv4)",
            "0",
            "(struct sockaddr *)&__ss_v4",
            "sizeof(struct sockaddr_in)"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ReqBufv4"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "SSDP",
            "__FILE__",
            "__LINE__",
            "\">>> SSDP SEND M-SEARCH >>>\\n%s\\n\"",
            "ReqBufv4"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "gSsdpReqSocket4",
            "&wrSet"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imillisleep",
          "args": [
            "SSDP_PAUSE"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendto",
          "args": [
            "gSsdpReqSocket6",
            "ReqBufv6",
            "strlen(ReqBufv6)",
            "0",
            "(struct sockaddr *)&__ss_v6",
            "sizeof(struct sockaddr_in6)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ReqBufv6"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "AF_INET6",
            "SSDP_IPV6_LINKLOCAL",
            "&destAddr6->sin6_addr"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "inet_pton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "307-321",
          "snippet": "int inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nint inet_pton(int af, const char *src, void *dst)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_pton4(src, dst);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_pton6(src, dst);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn -1;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "imillisleep",
          "args": [
            "SSDP_PAUSE"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendto",
          "args": [
            "gSsdpReqSocket6",
            "ReqBufv6UlaGua",
            "strlen(ReqBufv6UlaGua)",
            "0",
            "(struct sockaddr *)&__ss_v6",
            "sizeof(struct sockaddr_in6)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ReqBufv6UlaGua"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "gSsdpReqSocket6",
            "&wrSet"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "gSsdpReqSocket6"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "gSsdpReqSocket4"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "max_fd + 1",
            "NULL",
            "&wrSet",
            "NULL",
            "NULL"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "max_fd",
            "gSsdpReqSocket6"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "gSsdpReqSocket6",
            "&wrSet"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "gSsdpReqSocket6",
            "IPPROTO_IPV6",
            "IPV6_MULTICAST_IF",
            "(char *)&gIF_INDEX",
            "sizeof(gIF_INDEX)"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "max_fd",
            "gSsdpReqSocket4"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "gSsdpReqSocket4",
            "&wrSet"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "gSsdpReqSocket4",
            "IPPROTO_IP",
            "IP_MULTICAST_IF",
            "(char *)&addrv4",
            "sizeof(addrv4)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&wrSet"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListAddTail",
          "args": [
            "&ctrlpt_info->SsdpSearchList",
            "newArg"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimerThreadSchedule",
          "args": [
            "&gTimerThread",
            "timeTillRead",
            "REL_SEC",
            "&job",
            "SHORT_TERM",
            "id"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "(free_routine) free"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "(start_routine) searchExpired",
            "id"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(int)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "St"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(SsdpSearchArg)"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetClientHandleInfo",
          "args": [
            "&handle",
            "&ctrlpt_info"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "GetClientHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3822-3846",
          "snippet": "Upnp_Handle_Type GetClientHandleInfo(\n\tUpnpClient_Handle *client_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_CLIENT;\n\tUpnpClient_Handle client;\n\n\tswitch (GetHandleInfo(1, HndInfo)) {\n\tcase HND_CLIENT:\n\t\tclient = 1;\n\t\tbreak;\n\tdefault:\n\t\tswitch (GetHandleInfo(2, HndInfo)) {\n\t\tcase HND_CLIENT:\n\t\t\tclient = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclient = -1;\n\t\t\tret = HND_INVALID;\n\t\t}\n\t}\n\n\t*client_handle_out = client;\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nUpnp_Handle_Type GetClientHandleInfo(\n\tUpnpClient_Handle *client_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_CLIENT;\n\tUpnpClient_Handle client;\n\n\tswitch (GetHandleInfo(1, HndInfo)) {\n\tcase HND_CLIENT:\n\t\tclient = 1;\n\t\tbreak;\n\tdefault:\n\t\tswitch (GetHandleInfo(2, HndInfo)) {\n\t\tcase HND_CLIENT:\n\t\t\tclient = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclient = -1;\n\t\t\tret = HND_INVALID;\n\t\t}\n\t}\n\n\t*client_handle_out = client;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "SSDP_PORT"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&__ss_v6",
            "0",
            "sizeof(__ss_v6)"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "SSDP_PORT"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateClientRequestPacketUlaGua",
          "args": [
            "ReqBufv6UlaGua",
            "sizeof(ReqBufv6UlaGua)",
            "timeTillRead",
            "St",
            "AF_INET6"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "CreateClientRequestPacketUlaGua",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_ctrlpt.c",
          "lines": "392-457",
          "snippet": "static int CreateClientRequestPacketUlaGua(\n\t/*! [in,out] . */\n\tchar *RqstBuf,\n\t/*! [in] . */\n\tsize_t RqstBufSize,\n\t/*! [in] . */\n\tint Mx,\n\t/*! [in] . */\n\tchar *SearchTarget,\n\t/*! [in] . */\n\tint AddressFamily)\n{\n\tint rc;\n\tchar TempBuf[COMMAND_LEN];\n\tconst char *command = \"M-SEARCH * HTTP/1.1\\r\\n\";\n\tconst char *man = \"MAN: \\\"ssdp:discover\\\"\\r\\n\";\n\n\tmemset(TempBuf, 0, sizeof(TempBuf));\n\tif (RqstBufSize <= strlen(command))\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\tstrcpy(RqstBuf, command);\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"HOST: %s:%d\\r\\n\", SSDP_IP,\n\t\t\tSSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"HOST: [%s]:%d\\r\\n\",\n\t\t\tSSDP_IPV6_SITELOCAL, SSDP_PORT);\n\t\tbreak;\n\tdefault:\n\t\treturn UPNP_E_INVALID_ARGUMENT;\n\t}\n\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, TempBuf);\n\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(man))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, man);\n\n\tif (Mx > 0) {\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"MX: %d\\r\\n\", Mx);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\t\tstrcat(RqstBuf, TempBuf);\n\t}\n\tif (SearchTarget) {\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"ST: %s\\r\\n\", SearchTarget);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\t\tstrcat(RqstBuf, TempBuf);\n\t}\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(\"\\r\\n\"))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, \"\\r\\n\");\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"ThreadPool.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ssdp_ResultData.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"upnputil.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include \"ThreadPool.h\"\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ssdp_ResultData.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"upnputil.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic int CreateClientRequestPacketUlaGua(\n\t/*! [in,out] . */\n\tchar *RqstBuf,\n\t/*! [in] . */\n\tsize_t RqstBufSize,\n\t/*! [in] . */\n\tint Mx,\n\t/*! [in] . */\n\tchar *SearchTarget,\n\t/*! [in] . */\n\tint AddressFamily)\n{\n\tint rc;\n\tchar TempBuf[COMMAND_LEN];\n\tconst char *command = \"M-SEARCH * HTTP/1.1\\r\\n\";\n\tconst char *man = \"MAN: \\\"ssdp:discover\\\"\\r\\n\";\n\n\tmemset(TempBuf, 0, sizeof(TempBuf));\n\tif (RqstBufSize <= strlen(command))\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\tstrcpy(RqstBuf, command);\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"HOST: %s:%d\\r\\n\", SSDP_IP,\n\t\t\tSSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"HOST: [%s]:%d\\r\\n\",\n\t\t\tSSDP_IPV6_SITELOCAL, SSDP_PORT);\n\t\tbreak;\n\tdefault:\n\t\treturn UPNP_E_INVALID_ARGUMENT;\n\t}\n\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, TempBuf);\n\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(man))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, man);\n\n\tif (Mx > 0) {\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"MX: %d\\r\\n\", Mx);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\t\tstrcat(RqstBuf, TempBuf);\n\t}\n\tif (SearchTarget) {\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"ST: %s\\r\\n\", SearchTarget);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\t\tstrcat(RqstBuf, TempBuf);\n\t}\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(\"\\r\\n\"))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, \"\\r\\n\");\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssdp_request_type1",
          "args": [
            "St"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ssdp_request_type1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "534-547",
          "snippet": "enum SsdpSearchType ssdp_request_type1(char *cmd)\n{\n\tif (strstr(cmd, \":all\"))\n\t\treturn SSDP_ALL;\n\tif (strstr(cmd, \":rootdevice\"))\n\t\treturn SSDP_ROOTDEVICE;\n\tif (strstr(cmd, \"uuid:\"))\n\t\treturn SSDP_DEVICEUDN;\n\tif (strstr(cmd, \"urn:\") && strstr(cmd, \":device:\"))\n\t\treturn SSDP_DEVICETYPE;\n\tif (strstr(cmd, \"urn:\") && strstr(cmd, \":service:\"))\n\t\treturn SSDP_SERVICE;\n\treturn SSDP_SERROR;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nenum SsdpSearchType ssdp_request_type1(char *cmd)\n{\n\tif (strstr(cmd, \":all\"))\n\t\treturn SSDP_ALL;\n\tif (strstr(cmd, \":rootdevice\"))\n\t\treturn SSDP_ROOTDEVICE;\n\tif (strstr(cmd, \"uuid:\"))\n\t\treturn SSDP_DEVICEUDN;\n\tif (strstr(cmd, \"urn:\") && strstr(cmd, \":device:\"))\n\t\treturn SSDP_DEVICETYPE;\n\tif (strstr(cmd, \"urn:\") && strstr(cmd, \":service:\"))\n\t\treturn SSDP_SERVICE;\n\treturn SSDP_SERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_addr",
          "args": [
            "gIF_IPV4"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include \"ThreadPool.h\"\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ssdp_ResultData.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"upnputil.h\"\n#include \"config.h\"\n\nint SearchByTarget(int Mx, char *St, void *Cookie)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tint *id = NULL;\n\tint ret = 0;\n\tchar ReqBufv4[BUFSIZE];\n#ifdef UPNP_ENABLE_IPV6\n\tchar ReqBufv6[BUFSIZE];\n\tchar ReqBufv6UlaGua[BUFSIZE];\n#endif\n\tstruct sockaddr_storage __ss_v4;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n#endif\n\tstruct sockaddr_in *destAddr4 = (struct sockaddr_in *)&__ss_v4;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_in6 *destAddr6 = (struct sockaddr_in6 *)&__ss_v6;\n#endif\n\tfd_set wrSet;\n\tSsdpSearchArg *newArg = NULL;\n\tint timeTillRead = 0;\n\tint handle;\n\tstruct Handle_Info *ctrlpt_info = NULL;\n\tenum SsdpSearchType requestType;\n\tunsigned long addrv4 = inet_addr(gIF_IPV4);\n\tSOCKET max_fd = 0;\n\tint retVal;\n\n\t/*ThreadData *ThData; */\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\trequestType = ssdp_request_type1(St);\n\tif (requestType == SSDP_SERROR)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t   \"Inside SearchByTarget\\n\");\n\ttimeTillRead = Mx;\n\tif (timeTillRead < MIN_SEARCH_TIME)\n\t\ttimeTillRead = MIN_SEARCH_TIME;\n\telse if (timeTillRead > MAX_SEARCH_TIME)\n\t\ttimeTillRead = MAX_SEARCH_TIME;\n\tretVal = CreateClientRequestPacket(ReqBufv4, sizeof(ReqBufv4), timeTillRead, St, AF_INET);\n\tif (retVal != UPNP_E_SUCCESS)\n\t\treturn retVal;\n#ifdef UPNP_ENABLE_IPV6\n\tretVal = CreateClientRequestPacket(ReqBufv6, sizeof(ReqBufv6), timeTillRead, St, AF_INET6);\n\tif (retVal != UPNP_E_SUCCESS)\n\t\treturn retVal;\n\tretVal = CreateClientRequestPacketUlaGua(ReqBufv6UlaGua, sizeof(ReqBufv6UlaGua), timeTillRead, St, AF_INET6);\n\tif (retVal != UPNP_E_SUCCESS)\n\t\treturn retVal;\n#endif\n\n\tmemset(&__ss_v4, 0, sizeof(__ss_v4));\n\tdestAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, SSDP_IP, &destAddr4->sin_addr);\n\tdestAddr4->sin_port = htons(SSDP_PORT);\n\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof(__ss_v6));\n\tdestAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, SSDP_IPV6_SITELOCAL, &destAddr6->sin6_addr);\n\tdestAddr6->sin6_port = htons(SSDP_PORT);\n\tdestAddr6->sin6_scope_id = gIF_INDEX;\n#endif\n\n\t/* add search criteria to list */\n\tHandleLock();\n\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n\tnewArg = (SsdpSearchArg *) malloc(sizeof(SsdpSearchArg));\n\tnewArg->searchTarget = strdup(St);\n\tnewArg->cookie = Cookie;\n\tnewArg->requestType = requestType;\n\tid = (int *)malloc(sizeof(int));\n\tTPJobInit(&job, (start_routine) searchExpired, id);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\tTPJobSetFreeFunction(&job, (free_routine) free);\n\t/* Schedule a timeout event to remove search Arg */\n\tTimerThreadSchedule(&gTimerThread, timeTillRead,\n\t\t\t    REL_SEC, &job, SHORT_TERM, id);\n\tnewArg->timeoutEventId = *id;\n\tListAddTail(&ctrlpt_info->SsdpSearchList, newArg);\n\tHandleUnlock();\n\t/* End of lock */\n\n\tFD_ZERO(&wrSet);\n\tif (gSsdpReqSocket4 != INVALID_SOCKET) {\n\t\tsetsockopt(gSsdpReqSocket4, IPPROTO_IP, IP_MULTICAST_IF,\n\t\t\t   (char *)&addrv4, sizeof(addrv4));\n\t\tFD_SET(gSsdpReqSocket4, &wrSet);\n\t\tmax_fd = max(max_fd, gSsdpReqSocket4);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (gSsdpReqSocket6 != INVALID_SOCKET) {\n\t\tsetsockopt(gSsdpReqSocket6, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n\t\t\t   (char *)&gIF_INDEX, sizeof(gIF_INDEX));\n\t\tFD_SET(gSsdpReqSocket6, &wrSet);\n\t\tmax_fd = max(max_fd, gSsdpReqSocket6);\n\t}\n#endif\n\tret = select(max_fd + 1, NULL, &wrSet, NULL, NULL);\n\tif (ret == -1) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t   \"SSDP_LIB: Error in select(): %s\\n\", errorBuffer);\n\t\tUpnpCloseSocket(gSsdpReqSocket4);\n#ifdef UPNP_ENABLE_IPV6\n\t\tUpnpCloseSocket(gSsdpReqSocket6);\n#endif\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (gSsdpReqSocket6 != INVALID_SOCKET &&\n\t    FD_ISSET(gSsdpReqSocket6, &wrSet)) {\n\t\tint NumCopy = 0;\n\n\t\twhile (NumCopy < NUM_SSDP_COPY) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \">>> SSDP SEND M-SEARCH >>>\\n%s\\n\",\n\t\t\t\t   ReqBufv6UlaGua);\n\t\t\tsendto(gSsdpReqSocket6,\n\t\t\t       ReqBufv6UlaGua, strlen(ReqBufv6UlaGua), 0,\n\t\t\t       (struct sockaddr *)&__ss_v6,\n\t\t\t       sizeof(struct sockaddr_in6));\n\t\t\tNumCopy++;\n\t\t\timillisleep(SSDP_PAUSE);\n\t\t}\n\t\tNumCopy = 0;\n\t\tinet_pton(AF_INET6, SSDP_IPV6_LINKLOCAL, &destAddr6->sin6_addr);\n\t\twhile (NumCopy < NUM_SSDP_COPY) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \">>> SSDP SEND M-SEARCH >>>\\n%s\\n\",\n\t\t\t\t   ReqBufv6);\n\t\t\tsendto(gSsdpReqSocket6,\n\t\t\t       ReqBufv6, strlen(ReqBufv6), 0,\n\t\t\t       (struct sockaddr *)&__ss_v6,\n\t\t\t       sizeof(struct sockaddr_in6));\n\t\t\tNumCopy++;\n\t\t\timillisleep(SSDP_PAUSE);\n\t\t}\n\t}\n#endif /* IPv6 */\n\tif (gSsdpReqSocket4 != INVALID_SOCKET &&\n\t    FD_ISSET(gSsdpReqSocket4, &wrSet)) {\n\t\tint NumCopy = 0;\n\t\twhile (NumCopy < NUM_SSDP_COPY) {\n\t\t\tUpnpPrintf(UPNP_INFO, SSDP, __FILE__, __LINE__,\n\t\t\t\t   \">>> SSDP SEND M-SEARCH >>>\\n%s\\n\",\n\t\t\t\t   ReqBufv4);\n\t\t\tsendto(gSsdpReqSocket4,\n\t\t\t       ReqBufv4, strlen(ReqBufv4), 0,\n\t\t\t       (struct sockaddr *)&__ss_v4,\n\t\t\t       sizeof(struct sockaddr_in));\n\t\t\tNumCopy++;\n\t\t\timillisleep(SSDP_PAUSE);\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "searchExpired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_ctrlpt.c",
    "lines": "463-508",
    "snippet": "static void searchExpired(\n\t/* [in] . */\n\tvoid *arg)\n{\n\n\tint *id = (int *)arg;\n\tint handle = -1;\n\tstruct Handle_Info *ctrlpt_info = NULL;\n\n\t/* remove search Target from list and call client back */\n\tListNode *node = NULL;\n\tSsdpSearchArg *item;\n\tUpnp_FunPtr ctrlpt_callback;\n\tvoid *cookie = NULL;\n\tint found = 0;\n\n\tHandleLock();\n\n\t/* remove search target from search list */\n\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\tfree(id);\n\t\tHandleUnlock();\n\t\treturn;\n\t}\n\tctrlpt_callback = ctrlpt_info->Callback;\n\tnode = ListHead(&ctrlpt_info->SsdpSearchList);\n\twhile (node != NULL) {\n\t\titem = (SsdpSearchArg *) node->item;\n\t\tif (item->timeoutEventId == (*id)) {\n\t\t\tfree(item->searchTarget);\n\t\t\tcookie = item->cookie;\n\t\t\tfound = 1;\n\t\t\titem->searchTarget = NULL;\n\t\t\tfree(item);\n\t\t\tListDelNode(&ctrlpt_info->SsdpSearchList, node, 0);\n\t\t\tbreak;\n\t\t}\n\t\tnode = ListNext(&ctrlpt_info->SsdpSearchList, node);\n\t}\n\tHandleUnlock();\n\n\tif (found)\n\t\tctrlpt_callback(UPNP_DISCOVERY_SEARCH_TIMEOUT, NULL, cookie);\n\n\tfree(id);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"ThreadPool.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ssdp_ResultData.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"upnputil.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "id"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "free_ssdp_event_handler_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "565-578",
          "snippet": "static void free_ssdp_event_handler_data(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\n\tif (data != NULL) {\n\t\thttp_message_t *hmsg = &data->parser.msg;\n\t\t/* free data */\n\t\thttpmsg_destroy(hmsg);\n\t\tfree(data);\n\t}\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nstatic void free_ssdp_event_handler_data(\n\t/*! [in] ssdp_thread_data structure. This structure contains SSDP\n\t * request message. */\n\tvoid *the_data)\n{\n\tssdp_thread_data *data = (ssdp_thread_data *) the_data;\n\n\tif (data != NULL) {\n\t\thttp_message_t *hmsg = &data->parser.msg;\n\t\t/* free data */\n\t\thttpmsg_destroy(hmsg);\n\t\tfree(data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctrlpt_callback",
          "args": [
            "UPNP_DISCOVERY_SEARCH_TIMEOUT",
            "NULL",
            "cookie"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListNext",
          "args": [
            "&ctrlpt_info->SsdpSearchList",
            "node"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListDelNode",
          "args": [
            "&ctrlpt_info->SsdpSearchList",
            "node",
            "0"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListHead",
          "args": [
            "&ctrlpt_info->SsdpSearchList"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetClientHandleInfo",
          "args": [
            "&handle",
            "&ctrlpt_info"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "GetClientHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3822-3846",
          "snippet": "Upnp_Handle_Type GetClientHandleInfo(\n\tUpnpClient_Handle *client_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_CLIENT;\n\tUpnpClient_Handle client;\n\n\tswitch (GetHandleInfo(1, HndInfo)) {\n\tcase HND_CLIENT:\n\t\tclient = 1;\n\t\tbreak;\n\tdefault:\n\t\tswitch (GetHandleInfo(2, HndInfo)) {\n\t\tcase HND_CLIENT:\n\t\t\tclient = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclient = -1;\n\t\t\tret = HND_INVALID;\n\t\t}\n\t}\n\n\t*client_handle_out = client;\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nUpnp_Handle_Type GetClientHandleInfo(\n\tUpnpClient_Handle *client_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_CLIENT;\n\tUpnpClient_Handle client;\n\n\tswitch (GetHandleInfo(1, HndInfo)) {\n\tcase HND_CLIENT:\n\t\tclient = 1;\n\t\tbreak;\n\tdefault:\n\t\tswitch (GetHandleInfo(2, HndInfo)) {\n\t\tcase HND_CLIENT:\n\t\t\tclient = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclient = -1;\n\t\t\tret = HND_INVALID;\n\t\t}\n\t}\n\n\t*client_handle_out = client;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include \"ThreadPool.h\"\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ssdp_ResultData.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"upnputil.h\"\n#include \"config.h\"\n\nstatic void searchExpired(\n\t/* [in] . */\n\tvoid *arg)\n{\n\n\tint *id = (int *)arg;\n\tint handle = -1;\n\tstruct Handle_Info *ctrlpt_info = NULL;\n\n\t/* remove search Target from list and call client back */\n\tListNode *node = NULL;\n\tSsdpSearchArg *item;\n\tUpnp_FunPtr ctrlpt_callback;\n\tvoid *cookie = NULL;\n\tint found = 0;\n\n\tHandleLock();\n\n\t/* remove search target from search list */\n\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\tfree(id);\n\t\tHandleUnlock();\n\t\treturn;\n\t}\n\tctrlpt_callback = ctrlpt_info->Callback;\n\tnode = ListHead(&ctrlpt_info->SsdpSearchList);\n\twhile (node != NULL) {\n\t\titem = (SsdpSearchArg *) node->item;\n\t\tif (item->timeoutEventId == (*id)) {\n\t\t\tfree(item->searchTarget);\n\t\t\tcookie = item->cookie;\n\t\t\tfound = 1;\n\t\t\titem->searchTarget = NULL;\n\t\t\tfree(item);\n\t\t\tListDelNode(&ctrlpt_info->SsdpSearchList, node, 0);\n\t\t\tbreak;\n\t\t}\n\t\tnode = ListNext(&ctrlpt_info->SsdpSearchList, node);\n\t}\n\tHandleUnlock();\n\n\tif (found)\n\t\tctrlpt_callback(UPNP_DISCOVERY_SEARCH_TIMEOUT, NULL, cookie);\n\n\tfree(id);\n}"
  },
  {
    "function_name": "CreateClientRequestPacketUlaGua",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_ctrlpt.c",
    "lines": "392-457",
    "snippet": "static int CreateClientRequestPacketUlaGua(\n\t/*! [in,out] . */\n\tchar *RqstBuf,\n\t/*! [in] . */\n\tsize_t RqstBufSize,\n\t/*! [in] . */\n\tint Mx,\n\t/*! [in] . */\n\tchar *SearchTarget,\n\t/*! [in] . */\n\tint AddressFamily)\n{\n\tint rc;\n\tchar TempBuf[COMMAND_LEN];\n\tconst char *command = \"M-SEARCH * HTTP/1.1\\r\\n\";\n\tconst char *man = \"MAN: \\\"ssdp:discover\\\"\\r\\n\";\n\n\tmemset(TempBuf, 0, sizeof(TempBuf));\n\tif (RqstBufSize <= strlen(command))\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\tstrcpy(RqstBuf, command);\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"HOST: %s:%d\\r\\n\", SSDP_IP,\n\t\t\tSSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"HOST: [%s]:%d\\r\\n\",\n\t\t\tSSDP_IPV6_SITELOCAL, SSDP_PORT);\n\t\tbreak;\n\tdefault:\n\t\treturn UPNP_E_INVALID_ARGUMENT;\n\t}\n\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, TempBuf);\n\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(man))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, man);\n\n\tif (Mx > 0) {\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"MX: %d\\r\\n\", Mx);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\t\tstrcat(RqstBuf, TempBuf);\n\t}\n\tif (SearchTarget) {\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"ST: %s\\r\\n\", SearchTarget);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\t\tstrcat(RqstBuf, TempBuf);\n\t}\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(\"\\r\\n\"))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, \"\\r\\n\");\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"ThreadPool.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ssdp_ResultData.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"upnputil.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "RqstBuf",
            "\"\\r\\n\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "RqstBuf"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "RqstBuf",
            "TempBuf"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TempBuf"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "RqstBuf"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "TempBuf",
            "sizeof(TempBuf)",
            "\"ST: %s\\r\\n\"",
            "SearchTarget"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "RqstBuf",
            "TempBuf"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TempBuf"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "RqstBuf"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "TempBuf",
            "sizeof(TempBuf)",
            "\"MX: %d\\r\\n\"",
            "Mx"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "RqstBuf",
            "man"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "man"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "RqstBuf"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "RqstBuf",
            "TempBuf"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TempBuf"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "RqstBuf"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "TempBuf",
            "sizeof(TempBuf)",
            "\"HOST: [%s]:%d\\r\\n\"",
            "SSDP_IPV6_SITELOCAL",
            "SSDP_PORT"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "TempBuf",
            "sizeof(TempBuf)",
            "\"HOST: %s:%d\\r\\n\"",
            "SSDP_IP",
            "SSDP_PORT"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "RqstBuf",
            "command"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "command"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "TempBuf",
            "0",
            "sizeof(TempBuf)"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include \"ThreadPool.h\"\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ssdp_ResultData.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"upnputil.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic int CreateClientRequestPacketUlaGua(\n\t/*! [in,out] . */\n\tchar *RqstBuf,\n\t/*! [in] . */\n\tsize_t RqstBufSize,\n\t/*! [in] . */\n\tint Mx,\n\t/*! [in] . */\n\tchar *SearchTarget,\n\t/*! [in] . */\n\tint AddressFamily)\n{\n\tint rc;\n\tchar TempBuf[COMMAND_LEN];\n\tconst char *command = \"M-SEARCH * HTTP/1.1\\r\\n\";\n\tconst char *man = \"MAN: \\\"ssdp:discover\\\"\\r\\n\";\n\n\tmemset(TempBuf, 0, sizeof(TempBuf));\n\tif (RqstBufSize <= strlen(command))\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\tstrcpy(RqstBuf, command);\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"HOST: %s:%d\\r\\n\", SSDP_IP,\n\t\t\tSSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"HOST: [%s]:%d\\r\\n\",\n\t\t\tSSDP_IPV6_SITELOCAL, SSDP_PORT);\n\t\tbreak;\n\tdefault:\n\t\treturn UPNP_E_INVALID_ARGUMENT;\n\t}\n\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, TempBuf);\n\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(man))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, man);\n\n\tif (Mx > 0) {\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"MX: %d\\r\\n\", Mx);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\t\tstrcat(RqstBuf, TempBuf);\n\t}\n\tif (SearchTarget) {\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"ST: %s\\r\\n\", SearchTarget);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\t\tstrcat(RqstBuf, TempBuf);\n\t}\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(\"\\r\\n\"))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, \"\\r\\n\");\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "CreateClientRequestPacket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_ctrlpt.c",
    "lines": "319-386",
    "snippet": "static int CreateClientRequestPacket(\n\t/*! [in,out] Output string in HTTP format. */\n\tINOUT char *RqstBuf,\n\t/*! [in] RqstBuf size. */\n\tIN size_t RqstBufSize,\n\t/*! [in] Search Target. */\n\tIN int Mx,\n\t/*! [in] Number of seconds to wait to collect all the responses. */\n\tIN char *SearchTarget,\n\t/*! [in] search address family. */\n\tIN int AddressFamily)\n{\n\tint rc;\n\tchar TempBuf[COMMAND_LEN];\n\tconst char *command = \"M-SEARCH * HTTP/1.1\\r\\n\";\n\tconst char *man = \"MAN: \\\"ssdp:discover\\\"\\r\\n\";\n\n\tmemset(TempBuf, 0, sizeof(TempBuf));\n\tif (RqstBufSize <= strlen(command))\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\tstrcpy(RqstBuf, command);\n\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"HOST: %s:%d\\r\\n\", SSDP_IP,\n\t\t\tSSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"HOST: [%s]:%d\\r\\n\",\n\t\t\tSSDP_IPV6_LINKLOCAL, SSDP_PORT);\n\t\tbreak;\n\tdefault:\n\t\treturn UPNP_E_INVALID_ARGUMENT;\n\t}\n\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, TempBuf);\n\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(man))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, man);\n\n\tif (Mx > 0) {\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"MX: %d\\r\\n\", Mx);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\t\tstrcat(RqstBuf, TempBuf);\n\t}\n\n\tif (SearchTarget != NULL) {\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"ST: %s\\r\\n\", SearchTarget);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\t\tstrcat(RqstBuf, TempBuf);\n\t}\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(\"\\r\\n\"))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, \"\\r\\n\");\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"ThreadPool.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ssdp_ResultData.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"upnputil.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "RqstBuf",
            "\"\\r\\n\""
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "RqstBuf"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "RqstBuf",
            "TempBuf"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TempBuf"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "RqstBuf"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "TempBuf",
            "sizeof(TempBuf)",
            "\"ST: %s\\r\\n\"",
            "SearchTarget"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "RqstBuf",
            "TempBuf"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TempBuf"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "RqstBuf"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "TempBuf",
            "sizeof(TempBuf)",
            "\"MX: %d\\r\\n\"",
            "Mx"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "RqstBuf",
            "man"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "man"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "RqstBuf"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "RqstBuf",
            "TempBuf"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TempBuf"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "RqstBuf"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "TempBuf",
            "sizeof(TempBuf)",
            "\"HOST: [%s]:%d\\r\\n\"",
            "SSDP_IPV6_LINKLOCAL",
            "SSDP_PORT"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "TempBuf",
            "sizeof(TempBuf)",
            "\"HOST: %s:%d\\r\\n\"",
            "SSDP_IP",
            "SSDP_PORT"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "RqstBuf",
            "command"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "command"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "TempBuf",
            "0",
            "sizeof(TempBuf)"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include \"ThreadPool.h\"\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ssdp_ResultData.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"upnputil.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic int CreateClientRequestPacket(\n\t/*! [in,out] Output string in HTTP format. */\n\tINOUT char *RqstBuf,\n\t/*! [in] RqstBuf size. */\n\tIN size_t RqstBufSize,\n\t/*! [in] Search Target. */\n\tIN int Mx,\n\t/*! [in] Number of seconds to wait to collect all the responses. */\n\tIN char *SearchTarget,\n\t/*! [in] search address family. */\n\tIN int AddressFamily)\n{\n\tint rc;\n\tchar TempBuf[COMMAND_LEN];\n\tconst char *command = \"M-SEARCH * HTTP/1.1\\r\\n\";\n\tconst char *man = \"MAN: \\\"ssdp:discover\\\"\\r\\n\";\n\n\tmemset(TempBuf, 0, sizeof(TempBuf));\n\tif (RqstBufSize <= strlen(command))\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\tstrcpy(RqstBuf, command);\n\n\tswitch (AddressFamily) {\n\tcase AF_INET:\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"HOST: %s:%d\\r\\n\", SSDP_IP,\n\t\t\tSSDP_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"HOST: [%s]:%d\\r\\n\",\n\t\t\tSSDP_IPV6_LINKLOCAL, SSDP_PORT);\n\t\tbreak;\n\tdefault:\n\t\treturn UPNP_E_INVALID_ARGUMENT;\n\t}\n\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\treturn UPNP_E_INTERNAL_ERROR;\n\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, TempBuf);\n\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(man))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, man);\n\n\tif (Mx > 0) {\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"MX: %d\\r\\n\", Mx);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\t\tstrcat(RqstBuf, TempBuf);\n\t}\n\n\tif (SearchTarget != NULL) {\n\t\trc = snprintf(TempBuf, sizeof(TempBuf), \"ST: %s\\r\\n\", SearchTarget);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(TempBuf))\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\tif (RqstBufSize <= strlen(RqstBuf) + strlen(TempBuf))\n\t\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\t\tstrcat(RqstBuf, TempBuf);\n\t}\n\tif (RqstBufSize <= strlen(RqstBuf) + strlen(\"\\r\\n\"))\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\tstrcat(RqstBuf, \"\\r\\n\");\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "ssdp_handle_ctrlpt_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_ctrlpt.c",
    "lines": "78-313",
    "snippet": "void ssdp_handle_ctrlpt_msg(http_message_t *hmsg, struct sockaddr_storage *dest_addr,\n\t\t\t    int timeout, void *cookie)\n{\n\tint handle;\n\tstruct Handle_Info *ctrlpt_info = NULL;\n\tmemptr hdr_value;\n\t/* byebye or alive */\n\tint is_byebye;\n\tUpnpDiscovery *param = UpnpDiscovery_new();\n\tint expires;\n\tint ret;\n\tSsdpEvent event;\n\tint nt_found;\n\tint usn_found;\n\tint st_found;\n\tchar save_char;\n\tUpnp_EventType event_type;\n\tUpnp_FunPtr ctrlpt_callback;\n\tvoid *ctrlpt_cookie;\n\tListNode *node = NULL;\n\tSsdpSearchArg *searchArg = NULL;\n\tint matched = 0;\n\tSSDPResultData *threadData = NULL;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\t/* we are assuming that there can be only one client supported at a time */\n\tHandleReadLock();\n\n\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t}\n\t/* copy */\n\tctrlpt_callback = ctrlpt_info->Callback;\n\tctrlpt_cookie = ctrlpt_info->Cookie;\n\tHandleUnlock();\n\t/* search timeout */\n\tif (timeout) {\n\t\tctrlpt_callback(UPNP_DISCOVERY_SEARCH_TIMEOUT, NULL, cookie);\n\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t}\n\n\tUpnpDiscovery_set_ErrCode(param, UPNP_E_SUCCESS);\n\t/* MAX-AGE, assume error */\n\texpires = -1;\n\tUpnpDiscovery_set_Expires(param, expires);\n\tif (httpmsg_find_hdr(hmsg, HDR_CACHE_CONTROL, &hdr_value) != NULL) {\n\t\tret = matchstr(hdr_value.buf, hdr_value.length,\n\t\t\t\"%imax-age = %d%0\", &expires);\n\t\tUpnpDiscovery_set_Expires(param, expires);\n\t\tif (ret != PARSE_OK)\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t}\n\t/* DATE */\n\tif (httpmsg_find_hdr(hmsg, HDR_DATE, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strcpy_Date(param, hdr_value.buf);\n\t}\n\t/* dest addr */\n\tUpnpDiscovery_set_DestAddr(param, dest_addr);\n\t/* EXT */\n\tif (httpmsg_find_hdr(hmsg, HDR_EXT, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strncpy_Ext(param, hdr_value.buf,\n\t\t\t\t\t  hdr_value.length);\n\t}\n\t/* LOCATION */\n\tif (httpmsg_find_hdr(hmsg, HDR_LOCATION, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strncpy_Location(param, hdr_value.buf,\n\t\t\t\t\t       hdr_value.length);\n\t}\n\t/* SERVER / USER-AGENT */\n\tif (httpmsg_find_hdr(hmsg, HDR_SERVER, &hdr_value) != NULL ||\n\t    httpmsg_find_hdr(hmsg, HDR_USER_AGENT, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strncpy_Os(param, hdr_value.buf,\n\t\t\t\t\t hdr_value.length);\n\t}\n\t/* clear everything */\n\tevent.UDN[0] = '\\0';\n\tevent.DeviceType[0] = '\\0';\n\tevent.ServiceType[0] = '\\0';\n\tnt_found = FALSE;\n\tif (httpmsg_find_hdr(hmsg, HDR_NT, &hdr_value) != NULL) {\n\t\tsave_char = hdr_value.buf[hdr_value.length];\n\t\thdr_value.buf[hdr_value.length] = '\\0';\n\t\tnt_found = (ssdp_request_type(hdr_value.buf, &event) == 0);\n\t\thdr_value.buf[hdr_value.length] = save_char;\n\t}\n\tusn_found = FALSE;\n\tif (httpmsg_find_hdr(hmsg, HDR_USN, &hdr_value) != NULL) {\n\t\tsave_char = hdr_value.buf[hdr_value.length];\n\t\thdr_value.buf[hdr_value.length] = '\\0';\n\t\tusn_found = (unique_service_name(hdr_value.buf, &event) == 0);\n\t\thdr_value.buf[hdr_value.length] = save_char;\n\t}\n\tif (nt_found || usn_found) {\n\t\tUpnpDiscovery_strcpy_DeviceID(param, event.UDN);\n\t\tUpnpDiscovery_strcpy_DeviceType(param, event.DeviceType);\n\t\tUpnpDiscovery_strcpy_ServiceType(param, event.ServiceType);\n\t}\n\t/* ADVERT. OR BYEBYE */\n\tif (hmsg->is_request) {\n\t\t/* use NTS hdr to determine advert., or byebye */\n\t\tif (httpmsg_find_hdr(hmsg, HDR_NTS, &hdr_value) == NULL) {\n\t\t\t/* error; NTS header not found */\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\tif (memptr_cmp(&hdr_value, \"ssdp:alive\") == 0) {\n\t\t\tis_byebye = FALSE;\n\t\t} else if (memptr_cmp(&hdr_value, \"ssdp:byebye\") == 0) {\n\t\t\tis_byebye = TRUE;\n\t\t} else {\n\t\t\t/* bad value */\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\tif (is_byebye) {\n\t\t\t/* check device byebye */\n\t\t\tif (!nt_found || !usn_found) {\n\t\t\t\t/* bad byebye */\n\t\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t\t}\n\t\t\tevent_type = UPNP_DISCOVERY_ADVERTISEMENT_BYEBYE;\n\t\t} else {\n\t\t\t/* check advertisement.\n\t\t\t * Expires is valid if positive. This is for testing\n\t\t\t * only. Expires should be greater than 1800 (30 mins) */\n\t\t\tif (!nt_found ||\n\t\t\t    !usn_found ||\n\t\t\t    UpnpString_get_Length(UpnpDiscovery_get_Location(param)) == 0 ||\n\t\t\t    UpnpDiscovery_get_Expires(param) <= 0) {\n\t\t\t\t/* bad advertisement */\n\t\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t\t}\n\t\t\tevent_type = UPNP_DISCOVERY_ADVERTISEMENT_ALIVE;\n\t\t}\n\t\t/* call callback */\n\t\tctrlpt_callback(event_type, param, ctrlpt_cookie);\n\t} else {\n\t\t/* reply (to a SEARCH) */\n\t\t/* only checking to see if there is a valid ST header */\n\t\tst_found = FALSE;\n\t\tif (httpmsg_find_hdr(hmsg, HDR_ST, &hdr_value) != NULL) {\n\t\t\tsave_char = hdr_value.buf[hdr_value.length];\n\t\t\thdr_value.buf[hdr_value.length] = '\\0';\n\t\t\tst_found =\n\t\t\t    ssdp_request_type(hdr_value.buf, &event) == 0;\n\t\t\thdr_value.buf[hdr_value.length] = save_char;\n\t\t}\n\t\tif (hmsg->status_code != HTTP_OK ||\n\t\t    UpnpDiscovery_get_Expires(param) <= 0 ||\n\t\t    UpnpString_get_Length(UpnpDiscovery_get_Location(param)) == 0 ||\n\t\t    !usn_found || !st_found) {\n\t\t\t/* bad reply */\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\t/* check each current search */\n\t\tHandleLock();\n\t\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\t\tHandleUnlock();\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\tnode = ListHead(&ctrlpt_info->SsdpSearchList);\n\t\t/* temporary add null termination */\n\t\t/*save_char = hdr_value.buf[ hdr_value.length ]; */\n\t\t/*hdr_value.buf[ hdr_value.length ] = '\\0'; */\n\t\twhile (node != NULL) {\n\t\t\tsearchArg = node->item;\n\t\t\t/* check for match of ST header and search target */\n\t\t\tswitch (searchArg->requestType) {\n\t\t\tcase SSDP_ALL:\n\t\t\t\tmatched = 1;\n\t\t\t\tbreak;\n\t\t\tcase SSDP_ROOTDEVICE:\n\t\t\t\tmatched =\n\t\t\t\t    (event.RequestType == SSDP_ROOTDEVICE);\n\t\t\t\tbreak;\n\t\t\tcase SSDP_DEVICEUDN:\n\t\t\t\tmatched = !strncmp(searchArg->searchTarget,\n\t\t\t\t\t\t   hdr_value.buf,\n\t\t\t\t\t\t   hdr_value.length);\n\t\t\t\tbreak;\n\t\t\tcase SSDP_DEVICETYPE:{\n\t\t\t\t\tsize_t m = min(hdr_value.length,\n\t\t\t\t\t\t       strlen\n\t\t\t\t\t\t       (searchArg->searchTarget));\n\t\t\t\t\tmatched =\n\t\t\t\t\t    !strncmp(searchArg->searchTarget,\n\t\t\t\t\t\t     hdr_value.buf, m);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase SSDP_SERVICE:{\n\t\t\t\t\tsize_t m = min(hdr_value.length,\n\t\t\t\t\t\t       strlen\n\t\t\t\t\t\t       (searchArg->searchTarget));\n\t\t\t\t\tmatched =\n\t\t\t\t\t    !strncmp(searchArg->searchTarget,\n\t\t\t\t\t\t     hdr_value.buf, m);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tmatched = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (matched) {\n\t\t\t\t/* schedule call back */\n\t\t\t\tthreadData = SSDPResultData_new();\n\t\t\t\tif (threadData != NULL) {\n\t\t\t\t\tSSDPResultData_set_Param(threadData,\n\t\t\t\t\t\t\t\t param);\n\t\t\t\t\tSSDPResultData_set_Cookie(threadData,\n\t\t\t\t\t\t\t\t  searchArg->\n\t\t\t\t\t\t\t\t  cookie);\n\t\t\t\t\tSSDPResultData_set_CtrlptCallback\n\t\t\t\t\t    (threadData, ctrlpt_callback);\n\t\t\t\t\tTPJobInit(&job, (start_routine)\n\t\t\t\t\t\t  send_search_result,\n\t\t\t\t\t\t  threadData);\n\t\t\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\t\t\tTPJobSetFreeFunction(&job,\n\t\t\t\t\t\t\t     (free_routine)\n\t\t\t\t\t\t\t     free);\n\t\t\t\t\tif (ThreadPoolAdd(&gRecvThreadPool, &job, NULL) != 0) {\n\t\t\t\t\t\tSSDPResultData_delete(threadData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = ListNext(&ctrlpt_info->SsdpSearchList, node);\n\t\t}\n\n\t\tHandleUnlock();\n\t\t/*ctrlpt_callback( UPNP_DISCOVERY_SEARCH_RESULT, param, cookie ); */\n\t}\n\nend_ssdp_handle_ctrlpt_msg:\n\tUpnpDiscovery_delete(param);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"ThreadPool.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ssdp_ResultData.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"upnputil.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpDiscovery_delete",
          "args": [
            "param"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListNext",
          "args": [
            "&ctrlpt_info->SsdpSearchList",
            "node"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSDPResultData_delete",
          "args": [
            "threadData"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gRecvThreadPool",
            "&job",
            "NULL"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "(free_routine)\n\t\t\t\t\t\t\t     free"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "(start_routine)\n\t\t\t\t\t\t  send_search_result",
            "threadData"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSDPResultData_set_CtrlptCallback",
          "args": [
            "threadData",
            "ctrlpt_callback"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSDPResultData_set_Cookie",
          "args": [
            "threadData",
            "searchArg->\n\t\t\t\t\t\t\t\t  cookie"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSDPResultData_set_Param",
          "args": [
            "threadData",
            "param"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSDPResultData_new",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "searchArg->searchTarget",
            "hdr_value.buf",
            "m"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "hdr_value.length",
            "strlen\n\t\t\t\t\t\t       (searchArg->searchTarget)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "searchArg->searchTarget"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "searchArg->searchTarget",
            "hdr_value.buf",
            "m"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "hdr_value.length",
            "strlen\n\t\t\t\t\t\t       (searchArg->searchTarget)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "searchArg->searchTarget"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "searchArg->searchTarget",
            "hdr_value.buf",
            "hdr_value.length"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListHead",
          "args": [
            "&ctrlpt_info->SsdpSearchList"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetClientHandleInfo",
          "args": [
            "&handle",
            "&ctrlpt_info"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "GetClientHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3822-3846",
          "snippet": "Upnp_Handle_Type GetClientHandleInfo(\n\tUpnpClient_Handle *client_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_CLIENT;\n\tUpnpClient_Handle client;\n\n\tswitch (GetHandleInfo(1, HndInfo)) {\n\tcase HND_CLIENT:\n\t\tclient = 1;\n\t\tbreak;\n\tdefault:\n\t\tswitch (GetHandleInfo(2, HndInfo)) {\n\t\tcase HND_CLIENT:\n\t\t\tclient = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclient = -1;\n\t\t\tret = HND_INVALID;\n\t\t}\n\t}\n\n\t*client_handle_out = client;\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nUpnp_Handle_Type GetClientHandleInfo(\n\tUpnpClient_Handle *client_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_CLIENT;\n\tUpnpClient_Handle client;\n\n\tswitch (GetHandleInfo(1, HndInfo)) {\n\tcase HND_CLIENT:\n\t\tclient = 1;\n\t\tbreak;\n\tdefault:\n\t\tswitch (GetHandleInfo(2, HndInfo)) {\n\t\tcase HND_CLIENT:\n\t\t\tclient = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclient = -1;\n\t\t\tret = HND_INVALID;\n\t\t}\n\t}\n\n\t*client_handle_out = client;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_get_Length",
          "args": [
            "UpnpDiscovery_get_Location(param)"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_get_Length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "141-144",
          "snippet": "size_t UpnpString_get_Length(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_length;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nsize_t UpnpString_get_Length(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_get_Location",
          "args": [
            "param"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_get_Expires",
          "args": [
            "param"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssdp_request_type",
          "args": [
            "hdr_value.buf",
            "&event"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "ssdp_request_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "549-560",
          "snippet": "int ssdp_request_type(char *cmd, SsdpEvent *Evt)\n{\n\t/* clear event */\n\tmemset(Evt, 0, sizeof(SsdpEvent));\n\tunique_service_name(cmd, Evt);\n\tEvt->ErrCode = NO_ERROR_FOUND;\n\tif ((Evt->RequestType = ssdp_request_type1(cmd)) == SSDP_SERROR) {\n\t\tEvt->ErrCode = E_HTTP_SYNTEX;\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\nint ssdp_request_type(char *cmd, SsdpEvent *Evt)\n{\n\t/* clear event */\n\tmemset(Evt, 0, sizeof(SsdpEvent));\n\tunique_service_name(cmd, Evt);\n\tEvt->ErrCode = NO_ERROR_FOUND;\n\tif ((Evt->RequestType = ssdp_request_type1(cmd)) == SSDP_SERROR) {\n\t\tEvt->ErrCode = E_HTTP_SYNTEX;\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "hmsg",
            "HDR_ST",
            "&hdr_value"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctrlpt_callback",
          "args": [
            "event_type",
            "param",
            "ctrlpt_cookie"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_get_Expires",
          "args": [
            "param"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_get_Location",
          "args": [
            "param"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memptr_cmp",
          "args": [
            "&hdr_value",
            "\"ssdp:byebye\""
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "memptr_cmp_nocase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "78-90",
          "snippet": "int memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_strcpy_ServiceType",
          "args": [
            "param",
            "event.ServiceType"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_strcpy_DeviceType",
          "args": [
            "param",
            "event.DeviceType"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_strcpy_DeviceID",
          "args": [
            "param",
            "event.UDN"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unique_service_name",
          "args": [
            "hdr_value.buf",
            "&event"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "unique_service_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_server.c",
          "lines": "448-532",
          "snippet": "int unique_service_name(char *cmd, SsdpEvent *Evt)\n{\n\tchar TempBuf[COMMAND_LEN];\n\tchar *TempPtr = NULL;\n\tchar *Ptr = NULL;\n\tchar *ptr1 = NULL;\n\tchar *ptr2 = NULL;\n\tchar *ptr3 = NULL;\n\tint CommandFound = 0;\n\tsize_t n = (size_t)0;\n\n\tif (strstr(cmd, \"uuid:schemas\") != NULL) {\n\t\tptr1 = strstr(cmd, \":device\");\n\t\tif (ptr1 != NULL)\n\t\t\tptr2 = strstr(ptr1 + 1, \":\");\n\t\telse\n\t\t\treturn -1;\n\t\tif (ptr2 != NULL)\n\t\t\tptr3 = strstr(ptr2 + 1, \":\");\n\t\telse\n\t\t\treturn -1;\n\t\tif (ptr3 != NULL) {\n\t\t\tif (strlen(\"uuid:\") + strlen(ptr3 + 1) >= sizeof Evt->UDN)\n\t\t\t\treturn -1;\n\t\t\tsnprintf(Evt->UDN, sizeof Evt->UDN, \"uuid:%s\", ptr3 + 1);\n\t\t}\n\t\telse\n\t\t\treturn -1;\n\t\tptr1 = strstr(cmd, \":\");\n\t\tif (ptr1 != NULL) {\n\t\t\tn = (size_t)ptr3 - (size_t)ptr1;\n\t\t\tn = n >= sizeof TempBuf ? sizeof TempBuf - 1 : n;\n\t\t\tstrncpy(TempBuf, ptr1, n);\n\t\t\tTempBuf[n] = '\\0';\n\t\t\tif (strlen(\"urn\") + strlen(TempBuf) >= sizeof(Evt->DeviceType))\n\t\t\t\treturn -1;\n\t\t\tsnprintf(Evt->DeviceType, sizeof(Evt->DeviceType),\n\t\t\t\t\"urn%s\", TempBuf);\n\t\t} else\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tif ((TempPtr = strstr(cmd, \"uuid\")) != NULL) {\n\t\tif ((Ptr = strstr(cmd, \"::\")) != NULL) {\n\t\t\tn = (size_t)Ptr - (size_t)TempPtr;\n\t\t\tn = n >= sizeof Evt->UDN ? sizeof Evt->UDN - 1 : n;\n\t\t\tstrncpy(Evt->UDN, TempPtr, n);\n\t\t\tEvt->UDN[n] = '\\0';\n\t\t} else {\n\t\t\tmemset(Evt->UDN, 0, sizeof(Evt->UDN));\n\t\t\tstrncpy(Evt->UDN, TempPtr, sizeof Evt->UDN - 1);\n\t\t}\n\t\tCommandFound = 1;\n\t}\n\tif (strstr(cmd, \"urn:\") != NULL && strstr(cmd, \":service:\") != NULL) {\n\t\tif ((TempPtr = strstr(cmd, \"urn\")) != NULL) {\n\t\t\tmemset(Evt->ServiceType, 0, sizeof Evt->ServiceType);\n\t\t\tstrncpy(Evt->ServiceType, TempPtr,\n\t\t\t\tsizeof Evt->ServiceType - 1);\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif (strstr(cmd, \"urn:\") != NULL && strstr(cmd, \":device:\") != NULL) {\n\t\tif ((TempPtr = strstr(cmd, \"urn\")) != NULL) {\n\t\t\tmemset(Evt->DeviceType, 0, sizeof Evt->DeviceType);\n\t\t\tstrncpy(Evt->DeviceType, TempPtr,\n\t\t\t\tsizeof Evt->DeviceType - 1);\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif ((TempPtr = strstr(cmd, \"::upnp:rootdevice\")) != NULL) {\n\t\t/* Everything before \"::upnp::rootdevice\" is the UDN. */\n\t\tif (TempPtr != cmd) {\n\t\t\tn = (size_t)TempPtr - (size_t)cmd;\n\t\t\tn = n >= sizeof Evt->UDN ? sizeof Evt->UDN - 1 : n;\n\t\t\tstrncpy(Evt->UDN, cmd, n);\n\t\t\tEvt->UDN[n] = 0;\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif (CommandFound == 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include \"upnpapi.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sock.h\"",
            "#include \"miniserver.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ssdplib.h\"",
            "#include \"config.h\"",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include \"upnpapi.h\"\n#include \"ThreadPool.h\"\n#include \"sock.h\"\n#include \"miniserver.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ssdplib.h\"\n#include \"config.h\"\n#include <sys/param.h>\n\n#define snprintf _snprintf\n\nint unique_service_name(char *cmd, SsdpEvent *Evt)\n{\n\tchar TempBuf[COMMAND_LEN];\n\tchar *TempPtr = NULL;\n\tchar *Ptr = NULL;\n\tchar *ptr1 = NULL;\n\tchar *ptr2 = NULL;\n\tchar *ptr3 = NULL;\n\tint CommandFound = 0;\n\tsize_t n = (size_t)0;\n\n\tif (strstr(cmd, \"uuid:schemas\") != NULL) {\n\t\tptr1 = strstr(cmd, \":device\");\n\t\tif (ptr1 != NULL)\n\t\t\tptr2 = strstr(ptr1 + 1, \":\");\n\t\telse\n\t\t\treturn -1;\n\t\tif (ptr2 != NULL)\n\t\t\tptr3 = strstr(ptr2 + 1, \":\");\n\t\telse\n\t\t\treturn -1;\n\t\tif (ptr3 != NULL) {\n\t\t\tif (strlen(\"uuid:\") + strlen(ptr3 + 1) >= sizeof Evt->UDN)\n\t\t\t\treturn -1;\n\t\t\tsnprintf(Evt->UDN, sizeof Evt->UDN, \"uuid:%s\", ptr3 + 1);\n\t\t}\n\t\telse\n\t\t\treturn -1;\n\t\tptr1 = strstr(cmd, \":\");\n\t\tif (ptr1 != NULL) {\n\t\t\tn = (size_t)ptr3 - (size_t)ptr1;\n\t\t\tn = n >= sizeof TempBuf ? sizeof TempBuf - 1 : n;\n\t\t\tstrncpy(TempBuf, ptr1, n);\n\t\t\tTempBuf[n] = '\\0';\n\t\t\tif (strlen(\"urn\") + strlen(TempBuf) >= sizeof(Evt->DeviceType))\n\t\t\t\treturn -1;\n\t\t\tsnprintf(Evt->DeviceType, sizeof(Evt->DeviceType),\n\t\t\t\t\"urn%s\", TempBuf);\n\t\t} else\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tif ((TempPtr = strstr(cmd, \"uuid\")) != NULL) {\n\t\tif ((Ptr = strstr(cmd, \"::\")) != NULL) {\n\t\t\tn = (size_t)Ptr - (size_t)TempPtr;\n\t\t\tn = n >= sizeof Evt->UDN ? sizeof Evt->UDN - 1 : n;\n\t\t\tstrncpy(Evt->UDN, TempPtr, n);\n\t\t\tEvt->UDN[n] = '\\0';\n\t\t} else {\n\t\t\tmemset(Evt->UDN, 0, sizeof(Evt->UDN));\n\t\t\tstrncpy(Evt->UDN, TempPtr, sizeof Evt->UDN - 1);\n\t\t}\n\t\tCommandFound = 1;\n\t}\n\tif (strstr(cmd, \"urn:\") != NULL && strstr(cmd, \":service:\") != NULL) {\n\t\tif ((TempPtr = strstr(cmd, \"urn\")) != NULL) {\n\t\t\tmemset(Evt->ServiceType, 0, sizeof Evt->ServiceType);\n\t\t\tstrncpy(Evt->ServiceType, TempPtr,\n\t\t\t\tsizeof Evt->ServiceType - 1);\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif (strstr(cmd, \"urn:\") != NULL && strstr(cmd, \":device:\") != NULL) {\n\t\tif ((TempPtr = strstr(cmd, \"urn\")) != NULL) {\n\t\t\tmemset(Evt->DeviceType, 0, sizeof Evt->DeviceType);\n\t\t\tstrncpy(Evt->DeviceType, TempPtr,\n\t\t\t\tsizeof Evt->DeviceType - 1);\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif ((TempPtr = strstr(cmd, \"::upnp:rootdevice\")) != NULL) {\n\t\t/* Everything before \"::upnp::rootdevice\" is the UDN. */\n\t\tif (TempPtr != cmd) {\n\t\t\tn = (size_t)TempPtr - (size_t)cmd;\n\t\t\tn = n >= sizeof Evt->UDN ? sizeof Evt->UDN - 1 : n;\n\t\t\tstrncpy(Evt->UDN, cmd, n);\n\t\t\tEvt->UDN[n] = 0;\n\t\t\tCommandFound = 1;\n\t\t}\n\t}\n\tif (CommandFound == 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_strncpy_Os",
          "args": [
            "param",
            "hdr_value.buf",
            "hdr_value.length"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_strncpy_Location",
          "args": [
            "param",
            "hdr_value.buf",
            "hdr_value.length"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_strncpy_Ext",
          "args": [
            "param",
            "hdr_value.buf",
            "hdr_value.length"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_set_DestAddr",
          "args": [
            "param",
            "dest_addr"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_strcpy_Date",
          "args": [
            "param",
            "hdr_value.buf"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_set_Expires",
          "args": [
            "param",
            "expires"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matchstr",
          "args": [
            "hdr_value.buf",
            "hdr_value.length",
            "\"%imax-age = %d%0\"",
            "&expires"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "matchstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1168-1203",
          "snippet": "parse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_set_Expires",
          "args": [
            "param",
            "expires"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_set_ErrCode",
          "args": [
            "param",
            "UPNP_E_SUCCESS"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctrlpt_callback",
          "args": [
            "UPNP_DISCOVERY_SEARCH_TIMEOUT",
            "NULL",
            "cookie"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&job",
            "0",
            "sizeof(job)"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpDiscovery_new",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include \"ThreadPool.h\"\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ssdp_ResultData.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"upnputil.h\"\n#include \"config.h\"\n\nvoid ssdp_handle_ctrlpt_msg(http_message_t *hmsg, struct sockaddr_storage *dest_addr,\n\t\t\t    int timeout, void *cookie)\n{\n\tint handle;\n\tstruct Handle_Info *ctrlpt_info = NULL;\n\tmemptr hdr_value;\n\t/* byebye or alive */\n\tint is_byebye;\n\tUpnpDiscovery *param = UpnpDiscovery_new();\n\tint expires;\n\tint ret;\n\tSsdpEvent event;\n\tint nt_found;\n\tint usn_found;\n\tint st_found;\n\tchar save_char;\n\tUpnp_EventType event_type;\n\tUpnp_FunPtr ctrlpt_callback;\n\tvoid *ctrlpt_cookie;\n\tListNode *node = NULL;\n\tSsdpSearchArg *searchArg = NULL;\n\tint matched = 0;\n\tSSDPResultData *threadData = NULL;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\t/* we are assuming that there can be only one client supported at a time */\n\tHandleReadLock();\n\n\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t}\n\t/* copy */\n\tctrlpt_callback = ctrlpt_info->Callback;\n\tctrlpt_cookie = ctrlpt_info->Cookie;\n\tHandleUnlock();\n\t/* search timeout */\n\tif (timeout) {\n\t\tctrlpt_callback(UPNP_DISCOVERY_SEARCH_TIMEOUT, NULL, cookie);\n\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t}\n\n\tUpnpDiscovery_set_ErrCode(param, UPNP_E_SUCCESS);\n\t/* MAX-AGE, assume error */\n\texpires = -1;\n\tUpnpDiscovery_set_Expires(param, expires);\n\tif (httpmsg_find_hdr(hmsg, HDR_CACHE_CONTROL, &hdr_value) != NULL) {\n\t\tret = matchstr(hdr_value.buf, hdr_value.length,\n\t\t\t\"%imax-age = %d%0\", &expires);\n\t\tUpnpDiscovery_set_Expires(param, expires);\n\t\tif (ret != PARSE_OK)\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t}\n\t/* DATE */\n\tif (httpmsg_find_hdr(hmsg, HDR_DATE, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strcpy_Date(param, hdr_value.buf);\n\t}\n\t/* dest addr */\n\tUpnpDiscovery_set_DestAddr(param, dest_addr);\n\t/* EXT */\n\tif (httpmsg_find_hdr(hmsg, HDR_EXT, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strncpy_Ext(param, hdr_value.buf,\n\t\t\t\t\t  hdr_value.length);\n\t}\n\t/* LOCATION */\n\tif (httpmsg_find_hdr(hmsg, HDR_LOCATION, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strncpy_Location(param, hdr_value.buf,\n\t\t\t\t\t       hdr_value.length);\n\t}\n\t/* SERVER / USER-AGENT */\n\tif (httpmsg_find_hdr(hmsg, HDR_SERVER, &hdr_value) != NULL ||\n\t    httpmsg_find_hdr(hmsg, HDR_USER_AGENT, &hdr_value) != NULL) {\n\t\tUpnpDiscovery_strncpy_Os(param, hdr_value.buf,\n\t\t\t\t\t hdr_value.length);\n\t}\n\t/* clear everything */\n\tevent.UDN[0] = '\\0';\n\tevent.DeviceType[0] = '\\0';\n\tevent.ServiceType[0] = '\\0';\n\tnt_found = FALSE;\n\tif (httpmsg_find_hdr(hmsg, HDR_NT, &hdr_value) != NULL) {\n\t\tsave_char = hdr_value.buf[hdr_value.length];\n\t\thdr_value.buf[hdr_value.length] = '\\0';\n\t\tnt_found = (ssdp_request_type(hdr_value.buf, &event) == 0);\n\t\thdr_value.buf[hdr_value.length] = save_char;\n\t}\n\tusn_found = FALSE;\n\tif (httpmsg_find_hdr(hmsg, HDR_USN, &hdr_value) != NULL) {\n\t\tsave_char = hdr_value.buf[hdr_value.length];\n\t\thdr_value.buf[hdr_value.length] = '\\0';\n\t\tusn_found = (unique_service_name(hdr_value.buf, &event) == 0);\n\t\thdr_value.buf[hdr_value.length] = save_char;\n\t}\n\tif (nt_found || usn_found) {\n\t\tUpnpDiscovery_strcpy_DeviceID(param, event.UDN);\n\t\tUpnpDiscovery_strcpy_DeviceType(param, event.DeviceType);\n\t\tUpnpDiscovery_strcpy_ServiceType(param, event.ServiceType);\n\t}\n\t/* ADVERT. OR BYEBYE */\n\tif (hmsg->is_request) {\n\t\t/* use NTS hdr to determine advert., or byebye */\n\t\tif (httpmsg_find_hdr(hmsg, HDR_NTS, &hdr_value) == NULL) {\n\t\t\t/* error; NTS header not found */\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\tif (memptr_cmp(&hdr_value, \"ssdp:alive\") == 0) {\n\t\t\tis_byebye = FALSE;\n\t\t} else if (memptr_cmp(&hdr_value, \"ssdp:byebye\") == 0) {\n\t\t\tis_byebye = TRUE;\n\t\t} else {\n\t\t\t/* bad value */\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\tif (is_byebye) {\n\t\t\t/* check device byebye */\n\t\t\tif (!nt_found || !usn_found) {\n\t\t\t\t/* bad byebye */\n\t\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t\t}\n\t\t\tevent_type = UPNP_DISCOVERY_ADVERTISEMENT_BYEBYE;\n\t\t} else {\n\t\t\t/* check advertisement.\n\t\t\t * Expires is valid if positive. This is for testing\n\t\t\t * only. Expires should be greater than 1800 (30 mins) */\n\t\t\tif (!nt_found ||\n\t\t\t    !usn_found ||\n\t\t\t    UpnpString_get_Length(UpnpDiscovery_get_Location(param)) == 0 ||\n\t\t\t    UpnpDiscovery_get_Expires(param) <= 0) {\n\t\t\t\t/* bad advertisement */\n\t\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t\t}\n\t\t\tevent_type = UPNP_DISCOVERY_ADVERTISEMENT_ALIVE;\n\t\t}\n\t\t/* call callback */\n\t\tctrlpt_callback(event_type, param, ctrlpt_cookie);\n\t} else {\n\t\t/* reply (to a SEARCH) */\n\t\t/* only checking to see if there is a valid ST header */\n\t\tst_found = FALSE;\n\t\tif (httpmsg_find_hdr(hmsg, HDR_ST, &hdr_value) != NULL) {\n\t\t\tsave_char = hdr_value.buf[hdr_value.length];\n\t\t\thdr_value.buf[hdr_value.length] = '\\0';\n\t\t\tst_found =\n\t\t\t    ssdp_request_type(hdr_value.buf, &event) == 0;\n\t\t\thdr_value.buf[hdr_value.length] = save_char;\n\t\t}\n\t\tif (hmsg->status_code != HTTP_OK ||\n\t\t    UpnpDiscovery_get_Expires(param) <= 0 ||\n\t\t    UpnpString_get_Length(UpnpDiscovery_get_Location(param)) == 0 ||\n\t\t    !usn_found || !st_found) {\n\t\t\t/* bad reply */\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\t/* check each current search */\n\t\tHandleLock();\n\t\tif (GetClientHandleInfo(&handle, &ctrlpt_info) != HND_CLIENT) {\n\t\t\tHandleUnlock();\n\t\t\tgoto end_ssdp_handle_ctrlpt_msg;\n\t\t}\n\t\tnode = ListHead(&ctrlpt_info->SsdpSearchList);\n\t\t/* temporary add null termination */\n\t\t/*save_char = hdr_value.buf[ hdr_value.length ]; */\n\t\t/*hdr_value.buf[ hdr_value.length ] = '\\0'; */\n\t\twhile (node != NULL) {\n\t\t\tsearchArg = node->item;\n\t\t\t/* check for match of ST header and search target */\n\t\t\tswitch (searchArg->requestType) {\n\t\t\tcase SSDP_ALL:\n\t\t\t\tmatched = 1;\n\t\t\t\tbreak;\n\t\t\tcase SSDP_ROOTDEVICE:\n\t\t\t\tmatched =\n\t\t\t\t    (event.RequestType == SSDP_ROOTDEVICE);\n\t\t\t\tbreak;\n\t\t\tcase SSDP_DEVICEUDN:\n\t\t\t\tmatched = !strncmp(searchArg->searchTarget,\n\t\t\t\t\t\t   hdr_value.buf,\n\t\t\t\t\t\t   hdr_value.length);\n\t\t\t\tbreak;\n\t\t\tcase SSDP_DEVICETYPE:{\n\t\t\t\t\tsize_t m = min(hdr_value.length,\n\t\t\t\t\t\t       strlen\n\t\t\t\t\t\t       (searchArg->searchTarget));\n\t\t\t\t\tmatched =\n\t\t\t\t\t    !strncmp(searchArg->searchTarget,\n\t\t\t\t\t\t     hdr_value.buf, m);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase SSDP_SERVICE:{\n\t\t\t\t\tsize_t m = min(hdr_value.length,\n\t\t\t\t\t\t       strlen\n\t\t\t\t\t\t       (searchArg->searchTarget));\n\t\t\t\t\tmatched =\n\t\t\t\t\t    !strncmp(searchArg->searchTarget,\n\t\t\t\t\t\t     hdr_value.buf, m);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tmatched = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (matched) {\n\t\t\t\t/* schedule call back */\n\t\t\t\tthreadData = SSDPResultData_new();\n\t\t\t\tif (threadData != NULL) {\n\t\t\t\t\tSSDPResultData_set_Param(threadData,\n\t\t\t\t\t\t\t\t param);\n\t\t\t\t\tSSDPResultData_set_Cookie(threadData,\n\t\t\t\t\t\t\t\t  searchArg->\n\t\t\t\t\t\t\t\t  cookie);\n\t\t\t\t\tSSDPResultData_set_CtrlptCallback\n\t\t\t\t\t    (threadData, ctrlpt_callback);\n\t\t\t\t\tTPJobInit(&job, (start_routine)\n\t\t\t\t\t\t  send_search_result,\n\t\t\t\t\t\t  threadData);\n\t\t\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\t\t\tTPJobSetFreeFunction(&job,\n\t\t\t\t\t\t\t     (free_routine)\n\t\t\t\t\t\t\t     free);\n\t\t\t\t\tif (ThreadPoolAdd(&gRecvThreadPool, &job, NULL) != 0) {\n\t\t\t\t\t\tSSDPResultData_delete(threadData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = ListNext(&ctrlpt_info->SsdpSearchList, node);\n\t\t}\n\n\t\tHandleUnlock();\n\t\t/*ctrlpt_callback( UPNP_DISCOVERY_SEARCH_RESULT, param, cookie ); */\n\t}\n\nend_ssdp_handle_ctrlpt_msg:\n\tUpnpDiscovery_delete(param);\n}"
  },
  {
    "function_name": "send_search_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_ctrlpt.c",
    "lines": "68-76",
    "snippet": "static void send_search_result(\n\t/* [in] Search reply from the device. */\n\tIN void *data)\n{\n\tSSDPResultData *temp = (SSDPResultData *)data;\n\n\tSSDPResultData_Callback(temp);\n\tSSDPResultData_delete(temp);\n}",
    "includes": [
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"ThreadPool.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"ssdp_ResultData.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"upnputil.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SSDPResultData_delete",
          "args": [
            "temp"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSDPResultData_Callback",
          "args": [
            "temp"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "SSDPResultData_Callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/ssdp/ssdp_ResultData.c",
          "lines": "15-21",
          "snippet": "void SSDPResultData_Callback(const SSDPResultData *p)\n{\n\tUpnp_FunPtr callback = SSDPResultData_get_CtrlptCallback(p);\n\tcallback(UPNP_DISCOVERY_SEARCH_RESULT,\n\t\tSSDPResultData_get_Param(p),\n\t\tSSDPResultData_get_Cookie(p));\n}",
          "includes": [
            "#include \"ssdp_ResultData.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssdp_ResultData.h\"\n#include \"config.h\"\n\nvoid SSDPResultData_Callback(const SSDPResultData *p)\n{\n\tUpnp_FunPtr callback = SSDPResultData_get_CtrlptCallback(p);\n\tcallback(UPNP_DISCOVERY_SEARCH_RESULT,\n\t\tSSDPResultData_get_Param(p),\n\t\tSSDPResultData_get_Cookie(p));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include \"ThreadPool.h\"\n#include \"UpnpInet.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ssdp_ResultData.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"upnputil.h\"\n#include \"config.h\"\n\nstatic void send_search_result(\n\t/* [in] Search reply from the device. */\n\tIN void *data)\n{\n\tSSDPResultData *temp = (SSDPResultData *)data;\n\n\tSSDPResultData_Callback(temp);\n\tSSDPResultData_delete(temp);\n}"
  }
]