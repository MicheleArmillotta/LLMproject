[
  {
    "function_name": "gena_process_unsubscribe_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "1485-1547",
    "snippet": "void gena_process_unsubscribe_request(\n\tSOCKINFO *info,\n\thttp_message_t *request)\n{\n    Upnp_SID sid;\n    service_info *service;\n    struct Handle_Info *handle_info;\n    UpnpDevice_Handle device_handle;\n\n    memptr temp_hdr;\n    membuffer event_url_path;\n\n    /* if a CALLBACK or NT header is present, then it is an error */\n    if( httpmsg_find_hdr( request, HDR_CALLBACK, NULL ) != NULL ||\n        httpmsg_find_hdr( request, HDR_NT, NULL ) != NULL ) {\n        error_respond( info, HTTP_BAD_REQUEST, request );\n        return;\n    }\n    /* get SID */\n    if( httpmsg_find_hdr( request, HDR_SID, &temp_hdr ) == NULL ||\n        temp_hdr.length > SID_SIZE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        return;\n    }\n    memcpy( sid, temp_hdr.buf, temp_hdr.length );\n    sid[temp_hdr.length] = '\\0';\n\n    /* lookup service by eventURL */\n    membuffer_init( &event_url_path );\n    if( membuffer_append( &event_url_path, request->uri.pathquery.buff,\n                          request->uri.pathquery.size ) != 0 ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return;\n    }\n\n    HandleLock();\n\n    /* CURRENTLY, ONLY SUPPORT ONE DEVICE */\n    if( GetDeviceHandleInfo( info->foreign_sockaddr.ss_family,\n        &device_handle, &handle_info ) != HND_DEVICE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        membuffer_destroy( &event_url_path );\n        HandleUnlock();\n        return;\n    }\n    service = FindServiceEventURLPath( &handle_info->ServiceTable,\n                                       event_url_path.buf );\n    membuffer_destroy( &event_url_path );\n\n    /* validate service */\n    if( service == NULL ||\n        !service->active || GetSubscriptionSID( sid, service ) == NULL )\n    {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        HandleUnlock();\n        return;\n    }\n\n    RemoveSubscriptionSID(sid, service);\n    error_respond(info, HTTP_OK, request);    /* success */\n\n    HandleUnlock();\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_respond",
          "args": [
            "info",
            "HTTP_OK",
            "request"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "error_respond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_callback2.c",
          "lines": "58-71",
          "snippet": "void\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena_ctrlpt.h\"",
            "#include \"gena_device.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena_ctrlpt.h\"\n#include \"gena_device.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nvoid\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}"
        }
      },
      {
        "call_info": {
          "callee": "RemoveSubscriptionSID",
          "args": [
            "sid",
            "service"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "RemoveSubscriptionSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "97-120",
          "snippet": "void\nRemoveSubscriptionSID( Upnp_SID sid,\n                       service_info * service )\n{\n    subscription *finger = service->subscriptionList;\n    subscription *previous = NULL;\n\n    while( finger ) {\n        if( !( strcmp( sid, finger->sid ) ) ) {\n            if( previous )\n                previous->next = finger->next;\n            else\n                service->subscriptionList = finger->next;\n            finger->next = NULL;\n            freeSubscriptionList( finger );\n            finger = NULL;\n            service->TotalSubscriptions--;\n        } else {\n            previous = finger;\n            finger = finger->next;\n        }\n    }\n\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nvoid\nRemoveSubscriptionSID( Upnp_SID sid,\n                       service_info * service )\n{\n    subscription *finger = service->subscriptionList;\n    subscription *previous = NULL;\n\n    while( finger ) {\n        if( !( strcmp( sid, finger->sid ) ) ) {\n            if( previous )\n                previous->next = finger->next;\n            else\n                service->subscriptionList = finger->next;\n            finger->next = NULL;\n            freeSubscriptionList( finger );\n            finger = NULL;\n            service->TotalSubscriptions--;\n        } else {\n            previous = finger;\n            finger = finger->next;\n        }\n    }\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSubscriptionSID",
          "args": [
            "sid",
            "service"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "GetSubscriptionSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "123-156",
          "snippet": "subscription *GetSubscriptionSID(const Upnp_SID sid, service_info *service)\n{\n    subscription *next = service->subscriptionList;\n    subscription *previous = NULL;\n    subscription *found = NULL;\n\n    time_t current_time;\n\n    while( ( next ) && ( found == NULL ) ) {\n        if( !strcmp( next->sid, sid ) )\n            found = next;\n        else {\n            previous = next;\n            next = next->next;\n        }\n    }\n    if( found ) {\n        /*get the current_time */\n        time( &current_time );\n        if( ( found->expireTime != 0 )\n            && ( found->expireTime < current_time ) ) {\n            if( previous )\n                previous->next = found->next;\n            else\n                service->subscriptionList = found->next;\n            found->next = NULL;\n            freeSubscriptionList( found );\n            found = NULL;\n            service->TotalSubscriptions--;\n        }\n    }\n    return found;\n\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nsubscription *GetSubscriptionSID(const Upnp_SID sid, service_info *service)\n{\n    subscription *next = service->subscriptionList;\n    subscription *previous = NULL;\n    subscription *found = NULL;\n\n    time_t current_time;\n\n    while( ( next ) && ( found == NULL ) ) {\n        if( !strcmp( next->sid, sid ) )\n            found = next;\n        else {\n            previous = next;\n            next = next->next;\n        }\n    }\n    if( found ) {\n        /*get the current_time */\n        time( &current_time );\n        if( ( found->expireTime != 0 )\n            && ( found->expireTime < current_time ) ) {\n            if( previous )\n                previous->next = found->next;\n            else\n                service->subscriptionList = found->next;\n            found->next = NULL;\n            freeSubscriptionList( found );\n            found = NULL;\n            service->TotalSubscriptions--;\n        }\n    }\n    return found;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&event_url_path"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindServiceEventURLPath",
          "args": [
            "&handle_info->ServiceTable",
            "event_url_path.buf"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "FindServiceEventURLPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "294-326",
          "snippet": "service_info *\nFindServiceEventURLPath( service_table * table,\n                         char *eventURLPath )\n{\n    service_info *finger = NULL;\n    uri_type parsed_url;\n    uri_type parsed_url_in;\n\n    if( ( table )\n        &&\n        ( parse_uri( eventURLPath,\n                     strlen( eventURLPath ),\n                     &parsed_url_in ) == HTTP_SUCCESS ) ) {\n\n        finger = table->serviceList;\n        while( finger ) {\n            if( finger->eventURL )\n                if( ( parse_uri\n                      ( finger->eventURL, strlen( finger->eventURL ),\n                        &parsed_url ) == HTTP_SUCCESS ) ) {\n\n                    if( !token_cmp\n                        ( &parsed_url.pathquery,\n                          &parsed_url_in.pathquery ) )\n                        return finger;\n\n                }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nservice_info *\nFindServiceEventURLPath( service_table * table,\n                         char *eventURLPath )\n{\n    service_info *finger = NULL;\n    uri_type parsed_url;\n    uri_type parsed_url_in;\n\n    if( ( table )\n        &&\n        ( parse_uri( eventURLPath,\n                     strlen( eventURLPath ),\n                     &parsed_url_in ) == HTTP_SUCCESS ) ) {\n\n        finger = table->serviceList;\n        while( finger ) {\n            if( finger->eventURL )\n                if( ( parse_uri\n                      ( finger->eventURL, strlen( finger->eventURL ),\n                        &parsed_url ) == HTTP_SUCCESS ) ) {\n\n                    if( !token_cmp\n                        ( &parsed_url.pathquery,\n                          &parsed_url_in.pathquery ) )\n                        return finger;\n\n                }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDeviceHandleInfo",
          "args": [
            "info->foreign_sockaddr.ss_family",
            "&device_handle",
            "&handle_info"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "GetDeviceHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3849-3878",
          "snippet": "Upnp_Handle_Type GetDeviceHandleInfo(\n\tint AddressFamily,\n\tUpnpDevice_Handle *device_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\t/* Check if we've got a registered device of the address family specified. */\n\tif ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||\n\t    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {\n\t\t*device_handle_out = -1;\n\t\treturn HND_INVALID;\n\t}\n\n\t/* Find it. */\n\tfor (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {\n\t\tswitch (GetHandleInfo(*device_handle_out, HndInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tif ((*HndInfo)->DeviceAf == AddressFamily) {\n\t\t\t\treturn HND_DEVICE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif /* INCLUDE_DEVICE_APIS */\n\n\t*device_handle_out = -1;\n\treturn HND_INVALID;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "int UpnpSdkDeviceRegisteredV4 = 0;",
            "int UpnpSdkDeviceregisteredV6 = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nint UpnpSdkDeviceRegisteredV4 = 0;\nint UpnpSdkDeviceregisteredV6 = 0;\n\nUpnp_Handle_Type GetDeviceHandleInfo(\n\tint AddressFamily,\n\tUpnpDevice_Handle *device_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\t/* Check if we've got a registered device of the address family specified. */\n\tif ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||\n\t    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {\n\t\t*device_handle_out = -1;\n\t\treturn HND_INVALID;\n\t}\n\n\t/* Find it. */\n\tfor (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {\n\t\tswitch (GetHandleInfo(*device_handle_out, HndInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tif ((*HndInfo)->DeviceAf == AddressFamily) {\n\t\t\t\treturn HND_DEVICE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif /* INCLUDE_DEVICE_APIS */\n\n\t*device_handle_out = -1;\n\treturn HND_INVALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_append",
          "args": [
            "&event_url_path",
            "request->uri.pathquery.buff",
            "request->uri.pathquery.size"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "200-205",
          "snippet": "int membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&event_url_path"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sid",
            "temp_hdr.buf",
            "temp_hdr.length"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "request",
            "HDR_SID",
            "&temp_hdr"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nvoid gena_process_unsubscribe_request(\n\tSOCKINFO *info,\n\thttp_message_t *request)\n{\n    Upnp_SID sid;\n    service_info *service;\n    struct Handle_Info *handle_info;\n    UpnpDevice_Handle device_handle;\n\n    memptr temp_hdr;\n    membuffer event_url_path;\n\n    /* if a CALLBACK or NT header is present, then it is an error */\n    if( httpmsg_find_hdr( request, HDR_CALLBACK, NULL ) != NULL ||\n        httpmsg_find_hdr( request, HDR_NT, NULL ) != NULL ) {\n        error_respond( info, HTTP_BAD_REQUEST, request );\n        return;\n    }\n    /* get SID */\n    if( httpmsg_find_hdr( request, HDR_SID, &temp_hdr ) == NULL ||\n        temp_hdr.length > SID_SIZE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        return;\n    }\n    memcpy( sid, temp_hdr.buf, temp_hdr.length );\n    sid[temp_hdr.length] = '\\0';\n\n    /* lookup service by eventURL */\n    membuffer_init( &event_url_path );\n    if( membuffer_append( &event_url_path, request->uri.pathquery.buff,\n                          request->uri.pathquery.size ) != 0 ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return;\n    }\n\n    HandleLock();\n\n    /* CURRENTLY, ONLY SUPPORT ONE DEVICE */\n    if( GetDeviceHandleInfo( info->foreign_sockaddr.ss_family,\n        &device_handle, &handle_info ) != HND_DEVICE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        membuffer_destroy( &event_url_path );\n        HandleUnlock();\n        return;\n    }\n    service = FindServiceEventURLPath( &handle_info->ServiceTable,\n                                       event_url_path.buf );\n    membuffer_destroy( &event_url_path );\n\n    /* validate service */\n    if( service == NULL ||\n        !service->active || GetSubscriptionSID( sid, service ) == NULL )\n    {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        HandleUnlock();\n        return;\n    }\n\n    RemoveSubscriptionSID(sid, service);\n    error_respond(info, HTTP_OK, request);    /* success */\n\n    HandleUnlock();\n}"
  },
  {
    "function_name": "gena_process_subscription_renewal_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "1372-1482",
    "snippet": "void gena_process_subscription_renewal_request(\n\tSOCKINFO *info,\n\thttp_message_t *request)\n{\n    Upnp_SID sid;\n    subscription *sub;\n    int time_out = 1801;\n    service_info *service;\n    struct Handle_Info *handle_info;\n    UpnpDevice_Handle device_handle;\n    memptr temp_hdr;\n    membuffer event_url_path;\n    memptr timeout_hdr;\n\n    /* if a CALLBACK or NT header is present, then it is an error */\n    if( httpmsg_find_hdr( request, HDR_CALLBACK, NULL ) != NULL ||\n        httpmsg_find_hdr( request, HDR_NT, NULL ) != NULL ) {\n        error_respond( info, HTTP_BAD_REQUEST, request );\n        return;\n    }\n    /* get SID */\n    if( httpmsg_find_hdr( request, HDR_SID, &temp_hdr ) == NULL ||\n        temp_hdr.length > SID_SIZE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        return;\n    }\n    memcpy( sid, temp_hdr.buf, temp_hdr.length );\n    sid[temp_hdr.length] = '\\0';\n\n    /* lookup service by eventURL */\n    membuffer_init( &event_url_path );\n    if( membuffer_append( &event_url_path, request->uri.pathquery.buff,\n                          request->uri.pathquery.size ) != 0 ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return;\n    }\n\n    HandleLock();\n\n    /* CURRENTLY, ONLY SUPPORT ONE DEVICE */\n    if( GetDeviceHandleInfo( info->foreign_sockaddr.ss_family,\n        &device_handle, &handle_info ) != HND_DEVICE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        membuffer_destroy( &event_url_path );\n        HandleUnlock();\n        return;\n    }\n    service = FindServiceEventURLPath( &handle_info->ServiceTable,\n                                       event_url_path.buf );\n    membuffer_destroy( &event_url_path );\n\n    /* get subscription */\n    if( service == NULL ||\n        !service->active ||\n        ( ( sub = GetSubscriptionSID( sid, service ) ) == NULL ) ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        HandleUnlock();\n        return;\n    }\n\n    UpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__,\n        \"Renew request: Number of subscriptions already: %d\\n \"\n        \"Max Subscriptions allowed:%d\\n\",\n        service->TotalSubscriptions,\n        handle_info->MaxSubscriptions );\n    /* too many subscriptions */\n    if( handle_info->MaxSubscriptions != -1 &&\n            service->TotalSubscriptions > handle_info->MaxSubscriptions ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        RemoveSubscriptionSID( sub->sid, service );\n        HandleUnlock();\n        return;\n    }\n    /* set the timeout */\n    if( httpmsg_find_hdr( request, HDR_TIMEOUT, &timeout_hdr ) != NULL ) {\n        if( matchstr( timeout_hdr.buf, timeout_hdr.length,\n                      \"%iSecond-%d%0\", &time_out ) == PARSE_OK ) {\n\n            /*nothing */\n\n        } else if( memptr_cmp_nocase( &timeout_hdr, \"Second-infinite\" ) ==\n                   0 ) {\n\n            time_out = -1;      /* inifinite timeout */\n\n        } else {\n            time_out = DEFAULT_TIMEOUT; /* default is > 1800 seconds */\n\n        }\n    }\n\n    /* replace infinite timeout with max timeout, if possible */\n    if( handle_info->MaxSubscriptionTimeOut != -1 ) {\n        if( time_out == -1 ||\n            time_out > handle_info->MaxSubscriptionTimeOut ) {\n            time_out = handle_info->MaxSubscriptionTimeOut;\n        }\n    }\n\n    if( time_out == -1 ) {\n        sub->expireTime = 0;\n    } else {\n        sub->expireTime = time( NULL ) + time_out;\n    }\n\n    if( respond_ok( info, time_out, sub, request ) != UPNP_E_SUCCESS ) {\n        RemoveSubscriptionSID( sub->sid, service );\n    }\n\n    HandleUnlock();\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RemoveSubscriptionSID",
          "args": [
            "sub->sid",
            "service"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "RemoveSubscriptionSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "97-120",
          "snippet": "void\nRemoveSubscriptionSID( Upnp_SID sid,\n                       service_info * service )\n{\n    subscription *finger = service->subscriptionList;\n    subscription *previous = NULL;\n\n    while( finger ) {\n        if( !( strcmp( sid, finger->sid ) ) ) {\n            if( previous )\n                previous->next = finger->next;\n            else\n                service->subscriptionList = finger->next;\n            finger->next = NULL;\n            freeSubscriptionList( finger );\n            finger = NULL;\n            service->TotalSubscriptions--;\n        } else {\n            previous = finger;\n            finger = finger->next;\n        }\n    }\n\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nvoid\nRemoveSubscriptionSID( Upnp_SID sid,\n                       service_info * service )\n{\n    subscription *finger = service->subscriptionList;\n    subscription *previous = NULL;\n\n    while( finger ) {\n        if( !( strcmp( sid, finger->sid ) ) ) {\n            if( previous )\n                previous->next = finger->next;\n            else\n                service->subscriptionList = finger->next;\n            finger->next = NULL;\n            freeSubscriptionList( finger );\n            finger = NULL;\n            service->TotalSubscriptions--;\n        } else {\n            previous = finger;\n            finger = finger->next;\n        }\n    }\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "respond_ok",
          "args": [
            "info",
            "time_out",
            "sub",
            "request"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "respond_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "1042-1097",
          "snippet": "static int respond_ok(\n\t/*! [in] Socket connection of request. */\n\tSOCKINFO *info,\n\t/*! [in] Accepted duration. */\n\tint time_out,\n\t/*! [in] Accepted subscription. */\n\tsubscription *sub,\n\t/*! [in] Http request. */\n\thttp_message_t *request)\n{\n    int major;\n    int minor;\n    membuffer response;\n    int return_code;\n    char timeout_str[100];\n    int upnp_timeout = UPNP_TIMEOUT;\n    int rc = 0;\n\n    http_CalcResponseVersion( request->major_version,\n                              request->minor_version, &major, &minor );\n\n    if( time_out >= 0 ) {\n        rc = snprintf( timeout_str, sizeof ( timeout_str ),\n                       \"TIMEOUT: Second-%d\", time_out );\n    } else {\n        memset( timeout_str, 0, sizeof( timeout_str ) );\n        strncpy( timeout_str, \"TIMEOUT: Second-infinite\",\n                 sizeof ( timeout_str ) - 1);\n    }\n    if (rc < 0 || (unsigned int) rc >= sizeof ( timeout_str ) ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request ); \n        return UPNP_E_OUTOF_MEMORY;\n    }\n\n    membuffer_init( &response );\n    response.size_inc = 30;\n    if( http_MakeMessage(\n        &response, major, minor,\n        \"R\" \"D\" \"S\" \"N\" \"Xc\" \"ssc\" \"scc\",\n        HTTP_OK,\n        (off_t)0,\n        X_USER_AGENT,\n        \"SID: \", sub->sid,\n        timeout_str ) != 0 ) {\n        membuffer_destroy( &response );\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n\n    return_code = http_SendMessage( info, &upnp_timeout, \"b\",\n                                    response.buf, response.length );\n\n    membuffer_destroy( &response );\n\n    return return_code;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic int respond_ok(\n\t/*! [in] Socket connection of request. */\n\tSOCKINFO *info,\n\t/*! [in] Accepted duration. */\n\tint time_out,\n\t/*! [in] Accepted subscription. */\n\tsubscription *sub,\n\t/*! [in] Http request. */\n\thttp_message_t *request)\n{\n    int major;\n    int minor;\n    membuffer response;\n    int return_code;\n    char timeout_str[100];\n    int upnp_timeout = UPNP_TIMEOUT;\n    int rc = 0;\n\n    http_CalcResponseVersion( request->major_version,\n                              request->minor_version, &major, &minor );\n\n    if( time_out >= 0 ) {\n        rc = snprintf( timeout_str, sizeof ( timeout_str ),\n                       \"TIMEOUT: Second-%d\", time_out );\n    } else {\n        memset( timeout_str, 0, sizeof( timeout_str ) );\n        strncpy( timeout_str, \"TIMEOUT: Second-infinite\",\n                 sizeof ( timeout_str ) - 1);\n    }\n    if (rc < 0 || (unsigned int) rc >= sizeof ( timeout_str ) ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request ); \n        return UPNP_E_OUTOF_MEMORY;\n    }\n\n    membuffer_init( &response );\n    response.size_inc = 30;\n    if( http_MakeMessage(\n        &response, major, minor,\n        \"R\" \"D\" \"S\" \"N\" \"Xc\" \"ssc\" \"scc\",\n        HTTP_OK,\n        (off_t)0,\n        X_USER_AGENT,\n        \"SID: \", sub->sid,\n        timeout_str ) != 0 ) {\n        membuffer_destroy( &response );\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n\n    return_code = http_SendMessage( info, &upnp_timeout, \"b\",\n                                    response.buf, response.length );\n\n    membuffer_destroy( &response );\n\n    return return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "get_system_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/sysdep.c",
          "lines": "115-127",
          "snippet": "void get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpInet.h\"",
            "#include \"sysdep.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <string.h>\n#include \"UpnpInet.h\"\n#include \"sysdep.h\"\n#include \"config.h\"\n\nvoid get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memptr_cmp_nocase",
          "args": [
            "&timeout_hdr",
            "\"Second-infinite\""
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "memptr_cmp_nocase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "78-90",
          "snippet": "int memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "matchstr",
          "args": [
            "timeout_hdr.buf",
            "timeout_hdr.length",
            "\"%iSecond-%d%0\"",
            "&time_out"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "matchstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1168-1203",
          "snippet": "parse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "request",
            "HDR_TIMEOUT",
            "&timeout_hdr"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_respond",
          "args": [
            "info",
            "HTTP_INTERNAL_SERVER_ERROR",
            "request"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "error_respond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_callback2.c",
          "lines": "58-71",
          "snippet": "void\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena_ctrlpt.h\"",
            "#include \"gena_device.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena_ctrlpt.h\"\n#include \"gena_device.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nvoid\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "GENA",
            "__FILE__",
            "__LINE__",
            "\"Renew request: Number of subscriptions already: %d\\n \"\n        \"Max Subscriptions allowed:%d\\n\"",
            "service->TotalSubscriptions",
            "handle_info->MaxSubscriptions"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSubscriptionSID",
          "args": [
            "sid",
            "service"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "GetSubscriptionSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "123-156",
          "snippet": "subscription *GetSubscriptionSID(const Upnp_SID sid, service_info *service)\n{\n    subscription *next = service->subscriptionList;\n    subscription *previous = NULL;\n    subscription *found = NULL;\n\n    time_t current_time;\n\n    while( ( next ) && ( found == NULL ) ) {\n        if( !strcmp( next->sid, sid ) )\n            found = next;\n        else {\n            previous = next;\n            next = next->next;\n        }\n    }\n    if( found ) {\n        /*get the current_time */\n        time( &current_time );\n        if( ( found->expireTime != 0 )\n            && ( found->expireTime < current_time ) ) {\n            if( previous )\n                previous->next = found->next;\n            else\n                service->subscriptionList = found->next;\n            found->next = NULL;\n            freeSubscriptionList( found );\n            found = NULL;\n            service->TotalSubscriptions--;\n        }\n    }\n    return found;\n\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nsubscription *GetSubscriptionSID(const Upnp_SID sid, service_info *service)\n{\n    subscription *next = service->subscriptionList;\n    subscription *previous = NULL;\n    subscription *found = NULL;\n\n    time_t current_time;\n\n    while( ( next ) && ( found == NULL ) ) {\n        if( !strcmp( next->sid, sid ) )\n            found = next;\n        else {\n            previous = next;\n            next = next->next;\n        }\n    }\n    if( found ) {\n        /*get the current_time */\n        time( &current_time );\n        if( ( found->expireTime != 0 )\n            && ( found->expireTime < current_time ) ) {\n            if( previous )\n                previous->next = found->next;\n            else\n                service->subscriptionList = found->next;\n            found->next = NULL;\n            freeSubscriptionList( found );\n            found = NULL;\n            service->TotalSubscriptions--;\n        }\n    }\n    return found;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&event_url_path"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindServiceEventURLPath",
          "args": [
            "&handle_info->ServiceTable",
            "event_url_path.buf"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "FindServiceEventURLPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "294-326",
          "snippet": "service_info *\nFindServiceEventURLPath( service_table * table,\n                         char *eventURLPath )\n{\n    service_info *finger = NULL;\n    uri_type parsed_url;\n    uri_type parsed_url_in;\n\n    if( ( table )\n        &&\n        ( parse_uri( eventURLPath,\n                     strlen( eventURLPath ),\n                     &parsed_url_in ) == HTTP_SUCCESS ) ) {\n\n        finger = table->serviceList;\n        while( finger ) {\n            if( finger->eventURL )\n                if( ( parse_uri\n                      ( finger->eventURL, strlen( finger->eventURL ),\n                        &parsed_url ) == HTTP_SUCCESS ) ) {\n\n                    if( !token_cmp\n                        ( &parsed_url.pathquery,\n                          &parsed_url_in.pathquery ) )\n                        return finger;\n\n                }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nservice_info *\nFindServiceEventURLPath( service_table * table,\n                         char *eventURLPath )\n{\n    service_info *finger = NULL;\n    uri_type parsed_url;\n    uri_type parsed_url_in;\n\n    if( ( table )\n        &&\n        ( parse_uri( eventURLPath,\n                     strlen( eventURLPath ),\n                     &parsed_url_in ) == HTTP_SUCCESS ) ) {\n\n        finger = table->serviceList;\n        while( finger ) {\n            if( finger->eventURL )\n                if( ( parse_uri\n                      ( finger->eventURL, strlen( finger->eventURL ),\n                        &parsed_url ) == HTTP_SUCCESS ) ) {\n\n                    if( !token_cmp\n                        ( &parsed_url.pathquery,\n                          &parsed_url_in.pathquery ) )\n                        return finger;\n\n                }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDeviceHandleInfo",
          "args": [
            "info->foreign_sockaddr.ss_family",
            "&device_handle",
            "&handle_info"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "GetDeviceHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3849-3878",
          "snippet": "Upnp_Handle_Type GetDeviceHandleInfo(\n\tint AddressFamily,\n\tUpnpDevice_Handle *device_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\t/* Check if we've got a registered device of the address family specified. */\n\tif ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||\n\t    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {\n\t\t*device_handle_out = -1;\n\t\treturn HND_INVALID;\n\t}\n\n\t/* Find it. */\n\tfor (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {\n\t\tswitch (GetHandleInfo(*device_handle_out, HndInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tif ((*HndInfo)->DeviceAf == AddressFamily) {\n\t\t\t\treturn HND_DEVICE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif /* INCLUDE_DEVICE_APIS */\n\n\t*device_handle_out = -1;\n\treturn HND_INVALID;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "int UpnpSdkDeviceRegisteredV4 = 0;",
            "int UpnpSdkDeviceregisteredV6 = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nint UpnpSdkDeviceRegisteredV4 = 0;\nint UpnpSdkDeviceregisteredV6 = 0;\n\nUpnp_Handle_Type GetDeviceHandleInfo(\n\tint AddressFamily,\n\tUpnpDevice_Handle *device_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\t/* Check if we've got a registered device of the address family specified. */\n\tif ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||\n\t    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {\n\t\t*device_handle_out = -1;\n\t\treturn HND_INVALID;\n\t}\n\n\t/* Find it. */\n\tfor (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {\n\t\tswitch (GetHandleInfo(*device_handle_out, HndInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tif ((*HndInfo)->DeviceAf == AddressFamily) {\n\t\t\t\treturn HND_DEVICE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif /* INCLUDE_DEVICE_APIS */\n\n\t*device_handle_out = -1;\n\treturn HND_INVALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_append",
          "args": [
            "&event_url_path",
            "request->uri.pathquery.buff",
            "request->uri.pathquery.size"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "200-205",
          "snippet": "int membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&event_url_path"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sid",
            "temp_hdr.buf",
            "temp_hdr.length"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nvoid gena_process_subscription_renewal_request(\n\tSOCKINFO *info,\n\thttp_message_t *request)\n{\n    Upnp_SID sid;\n    subscription *sub;\n    int time_out = 1801;\n    service_info *service;\n    struct Handle_Info *handle_info;\n    UpnpDevice_Handle device_handle;\n    memptr temp_hdr;\n    membuffer event_url_path;\n    memptr timeout_hdr;\n\n    /* if a CALLBACK or NT header is present, then it is an error */\n    if( httpmsg_find_hdr( request, HDR_CALLBACK, NULL ) != NULL ||\n        httpmsg_find_hdr( request, HDR_NT, NULL ) != NULL ) {\n        error_respond( info, HTTP_BAD_REQUEST, request );\n        return;\n    }\n    /* get SID */\n    if( httpmsg_find_hdr( request, HDR_SID, &temp_hdr ) == NULL ||\n        temp_hdr.length > SID_SIZE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        return;\n    }\n    memcpy( sid, temp_hdr.buf, temp_hdr.length );\n    sid[temp_hdr.length] = '\\0';\n\n    /* lookup service by eventURL */\n    membuffer_init( &event_url_path );\n    if( membuffer_append( &event_url_path, request->uri.pathquery.buff,\n                          request->uri.pathquery.size ) != 0 ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return;\n    }\n\n    HandleLock();\n\n    /* CURRENTLY, ONLY SUPPORT ONE DEVICE */\n    if( GetDeviceHandleInfo( info->foreign_sockaddr.ss_family,\n        &device_handle, &handle_info ) != HND_DEVICE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        membuffer_destroy( &event_url_path );\n        HandleUnlock();\n        return;\n    }\n    service = FindServiceEventURLPath( &handle_info->ServiceTable,\n                                       event_url_path.buf );\n    membuffer_destroy( &event_url_path );\n\n    /* get subscription */\n    if( service == NULL ||\n        !service->active ||\n        ( ( sub = GetSubscriptionSID( sid, service ) ) == NULL ) ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        HandleUnlock();\n        return;\n    }\n\n    UpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__,\n        \"Renew request: Number of subscriptions already: %d\\n \"\n        \"Max Subscriptions allowed:%d\\n\",\n        service->TotalSubscriptions,\n        handle_info->MaxSubscriptions );\n    /* too many subscriptions */\n    if( handle_info->MaxSubscriptions != -1 &&\n            service->TotalSubscriptions > handle_info->MaxSubscriptions ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        RemoveSubscriptionSID( sub->sid, service );\n        HandleUnlock();\n        return;\n    }\n    /* set the timeout */\n    if( httpmsg_find_hdr( request, HDR_TIMEOUT, &timeout_hdr ) != NULL ) {\n        if( matchstr( timeout_hdr.buf, timeout_hdr.length,\n                      \"%iSecond-%d%0\", &time_out ) == PARSE_OK ) {\n\n            /*nothing */\n\n        } else if( memptr_cmp_nocase( &timeout_hdr, \"Second-infinite\" ) ==\n                   0 ) {\n\n            time_out = -1;      /* inifinite timeout */\n\n        } else {\n            time_out = DEFAULT_TIMEOUT; /* default is > 1800 seconds */\n\n        }\n    }\n\n    /* replace infinite timeout with max timeout, if possible */\n    if( handle_info->MaxSubscriptionTimeOut != -1 ) {\n        if( time_out == -1 ||\n            time_out > handle_info->MaxSubscriptionTimeOut ) {\n            time_out = handle_info->MaxSubscriptionTimeOut;\n        }\n    }\n\n    if( time_out == -1 ) {\n        sub->expireTime = 0;\n    } else {\n        sub->expireTime = time( NULL ) + time_out;\n    }\n\n    if( respond_ok( info, time_out, sub, request ) != UPNP_E_SUCCESS ) {\n        RemoveSubscriptionSID( sub->sid, service );\n    }\n\n    HandleUnlock();\n}"
  },
  {
    "function_name": "gena_process_subscription_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "1186-1369",
    "snippet": "void gena_process_subscription_request(\n\tSOCKINFO *info,\n\thttp_message_t *request)\n{\n\tUpnpSubscriptionRequest *request_struct = UpnpSubscriptionRequest_new();\n\tUpnp_SID temp_sid;\n\tint return_code = 1;\n\tint time_out = 1801;\n\tservice_info *service;\n\tsubscription *sub;\n\tuuid_upnp uid;\n\tstruct Handle_Info *handle_info;\n\tvoid *cookie;\n\tUpnp_FunPtr callback_fun;\n\tUpnpDevice_Handle device_handle;\n\tmemptr nt_hdr;\n\tchar *event_url_path = NULL;\n\tmemptr callback_hdr;\n\tmemptr timeout_hdr;\n\tint rc = 0;\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"Subscription Request Received:\\n\");\n\n\tif (httpmsg_find_hdr(request, HDR_NT, &nt_hdr) == NULL) {\n\t\terror_respond(info, HTTP_BAD_REQUEST, request);\n\t\tgoto exit_function;\n\t}\n\n\t/* check NT header */\n\t/* Windows Millenium Interoperability: */\n\t/* we accept either upnp:event, or upnp:propchange for the NT header */\n\tif (memptr_cmp_nocase(&nt_hdr, \"upnp:event\") != 0) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, request);\n\t\tgoto exit_function;\n\t}\n\n\t/* if a SID is present then the we have a bad request \"incompatible headers\" */\n\tif (httpmsg_find_hdr(request, HDR_SID, NULL) != NULL) {\n\t\terror_respond(info, HTTP_BAD_REQUEST, request);\n\t\tgoto exit_function;\n\t}\n\t/* look up service by eventURL */\n\tevent_url_path = str_alloc(request->uri.pathquery.buff, request->uri.pathquery.size);\n\tif (event_url_path == NULL) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"SubscriptionRequest for event URL path: %s\\n\",\n\t\tevent_url_path);\n\n\tHandleLock();\n\n\t/* CURRENTLY, ONLY ONE DEVICE */\n\tif (GetDeviceHandleInfo(info->foreign_sockaddr.ss_family , \n\t    &device_handle, &handle_info) != HND_DEVICE) {\n\t\tfree(event_url_path);\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\tservice = FindServiceEventURLPath(&handle_info->ServiceTable, event_url_path);\n\tfree(event_url_path);\n\n\tif (service == NULL || !service->active) {\n\t\terror_respond(info, HTTP_NOT_FOUND, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"Subscription Request: Number of Subscriptions already %d\\n \"\n\t\t\"Max Subscriptions allowed: %d\\n\",\n\t\tservice->TotalSubscriptions,\n\t\thandle_info->MaxSubscriptions);\n\n\t/* too many subscriptions */\n\tif (handle_info->MaxSubscriptions != -1 &&\n\t    service->TotalSubscriptions >= handle_info->MaxSubscriptions) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\t/* generate new subscription */\n\tsub = (subscription *)malloc(sizeof (subscription));\n\tif (sub == NULL) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\tsub->eventKey = 0;\n\tsub->ToSendEventKey = 0;\n\tsub->active = 0;\n\tsub->next = NULL;\n\tsub->DeliveryURLs.size = 0;\n\tsub->DeliveryURLs.URLs = NULL;\n\tsub->DeliveryURLs.parsedURLs = NULL;\n\n\t/* check for valid callbacks */\n\tif (httpmsg_find_hdr( request, HDR_CALLBACK, &callback_hdr) == NULL) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, request);\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\treturn_code = create_url_list(&callback_hdr, &sub->DeliveryURLs);\n\tif (return_code == 0) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, request);\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\tif (return_code == UPNP_E_OUTOF_MEMORY) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\t/* set the timeout */\n\tif (httpmsg_find_hdr(request, HDR_TIMEOUT, &timeout_hdr) != NULL) {\n\t\tif (matchstr(timeout_hdr.buf, timeout_hdr.length,\n\t\t    \"%iSecond-%d%0\", &time_out) == PARSE_OK) {\n\t\t\t/* nothing */\n\t\t} else if(memptr_cmp_nocase(&timeout_hdr, \"Second-infinite\") == 0) {\n\t\t\t/* infinite timeout */\n\t\t\ttime_out = -1;\n\t\t} else {\n\t\t\t/* default is > 1800 seconds */\n\t\t\ttime_out = DEFAULT_TIMEOUT;\n\t\t}\n\t}\n\t/* replace infinite timeout with max timeout, if possible */\n\tif (handle_info->MaxSubscriptionTimeOut != -1) {\n\t\tif (time_out == -1 ||\n\t\t    time_out > handle_info->MaxSubscriptionTimeOut) {\n\t\t\ttime_out = handle_info->MaxSubscriptionTimeOut;\n\t\t}\n\t}\n\tif (time_out >= 0) {\n\t\tsub->expireTime = time(NULL) + time_out;\n\t} else {\n\t\t/* infinite time */\n\t\tsub->expireTime = 0;\n\t}\n\n\t/* generate SID */\n\tuuid_create(&uid);\n\tuuid_unpack(&uid, temp_sid);\n\trc = snprintf(sub->sid, sizeof(sub->sid), \"uuid:%s\", temp_sid);\n\n\t/* respond OK */\n\tif (rc < 0 || (unsigned int) rc >= sizeof(sub->sid) ||\n\t\t(respond_ok(info, time_out,\n\t\tsub, request) != UPNP_E_SUCCESS)) {\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\t/* add to subscription list */\n\tsub->next = service->subscriptionList;\n\tservice->subscriptionList = sub;\n\tservice->TotalSubscriptions++;\n\n\t/* finally generate callback for init table dump */\n\tUpnpSubscriptionRequest_strcpy_ServiceId(request_struct, service->serviceId);\n\tUpnpSubscriptionRequest_strcpy_UDN(request_struct, service->UDN);\n\tUpnpSubscriptionRequest_strcpy_SID(request_struct, sub->sid);\n\n\t/* copy callback */\n\tcallback_fun = handle_info->Callback;\n\tcookie = handle_info->Cookie;\n\n\tHandleUnlock();\n\n\t/* make call back with request struct */\n\t/* in the future should find a way of mainting that the handle */\n\t/* is not unregistered in the middle of a callback */\n\tcallback_fun(UPNP_EVENT_SUBSCRIPTION_REQUEST, request_struct, cookie);\n\nexit_function:\n\tUpnpSubscriptionRequest_delete(request_struct);\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpSubscriptionRequest_delete",
          "args": [
            "request_struct"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callback_fun",
          "args": [
            "UPNP_EVENT_SUBSCRIPTION_REQUEST",
            "request_struct",
            "cookie"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpSubscriptionRequest_strcpy_SID",
          "args": [
            "request_struct",
            "sub->sid"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpSubscriptionRequest_strcpy_UDN",
          "args": [
            "request_struct",
            "service->UDN"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpSubscriptionRequest_strcpy_ServiceId",
          "args": [
            "request_struct",
            "service->serviceId"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeSubscriptionList",
          "args": [
            "sub"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "freeSubscriptionList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "226-237",
          "snippet": "void\nfreeSubscriptionList( subscription * head )\n{\n    subscription *next = NULL;\n\n    while( head ) {\n        next = head->next;\n        freeSubscription( head );\n        free( head );\n        head = next;\n    }\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nvoid\nfreeSubscriptionList( subscription * head )\n{\n    subscription *next = NULL;\n\n    while( head ) {\n        next = head->next;\n        freeSubscription( head );\n        free( head );\n        head = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "respond_ok",
          "args": [
            "info",
            "time_out",
            "sub",
            "request"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "respond_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "1042-1097",
          "snippet": "static int respond_ok(\n\t/*! [in] Socket connection of request. */\n\tSOCKINFO *info,\n\t/*! [in] Accepted duration. */\n\tint time_out,\n\t/*! [in] Accepted subscription. */\n\tsubscription *sub,\n\t/*! [in] Http request. */\n\thttp_message_t *request)\n{\n    int major;\n    int minor;\n    membuffer response;\n    int return_code;\n    char timeout_str[100];\n    int upnp_timeout = UPNP_TIMEOUT;\n    int rc = 0;\n\n    http_CalcResponseVersion( request->major_version,\n                              request->minor_version, &major, &minor );\n\n    if( time_out >= 0 ) {\n        rc = snprintf( timeout_str, sizeof ( timeout_str ),\n                       \"TIMEOUT: Second-%d\", time_out );\n    } else {\n        memset( timeout_str, 0, sizeof( timeout_str ) );\n        strncpy( timeout_str, \"TIMEOUT: Second-infinite\",\n                 sizeof ( timeout_str ) - 1);\n    }\n    if (rc < 0 || (unsigned int) rc >= sizeof ( timeout_str ) ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request ); \n        return UPNP_E_OUTOF_MEMORY;\n    }\n\n    membuffer_init( &response );\n    response.size_inc = 30;\n    if( http_MakeMessage(\n        &response, major, minor,\n        \"R\" \"D\" \"S\" \"N\" \"Xc\" \"ssc\" \"scc\",\n        HTTP_OK,\n        (off_t)0,\n        X_USER_AGENT,\n        \"SID: \", sub->sid,\n        timeout_str ) != 0 ) {\n        membuffer_destroy( &response );\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n\n    return_code = http_SendMessage( info, &upnp_timeout, \"b\",\n                                    response.buf, response.length );\n\n    membuffer_destroy( &response );\n\n    return return_code;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic int respond_ok(\n\t/*! [in] Socket connection of request. */\n\tSOCKINFO *info,\n\t/*! [in] Accepted duration. */\n\tint time_out,\n\t/*! [in] Accepted subscription. */\n\tsubscription *sub,\n\t/*! [in] Http request. */\n\thttp_message_t *request)\n{\n    int major;\n    int minor;\n    membuffer response;\n    int return_code;\n    char timeout_str[100];\n    int upnp_timeout = UPNP_TIMEOUT;\n    int rc = 0;\n\n    http_CalcResponseVersion( request->major_version,\n                              request->minor_version, &major, &minor );\n\n    if( time_out >= 0 ) {\n        rc = snprintf( timeout_str, sizeof ( timeout_str ),\n                       \"TIMEOUT: Second-%d\", time_out );\n    } else {\n        memset( timeout_str, 0, sizeof( timeout_str ) );\n        strncpy( timeout_str, \"TIMEOUT: Second-infinite\",\n                 sizeof ( timeout_str ) - 1);\n    }\n    if (rc < 0 || (unsigned int) rc >= sizeof ( timeout_str ) ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request ); \n        return UPNP_E_OUTOF_MEMORY;\n    }\n\n    membuffer_init( &response );\n    response.size_inc = 30;\n    if( http_MakeMessage(\n        &response, major, minor,\n        \"R\" \"D\" \"S\" \"N\" \"Xc\" \"ssc\" \"scc\",\n        HTTP_OK,\n        (off_t)0,\n        X_USER_AGENT,\n        \"SID: \", sub->sid,\n        timeout_str ) != 0 ) {\n        membuffer_destroy( &response );\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n\n    return_code = http_SendMessage( info, &upnp_timeout, \"b\",\n                                    response.buf, response.length );\n\n    membuffer_destroy( &response );\n\n    return return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sub->sid",
            "sizeof(sub->sid)",
            "\"uuid:%s\"",
            "temp_sid"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_unpack",
          "args": [
            "&uid",
            "temp_sid"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_unpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "85-96",
          "snippet": "void uuid_unpack(uuid_upnp * u, char *out)\n{\n\tsprintf(out,\n\t\t\"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\",\n\t\t(unsigned int)u->time_low,\n\t\tu->time_mid,\n\t\tu->time_hi_and_version,\n\t\tu->clock_seq_hi_and_reserved,\n\t\tu->clock_seq_low,\n\t\tu->node[0],\n\t\tu->node[1], u->node[2], u->node[3], u->node[4], u->node[5]);\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"uuid.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
            "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
            "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\n\nvoid uuid_unpack(uuid_upnp * u, char *out)\n{\n\tsprintf(out,\n\t\t\"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\",\n\t\t(unsigned int)u->time_low,\n\t\tu->time_mid,\n\t\tu->time_hi_and_version,\n\t\tu->clock_seq_hi_and_reserved,\n\t\tu->clock_seq_low,\n\t\tu->node[0],\n\t\tu->node[1], u->node[2], u->node[3], u->node[4], u->node[5]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_create",
          "args": [
            "&uid"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "53-83",
          "snippet": "int uuid_create(uuid_upnp * uid)\n{\n\tuuid_time_t timestamp;\n\tuuid_time_t last_time;\n\tuint16_t clockseq;\n\tuuid_node_t node;\n\tuuid_node_t last_node;\n\tint f;\n\n\t/* acquire system wide lock so we're alone. */\n\tUUIDLock();\n\t/* get current time. */\n\tget_current_time(&timestamp);\n\t/* get node ID. */\n\tget_ieee_node_identifier(&node);\n\t/* get saved state from NV storage. */\n\tf = read_state(&clockseq, &last_time, &last_node);\n\t/* if no NV state, or if clock went backwards, or node ID changed\n\t * (e.g., net card swap) change clockseq. */\n\tif (!f || memcmp(&node, &last_node, sizeof(uuid_node_t)))\n\t\tclockseq = true_random();\n\telse if (timestamp < last_time)\n\t\tclockseq++;\n\t/* stuff fields into the UUID. */\n\tformat_uuid_v1(uid, clockseq, timestamp, node);\n\t/* save the state for next time. */\n\twrite_state(clockseq, timestamp, node);\n\tUUIDUnlock();\n\n\treturn 1;\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"uuid.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
            "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
            "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);",
            "static void get_current_time(uuid_time_t *timestamp);",
            "static uint16_t true_random(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\nstatic void get_current_time(uuid_time_t *timestamp);\nstatic uint16_t true_random(void);\n\nint uuid_create(uuid_upnp * uid)\n{\n\tuuid_time_t timestamp;\n\tuuid_time_t last_time;\n\tuint16_t clockseq;\n\tuuid_node_t node;\n\tuuid_node_t last_node;\n\tint f;\n\n\t/* acquire system wide lock so we're alone. */\n\tUUIDLock();\n\t/* get current time. */\n\tget_current_time(&timestamp);\n\t/* get node ID. */\n\tget_ieee_node_identifier(&node);\n\t/* get saved state from NV storage. */\n\tf = read_state(&clockseq, &last_time, &last_node);\n\t/* if no NV state, or if clock went backwards, or node ID changed\n\t * (e.g., net card swap) change clockseq. */\n\tif (!f || memcmp(&node, &last_node, sizeof(uuid_node_t)))\n\t\tclockseq = true_random();\n\telse if (timestamp < last_time)\n\t\tclockseq++;\n\t/* stuff fields into the UUID. */\n\tformat_uuid_v1(uid, clockseq, timestamp, node);\n\t/* save the state for next time. */\n\twrite_state(clockseq, timestamp, node);\n\tUUIDUnlock();\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "get_system_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/sysdep.c",
          "lines": "115-127",
          "snippet": "void get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpInet.h\"",
            "#include \"sysdep.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <string.h>\n#include \"UpnpInet.h\"\n#include \"sysdep.h\"\n#include \"config.h\"\n\nvoid get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memptr_cmp_nocase",
          "args": [
            "&timeout_hdr",
            "\"Second-infinite\""
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "memptr_cmp_nocase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "78-90",
          "snippet": "int memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "matchstr",
          "args": [
            "timeout_hdr.buf",
            "timeout_hdr.length",
            "\"%iSecond-%d%0\"",
            "&time_out"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "matchstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1168-1203",
          "snippet": "parse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "request",
            "HDR_TIMEOUT",
            "&timeout_hdr"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_respond",
          "args": [
            "info",
            "HTTP_INTERNAL_SERVER_ERROR",
            "request"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "error_respond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_callback2.c",
          "lines": "58-71",
          "snippet": "void\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena_ctrlpt.h\"",
            "#include \"gena_device.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena_ctrlpt.h\"\n#include \"gena_device.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nvoid\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_url_list",
          "args": [
            "&callback_hdr",
            "&sub->DeliveryURLs"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "create_url_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "1110-1183",
          "snippet": "static int create_url_list(\n\t/*! [in] . */\n\tmemptr *url_list,\n\t/*! [out] . */\n\tURL_list *out)\n{\n    size_t URLcount = 0;\n    size_t i;\n    int return_code = 0;\n    uri_type temp;\n    token urls;\n    token *URLS;\n\n    urls.buff = url_list->buf;\n    urls.size = url_list->length;\n    URLS = &urls;\n\n    out->size = 0;\n    out->URLs = NULL;\n    out->parsedURLs = NULL;\n\n    for( i = 0; i < URLS->size; i++ ) {\n        if( ( URLS->buff[i] == '<' ) && ( i + 1 < URLS->size ) ) {\n            if( ( ( return_code = parse_uri( &URLS->buff[i + 1],\n                                             URLS->size - i + 1,\n                                             &temp ) ) == HTTP_SUCCESS )\n                && ( temp.hostport.text.size != 0 ) ) {\n                URLcount++;\n            } else {\n                if( return_code == UPNP_E_OUTOF_MEMORY ) {\n                    return return_code;\n                }\n            }\n        }\n    }\n\n    if( URLcount > 0 ) {\n        out->URLs = malloc(URLS->size + 1);\n        out->parsedURLs = malloc(sizeof(uri_type) * URLcount);\n        if (!out->URLs || !out->parsedURLs) {\n            free(out->URLs);\n            free(out->parsedURLs);\n            out->URLs = NULL;\n            out->parsedURLs = NULL;\n            return UPNP_E_OUTOF_MEMORY;\n        }\n        memcpy( out->URLs, URLS->buff, URLS->size );\n        out->URLs[URLS->size] = 0;\n        URLcount = 0;\n        for( i = 0; i < URLS->size; i++ ) {\n            if( ( URLS->buff[i] == '<' ) && ( i + 1 < URLS->size ) ) {\n                if( ( ( return_code =\n                        parse_uri( &out->URLs[i + 1], URLS->size - i + 1,\n                                   &out->parsedURLs[URLcount] ) ) ==\n                      HTTP_SUCCESS )\n                    && ( out->parsedURLs[URLcount].hostport.text.size !=\n                         0 ) ) {\n                    URLcount++;\n                } else {\n                    if( return_code == UPNP_E_OUTOF_MEMORY ) {\n                        free( out->URLs );\n                        free( out->parsedURLs );\n                        out->URLs = NULL;\n                        out->parsedURLs = NULL;\n                        return return_code;\n                    }\n                }\n            }\n        }\n    }\n    out->size = URLcount;\n\n    return (int)URLcount;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic int create_url_list(\n\t/*! [in] . */\n\tmemptr *url_list,\n\t/*! [out] . */\n\tURL_list *out)\n{\n    size_t URLcount = 0;\n    size_t i;\n    int return_code = 0;\n    uri_type temp;\n    token urls;\n    token *URLS;\n\n    urls.buff = url_list->buf;\n    urls.size = url_list->length;\n    URLS = &urls;\n\n    out->size = 0;\n    out->URLs = NULL;\n    out->parsedURLs = NULL;\n\n    for( i = 0; i < URLS->size; i++ ) {\n        if( ( URLS->buff[i] == '<' ) && ( i + 1 < URLS->size ) ) {\n            if( ( ( return_code = parse_uri( &URLS->buff[i + 1],\n                                             URLS->size - i + 1,\n                                             &temp ) ) == HTTP_SUCCESS )\n                && ( temp.hostport.text.size != 0 ) ) {\n                URLcount++;\n            } else {\n                if( return_code == UPNP_E_OUTOF_MEMORY ) {\n                    return return_code;\n                }\n            }\n        }\n    }\n\n    if( URLcount > 0 ) {\n        out->URLs = malloc(URLS->size + 1);\n        out->parsedURLs = malloc(sizeof(uri_type) * URLcount);\n        if (!out->URLs || !out->parsedURLs) {\n            free(out->URLs);\n            free(out->parsedURLs);\n            out->URLs = NULL;\n            out->parsedURLs = NULL;\n            return UPNP_E_OUTOF_MEMORY;\n        }\n        memcpy( out->URLs, URLS->buff, URLS->size );\n        out->URLs[URLS->size] = 0;\n        URLcount = 0;\n        for( i = 0; i < URLS->size; i++ ) {\n            if( ( URLS->buff[i] == '<' ) && ( i + 1 < URLS->size ) ) {\n                if( ( ( return_code =\n                        parse_uri( &out->URLs[i + 1], URLS->size - i + 1,\n                                   &out->parsedURLs[URLcount] ) ) ==\n                      HTTP_SUCCESS )\n                    && ( out->parsedURLs[URLcount].hostport.text.size !=\n                         0 ) ) {\n                    URLcount++;\n                } else {\n                    if( return_code == UPNP_E_OUTOF_MEMORY ) {\n                        free( out->URLs );\n                        free( out->parsedURLs );\n                        out->URLs = NULL;\n                        out->parsedURLs = NULL;\n                        return return_code;\n                    }\n                }\n            }\n        }\n    }\n    out->size = URLcount;\n\n    return (int)URLcount;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (subscription)"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "GENA",
            "__FILE__",
            "__LINE__",
            "\"Subscription Request: Number of Subscriptions already %d\\n \"\n\t\t\"Max Subscriptions allowed: %d\\n\"",
            "service->TotalSubscriptions",
            "handle_info->MaxSubscriptions"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "event_url_path"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindServiceEventURLPath",
          "args": [
            "&handle_info->ServiceTable",
            "event_url_path"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "FindServiceEventURLPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "294-326",
          "snippet": "service_info *\nFindServiceEventURLPath( service_table * table,\n                         char *eventURLPath )\n{\n    service_info *finger = NULL;\n    uri_type parsed_url;\n    uri_type parsed_url_in;\n\n    if( ( table )\n        &&\n        ( parse_uri( eventURLPath,\n                     strlen( eventURLPath ),\n                     &parsed_url_in ) == HTTP_SUCCESS ) ) {\n\n        finger = table->serviceList;\n        while( finger ) {\n            if( finger->eventURL )\n                if( ( parse_uri\n                      ( finger->eventURL, strlen( finger->eventURL ),\n                        &parsed_url ) == HTTP_SUCCESS ) ) {\n\n                    if( !token_cmp\n                        ( &parsed_url.pathquery,\n                          &parsed_url_in.pathquery ) )\n                        return finger;\n\n                }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nservice_info *\nFindServiceEventURLPath( service_table * table,\n                         char *eventURLPath )\n{\n    service_info *finger = NULL;\n    uri_type parsed_url;\n    uri_type parsed_url_in;\n\n    if( ( table )\n        &&\n        ( parse_uri( eventURLPath,\n                     strlen( eventURLPath ),\n                     &parsed_url_in ) == HTTP_SUCCESS ) ) {\n\n        finger = table->serviceList;\n        while( finger ) {\n            if( finger->eventURL )\n                if( ( parse_uri\n                      ( finger->eventURL, strlen( finger->eventURL ),\n                        &parsed_url ) == HTTP_SUCCESS ) ) {\n\n                    if( !token_cmp\n                        ( &parsed_url.pathquery,\n                          &parsed_url_in.pathquery ) )\n                        return finger;\n\n                }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDeviceHandleInfo",
          "args": [
            "info->foreign_sockaddr.ss_family",
            "&device_handle",
            "&handle_info"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "GetDeviceHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3849-3878",
          "snippet": "Upnp_Handle_Type GetDeviceHandleInfo(\n\tint AddressFamily,\n\tUpnpDevice_Handle *device_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\t/* Check if we've got a registered device of the address family specified. */\n\tif ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||\n\t    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {\n\t\t*device_handle_out = -1;\n\t\treturn HND_INVALID;\n\t}\n\n\t/* Find it. */\n\tfor (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {\n\t\tswitch (GetHandleInfo(*device_handle_out, HndInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tif ((*HndInfo)->DeviceAf == AddressFamily) {\n\t\t\t\treturn HND_DEVICE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif /* INCLUDE_DEVICE_APIS */\n\n\t*device_handle_out = -1;\n\treturn HND_INVALID;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "int UpnpSdkDeviceRegisteredV4 = 0;",
            "int UpnpSdkDeviceregisteredV6 = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nint UpnpSdkDeviceRegisteredV4 = 0;\nint UpnpSdkDeviceregisteredV6 = 0;\n\nUpnp_Handle_Type GetDeviceHandleInfo(\n\tint AddressFamily,\n\tUpnpDevice_Handle *device_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\t/* Check if we've got a registered device of the address family specified. */\n\tif ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||\n\t    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {\n\t\t*device_handle_out = -1;\n\t\treturn HND_INVALID;\n\t}\n\n\t/* Find it. */\n\tfor (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {\n\t\tswitch (GetHandleInfo(*device_handle_out, HndInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tif ((*HndInfo)->DeviceAf == AddressFamily) {\n\t\t\t\treturn HND_DEVICE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif /* INCLUDE_DEVICE_APIS */\n\n\t*device_handle_out = -1;\n\treturn HND_INVALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_alloc",
          "args": [
            "request->uri.pathquery.buff",
            "request->uri.pathquery.size"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "str_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "48-61",
          "snippet": "char *str_alloc(const char *str, size_t str_len)\n{\n\tchar *s;\n\n\ts = (char *)malloc(str_len + (size_t)1);\n\tif (s == NULL) {\n\t\treturn NULL;\t/* no mem */\n\t}\n\n\tmemcpy(s, str, str_len);\n\ts[str_len] = '\\0';\n\n\treturn s;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nchar *str_alloc(const char *str, size_t str_len)\n{\n\tchar *s;\n\n\ts = (char *)malloc(str_len + (size_t)1);\n\tif (s == NULL) {\n\t\treturn NULL;\t/* no mem */\n\t}\n\n\tmemcpy(s, str, str_len);\n\ts[str_len] = '\\0';\n\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpSubscriptionRequest_new",
          "args": [],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nvoid gena_process_subscription_request(\n\tSOCKINFO *info,\n\thttp_message_t *request)\n{\n\tUpnpSubscriptionRequest *request_struct = UpnpSubscriptionRequest_new();\n\tUpnp_SID temp_sid;\n\tint return_code = 1;\n\tint time_out = 1801;\n\tservice_info *service;\n\tsubscription *sub;\n\tuuid_upnp uid;\n\tstruct Handle_Info *handle_info;\n\tvoid *cookie;\n\tUpnp_FunPtr callback_fun;\n\tUpnpDevice_Handle device_handle;\n\tmemptr nt_hdr;\n\tchar *event_url_path = NULL;\n\tmemptr callback_hdr;\n\tmemptr timeout_hdr;\n\tint rc = 0;\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"Subscription Request Received:\\n\");\n\n\tif (httpmsg_find_hdr(request, HDR_NT, &nt_hdr) == NULL) {\n\t\terror_respond(info, HTTP_BAD_REQUEST, request);\n\t\tgoto exit_function;\n\t}\n\n\t/* check NT header */\n\t/* Windows Millenium Interoperability: */\n\t/* we accept either upnp:event, or upnp:propchange for the NT header */\n\tif (memptr_cmp_nocase(&nt_hdr, \"upnp:event\") != 0) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, request);\n\t\tgoto exit_function;\n\t}\n\n\t/* if a SID is present then the we have a bad request \"incompatible headers\" */\n\tif (httpmsg_find_hdr(request, HDR_SID, NULL) != NULL) {\n\t\terror_respond(info, HTTP_BAD_REQUEST, request);\n\t\tgoto exit_function;\n\t}\n\t/* look up service by eventURL */\n\tevent_url_path = str_alloc(request->uri.pathquery.buff, request->uri.pathquery.size);\n\tif (event_url_path == NULL) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"SubscriptionRequest for event URL path: %s\\n\",\n\t\tevent_url_path);\n\n\tHandleLock();\n\n\t/* CURRENTLY, ONLY ONE DEVICE */\n\tif (GetDeviceHandleInfo(info->foreign_sockaddr.ss_family , \n\t    &device_handle, &handle_info) != HND_DEVICE) {\n\t\tfree(event_url_path);\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\tservice = FindServiceEventURLPath(&handle_info->ServiceTable, event_url_path);\n\tfree(event_url_path);\n\n\tif (service == NULL || !service->active) {\n\t\terror_respond(info, HTTP_NOT_FOUND, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"Subscription Request: Number of Subscriptions already %d\\n \"\n\t\t\"Max Subscriptions allowed: %d\\n\",\n\t\tservice->TotalSubscriptions,\n\t\thandle_info->MaxSubscriptions);\n\n\t/* too many subscriptions */\n\tif (handle_info->MaxSubscriptions != -1 &&\n\t    service->TotalSubscriptions >= handle_info->MaxSubscriptions) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\t/* generate new subscription */\n\tsub = (subscription *)malloc(sizeof (subscription));\n\tif (sub == NULL) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\tsub->eventKey = 0;\n\tsub->ToSendEventKey = 0;\n\tsub->active = 0;\n\tsub->next = NULL;\n\tsub->DeliveryURLs.size = 0;\n\tsub->DeliveryURLs.URLs = NULL;\n\tsub->DeliveryURLs.parsedURLs = NULL;\n\n\t/* check for valid callbacks */\n\tif (httpmsg_find_hdr( request, HDR_CALLBACK, &callback_hdr) == NULL) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, request);\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\treturn_code = create_url_list(&callback_hdr, &sub->DeliveryURLs);\n\tif (return_code == 0) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, request);\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\tif (return_code == UPNP_E_OUTOF_MEMORY) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\t/* set the timeout */\n\tif (httpmsg_find_hdr(request, HDR_TIMEOUT, &timeout_hdr) != NULL) {\n\t\tif (matchstr(timeout_hdr.buf, timeout_hdr.length,\n\t\t    \"%iSecond-%d%0\", &time_out) == PARSE_OK) {\n\t\t\t/* nothing */\n\t\t} else if(memptr_cmp_nocase(&timeout_hdr, \"Second-infinite\") == 0) {\n\t\t\t/* infinite timeout */\n\t\t\ttime_out = -1;\n\t\t} else {\n\t\t\t/* default is > 1800 seconds */\n\t\t\ttime_out = DEFAULT_TIMEOUT;\n\t\t}\n\t}\n\t/* replace infinite timeout with max timeout, if possible */\n\tif (handle_info->MaxSubscriptionTimeOut != -1) {\n\t\tif (time_out == -1 ||\n\t\t    time_out > handle_info->MaxSubscriptionTimeOut) {\n\t\t\ttime_out = handle_info->MaxSubscriptionTimeOut;\n\t\t}\n\t}\n\tif (time_out >= 0) {\n\t\tsub->expireTime = time(NULL) + time_out;\n\t} else {\n\t\t/* infinite time */\n\t\tsub->expireTime = 0;\n\t}\n\n\t/* generate SID */\n\tuuid_create(&uid);\n\tuuid_unpack(&uid, temp_sid);\n\trc = snprintf(sub->sid, sizeof(sub->sid), \"uuid:%s\", temp_sid);\n\n\t/* respond OK */\n\tif (rc < 0 || (unsigned int) rc >= sizeof(sub->sid) ||\n\t\t(respond_ok(info, time_out,\n\t\tsub, request) != UPNP_E_SUCCESS)) {\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\t/* add to subscription list */\n\tsub->next = service->subscriptionList;\n\tservice->subscriptionList = sub;\n\tservice->TotalSubscriptions++;\n\n\t/* finally generate callback for init table dump */\n\tUpnpSubscriptionRequest_strcpy_ServiceId(request_struct, service->serviceId);\n\tUpnpSubscriptionRequest_strcpy_UDN(request_struct, service->UDN);\n\tUpnpSubscriptionRequest_strcpy_SID(request_struct, sub->sid);\n\n\t/* copy callback */\n\tcallback_fun = handle_info->Callback;\n\tcookie = handle_info->Cookie;\n\n\tHandleUnlock();\n\n\t/* make call back with request struct */\n\t/* in the future should find a way of mainting that the handle */\n\t/* is not unregistered in the middle of a callback */\n\tcallback_fun(UPNP_EVENT_SUBSCRIPTION_REQUEST, request_struct, cookie);\n\nexit_function:\n\tUpnpSubscriptionRequest_delete(request_struct);\n}"
  },
  {
    "function_name": "create_url_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "1110-1183",
    "snippet": "static int create_url_list(\n\t/*! [in] . */\n\tmemptr *url_list,\n\t/*! [out] . */\n\tURL_list *out)\n{\n    size_t URLcount = 0;\n    size_t i;\n    int return_code = 0;\n    uri_type temp;\n    token urls;\n    token *URLS;\n\n    urls.buff = url_list->buf;\n    urls.size = url_list->length;\n    URLS = &urls;\n\n    out->size = 0;\n    out->URLs = NULL;\n    out->parsedURLs = NULL;\n\n    for( i = 0; i < URLS->size; i++ ) {\n        if( ( URLS->buff[i] == '<' ) && ( i + 1 < URLS->size ) ) {\n            if( ( ( return_code = parse_uri( &URLS->buff[i + 1],\n                                             URLS->size - i + 1,\n                                             &temp ) ) == HTTP_SUCCESS )\n                && ( temp.hostport.text.size != 0 ) ) {\n                URLcount++;\n            } else {\n                if( return_code == UPNP_E_OUTOF_MEMORY ) {\n                    return return_code;\n                }\n            }\n        }\n    }\n\n    if( URLcount > 0 ) {\n        out->URLs = malloc(URLS->size + 1);\n        out->parsedURLs = malloc(sizeof(uri_type) * URLcount);\n        if (!out->URLs || !out->parsedURLs) {\n            free(out->URLs);\n            free(out->parsedURLs);\n            out->URLs = NULL;\n            out->parsedURLs = NULL;\n            return UPNP_E_OUTOF_MEMORY;\n        }\n        memcpy( out->URLs, URLS->buff, URLS->size );\n        out->URLs[URLS->size] = 0;\n        URLcount = 0;\n        for( i = 0; i < URLS->size; i++ ) {\n            if( ( URLS->buff[i] == '<' ) && ( i + 1 < URLS->size ) ) {\n                if( ( ( return_code =\n                        parse_uri( &out->URLs[i + 1], URLS->size - i + 1,\n                                   &out->parsedURLs[URLcount] ) ) ==\n                      HTTP_SUCCESS )\n                    && ( out->parsedURLs[URLcount].hostport.text.size !=\n                         0 ) ) {\n                    URLcount++;\n                } else {\n                    if( return_code == UPNP_E_OUTOF_MEMORY ) {\n                        free( out->URLs );\n                        free( out->parsedURLs );\n                        out->URLs = NULL;\n                        out->parsedURLs = NULL;\n                        return return_code;\n                    }\n                }\n            }\n        }\n    }\n    out->size = URLcount;\n\n    return (int)URLcount;\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "out->parsedURLs"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_uri",
          "args": [
            "&out->URLs[i + 1]",
            "URLS->size - i + 1",
            "&out->parsedURLs[URLcount]"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uri_and_unescape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "759-775",
          "snippet": "int parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out->URLs",
            "URLS->buff",
            "URLS->size"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(uri_type) * URLcount"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "URLS->size + 1"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic int create_url_list(\n\t/*! [in] . */\n\tmemptr *url_list,\n\t/*! [out] . */\n\tURL_list *out)\n{\n    size_t URLcount = 0;\n    size_t i;\n    int return_code = 0;\n    uri_type temp;\n    token urls;\n    token *URLS;\n\n    urls.buff = url_list->buf;\n    urls.size = url_list->length;\n    URLS = &urls;\n\n    out->size = 0;\n    out->URLs = NULL;\n    out->parsedURLs = NULL;\n\n    for( i = 0; i < URLS->size; i++ ) {\n        if( ( URLS->buff[i] == '<' ) && ( i + 1 < URLS->size ) ) {\n            if( ( ( return_code = parse_uri( &URLS->buff[i + 1],\n                                             URLS->size - i + 1,\n                                             &temp ) ) == HTTP_SUCCESS )\n                && ( temp.hostport.text.size != 0 ) ) {\n                URLcount++;\n            } else {\n                if( return_code == UPNP_E_OUTOF_MEMORY ) {\n                    return return_code;\n                }\n            }\n        }\n    }\n\n    if( URLcount > 0 ) {\n        out->URLs = malloc(URLS->size + 1);\n        out->parsedURLs = malloc(sizeof(uri_type) * URLcount);\n        if (!out->URLs || !out->parsedURLs) {\n            free(out->URLs);\n            free(out->parsedURLs);\n            out->URLs = NULL;\n            out->parsedURLs = NULL;\n            return UPNP_E_OUTOF_MEMORY;\n        }\n        memcpy( out->URLs, URLS->buff, URLS->size );\n        out->URLs[URLS->size] = 0;\n        URLcount = 0;\n        for( i = 0; i < URLS->size; i++ ) {\n            if( ( URLS->buff[i] == '<' ) && ( i + 1 < URLS->size ) ) {\n                if( ( ( return_code =\n                        parse_uri( &out->URLs[i + 1], URLS->size - i + 1,\n                                   &out->parsedURLs[URLcount] ) ) ==\n                      HTTP_SUCCESS )\n                    && ( out->parsedURLs[URLcount].hostport.text.size !=\n                         0 ) ) {\n                    URLcount++;\n                } else {\n                    if( return_code == UPNP_E_OUTOF_MEMORY ) {\n                        free( out->URLs );\n                        free( out->parsedURLs );\n                        out->URLs = NULL;\n                        out->parsedURLs = NULL;\n                        return return_code;\n                    }\n                }\n            }\n        }\n    }\n    out->size = URLcount;\n\n    return (int)URLcount;\n}"
  },
  {
    "function_name": "respond_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "1042-1097",
    "snippet": "static int respond_ok(\n\t/*! [in] Socket connection of request. */\n\tSOCKINFO *info,\n\t/*! [in] Accepted duration. */\n\tint time_out,\n\t/*! [in] Accepted subscription. */\n\tsubscription *sub,\n\t/*! [in] Http request. */\n\thttp_message_t *request)\n{\n    int major;\n    int minor;\n    membuffer response;\n    int return_code;\n    char timeout_str[100];\n    int upnp_timeout = UPNP_TIMEOUT;\n    int rc = 0;\n\n    http_CalcResponseVersion( request->major_version,\n                              request->minor_version, &major, &minor );\n\n    if( time_out >= 0 ) {\n        rc = snprintf( timeout_str, sizeof ( timeout_str ),\n                       \"TIMEOUT: Second-%d\", time_out );\n    } else {\n        memset( timeout_str, 0, sizeof( timeout_str ) );\n        strncpy( timeout_str, \"TIMEOUT: Second-infinite\",\n                 sizeof ( timeout_str ) - 1);\n    }\n    if (rc < 0 || (unsigned int) rc >= sizeof ( timeout_str ) ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request ); \n        return UPNP_E_OUTOF_MEMORY;\n    }\n\n    membuffer_init( &response );\n    response.size_inc = 30;\n    if( http_MakeMessage(\n        &response, major, minor,\n        \"R\" \"D\" \"S\" \"N\" \"Xc\" \"ssc\" \"scc\",\n        HTTP_OK,\n        (off_t)0,\n        X_USER_AGENT,\n        \"SID: \", sub->sid,\n        timeout_str ) != 0 ) {\n        membuffer_destroy( &response );\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n\n    return_code = http_SendMessage( info, &upnp_timeout, \"b\",\n                                    response.buf, response.length );\n\n    membuffer_destroy( &response );\n\n    return return_code;\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&response"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_SendMessage",
          "args": [
            "info",
            "&upnp_timeout",
            "\"b\"",
            "response.buf",
            "response.length"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "437-613",
          "snippet": "int http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CHUNK_TAIL_SIZE (size_t)10",
            "#define CHUNK_HEADER_SIZE (size_t)10",
            "#define snprintf _snprintf",
            "#define fseeko fseek"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n#define snprintf _snprintf\n#define fseeko fseek\n\nint http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error_respond",
          "args": [
            "info",
            "HTTP_INTERNAL_SERVER_ERROR",
            "request"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "error_respond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_callback2.c",
          "lines": "58-71",
          "snippet": "void\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena_ctrlpt.h\"",
            "#include \"gena_device.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena_ctrlpt.h\"\n#include \"gena_device.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nvoid\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&response",
            "major",
            "minor",
            "\"R\" \"D\" \"S\" \"N\" \"Xc\" \"ssc\" \"scc\"",
            "HTTP_OK",
            "(off_t)0",
            "X_USER_AGENT",
            "\"SID: \"",
            "sub->sid",
            "timeout_str"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&response"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "timeout_str",
            "\"TIMEOUT: Second-infinite\"",
            "sizeof ( timeout_str ) - 1"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "timeout_str",
            "0",
            "sizeof( timeout_str )"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "timeout_str",
            "sizeof ( timeout_str )",
            "\"TIMEOUT: Second-%d\"",
            "time_out"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_CalcResponseVersion",
          "args": [
            "request->major_version",
            "request->minor_version",
            "&major",
            "&minor"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "http_CalcResponseVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1720-1733",
          "snippet": "void http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nvoid http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic int respond_ok(\n\t/*! [in] Socket connection of request. */\n\tSOCKINFO *info,\n\t/*! [in] Accepted duration. */\n\tint time_out,\n\t/*! [in] Accepted subscription. */\n\tsubscription *sub,\n\t/*! [in] Http request. */\n\thttp_message_t *request)\n{\n    int major;\n    int minor;\n    membuffer response;\n    int return_code;\n    char timeout_str[100];\n    int upnp_timeout = UPNP_TIMEOUT;\n    int rc = 0;\n\n    http_CalcResponseVersion( request->major_version,\n                              request->minor_version, &major, &minor );\n\n    if( time_out >= 0 ) {\n        rc = snprintf( timeout_str, sizeof ( timeout_str ),\n                       \"TIMEOUT: Second-%d\", time_out );\n    } else {\n        memset( timeout_str, 0, sizeof( timeout_str ) );\n        strncpy( timeout_str, \"TIMEOUT: Second-infinite\",\n                 sizeof ( timeout_str ) - 1);\n    }\n    if (rc < 0 || (unsigned int) rc >= sizeof ( timeout_str ) ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request ); \n        return UPNP_E_OUTOF_MEMORY;\n    }\n\n    membuffer_init( &response );\n    response.size_inc = 30;\n    if( http_MakeMessage(\n        &response, major, minor,\n        \"R\" \"D\" \"S\" \"N\" \"Xc\" \"ssc\" \"scc\",\n        HTTP_OK,\n        (off_t)0,\n        X_USER_AGENT,\n        \"SID: \", sub->sid,\n        timeout_str ) != 0 ) {\n        membuffer_destroy( &response );\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return UPNP_E_OUTOF_MEMORY;\n    }\n\n    return_code = http_SendMessage( info, &upnp_timeout, \"b\",\n                                    response.buf, response.length );\n\n    membuffer_destroy( &response );\n\n    return return_code;\n}"
  },
  {
    "function_name": "genaNotifyAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "896-1034",
    "snippet": "int genaNotifyAll(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tchar **VarNames,\n\tchar **VarValues,\n\tint var_count)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *finger = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN NOTIFY ALL\");\n\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif( servId_copy == NULL ) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tret = GeneratePropertySet(VarNames, VarValues, var_count, &propertySet);\n\tif (ret != XML_SUCCESS) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN EXT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t} else {\n\t\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\t\tif (service != NULL) {\n\t\t\tfinger = GetFirstSubscription(service);\n\t\t\twhile (finger) {\n\t\t\t\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\t\t\t\tif (thread_struct == NULL) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t(*reference_count)++;\n\t\t\t\tthread_struct->reference_count = reference_count;\n\t\t\t\tthread_struct->UDN = UDN_copy;\n\t\t\t\tthread_struct->servId = servId_copy;\n\t\t\t\tthread_struct->headers = headers;\n\t\t\t\tthread_struct->propertySet = propertySet;\n\t\t\t\tmemset(thread_struct->sid, 0,\n\t\t\t\t\tsizeof(thread_struct->sid));\n\t\t\t\tstrncpy(thread_struct->sid, finger->sid,\n\t\t\t\t\tsizeof(thread_struct->sid) - 1);\n\t\t\t\tthread_struct->eventKey = finger->eventKey++;\n\t\t\t\tthread_struct->device_handle = device_handle;\n\t\t\t\t/* if overflow, wrap to 1 */\n\t\t\t\tif (finger->eventKey < 0) {\n\t\t\t\t\tfinger->eventKey = 1;\n\t\t\t\t}\n\n\n\t\t\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\t\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\t\t\tline = __LINE__;\n\t\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfinger = GetNextSubscription(service, finger);\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_E_BAD_SERVICE;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || *reference_count == 0) {\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END NOTIFY ALL, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "GENA",
            "__FILE__",
            "line",
            "\"GENA END NOTIFY ALL, ret = %d\"",
            "ret"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "reference_count"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "propertySet"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNextSubscription",
          "args": [
            "service",
            "finger"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "GetNextSubscription",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "159-189",
          "snippet": "subscription *GetNextSubscription(service_info *service, subscription *current)\n{\n    time_t current_time;\n    subscription *next = NULL;\n    subscription *previous = NULL;\n    int notDone = 1;\n\n    /* get the current_time */\n    time( &current_time );\n    while( ( notDone ) && ( current ) ) {\n        previous = current;\n        current = current->next;\n\n        if( current == NULL ) {\n            notDone = 0;\n            next = current;\n        } else\n            if( ( current->expireTime != 0 )\n                && ( current->expireTime < current_time ) ) {\n            previous->next = current->next;\n            current->next = NULL;\n            freeSubscriptionList( current );\n            current = previous;\n            service->TotalSubscriptions--;\n        } else if( current->active ) {\n            notDone = 0;\n            next = current;\n        }\n    }\n    return next;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nsubscription *GetNextSubscription(service_info *service, subscription *current)\n{\n    time_t current_time;\n    subscription *next = NULL;\n    subscription *previous = NULL;\n    int notDone = 1;\n\n    /* get the current_time */\n    time( &current_time );\n    while( ( notDone ) && ( current ) ) {\n        previous = current;\n        current = current->next;\n\n        if( current == NULL ) {\n            notDone = 0;\n            next = current;\n        } else\n            if( ( current->expireTime != 0 )\n                && ( current->expireTime < current_time ) ) {\n            previous->next = current->next;\n            current->next = NULL;\n            freeSubscriptionList( current );\n            current = previous;\n            service->TotalSubscriptions--;\n        } else if( current->active ) {\n            notDone = 0;\n            next = current;\n        }\n    }\n    return next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gSendThreadPool",
            "&job",
            "NULL"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "(free_routine)free_notify_struct"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "(start_routine)genaNotifyThread",
            "thread_struct"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "thread_struct->sid",
            "finger->sid",
            "sizeof(thread_struct->sid) - 1"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "thread_struct->sid",
            "0",
            "sizeof(thread_struct->sid)"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (notify_thread_struct)"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetFirstSubscription",
          "args": [
            "service"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "GetFirstSubscription",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "192-203",
          "snippet": "subscription *GetFirstSubscription(service_info *service)\n{\n\tsubscription temp;\n\tsubscription *next = NULL;\n\n\ttemp.next = service->subscriptionList;\n\tnext = GetNextSubscription(service, &temp);\n\tservice->subscriptionList = temp.next;\n\t/* service->subscriptionList = next; */\n\t\n\treturn next;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nsubscription *GetFirstSubscription(service_info *service)\n{\n\tsubscription temp;\n\tsubscription *next = NULL;\n\n\ttemp.next = service->subscriptionList;\n\tnext = GetNextSubscription(service, &temp);\n\tservice->subscriptionList = temp.next;\n\t/* service->subscriptionList = next; */\n\t\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindServiceId",
          "args": [
            "&handle_info->ServiceTable",
            "servId",
            "UDN"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "FindServiceId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "257-276",
          "snippet": "service_info *\nFindServiceId( service_table * table,\n               const char *serviceId,\n               const char *UDN )\n{\n    service_info *finger = NULL;\n\n    if( table ) {\n        finger = table->serviceList;\n        while( finger ) {\n            if( ( !strcmp( serviceId, finger->serviceId ) ) &&\n                ( !strcmp( UDN, finger->UDN ) ) ) {\n                return finger;\n            }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nservice_info *\nFindServiceId( service_table * table,\n               const char *serviceId,\n               const char *UDN )\n{\n    service_info *finger = NULL;\n\n    if( table ) {\n        finger = table->serviceList;\n        while( finger ) {\n            if( ( !strcmp( serviceId, finger->serviceId ) ) &&\n                ( !strcmp( UDN, finger->UDN ) ) ) {\n                return finger;\n            }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "device_handle",
            "&handle_info"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocGenaHeaders",
          "args": [
            "propertySet"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "AllocGenaHeaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "399-443",
          "snippet": "static char *AllocGenaHeaders(\n\t/*! [in] The property set string. */\n\tconst DOMString propertySet)\n{\n\tstatic const char *HEADER_LINE_1 =\n\t\t\"CONTENT-TYPE: text/xml; charset=\\\"utf-8\\\"\\r\\n\";\n\tstatic const char *HEADER_LINE_2A =\n\t\t\"CONTENT-LENGTH: \";\n\tstatic const char *HEADER_LINE_2B =\n\t\t\"\\r\\n\";\n\tstatic const char *HEADER_LINE_3 =\n\t\t\"NT: upnp:event\\r\\n\";\n\tstatic const char *HEADER_LINE_4 =\n\t\t\"NTS: upnp:propchange\\r\\n\";\n\tchar *headers = NULL;\n\tsize_t headers_size = 0;\n\tint line = 0;\n\tint rc = 0;\n\n\theaders_size =\n\t\tstrlen(HEADER_LINE_1 ) +\n\t\tstrlen(HEADER_LINE_2A) + MAX_CONTENT_LENGTH +\n\t\tstrlen(HEADER_LINE_2B) +\n\t\tstrlen(HEADER_LINE_3 ) +\n\t\tstrlen(HEADER_LINE_4 ) + 1;\n\theaders = (char *)malloc(headers_size);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\trc = snprintf(headers, headers_size, \"%s%s%\"PRIzu\"%s%s%s\",\n\t\tHEADER_LINE_1,\n\t\tHEADER_LINE_2A,\n\t\tstrlen(propertySet) + 2,\n\t\tHEADER_LINE_2B,\n\t\tHEADER_LINE_3,\n\t\tHEADER_LINE_4);\n\nExitFunction:\n\tif (headers == NULL || rc < 0 || (unsigned int) rc >= headers_size) {\n\t\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, line,\n\t\t\t\"AllocGenaHeaders(): Error UPNP_E_OUTOF_MEMORY\\n\");\n\t}\n\treturn headers;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic char *AllocGenaHeaders(\n\t/*! [in] The property set string. */\n\tconst DOMString propertySet)\n{\n\tstatic const char *HEADER_LINE_1 =\n\t\t\"CONTENT-TYPE: text/xml; charset=\\\"utf-8\\\"\\r\\n\";\n\tstatic const char *HEADER_LINE_2A =\n\t\t\"CONTENT-LENGTH: \";\n\tstatic const char *HEADER_LINE_2B =\n\t\t\"\\r\\n\";\n\tstatic const char *HEADER_LINE_3 =\n\t\t\"NT: upnp:event\\r\\n\";\n\tstatic const char *HEADER_LINE_4 =\n\t\t\"NTS: upnp:propchange\\r\\n\";\n\tchar *headers = NULL;\n\tsize_t headers_size = 0;\n\tint line = 0;\n\tint rc = 0;\n\n\theaders_size =\n\t\tstrlen(HEADER_LINE_1 ) +\n\t\tstrlen(HEADER_LINE_2A) + MAX_CONTENT_LENGTH +\n\t\tstrlen(HEADER_LINE_2B) +\n\t\tstrlen(HEADER_LINE_3 ) +\n\t\tstrlen(HEADER_LINE_4 ) + 1;\n\theaders = (char *)malloc(headers_size);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\trc = snprintf(headers, headers_size, \"%s%s%\"PRIzu\"%s%s%s\",\n\t\tHEADER_LINE_1,\n\t\tHEADER_LINE_2A,\n\t\tstrlen(propertySet) + 2,\n\t\tHEADER_LINE_2B,\n\t\tHEADER_LINE_3,\n\t\tHEADER_LINE_4);\n\nExitFunction:\n\tif (headers == NULL || rc < 0 || (unsigned int) rc >= headers_size) {\n\t\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, line,\n\t\t\t\"AllocGenaHeaders(): Error UPNP_E_OUTOF_MEMORY\\n\");\n\t}\n\treturn headers;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GeneratePropertySet",
          "args": [
            "VarNames",
            "VarValues",
            "var_count",
            "&propertySet"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "GeneratePropertySet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "92-138",
          "snippet": "static int GeneratePropertySet(\n\t/*! [in] Array of variable names (go in the event notify). */\n\tchar **names,\n\t/*! [in] Array of variable values (go in the event notify). */\n\tchar **values,\n\t/*! [in] number of variables. */\n\tint count,\n\t/*! [out] PropertySet node in the string format. */\n\tDOMString *out)\n{\n\tchar *buffer;\n\tint counter = 0;\n\tsize_t size = 0;\n\n\t/*size += strlen(XML_VERSION);*/\n\tsize += strlen(XML_PROPERTYSET_HEADER);\n\tsize += strlen(\"</e:propertyset>\\n\\n\");\n\tfor (counter = 0; counter < count; counter++) {\n\t\tsize += strlen( \"<e:property>\\n</e:property>\\n\" );\n\t\tsize += 2 * strlen(names[counter]) +\n\t\t\tstrlen(values[counter]) +\n\t\t\tstrlen(\"<></>\\n\");\n\t}\n\n\tbuffer = (char *)malloc(size + 1);\n\tif (buffer == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tmemset(buffer, 0, size + 1);\n\t/*\n\tstrcpy(buffer,XML_VERSION);\n\tstrcat(buffer, XML_PROPERTYSET_HEADER);\n\t*/\n\tstrcpy(buffer, XML_PROPERTYSET_HEADER);\n\tfor (counter = 0; counter < count; counter++) {\n\t\tstrcat(buffer, \"<e:property>\\n\");\n\t\tsprintf(&buffer[strlen(buffer)],\n\t\t\t\"<%s>%s</%s>\\n</e:property>\\n\",\n\t\t\tnames[counter],\n\t\t\tvalues[counter],\n\t\t\tnames[counter]);\n\t}\n\tstrcat(buffer, \"</e:propertyset>\\n\\n\");\n\t*out = ixmlCloneDOMString(buffer);\n\tfree(buffer);\n\n\treturn XML_SUCCESS;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic int GeneratePropertySet(\n\t/*! [in] Array of variable names (go in the event notify). */\n\tchar **names,\n\t/*! [in] Array of variable values (go in the event notify). */\n\tchar **values,\n\t/*! [in] number of variables. */\n\tint count,\n\t/*! [out] PropertySet node in the string format. */\n\tDOMString *out)\n{\n\tchar *buffer;\n\tint counter = 0;\n\tsize_t size = 0;\n\n\t/*size += strlen(XML_VERSION);*/\n\tsize += strlen(XML_PROPERTYSET_HEADER);\n\tsize += strlen(\"</e:propertyset>\\n\\n\");\n\tfor (counter = 0; counter < count; counter++) {\n\t\tsize += strlen( \"<e:property>\\n</e:property>\\n\" );\n\t\tsize += 2 * strlen(names[counter]) +\n\t\t\tstrlen(values[counter]) +\n\t\t\tstrlen(\"<></>\\n\");\n\t}\n\n\tbuffer = (char *)malloc(size + 1);\n\tif (buffer == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tmemset(buffer, 0, size + 1);\n\t/*\n\tstrcpy(buffer,XML_VERSION);\n\tstrcat(buffer, XML_PROPERTYSET_HEADER);\n\t*/\n\tstrcpy(buffer, XML_PROPERTYSET_HEADER);\n\tfor (counter = 0; counter < count; counter++) {\n\t\tstrcat(buffer, \"<e:property>\\n\");\n\t\tsprintf(&buffer[strlen(buffer)],\n\t\t\t\"<%s>%s</%s>\\n</e:property>\\n\",\n\t\t\tnames[counter],\n\t\t\tvalues[counter],\n\t\t\tnames[counter]);\n\t}\n\tstrcat(buffer, \"</e:propertyset>\\n\\n\");\n\t*out = ixmlCloneDOMString(buffer);\n\tfree(buffer);\n\n\treturn XML_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "servId"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "UDN"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (int)"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nint genaNotifyAll(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tchar **VarNames,\n\tchar **VarValues,\n\tint var_count)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *finger = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN NOTIFY ALL\");\n\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif( servId_copy == NULL ) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tret = GeneratePropertySet(VarNames, VarValues, var_count, &propertySet);\n\tif (ret != XML_SUCCESS) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN EXT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t} else {\n\t\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\t\tif (service != NULL) {\n\t\t\tfinger = GetFirstSubscription(service);\n\t\t\twhile (finger) {\n\t\t\t\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\t\t\t\tif (thread_struct == NULL) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t(*reference_count)++;\n\t\t\t\tthread_struct->reference_count = reference_count;\n\t\t\t\tthread_struct->UDN = UDN_copy;\n\t\t\t\tthread_struct->servId = servId_copy;\n\t\t\t\tthread_struct->headers = headers;\n\t\t\t\tthread_struct->propertySet = propertySet;\n\t\t\t\tmemset(thread_struct->sid, 0,\n\t\t\t\t\tsizeof(thread_struct->sid));\n\t\t\t\tstrncpy(thread_struct->sid, finger->sid,\n\t\t\t\t\tsizeof(thread_struct->sid) - 1);\n\t\t\t\tthread_struct->eventKey = finger->eventKey++;\n\t\t\t\tthread_struct->device_handle = device_handle;\n\t\t\t\t/* if overflow, wrap to 1 */\n\t\t\t\tif (finger->eventKey < 0) {\n\t\t\t\t\tfinger->eventKey = 1;\n\t\t\t\t}\n\n\n\t\t\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\t\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\t\t\tline = __LINE__;\n\t\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfinger = GetNextSubscription(service, finger);\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_E_BAD_SERVICE;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || *reference_count == 0) {\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END NOTIFY ALL, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "genaNotifyAllExt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "757-893",
    "snippet": "int genaNotifyAllExt(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tIXML_Document *PropSet)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *finger = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN NOTIFY ALL EXT\");\n\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif( servId_copy == NULL ) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tpropertySet = ixmlPrintNode((IXML_Node *)PropSet);\n\tif (propertySet == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN EXT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t} else {\n\t\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\t\tif (service != NULL) {\n\t\t\tfinger = GetFirstSubscription(service);\n\t\t\twhile (finger) {\n\t\t\t\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\t\t\t\tif (thread_struct == NULL) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t(*reference_count)++;\n\t\t\t\tthread_struct->reference_count = reference_count;\n\t\t\t\tthread_struct->UDN = UDN_copy;\n\t\t\t\tthread_struct->servId = servId_copy;\n\t\t\t\tthread_struct->headers = headers;\n\t\t\t\tthread_struct->propertySet = propertySet;\n\t\t\t\tmemset(thread_struct->sid, 0,\n\t\t\t\t\tsizeof(thread_struct->sid));\n\t\t\t\tstrncpy(thread_struct->sid, finger->sid,\n\t\t\t\t\tsizeof(thread_struct->sid) - 1);\n\t\t\t\tthread_struct->eventKey = finger->eventKey++;\n\t\t\t\tthread_struct->device_handle = device_handle;\n\t\t\t\t/* if overflow, wrap to 1 */\n\t\t\t\tif (finger->eventKey < 0) {\n\t\t\t\t\tfinger->eventKey = 1;\n\t\t\t\t}\n\n\t\t\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\t\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\t\t\tline = __LINE__;\n\t\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfinger = GetNextSubscription(service, finger);\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_E_BAD_SERVICE;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || *reference_count == 0) {\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END NOTIFY ALL EXT, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "GENA",
            "__FILE__",
            "line",
            "\"GENA END NOTIFY ALL EXT, ret = %d\"",
            "ret"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "reference_count"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "propertySet"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNextSubscription",
          "args": [
            "service",
            "finger"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "GetNextSubscription",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "159-189",
          "snippet": "subscription *GetNextSubscription(service_info *service, subscription *current)\n{\n    time_t current_time;\n    subscription *next = NULL;\n    subscription *previous = NULL;\n    int notDone = 1;\n\n    /* get the current_time */\n    time( &current_time );\n    while( ( notDone ) && ( current ) ) {\n        previous = current;\n        current = current->next;\n\n        if( current == NULL ) {\n            notDone = 0;\n            next = current;\n        } else\n            if( ( current->expireTime != 0 )\n                && ( current->expireTime < current_time ) ) {\n            previous->next = current->next;\n            current->next = NULL;\n            freeSubscriptionList( current );\n            current = previous;\n            service->TotalSubscriptions--;\n        } else if( current->active ) {\n            notDone = 0;\n            next = current;\n        }\n    }\n    return next;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nsubscription *GetNextSubscription(service_info *service, subscription *current)\n{\n    time_t current_time;\n    subscription *next = NULL;\n    subscription *previous = NULL;\n    int notDone = 1;\n\n    /* get the current_time */\n    time( &current_time );\n    while( ( notDone ) && ( current ) ) {\n        previous = current;\n        current = current->next;\n\n        if( current == NULL ) {\n            notDone = 0;\n            next = current;\n        } else\n            if( ( current->expireTime != 0 )\n                && ( current->expireTime < current_time ) ) {\n            previous->next = current->next;\n            current->next = NULL;\n            freeSubscriptionList( current );\n            current = previous;\n            service->TotalSubscriptions--;\n        } else if( current->active ) {\n            notDone = 0;\n            next = current;\n        }\n    }\n    return next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gSendThreadPool",
            "&job",
            "NULL"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "(free_routine)free_notify_struct"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "(start_routine)genaNotifyThread",
            "thread_struct"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "thread_struct->sid",
            "finger->sid",
            "sizeof(thread_struct->sid) - 1"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "thread_struct->sid",
            "0",
            "sizeof(thread_struct->sid)"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (notify_thread_struct)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetFirstSubscription",
          "args": [
            "service"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "GetFirstSubscription",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "192-203",
          "snippet": "subscription *GetFirstSubscription(service_info *service)\n{\n\tsubscription temp;\n\tsubscription *next = NULL;\n\n\ttemp.next = service->subscriptionList;\n\tnext = GetNextSubscription(service, &temp);\n\tservice->subscriptionList = temp.next;\n\t/* service->subscriptionList = next; */\n\t\n\treturn next;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nsubscription *GetFirstSubscription(service_info *service)\n{\n\tsubscription temp;\n\tsubscription *next = NULL;\n\n\ttemp.next = service->subscriptionList;\n\tnext = GetNextSubscription(service, &temp);\n\tservice->subscriptionList = temp.next;\n\t/* service->subscriptionList = next; */\n\t\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindServiceId",
          "args": [
            "&handle_info->ServiceTable",
            "servId",
            "UDN"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "FindServiceId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "257-276",
          "snippet": "service_info *\nFindServiceId( service_table * table,\n               const char *serviceId,\n               const char *UDN )\n{\n    service_info *finger = NULL;\n\n    if( table ) {\n        finger = table->serviceList;\n        while( finger ) {\n            if( ( !strcmp( serviceId, finger->serviceId ) ) &&\n                ( !strcmp( UDN, finger->UDN ) ) ) {\n                return finger;\n            }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nservice_info *\nFindServiceId( service_table * table,\n               const char *serviceId,\n               const char *UDN )\n{\n    service_info *finger = NULL;\n\n    if( table ) {\n        finger = table->serviceList;\n        while( finger ) {\n            if( ( !strcmp( serviceId, finger->serviceId ) ) &&\n                ( !strcmp( UDN, finger->UDN ) ) ) {\n                return finger;\n            }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "device_handle",
            "&handle_info"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocGenaHeaders",
          "args": [
            "propertySet"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "AllocGenaHeaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "399-443",
          "snippet": "static char *AllocGenaHeaders(\n\t/*! [in] The property set string. */\n\tconst DOMString propertySet)\n{\n\tstatic const char *HEADER_LINE_1 =\n\t\t\"CONTENT-TYPE: text/xml; charset=\\\"utf-8\\\"\\r\\n\";\n\tstatic const char *HEADER_LINE_2A =\n\t\t\"CONTENT-LENGTH: \";\n\tstatic const char *HEADER_LINE_2B =\n\t\t\"\\r\\n\";\n\tstatic const char *HEADER_LINE_3 =\n\t\t\"NT: upnp:event\\r\\n\";\n\tstatic const char *HEADER_LINE_4 =\n\t\t\"NTS: upnp:propchange\\r\\n\";\n\tchar *headers = NULL;\n\tsize_t headers_size = 0;\n\tint line = 0;\n\tint rc = 0;\n\n\theaders_size =\n\t\tstrlen(HEADER_LINE_1 ) +\n\t\tstrlen(HEADER_LINE_2A) + MAX_CONTENT_LENGTH +\n\t\tstrlen(HEADER_LINE_2B) +\n\t\tstrlen(HEADER_LINE_3 ) +\n\t\tstrlen(HEADER_LINE_4 ) + 1;\n\theaders = (char *)malloc(headers_size);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\trc = snprintf(headers, headers_size, \"%s%s%\"PRIzu\"%s%s%s\",\n\t\tHEADER_LINE_1,\n\t\tHEADER_LINE_2A,\n\t\tstrlen(propertySet) + 2,\n\t\tHEADER_LINE_2B,\n\t\tHEADER_LINE_3,\n\t\tHEADER_LINE_4);\n\nExitFunction:\n\tif (headers == NULL || rc < 0 || (unsigned int) rc >= headers_size) {\n\t\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, line,\n\t\t\t\"AllocGenaHeaders(): Error UPNP_E_OUTOF_MEMORY\\n\");\n\t}\n\treturn headers;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic char *AllocGenaHeaders(\n\t/*! [in] The property set string. */\n\tconst DOMString propertySet)\n{\n\tstatic const char *HEADER_LINE_1 =\n\t\t\"CONTENT-TYPE: text/xml; charset=\\\"utf-8\\\"\\r\\n\";\n\tstatic const char *HEADER_LINE_2A =\n\t\t\"CONTENT-LENGTH: \";\n\tstatic const char *HEADER_LINE_2B =\n\t\t\"\\r\\n\";\n\tstatic const char *HEADER_LINE_3 =\n\t\t\"NT: upnp:event\\r\\n\";\n\tstatic const char *HEADER_LINE_4 =\n\t\t\"NTS: upnp:propchange\\r\\n\";\n\tchar *headers = NULL;\n\tsize_t headers_size = 0;\n\tint line = 0;\n\tint rc = 0;\n\n\theaders_size =\n\t\tstrlen(HEADER_LINE_1 ) +\n\t\tstrlen(HEADER_LINE_2A) + MAX_CONTENT_LENGTH +\n\t\tstrlen(HEADER_LINE_2B) +\n\t\tstrlen(HEADER_LINE_3 ) +\n\t\tstrlen(HEADER_LINE_4 ) + 1;\n\theaders = (char *)malloc(headers_size);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\trc = snprintf(headers, headers_size, \"%s%s%\"PRIzu\"%s%s%s\",\n\t\tHEADER_LINE_1,\n\t\tHEADER_LINE_2A,\n\t\tstrlen(propertySet) + 2,\n\t\tHEADER_LINE_2B,\n\t\tHEADER_LINE_3,\n\t\tHEADER_LINE_4);\n\nExitFunction:\n\tif (headers == NULL || rc < 0 || (unsigned int) rc >= headers_size) {\n\t\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, line,\n\t\t\t\"AllocGenaHeaders(): Error UPNP_E_OUTOF_MEMORY\\n\");\n\t}\n\treturn headers;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "(IXML_Node *)PropSet"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "servId"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "UDN"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (int)"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nint genaNotifyAllExt(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tIXML_Document *PropSet)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *finger = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN NOTIFY ALL EXT\");\n\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif( servId_copy == NULL ) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tpropertySet = ixmlPrintNode((IXML_Node *)PropSet);\n\tif (propertySet == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN EXT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t} else {\n\t\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\t\tif (service != NULL) {\n\t\t\tfinger = GetFirstSubscription(service);\n\t\t\twhile (finger) {\n\t\t\t\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\t\t\t\tif (thread_struct == NULL) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t(*reference_count)++;\n\t\t\t\tthread_struct->reference_count = reference_count;\n\t\t\t\tthread_struct->UDN = UDN_copy;\n\t\t\t\tthread_struct->servId = servId_copy;\n\t\t\t\tthread_struct->headers = headers;\n\t\t\t\tthread_struct->propertySet = propertySet;\n\t\t\t\tmemset(thread_struct->sid, 0,\n\t\t\t\t\tsizeof(thread_struct->sid));\n\t\t\t\tstrncpy(thread_struct->sid, finger->sid,\n\t\t\t\t\tsizeof(thread_struct->sid) - 1);\n\t\t\t\tthread_struct->eventKey = finger->eventKey++;\n\t\t\t\tthread_struct->device_handle = device_handle;\n\t\t\t\t/* if overflow, wrap to 1 */\n\t\t\t\tif (finger->eventKey < 0) {\n\t\t\t\t\tfinger->eventKey = 1;\n\t\t\t\t}\n\n\t\t\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\t\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\t\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\t\t\tline = __LINE__;\n\t\t\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfinger = GetNextSubscription(service, finger);\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_E_BAD_SERVICE;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || *reference_count == 0) {\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END NOTIFY ALL EXT, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "genaInitNotifyExt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "602-754",
    "snippet": "int genaInitNotifyExt(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tIXML_Document *PropSet,\n\tconst Upnp_SID sid)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *sub = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN INITIAL NOTIFY EXT\");\n\t\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif( servId_copy == NULL ) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t\tgoto ExitFunction;\n\t}\n\n\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\tif (service == NULL) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SERVICE;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SERVICE IN INIT NOTFY EXT: UDN %s, ServID: %s\",\n\t\tUDN, servId);\n\n\tsub = GetSubscriptionSID(sid, service);\n\tif (sub == NULL || sub->active) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SID;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SUBSCRIPTION IN INIT NOTIFY EXT: SID %s\", sid);\n\tsub->active = 1;\n\n\tif (PropSet == 0) {\n\t\tline = __LINE__;\n\t\tret = GENA_SUCCESS;\n\t\tgoto ExitFunction;\n\t}\n\n\tpropertySet = ixmlPrintNode((IXML_Node *)PropSet);\n\tif (propertySet == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN INIT EXT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\t/* schedule thread for initial notification */\n\n\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\tif (thread_struct == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t} else {\n\t\t*reference_count = 1;\n\t\tthread_struct->servId = servId_copy;\n\t\tthread_struct->UDN = UDN_copy;\n\t\tthread_struct->headers = headers;\n\t\tthread_struct->propertySet = propertySet;\n\t\tmemset(thread_struct->sid, 0, sizeof(thread_struct->sid));\n\t\tstrncpy(thread_struct->sid, sid,\n\t\t\tsizeof(thread_struct->sid) - 1);\n\t\tthread_struct->eventKey = sub->eventKey++;\n\t\tthread_struct->reference_count = reference_count;\n\t\tthread_struct->device_handle = device_handle;\n\n\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\tif (ret != 0) {\n\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_SUCCESS;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || PropSet == 0) {\n\t\tfree(thread_struct);\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END INITIAL NOTIFY EXT, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "GENA",
            "__FILE__",
            "line",
            "\"GENA END INITIAL NOTIFY EXT, ret = %d\"",
            "ret"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "reference_count"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "propertySet"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gSendThreadPool",
            "&job",
            "NULL"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "(free_routine)free_notify_struct"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "(start_routine)genaNotifyThread",
            "thread_struct"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "thread_struct->sid",
            "sid",
            "sizeof(thread_struct->sid) - 1"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "thread_struct->sid",
            "0",
            "sizeof(thread_struct->sid)"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (notify_thread_struct)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocGenaHeaders",
          "args": [
            "propertySet"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "AllocGenaHeaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "399-443",
          "snippet": "static char *AllocGenaHeaders(\n\t/*! [in] The property set string. */\n\tconst DOMString propertySet)\n{\n\tstatic const char *HEADER_LINE_1 =\n\t\t\"CONTENT-TYPE: text/xml; charset=\\\"utf-8\\\"\\r\\n\";\n\tstatic const char *HEADER_LINE_2A =\n\t\t\"CONTENT-LENGTH: \";\n\tstatic const char *HEADER_LINE_2B =\n\t\t\"\\r\\n\";\n\tstatic const char *HEADER_LINE_3 =\n\t\t\"NT: upnp:event\\r\\n\";\n\tstatic const char *HEADER_LINE_4 =\n\t\t\"NTS: upnp:propchange\\r\\n\";\n\tchar *headers = NULL;\n\tsize_t headers_size = 0;\n\tint line = 0;\n\tint rc = 0;\n\n\theaders_size =\n\t\tstrlen(HEADER_LINE_1 ) +\n\t\tstrlen(HEADER_LINE_2A) + MAX_CONTENT_LENGTH +\n\t\tstrlen(HEADER_LINE_2B) +\n\t\tstrlen(HEADER_LINE_3 ) +\n\t\tstrlen(HEADER_LINE_4 ) + 1;\n\theaders = (char *)malloc(headers_size);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\trc = snprintf(headers, headers_size, \"%s%s%\"PRIzu\"%s%s%s\",\n\t\tHEADER_LINE_1,\n\t\tHEADER_LINE_2A,\n\t\tstrlen(propertySet) + 2,\n\t\tHEADER_LINE_2B,\n\t\tHEADER_LINE_3,\n\t\tHEADER_LINE_4);\n\nExitFunction:\n\tif (headers == NULL || rc < 0 || (unsigned int) rc >= headers_size) {\n\t\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, line,\n\t\t\t\"AllocGenaHeaders(): Error UPNP_E_OUTOF_MEMORY\\n\");\n\t}\n\treturn headers;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic char *AllocGenaHeaders(\n\t/*! [in] The property set string. */\n\tconst DOMString propertySet)\n{\n\tstatic const char *HEADER_LINE_1 =\n\t\t\"CONTENT-TYPE: text/xml; charset=\\\"utf-8\\\"\\r\\n\";\n\tstatic const char *HEADER_LINE_2A =\n\t\t\"CONTENT-LENGTH: \";\n\tstatic const char *HEADER_LINE_2B =\n\t\t\"\\r\\n\";\n\tstatic const char *HEADER_LINE_3 =\n\t\t\"NT: upnp:event\\r\\n\";\n\tstatic const char *HEADER_LINE_4 =\n\t\t\"NTS: upnp:propchange\\r\\n\";\n\tchar *headers = NULL;\n\tsize_t headers_size = 0;\n\tint line = 0;\n\tint rc = 0;\n\n\theaders_size =\n\t\tstrlen(HEADER_LINE_1 ) +\n\t\tstrlen(HEADER_LINE_2A) + MAX_CONTENT_LENGTH +\n\t\tstrlen(HEADER_LINE_2B) +\n\t\tstrlen(HEADER_LINE_3 ) +\n\t\tstrlen(HEADER_LINE_4 ) + 1;\n\theaders = (char *)malloc(headers_size);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\trc = snprintf(headers, headers_size, \"%s%s%\"PRIzu\"%s%s%s\",\n\t\tHEADER_LINE_1,\n\t\tHEADER_LINE_2A,\n\t\tstrlen(propertySet) + 2,\n\t\tHEADER_LINE_2B,\n\t\tHEADER_LINE_3,\n\t\tHEADER_LINE_4);\n\nExitFunction:\n\tif (headers == NULL || rc < 0 || (unsigned int) rc >= headers_size) {\n\t\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, line,\n\t\t\t\"AllocGenaHeaders(): Error UPNP_E_OUTOF_MEMORY\\n\");\n\t}\n\treturn headers;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "(IXML_Node *)PropSet"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSubscriptionSID",
          "args": [
            "sid",
            "service"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "GetSubscriptionSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "123-156",
          "snippet": "subscription *GetSubscriptionSID(const Upnp_SID sid, service_info *service)\n{\n    subscription *next = service->subscriptionList;\n    subscription *previous = NULL;\n    subscription *found = NULL;\n\n    time_t current_time;\n\n    while( ( next ) && ( found == NULL ) ) {\n        if( !strcmp( next->sid, sid ) )\n            found = next;\n        else {\n            previous = next;\n            next = next->next;\n        }\n    }\n    if( found ) {\n        /*get the current_time */\n        time( &current_time );\n        if( ( found->expireTime != 0 )\n            && ( found->expireTime < current_time ) ) {\n            if( previous )\n                previous->next = found->next;\n            else\n                service->subscriptionList = found->next;\n            found->next = NULL;\n            freeSubscriptionList( found );\n            found = NULL;\n            service->TotalSubscriptions--;\n        }\n    }\n    return found;\n\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nsubscription *GetSubscriptionSID(const Upnp_SID sid, service_info *service)\n{\n    subscription *next = service->subscriptionList;\n    subscription *previous = NULL;\n    subscription *found = NULL;\n\n    time_t current_time;\n\n    while( ( next ) && ( found == NULL ) ) {\n        if( !strcmp( next->sid, sid ) )\n            found = next;\n        else {\n            previous = next;\n            next = next->next;\n        }\n    }\n    if( found ) {\n        /*get the current_time */\n        time( &current_time );\n        if( ( found->expireTime != 0 )\n            && ( found->expireTime < current_time ) ) {\n            if( previous )\n                previous->next = found->next;\n            else\n                service->subscriptionList = found->next;\n            found->next = NULL;\n            freeSubscriptionList( found );\n            found = NULL;\n            service->TotalSubscriptions--;\n        }\n    }\n    return found;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindServiceId",
          "args": [
            "&handle_info->ServiceTable",
            "servId",
            "UDN"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "FindServiceId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "257-276",
          "snippet": "service_info *\nFindServiceId( service_table * table,\n               const char *serviceId,\n               const char *UDN )\n{\n    service_info *finger = NULL;\n\n    if( table ) {\n        finger = table->serviceList;\n        while( finger ) {\n            if( ( !strcmp( serviceId, finger->serviceId ) ) &&\n                ( !strcmp( UDN, finger->UDN ) ) ) {\n                return finger;\n            }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nservice_info *\nFindServiceId( service_table * table,\n               const char *serviceId,\n               const char *UDN )\n{\n    service_info *finger = NULL;\n\n    if( table ) {\n        finger = table->serviceList;\n        while( finger ) {\n            if( ( !strcmp( serviceId, finger->serviceId ) ) &&\n                ( !strcmp( UDN, finger->UDN ) ) ) {\n                return finger;\n            }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "device_handle",
            "&handle_info"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "servId"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "UDN"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (int)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nint genaInitNotifyExt(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tIXML_Document *PropSet,\n\tconst Upnp_SID sid)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *sub = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN INITIAL NOTIFY EXT\");\n\t\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif( servId_copy == NULL ) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t\tgoto ExitFunction;\n\t}\n\n\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\tif (service == NULL) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SERVICE;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SERVICE IN INIT NOTFY EXT: UDN %s, ServID: %s\",\n\t\tUDN, servId);\n\n\tsub = GetSubscriptionSID(sid, service);\n\tif (sub == NULL || sub->active) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SID;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SUBSCRIPTION IN INIT NOTIFY EXT: SID %s\", sid);\n\tsub->active = 1;\n\n\tif (PropSet == 0) {\n\t\tline = __LINE__;\n\t\tret = GENA_SUCCESS;\n\t\tgoto ExitFunction;\n\t}\n\n\tpropertySet = ixmlPrintNode((IXML_Node *)PropSet);\n\tif (propertySet == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN INIT EXT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\t/* schedule thread for initial notification */\n\n\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\tif (thread_struct == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t} else {\n\t\t*reference_count = 1;\n\t\tthread_struct->servId = servId_copy;\n\t\tthread_struct->UDN = UDN_copy;\n\t\tthread_struct->headers = headers;\n\t\tthread_struct->propertySet = propertySet;\n\t\tmemset(thread_struct->sid, 0, sizeof(thread_struct->sid));\n\t\tstrncpy(thread_struct->sid, sid,\n\t\t\tsizeof(thread_struct->sid) - 1);\n\t\tthread_struct->eventKey = sub->eventKey++;\n\t\tthread_struct->reference_count = reference_count;\n\t\tthread_struct->device_handle = device_handle;\n\n\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\tif (ret != 0) {\n\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_SUCCESS;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || PropSet == 0) {\n\t\tfree(thread_struct);\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END INITIAL NOTIFY EXT, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "genaInitNotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "446-599",
    "snippet": "int genaInitNotify(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tchar **VarNames,\n\tchar **VarValues,\n\tint var_count,\n\tconst Upnp_SID sid)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *sub = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN INITIAL NOTIFY\");\n\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif (servId_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t\tgoto ExitFunction;\n\t}\n\n\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\tif (service == NULL) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SERVICE;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SERVICE IN INIT NOTFY: UDN %s, ServID: %s\",\n\t\tUDN, servId);\n\n\tsub = GetSubscriptionSID(sid, service);\n\tif (sub == NULL || sub->active) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SID;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SUBSCRIPTION IN INIT NOTIFY: SID %s\", sid);\n\tsub->active = 1;\n\n\tif (var_count <= 0) {\n\t\tline = __LINE__;\n\t\tret = GENA_SUCCESS;\n\t\tgoto ExitFunction;\n\t}\n\n\tret = GeneratePropertySet(VarNames, VarValues, var_count, &propertySet);\n\tif (ret != XML_SUCCESS) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN INIT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\t/* schedule thread for initial notification */\n\n\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\tif (thread_struct == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t} else {\n\t\t*reference_count = 1;\n\t\tthread_struct->servId = servId_copy;\n\t\tthread_struct->UDN = UDN_copy;\n\t\tthread_struct->headers = headers;\n\t\tthread_struct->propertySet = propertySet;\n\t\tmemset(thread_struct->sid, 0, sizeof(thread_struct->sid));\n\t\tstrncpy(thread_struct->sid, sid,\n\t\t\tsizeof(thread_struct->sid) - 1);\n\t\tthread_struct->eventKey = sub->eventKey++;\n\t\tthread_struct->reference_count = reference_count;\n\t\tthread_struct->device_handle = device_handle;\n\n\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\tif (ret != 0) {\n\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_SUCCESS;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || var_count <= 0) {\n\t\tfree(thread_struct);\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END INITIAL NOTIFY, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "GENA",
            "__FILE__",
            "line",
            "\"GENA END INITIAL NOTIFY, ret = %d\"",
            "ret"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "reference_count"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "propertySet"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gSendThreadPool",
            "&job",
            "NULL"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "(free_routine)free_notify_struct"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "(start_routine)genaNotifyThread",
            "thread_struct"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "thread_struct->sid",
            "sid",
            "sizeof(thread_struct->sid) - 1"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "thread_struct->sid",
            "0",
            "sizeof(thread_struct->sid)"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (notify_thread_struct)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocGenaHeaders",
          "args": [
            "propertySet"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "AllocGenaHeaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "399-443",
          "snippet": "static char *AllocGenaHeaders(\n\t/*! [in] The property set string. */\n\tconst DOMString propertySet)\n{\n\tstatic const char *HEADER_LINE_1 =\n\t\t\"CONTENT-TYPE: text/xml; charset=\\\"utf-8\\\"\\r\\n\";\n\tstatic const char *HEADER_LINE_2A =\n\t\t\"CONTENT-LENGTH: \";\n\tstatic const char *HEADER_LINE_2B =\n\t\t\"\\r\\n\";\n\tstatic const char *HEADER_LINE_3 =\n\t\t\"NT: upnp:event\\r\\n\";\n\tstatic const char *HEADER_LINE_4 =\n\t\t\"NTS: upnp:propchange\\r\\n\";\n\tchar *headers = NULL;\n\tsize_t headers_size = 0;\n\tint line = 0;\n\tint rc = 0;\n\n\theaders_size =\n\t\tstrlen(HEADER_LINE_1 ) +\n\t\tstrlen(HEADER_LINE_2A) + MAX_CONTENT_LENGTH +\n\t\tstrlen(HEADER_LINE_2B) +\n\t\tstrlen(HEADER_LINE_3 ) +\n\t\tstrlen(HEADER_LINE_4 ) + 1;\n\theaders = (char *)malloc(headers_size);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\trc = snprintf(headers, headers_size, \"%s%s%\"PRIzu\"%s%s%s\",\n\t\tHEADER_LINE_1,\n\t\tHEADER_LINE_2A,\n\t\tstrlen(propertySet) + 2,\n\t\tHEADER_LINE_2B,\n\t\tHEADER_LINE_3,\n\t\tHEADER_LINE_4);\n\nExitFunction:\n\tif (headers == NULL || rc < 0 || (unsigned int) rc >= headers_size) {\n\t\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, line,\n\t\t\t\"AllocGenaHeaders(): Error UPNP_E_OUTOF_MEMORY\\n\");\n\t}\n\treturn headers;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic char *AllocGenaHeaders(\n\t/*! [in] The property set string. */\n\tconst DOMString propertySet)\n{\n\tstatic const char *HEADER_LINE_1 =\n\t\t\"CONTENT-TYPE: text/xml; charset=\\\"utf-8\\\"\\r\\n\";\n\tstatic const char *HEADER_LINE_2A =\n\t\t\"CONTENT-LENGTH: \";\n\tstatic const char *HEADER_LINE_2B =\n\t\t\"\\r\\n\";\n\tstatic const char *HEADER_LINE_3 =\n\t\t\"NT: upnp:event\\r\\n\";\n\tstatic const char *HEADER_LINE_4 =\n\t\t\"NTS: upnp:propchange\\r\\n\";\n\tchar *headers = NULL;\n\tsize_t headers_size = 0;\n\tint line = 0;\n\tint rc = 0;\n\n\theaders_size =\n\t\tstrlen(HEADER_LINE_1 ) +\n\t\tstrlen(HEADER_LINE_2A) + MAX_CONTENT_LENGTH +\n\t\tstrlen(HEADER_LINE_2B) +\n\t\tstrlen(HEADER_LINE_3 ) +\n\t\tstrlen(HEADER_LINE_4 ) + 1;\n\theaders = (char *)malloc(headers_size);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\trc = snprintf(headers, headers_size, \"%s%s%\"PRIzu\"%s%s%s\",\n\t\tHEADER_LINE_1,\n\t\tHEADER_LINE_2A,\n\t\tstrlen(propertySet) + 2,\n\t\tHEADER_LINE_2B,\n\t\tHEADER_LINE_3,\n\t\tHEADER_LINE_4);\n\nExitFunction:\n\tif (headers == NULL || rc < 0 || (unsigned int) rc >= headers_size) {\n\t\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, line,\n\t\t\t\"AllocGenaHeaders(): Error UPNP_E_OUTOF_MEMORY\\n\");\n\t}\n\treturn headers;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GeneratePropertySet",
          "args": [
            "VarNames",
            "VarValues",
            "var_count",
            "&propertySet"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "GeneratePropertySet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "92-138",
          "snippet": "static int GeneratePropertySet(\n\t/*! [in] Array of variable names (go in the event notify). */\n\tchar **names,\n\t/*! [in] Array of variable values (go in the event notify). */\n\tchar **values,\n\t/*! [in] number of variables. */\n\tint count,\n\t/*! [out] PropertySet node in the string format. */\n\tDOMString *out)\n{\n\tchar *buffer;\n\tint counter = 0;\n\tsize_t size = 0;\n\n\t/*size += strlen(XML_VERSION);*/\n\tsize += strlen(XML_PROPERTYSET_HEADER);\n\tsize += strlen(\"</e:propertyset>\\n\\n\");\n\tfor (counter = 0; counter < count; counter++) {\n\t\tsize += strlen( \"<e:property>\\n</e:property>\\n\" );\n\t\tsize += 2 * strlen(names[counter]) +\n\t\t\tstrlen(values[counter]) +\n\t\t\tstrlen(\"<></>\\n\");\n\t}\n\n\tbuffer = (char *)malloc(size + 1);\n\tif (buffer == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tmemset(buffer, 0, size + 1);\n\t/*\n\tstrcpy(buffer,XML_VERSION);\n\tstrcat(buffer, XML_PROPERTYSET_HEADER);\n\t*/\n\tstrcpy(buffer, XML_PROPERTYSET_HEADER);\n\tfor (counter = 0; counter < count; counter++) {\n\t\tstrcat(buffer, \"<e:property>\\n\");\n\t\tsprintf(&buffer[strlen(buffer)],\n\t\t\t\"<%s>%s</%s>\\n</e:property>\\n\",\n\t\t\tnames[counter],\n\t\t\tvalues[counter],\n\t\t\tnames[counter]);\n\t}\n\tstrcat(buffer, \"</e:propertyset>\\n\\n\");\n\t*out = ixmlCloneDOMString(buffer);\n\tfree(buffer);\n\n\treturn XML_SUCCESS;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic int GeneratePropertySet(\n\t/*! [in] Array of variable names (go in the event notify). */\n\tchar **names,\n\t/*! [in] Array of variable values (go in the event notify). */\n\tchar **values,\n\t/*! [in] number of variables. */\n\tint count,\n\t/*! [out] PropertySet node in the string format. */\n\tDOMString *out)\n{\n\tchar *buffer;\n\tint counter = 0;\n\tsize_t size = 0;\n\n\t/*size += strlen(XML_VERSION);*/\n\tsize += strlen(XML_PROPERTYSET_HEADER);\n\tsize += strlen(\"</e:propertyset>\\n\\n\");\n\tfor (counter = 0; counter < count; counter++) {\n\t\tsize += strlen( \"<e:property>\\n</e:property>\\n\" );\n\t\tsize += 2 * strlen(names[counter]) +\n\t\t\tstrlen(values[counter]) +\n\t\t\tstrlen(\"<></>\\n\");\n\t}\n\n\tbuffer = (char *)malloc(size + 1);\n\tif (buffer == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tmemset(buffer, 0, size + 1);\n\t/*\n\tstrcpy(buffer,XML_VERSION);\n\tstrcat(buffer, XML_PROPERTYSET_HEADER);\n\t*/\n\tstrcpy(buffer, XML_PROPERTYSET_HEADER);\n\tfor (counter = 0; counter < count; counter++) {\n\t\tstrcat(buffer, \"<e:property>\\n\");\n\t\tsprintf(&buffer[strlen(buffer)],\n\t\t\t\"<%s>%s</%s>\\n</e:property>\\n\",\n\t\t\tnames[counter],\n\t\t\tvalues[counter],\n\t\t\tnames[counter]);\n\t}\n\tstrcat(buffer, \"</e:propertyset>\\n\\n\");\n\t*out = ixmlCloneDOMString(buffer);\n\tfree(buffer);\n\n\treturn XML_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetSubscriptionSID",
          "args": [
            "sid",
            "service"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "GetSubscriptionSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "123-156",
          "snippet": "subscription *GetSubscriptionSID(const Upnp_SID sid, service_info *service)\n{\n    subscription *next = service->subscriptionList;\n    subscription *previous = NULL;\n    subscription *found = NULL;\n\n    time_t current_time;\n\n    while( ( next ) && ( found == NULL ) ) {\n        if( !strcmp( next->sid, sid ) )\n            found = next;\n        else {\n            previous = next;\n            next = next->next;\n        }\n    }\n    if( found ) {\n        /*get the current_time */\n        time( &current_time );\n        if( ( found->expireTime != 0 )\n            && ( found->expireTime < current_time ) ) {\n            if( previous )\n                previous->next = found->next;\n            else\n                service->subscriptionList = found->next;\n            found->next = NULL;\n            freeSubscriptionList( found );\n            found = NULL;\n            service->TotalSubscriptions--;\n        }\n    }\n    return found;\n\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nsubscription *GetSubscriptionSID(const Upnp_SID sid, service_info *service)\n{\n    subscription *next = service->subscriptionList;\n    subscription *previous = NULL;\n    subscription *found = NULL;\n\n    time_t current_time;\n\n    while( ( next ) && ( found == NULL ) ) {\n        if( !strcmp( next->sid, sid ) )\n            found = next;\n        else {\n            previous = next;\n            next = next->next;\n        }\n    }\n    if( found ) {\n        /*get the current_time */\n        time( &current_time );\n        if( ( found->expireTime != 0 )\n            && ( found->expireTime < current_time ) ) {\n            if( previous )\n                previous->next = found->next;\n            else\n                service->subscriptionList = found->next;\n            found->next = NULL;\n            freeSubscriptionList( found );\n            found = NULL;\n            service->TotalSubscriptions--;\n        }\n    }\n    return found;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindServiceId",
          "args": [
            "&handle_info->ServiceTable",
            "servId",
            "UDN"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "FindServiceId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "257-276",
          "snippet": "service_info *\nFindServiceId( service_table * table,\n               const char *serviceId,\n               const char *UDN )\n{\n    service_info *finger = NULL;\n\n    if( table ) {\n        finger = table->serviceList;\n        while( finger ) {\n            if( ( !strcmp( serviceId, finger->serviceId ) ) &&\n                ( !strcmp( UDN, finger->UDN ) ) ) {\n                return finger;\n            }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nservice_info *\nFindServiceId( service_table * table,\n               const char *serviceId,\n               const char *UDN )\n{\n    service_info *finger = NULL;\n\n    if( table ) {\n        finger = table->serviceList;\n        while( finger ) {\n            if( ( !strcmp( serviceId, finger->serviceId ) ) &&\n                ( !strcmp( UDN, finger->UDN ) ) ) {\n                return finger;\n            }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "device_handle",
            "&handle_info"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "servId"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "UDN"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (int)"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nint genaInitNotify(\n\tUpnpDevice_Handle device_handle,\n\tchar *UDN,\n\tchar *servId,\n\tchar **VarNames,\n\tchar **VarValues,\n\tint var_count,\n\tconst Upnp_SID sid)\n{\n\tint ret = GENA_SUCCESS;\n\tint line = 0;\n\n\tint *reference_count = NULL;\n\tchar *UDN_copy = NULL;\n\tchar *servId_copy = NULL;\n\tDOMString propertySet = NULL;\n\tchar *headers = NULL;\n\tnotify_thread_struct *thread_struct = NULL;\n\n\tsubscription *sub = NULL;\n\tservice_info *service = NULL;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENA BEGIN INITIAL NOTIFY\");\n\n\treference_count = (int *)malloc(sizeof (int));\n\tif (reference_count == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\t*reference_count = 0;\n\t\n\tUDN_copy = strdup(UDN);\n\tif (UDN_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tservId_copy = strdup(servId);\n\tif (servId_copy == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\tHandleLock();\n\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_HANDLE;\n\t\tgoto ExitFunction;\n\t}\n\n\tservice = FindServiceId(&handle_info->ServiceTable, servId, UDN);\n\tif (service == NULL) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SERVICE;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SERVICE IN INIT NOTFY: UDN %s, ServID: %s\",\n\t\tUDN, servId);\n\n\tsub = GetSubscriptionSID(sid, service);\n\tif (sub == NULL || sub->active) {\n\t\tline = __LINE__;\n\t\tret = GENA_E_BAD_SID;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"FOUND SUBSCRIPTION IN INIT NOTIFY: SID %s\", sid);\n\tsub->active = 1;\n\n\tif (var_count <= 0) {\n\t\tline = __LINE__;\n\t\tret = GENA_SUCCESS;\n\t\tgoto ExitFunction;\n\t}\n\n\tret = GeneratePropertySet(VarNames, VarValues, var_count, &propertySet);\n\tif (ret != XML_SUCCESS) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"GENERATED PROPERTY SET IN INIT NOTIFY: %s\",\n\t\tpropertySet);\n\n\theaders = AllocGenaHeaders(propertySet);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\tgoto ExitFunction;\n\t}\n\n\t/* schedule thread for initial notification */\n\n\tthread_struct = (notify_thread_struct *)malloc(sizeof (notify_thread_struct));\n\tif (thread_struct == NULL) {\n\t\tline = __LINE__;\n\t\tret = UPNP_E_OUTOF_MEMORY;\n\t} else {\n\t\t*reference_count = 1;\n\t\tthread_struct->servId = servId_copy;\n\t\tthread_struct->UDN = UDN_copy;\n\t\tthread_struct->headers = headers;\n\t\tthread_struct->propertySet = propertySet;\n\t\tmemset(thread_struct->sid, 0, sizeof(thread_struct->sid));\n\t\tstrncpy(thread_struct->sid, sid,\n\t\t\tsizeof(thread_struct->sid) - 1);\n\t\tthread_struct->eventKey = sub->eventKey++;\n\t\tthread_struct->reference_count = reference_count;\n\t\tthread_struct->device_handle = device_handle;\n\n\t\tTPJobInit(&job, (start_routine)genaNotifyThread, thread_struct);\n\t\tTPJobSetFreeFunction(&job, (free_routine)free_notify_struct);\n\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t\tret = ThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\tif (ret != 0) {\n\t\t\tif (ret == EOUTOFMEM) {\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_OUTOF_MEMORY;\n\t\t\t}\n\t\t} else {\n\t\t\tline = __LINE__;\n\t\t\tret = GENA_SUCCESS;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != GENA_SUCCESS || var_count <= 0) {\n\t\tfree(thread_struct);\n\t\tfree(headers);\n\t\tixmlFreeDOMString(propertySet);\n\t\tfree(servId_copy);\n\t\tfree(UDN_copy);\n\t\tfree(reference_count);\n\t}\n\n\tHandleUnlock();\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, line,\n\t\t\"GENA END INITIAL NOTIFY, ret = %d\",\n\t\tret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "AllocGenaHeaders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "399-443",
    "snippet": "static char *AllocGenaHeaders(\n\t/*! [in] The property set string. */\n\tconst DOMString propertySet)\n{\n\tstatic const char *HEADER_LINE_1 =\n\t\t\"CONTENT-TYPE: text/xml; charset=\\\"utf-8\\\"\\r\\n\";\n\tstatic const char *HEADER_LINE_2A =\n\t\t\"CONTENT-LENGTH: \";\n\tstatic const char *HEADER_LINE_2B =\n\t\t\"\\r\\n\";\n\tstatic const char *HEADER_LINE_3 =\n\t\t\"NT: upnp:event\\r\\n\";\n\tstatic const char *HEADER_LINE_4 =\n\t\t\"NTS: upnp:propchange\\r\\n\";\n\tchar *headers = NULL;\n\tsize_t headers_size = 0;\n\tint line = 0;\n\tint rc = 0;\n\n\theaders_size =\n\t\tstrlen(HEADER_LINE_1 ) +\n\t\tstrlen(HEADER_LINE_2A) + MAX_CONTENT_LENGTH +\n\t\tstrlen(HEADER_LINE_2B) +\n\t\tstrlen(HEADER_LINE_3 ) +\n\t\tstrlen(HEADER_LINE_4 ) + 1;\n\theaders = (char *)malloc(headers_size);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\trc = snprintf(headers, headers_size, \"%s%s%\"PRIzu\"%s%s%s\",\n\t\tHEADER_LINE_1,\n\t\tHEADER_LINE_2A,\n\t\tstrlen(propertySet) + 2,\n\t\tHEADER_LINE_2B,\n\t\tHEADER_LINE_3,\n\t\tHEADER_LINE_4);\n\nExitFunction:\n\tif (headers == NULL || rc < 0 || (unsigned int) rc >= headers_size) {\n\t\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, line,\n\t\t\t\"AllocGenaHeaders(): Error UPNP_E_OUTOF_MEMORY\\n\");\n\t}\n\treturn headers;\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "GENA",
            "__FILE__",
            "line",
            "\"AllocGenaHeaders(): Error UPNP_E_OUTOF_MEMORY\\n\""
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "headers",
            "headers_size",
            "\"%s%s%\"PRIzu\"%s%s%s\"",
            "HEADER_LINE_1",
            "HEADER_LINE_2A",
            "strlen(propertySet) + 2",
            "HEADER_LINE_2B",
            "HEADER_LINE_3",
            "HEADER_LINE_4"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "propertySet"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "headers_size"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "HEADER_LINE_4"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "HEADER_LINE_3"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "HEADER_LINE_2B"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "HEADER_LINE_2A"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "HEADER_LINE_1"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic char *AllocGenaHeaders(\n\t/*! [in] The property set string. */\n\tconst DOMString propertySet)\n{\n\tstatic const char *HEADER_LINE_1 =\n\t\t\"CONTENT-TYPE: text/xml; charset=\\\"utf-8\\\"\\r\\n\";\n\tstatic const char *HEADER_LINE_2A =\n\t\t\"CONTENT-LENGTH: \";\n\tstatic const char *HEADER_LINE_2B =\n\t\t\"\\r\\n\";\n\tstatic const char *HEADER_LINE_3 =\n\t\t\"NT: upnp:event\\r\\n\";\n\tstatic const char *HEADER_LINE_4 =\n\t\t\"NTS: upnp:propchange\\r\\n\";\n\tchar *headers = NULL;\n\tsize_t headers_size = 0;\n\tint line = 0;\n\tint rc = 0;\n\n\theaders_size =\n\t\tstrlen(HEADER_LINE_1 ) +\n\t\tstrlen(HEADER_LINE_2A) + MAX_CONTENT_LENGTH +\n\t\tstrlen(HEADER_LINE_2B) +\n\t\tstrlen(HEADER_LINE_3 ) +\n\t\tstrlen(HEADER_LINE_4 ) + 1;\n\theaders = (char *)malloc(headers_size);\n\tif (headers == NULL) {\n\t\tline = __LINE__;\n\t\tgoto ExitFunction;\n\t}\n\trc = snprintf(headers, headers_size, \"%s%s%\"PRIzu\"%s%s%s\",\n\t\tHEADER_LINE_1,\n\t\tHEADER_LINE_2A,\n\t\tstrlen(propertySet) + 2,\n\t\tHEADER_LINE_2B,\n\t\tHEADER_LINE_3,\n\t\tHEADER_LINE_4);\n\nExitFunction:\n\tif (headers == NULL || rc < 0 || (unsigned int) rc >= headers_size) {\n\t\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, line,\n\t\t\t\"AllocGenaHeaders(): Error UPNP_E_OUTOF_MEMORY\\n\");\n\t}\n\treturn headers;\n}"
  },
  {
    "function_name": "genaNotifyThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "307-388",
    "snippet": "static void genaNotifyThread(\n\t/*! [in] notify thread structure containing all the headers and property set info. */\n\tvoid *input)\n{\n\tsubscription *sub;\n\tservice_info *service;\n\tsubscription sub_copy;\n\tnotify_thread_struct *in = (notify_thread_struct *) input;\n\tint return_code;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\t/* This should be a HandleLock and not a HandleReadLock otherwise if there\n\t * is a lot of notifications, then multiple threads will acquire a read\n\t * lock and the thread which sends the notification will be blocked forever\n\t * on the HandleLock at the end of this function. */\n\t/*HandleReadLock(); */\n\tHandleLock();\n\t/* validate context */\n\n\tif (GetHandleInfo(in->device_handle, &handle_info) != HND_DEVICE) {\n\t\tfree_notify_struct(in);\n\t\tHandleUnlock();\n\t\treturn;\n\t}\n\n\tif (!(service = FindServiceId(&handle_info->ServiceTable, in->servId, in->UDN)) ||\n\t    !service->active ||\n\t    !(sub = GetSubscriptionSID(in->sid, service)) ||\n\t    copy_subscription(sub, &sub_copy) != HTTP_SUCCESS) {\n\t\tfree_notify_struct(in);\n\t\tHandleUnlock();\n\t\treturn;\n\t}\n#ifdef UPNP_ENABLE_NOTIFICATION_REORDERING\n\t/*If the event is out of order push it back to the job queue */\n\tif (in->eventKey != sub->ToSendEventKey) {\n\t\tTPJobInit(&job, (start_routine) genaNotifyThread, input);\n\t\tTPJobSetFreeFunction(&job, (free_function) free_notify_struct);\n\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t/* Sleep a little before creating another thread otherwise if there is\n\t\t * a lot of notifications to send, the device will take 100% of the CPU\n\t\t * to create threads and push them back to the job queue. */\n\t\timillisleep(1);\n\t\tThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\tfreeSubscription(&sub_copy);\n\t\tHandleUnlock();\n\t\treturn;\n\t}\n#endif\n\n\tHandleUnlock();\n\n\t/* send the notify */\n\treturn_code = genaNotify(in->headers, in->propertySet, &sub_copy);\n\tfreeSubscription(&sub_copy);\n\tHandleLock();\n\tif (GetHandleInfo(in->device_handle, &handle_info) != HND_DEVICE) {\n\t\tfree_notify_struct(in);\n\t\tHandleUnlock();\n\t\treturn;\n\t}\n\t/* validate context */\n\tif (!(service = FindServiceId(&handle_info->ServiceTable, in->servId, in->UDN)) ||\n\t    !service->active ||\n\t    !(sub = GetSubscriptionSID(in->sid, service))) {\n\t\tfree_notify_struct(in);\n\t\tHandleUnlock();\n\t\treturn;\n\t}\n\tsub->ToSendEventKey++;\n\tif (sub->ToSendEventKey < 0)\n\t\t/* wrap to 1 for overflow */\n\t\tsub->ToSendEventKey = 1;\n\tif (return_code == GENA_E_NOTIFY_UNACCEPTED_REMOVE_SUB)\n\t\tRemoveSubscriptionSID(in->sid, service);\n\tfree_notify_struct(in);\n\n\tHandleUnlock();\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_notify_struct",
          "args": [
            "in"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RemoveSubscriptionSID",
          "args": [
            "in->sid",
            "service"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "RemoveSubscriptionSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "97-120",
          "snippet": "void\nRemoveSubscriptionSID( Upnp_SID sid,\n                       service_info * service )\n{\n    subscription *finger = service->subscriptionList;\n    subscription *previous = NULL;\n\n    while( finger ) {\n        if( !( strcmp( sid, finger->sid ) ) ) {\n            if( previous )\n                previous->next = finger->next;\n            else\n                service->subscriptionList = finger->next;\n            finger->next = NULL;\n            freeSubscriptionList( finger );\n            finger = NULL;\n            service->TotalSubscriptions--;\n        } else {\n            previous = finger;\n            finger = finger->next;\n        }\n    }\n\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nvoid\nRemoveSubscriptionSID( Upnp_SID sid,\n                       service_info * service )\n{\n    subscription *finger = service->subscriptionList;\n    subscription *previous = NULL;\n\n    while( finger ) {\n        if( !( strcmp( sid, finger->sid ) ) ) {\n            if( previous )\n                previous->next = finger->next;\n            else\n                service->subscriptionList = finger->next;\n            finger->next = NULL;\n            freeSubscriptionList( finger );\n            finger = NULL;\n            service->TotalSubscriptions--;\n        } else {\n            previous = finger;\n            finger = finger->next;\n        }\n    }\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSubscriptionSID",
          "args": [
            "in->sid",
            "service"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "GetSubscriptionSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "123-156",
          "snippet": "subscription *GetSubscriptionSID(const Upnp_SID sid, service_info *service)\n{\n    subscription *next = service->subscriptionList;\n    subscription *previous = NULL;\n    subscription *found = NULL;\n\n    time_t current_time;\n\n    while( ( next ) && ( found == NULL ) ) {\n        if( !strcmp( next->sid, sid ) )\n            found = next;\n        else {\n            previous = next;\n            next = next->next;\n        }\n    }\n    if( found ) {\n        /*get the current_time */\n        time( &current_time );\n        if( ( found->expireTime != 0 )\n            && ( found->expireTime < current_time ) ) {\n            if( previous )\n                previous->next = found->next;\n            else\n                service->subscriptionList = found->next;\n            found->next = NULL;\n            freeSubscriptionList( found );\n            found = NULL;\n            service->TotalSubscriptions--;\n        }\n    }\n    return found;\n\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nsubscription *GetSubscriptionSID(const Upnp_SID sid, service_info *service)\n{\n    subscription *next = service->subscriptionList;\n    subscription *previous = NULL;\n    subscription *found = NULL;\n\n    time_t current_time;\n\n    while( ( next ) && ( found == NULL ) ) {\n        if( !strcmp( next->sid, sid ) )\n            found = next;\n        else {\n            previous = next;\n            next = next->next;\n        }\n    }\n    if( found ) {\n        /*get the current_time */\n        time( &current_time );\n        if( ( found->expireTime != 0 )\n            && ( found->expireTime < current_time ) ) {\n            if( previous )\n                previous->next = found->next;\n            else\n                service->subscriptionList = found->next;\n            found->next = NULL;\n            freeSubscriptionList( found );\n            found = NULL;\n            service->TotalSubscriptions--;\n        }\n    }\n    return found;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindServiceId",
          "args": [
            "&handle_info->ServiceTable",
            "in->servId",
            "in->UDN"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "FindServiceId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "257-276",
          "snippet": "service_info *\nFindServiceId( service_table * table,\n               const char *serviceId,\n               const char *UDN )\n{\n    service_info *finger = NULL;\n\n    if( table ) {\n        finger = table->serviceList;\n        while( finger ) {\n            if( ( !strcmp( serviceId, finger->serviceId ) ) &&\n                ( !strcmp( UDN, finger->UDN ) ) ) {\n                return finger;\n            }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nservice_info *\nFindServiceId( service_table * table,\n               const char *serviceId,\n               const char *UDN )\n{\n    service_info *finger = NULL;\n\n    if( table ) {\n        finger = table->serviceList;\n        while( finger ) {\n            if( ( !strcmp( serviceId, finger->serviceId ) ) &&\n                ( !strcmp( UDN, finger->UDN ) ) ) {\n                return finger;\n            }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "in->device_handle",
            "&handle_info"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeSubscription",
          "args": [
            "&sub_copy"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "freeSubscriptionList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "226-237",
          "snippet": "void\nfreeSubscriptionList( subscription * head )\n{\n    subscription *next = NULL;\n\n    while( head ) {\n        next = head->next;\n        freeSubscription( head );\n        free( head );\n        head = next;\n    }\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nvoid\nfreeSubscriptionList( subscription * head )\n{\n    subscription *next = NULL;\n\n    while( head ) {\n        next = head->next;\n        freeSubscription( head );\n        free( head );\n        head = next;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "genaNotify",
          "args": [
            "in->headers",
            "in->propertySet",
            "&sub_copy"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "genaNotify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "250-296",
          "snippet": "static int genaNotify(\n\t/*! [in] Null terminated, includes all headers (including \\\\r\\\\n) except SID and SEQ. */\n\tchar *headers,\n\t/*! [in] The evented XML. */\n\tchar *propertySet,\n\t/*! [in] subscription to be Notified, assumes this is valid for life of function. */\n\tsubscription *sub)\n{\n\tsize_t i;\n\tmembuffer mid_msg;\n\turi_type *url;\n\thttp_parser_t response;\n\tint return_code = -1;\n\n\tmembuffer_init(&mid_msg);\n\tif (http_MakeMessage(&mid_msg, 1, 1,\n\t\t\t     \"s\" \"ssc\" \"sdcc\",\n\t\t\t     headers,\n\t\t\t     \"SID: \", sub->sid,\n\t\t\t     \"SEQ: \", sub->ToSendEventKey) != 0) {\n\t\tmembuffer_destroy(&mid_msg);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\t/* send a notify to each url until one goes thru */\n\tfor (i = 0; i < sub->DeliveryURLs.size; i++) {\n\t\turl = &sub->DeliveryURLs.parsedURLs[i];\n\t\treturn_code = notify_send_and_recv(\n\t\t\turl, &mid_msg, propertySet, &response);\n\t\tif (return_code == UPNP_E_SUCCESS)\n\t\t\tbreak;\n\t}\n\tmembuffer_destroy(&mid_msg);\n\tif (return_code == UPNP_E_SUCCESS) {\n\t\tif (response.msg.status_code == HTTP_OK)\n\t\t\treturn_code = GENA_SUCCESS;\n\t\telse {\n\t\t\tif (response.msg.status_code == HTTP_PRECONDITION_FAILED)\n\t\t\t\t/*Invalid SID gets removed */\n\t\t\t\treturn_code = GENA_E_NOTIFY_UNACCEPTED_REMOVE_SUB;\n\t\t\telse\n\t\t\t\treturn_code = GENA_E_NOTIFY_UNACCEPTED;\n\t\t}\n\t\thttpmsg_destroy(&response.msg);\n\t}\n\n\treturn return_code;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic int genaNotify(\n\t/*! [in] Null terminated, includes all headers (including \\\\r\\\\n) except SID and SEQ. */\n\tchar *headers,\n\t/*! [in] The evented XML. */\n\tchar *propertySet,\n\t/*! [in] subscription to be Notified, assumes this is valid for life of function. */\n\tsubscription *sub)\n{\n\tsize_t i;\n\tmembuffer mid_msg;\n\turi_type *url;\n\thttp_parser_t response;\n\tint return_code = -1;\n\n\tmembuffer_init(&mid_msg);\n\tif (http_MakeMessage(&mid_msg, 1, 1,\n\t\t\t     \"s\" \"ssc\" \"sdcc\",\n\t\t\t     headers,\n\t\t\t     \"SID: \", sub->sid,\n\t\t\t     \"SEQ: \", sub->ToSendEventKey) != 0) {\n\t\tmembuffer_destroy(&mid_msg);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\t/* send a notify to each url until one goes thru */\n\tfor (i = 0; i < sub->DeliveryURLs.size; i++) {\n\t\turl = &sub->DeliveryURLs.parsedURLs[i];\n\t\treturn_code = notify_send_and_recv(\n\t\t\turl, &mid_msg, propertySet, &response);\n\t\tif (return_code == UPNP_E_SUCCESS)\n\t\t\tbreak;\n\t}\n\tmembuffer_destroy(&mid_msg);\n\tif (return_code == UPNP_E_SUCCESS) {\n\t\tif (response.msg.status_code == HTTP_OK)\n\t\t\treturn_code = GENA_SUCCESS;\n\t\telse {\n\t\t\tif (response.msg.status_code == HTTP_PRECONDITION_FAILED)\n\t\t\t\t/*Invalid SID gets removed */\n\t\t\t\treturn_code = GENA_E_NOTIFY_UNACCEPTED_REMOVE_SUB;\n\t\t\telse\n\t\t\t\treturn_code = GENA_E_NOTIFY_UNACCEPTED;\n\t\t}\n\t\thttpmsg_destroy(&response.msg);\n\t}\n\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ThreadPoolAdd",
          "args": [
            "&gSendThreadPool",
            "&job",
            "NULL"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imillisleep",
          "args": [
            "1"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "(free_function) free_notify_struct"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "(start_routine) genaNotifyThread",
            "input"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_subscription",
          "args": [
            "sub",
            "&sub_copy"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "copy_subscription",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "61-79",
          "snippet": "int\ncopy_subscription( subscription * in,\n                   subscription * out )\n{\n    int return_code = HTTP_SUCCESS;\n\n    memcpy( out->sid, in->sid, SID_SIZE );\n    out->sid[SID_SIZE] = 0;\n    out->eventKey = in->eventKey;\n    out->ToSendEventKey = in->ToSendEventKey;\n    out->expireTime = in->expireTime;\n    out->active = in->active;\n    if( ( return_code =\n          copy_URL_list( &in->DeliveryURLs, &out->DeliveryURLs ) )\n        != HTTP_SUCCESS )\n        return return_code;\n    out->next = NULL;\n    return HTTP_SUCCESS;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nint\ncopy_subscription( subscription * in,\n                   subscription * out )\n{\n    int return_code = HTTP_SUCCESS;\n\n    memcpy( out->sid, in->sid, SID_SIZE );\n    out->sid[SID_SIZE] = 0;\n    out->eventKey = in->eventKey;\n    out->ToSendEventKey = in->ToSendEventKey;\n    out->expireTime = in->expireTime;\n    out->active = in->active;\n    if( ( return_code =\n          copy_URL_list( &in->DeliveryURLs, &out->DeliveryURLs ) )\n        != HTTP_SUCCESS )\n        return return_code;\n    out->next = NULL;\n    return HTTP_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&job",
            "0",
            "sizeof(job)"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void genaNotifyThread(\n\t/*! [in] notify thread structure containing all the headers and property set info. */\n\tvoid *input)\n{\n\tsubscription *sub;\n\tservice_info *service;\n\tsubscription sub_copy;\n\tnotify_thread_struct *in = (notify_thread_struct *) input;\n\tint return_code;\n\tstruct Handle_Info *handle_info;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\t/* This should be a HandleLock and not a HandleReadLock otherwise if there\n\t * is a lot of notifications, then multiple threads will acquire a read\n\t * lock and the thread which sends the notification will be blocked forever\n\t * on the HandleLock at the end of this function. */\n\t/*HandleReadLock(); */\n\tHandleLock();\n\t/* validate context */\n\n\tif (GetHandleInfo(in->device_handle, &handle_info) != HND_DEVICE) {\n\t\tfree_notify_struct(in);\n\t\tHandleUnlock();\n\t\treturn;\n\t}\n\n\tif (!(service = FindServiceId(&handle_info->ServiceTable, in->servId, in->UDN)) ||\n\t    !service->active ||\n\t    !(sub = GetSubscriptionSID(in->sid, service)) ||\n\t    copy_subscription(sub, &sub_copy) != HTTP_SUCCESS) {\n\t\tfree_notify_struct(in);\n\t\tHandleUnlock();\n\t\treturn;\n\t}\n#ifdef UPNP_ENABLE_NOTIFICATION_REORDERING\n\t/*If the event is out of order push it back to the job queue */\n\tif (in->eventKey != sub->ToSendEventKey) {\n\t\tTPJobInit(&job, (start_routine) genaNotifyThread, input);\n\t\tTPJobSetFreeFunction(&job, (free_function) free_notify_struct);\n\t\tTPJobSetPriority(&job, MED_PRIORITY);\n\t\t/* Sleep a little before creating another thread otherwise if there is\n\t\t * a lot of notifications to send, the device will take 100% of the CPU\n\t\t * to create threads and push them back to the job queue. */\n\t\timillisleep(1);\n\t\tThreadPoolAdd(&gSendThreadPool, &job, NULL);\n\t\tfreeSubscription(&sub_copy);\n\t\tHandleUnlock();\n\t\treturn;\n\t}\n#endif\n\n\tHandleUnlock();\n\n\t/* send the notify */\n\treturn_code = genaNotify(in->headers, in->propertySet, &sub_copy);\n\tfreeSubscription(&sub_copy);\n\tHandleLock();\n\tif (GetHandleInfo(in->device_handle, &handle_info) != HND_DEVICE) {\n\t\tfree_notify_struct(in);\n\t\tHandleUnlock();\n\t\treturn;\n\t}\n\t/* validate context */\n\tif (!(service = FindServiceId(&handle_info->ServiceTable, in->servId, in->UDN)) ||\n\t    !service->active ||\n\t    !(sub = GetSubscriptionSID(in->sid, service))) {\n\t\tfree_notify_struct(in);\n\t\tHandleUnlock();\n\t\treturn;\n\t}\n\tsub->ToSendEventKey++;\n\tif (sub->ToSendEventKey < 0)\n\t\t/* wrap to 1 for overflow */\n\t\tsub->ToSendEventKey = 1;\n\tif (return_code == GENA_E_NOTIFY_UNACCEPTED_REMOVE_SUB)\n\t\tRemoveSubscriptionSID(in->sid, service);\n\tfree_notify_struct(in);\n\n\tHandleUnlock();\n}"
  },
  {
    "function_name": "genaNotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "250-296",
    "snippet": "static int genaNotify(\n\t/*! [in] Null terminated, includes all headers (including \\\\r\\\\n) except SID and SEQ. */\n\tchar *headers,\n\t/*! [in] The evented XML. */\n\tchar *propertySet,\n\t/*! [in] subscription to be Notified, assumes this is valid for life of function. */\n\tsubscription *sub)\n{\n\tsize_t i;\n\tmembuffer mid_msg;\n\turi_type *url;\n\thttp_parser_t response;\n\tint return_code = -1;\n\n\tmembuffer_init(&mid_msg);\n\tif (http_MakeMessage(&mid_msg, 1, 1,\n\t\t\t     \"s\" \"ssc\" \"sdcc\",\n\t\t\t     headers,\n\t\t\t     \"SID: \", sub->sid,\n\t\t\t     \"SEQ: \", sub->ToSendEventKey) != 0) {\n\t\tmembuffer_destroy(&mid_msg);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\t/* send a notify to each url until one goes thru */\n\tfor (i = 0; i < sub->DeliveryURLs.size; i++) {\n\t\turl = &sub->DeliveryURLs.parsedURLs[i];\n\t\treturn_code = notify_send_and_recv(\n\t\t\turl, &mid_msg, propertySet, &response);\n\t\tif (return_code == UPNP_E_SUCCESS)\n\t\t\tbreak;\n\t}\n\tmembuffer_destroy(&mid_msg);\n\tif (return_code == UPNP_E_SUCCESS) {\n\t\tif (response.msg.status_code == HTTP_OK)\n\t\t\treturn_code = GENA_SUCCESS;\n\t\telse {\n\t\t\tif (response.msg.status_code == HTTP_PRECONDITION_FAILED)\n\t\t\t\t/*Invalid SID gets removed */\n\t\t\t\treturn_code = GENA_E_NOTIFY_UNACCEPTED_REMOVE_SUB;\n\t\t\telse\n\t\t\t\treturn_code = GENA_E_NOTIFY_UNACCEPTED;\n\t\t}\n\t\thttpmsg_destroy(&response.msg);\n\t}\n\n\treturn return_code;\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&response.msg"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&mid_msg"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_send_and_recv",
          "args": [
            "url",
            "&mid_msg",
            "propertySet",
            "&response"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "notify_send_and_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "166-237",
          "snippet": "static UPNP_INLINE int notify_send_and_recv(\n\t/*! [in] subscription callback URL (URL of the control point). */\n\turi_type *destination_url,\n\t/*! [in] Common HTTP headers. */\n\tmembuffer *mid_msg,\n\t/*! [in] The evented XML. */\n\tchar *propertySet,\n\t/*! [out] The response from the control point. */\n\thttp_parser_t *response)\n{\n\turi_type url;\n\tSOCKET conn_fd;\n\tmembuffer start_msg;\n\tint ret_code;\n\tint err_code;\n\tint timeout;\n\tSOCKINFO info;\n\tconst char *CRLF = \"\\r\\n\";\n\n\t/* connect */\n\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, __LINE__,\n\t\t\"gena notify to: %.*s\\n\",\n\t\t(int)destination_url->hostport.text.size,\n\t\tdestination_url->hostport.text.buff);\n\n\tconn_fd = http_Connect(destination_url, &url);\n\tif (conn_fd < 0)\n\t\t/* return UPNP error */\n\t\treturn UPNP_E_SOCKET_CONNECT;\n\tret_code = sock_init(&info, conn_fd);\n\tif (ret_code) {\n\t\tsock_destroy(&info, SD_BOTH);\n\t\treturn ret_code;\n\t}\n\t/* make start line and HOST header */\n\tmembuffer_init(&start_msg);\n\tif (http_MakeMessage(\n\t\t\t&start_msg, 1, 1,\n\t\t\t\"q\" \"s\",\n\t\t\tHTTPMETHOD_NOTIFY, &url,\n\t\t\tmid_msg->buf) != 0) {\n\t\tmembuffer_destroy(&start_msg);\n\t\tsock_destroy(&info, SD_BOTH);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\ttimeout = GENA_NOTIFICATION_SENDING_TIMEOUT;\n\t/* send msg (note: end of notification will contain \"\\r\\n\" twice) */\n\tret_code = http_SendMessage(&info, &timeout,\n\t\t\"bbb\",\n\t\tstart_msg.buf, start_msg.length,\n\t\tpropertySet, strlen(propertySet),\n\t\tCRLF, strlen(CRLF));\n\tif (ret_code) {\n\t\tmembuffer_destroy(&start_msg);\n\t\tsock_destroy(&info, SD_BOTH);\n\t\treturn ret_code;\n\t}\n\ttimeout = GENA_NOTIFICATION_ANSWERING_TIMEOUT;\n\tret_code = http_RecvMessage(&info, response,\n\t\tHTTPMETHOD_NOTIFY, &timeout, &err_code);\n\tif (ret_code) {\n\t\tmembuffer_destroy(&start_msg);\n\t\tsock_destroy(&info, SD_BOTH);\n\t\thttpmsg_destroy(&response->msg);\n\t\treturn ret_code;\n\t}\n\t/* should shutdown completely when closing socket */\n\tsock_destroy(&info, SD_BOTH);\n\tmembuffer_destroy(&start_msg);\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int notify_send_and_recv(\n\t/*! [in] subscription callback URL (URL of the control point). */\n\turi_type *destination_url,\n\t/*! [in] Common HTTP headers. */\n\tmembuffer *mid_msg,\n\t/*! [in] The evented XML. */\n\tchar *propertySet,\n\t/*! [out] The response from the control point. */\n\thttp_parser_t *response)\n{\n\turi_type url;\n\tSOCKET conn_fd;\n\tmembuffer start_msg;\n\tint ret_code;\n\tint err_code;\n\tint timeout;\n\tSOCKINFO info;\n\tconst char *CRLF = \"\\r\\n\";\n\n\t/* connect */\n\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, __LINE__,\n\t\t\"gena notify to: %.*s\\n\",\n\t\t(int)destination_url->hostport.text.size,\n\t\tdestination_url->hostport.text.buff);\n\n\tconn_fd = http_Connect(destination_url, &url);\n\tif (conn_fd < 0)\n\t\t/* return UPNP error */\n\t\treturn UPNP_E_SOCKET_CONNECT;\n\tret_code = sock_init(&info, conn_fd);\n\tif (ret_code) {\n\t\tsock_destroy(&info, SD_BOTH);\n\t\treturn ret_code;\n\t}\n\t/* make start line and HOST header */\n\tmembuffer_init(&start_msg);\n\tif (http_MakeMessage(\n\t\t\t&start_msg, 1, 1,\n\t\t\t\"q\" \"s\",\n\t\t\tHTTPMETHOD_NOTIFY, &url,\n\t\t\tmid_msg->buf) != 0) {\n\t\tmembuffer_destroy(&start_msg);\n\t\tsock_destroy(&info, SD_BOTH);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\ttimeout = GENA_NOTIFICATION_SENDING_TIMEOUT;\n\t/* send msg (note: end of notification will contain \"\\r\\n\" twice) */\n\tret_code = http_SendMessage(&info, &timeout,\n\t\t\"bbb\",\n\t\tstart_msg.buf, start_msg.length,\n\t\tpropertySet, strlen(propertySet),\n\t\tCRLF, strlen(CRLF));\n\tif (ret_code) {\n\t\tmembuffer_destroy(&start_msg);\n\t\tsock_destroy(&info, SD_BOTH);\n\t\treturn ret_code;\n\t}\n\ttimeout = GENA_NOTIFICATION_ANSWERING_TIMEOUT;\n\tret_code = http_RecvMessage(&info, response,\n\t\tHTTPMETHOD_NOTIFY, &timeout, &err_code);\n\tif (ret_code) {\n\t\tmembuffer_destroy(&start_msg);\n\t\tsock_destroy(&info, SD_BOTH);\n\t\thttpmsg_destroy(&response->msg);\n\t\treturn ret_code;\n\t}\n\t/* should shutdown completely when closing socket */\n\tsock_destroy(&info, SD_BOTH);\n\tmembuffer_destroy(&start_msg);\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&mid_msg",
            "1",
            "1",
            "\"s\" \"ssc\" \"sdcc\"",
            "headers",
            "\"SID: \"",
            "sub->sid",
            "\"SEQ: \"",
            "sub->ToSendEventKey"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&mid_msg"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic int genaNotify(\n\t/*! [in] Null terminated, includes all headers (including \\\\r\\\\n) except SID and SEQ. */\n\tchar *headers,\n\t/*! [in] The evented XML. */\n\tchar *propertySet,\n\t/*! [in] subscription to be Notified, assumes this is valid for life of function. */\n\tsubscription *sub)\n{\n\tsize_t i;\n\tmembuffer mid_msg;\n\turi_type *url;\n\thttp_parser_t response;\n\tint return_code = -1;\n\n\tmembuffer_init(&mid_msg);\n\tif (http_MakeMessage(&mid_msg, 1, 1,\n\t\t\t     \"s\" \"ssc\" \"sdcc\",\n\t\t\t     headers,\n\t\t\t     \"SID: \", sub->sid,\n\t\t\t     \"SEQ: \", sub->ToSendEventKey) != 0) {\n\t\tmembuffer_destroy(&mid_msg);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\t/* send a notify to each url until one goes thru */\n\tfor (i = 0; i < sub->DeliveryURLs.size; i++) {\n\t\turl = &sub->DeliveryURLs.parsedURLs[i];\n\t\treturn_code = notify_send_and_recv(\n\t\t\turl, &mid_msg, propertySet, &response);\n\t\tif (return_code == UPNP_E_SUCCESS)\n\t\t\tbreak;\n\t}\n\tmembuffer_destroy(&mid_msg);\n\tif (return_code == UPNP_E_SUCCESS) {\n\t\tif (response.msg.status_code == HTTP_OK)\n\t\t\treturn_code = GENA_SUCCESS;\n\t\telse {\n\t\t\tif (response.msg.status_code == HTTP_PRECONDITION_FAILED)\n\t\t\t\t/*Invalid SID gets removed */\n\t\t\t\treturn_code = GENA_E_NOTIFY_UNACCEPTED_REMOVE_SUB;\n\t\t\telse\n\t\t\t\treturn_code = GENA_E_NOTIFY_UNACCEPTED;\n\t\t}\n\t\thttpmsg_destroy(&response.msg);\n\t}\n\n\treturn return_code;\n}"
  },
  {
    "function_name": "notify_send_and_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "166-237",
    "snippet": "static UPNP_INLINE int notify_send_and_recv(\n\t/*! [in] subscription callback URL (URL of the control point). */\n\turi_type *destination_url,\n\t/*! [in] Common HTTP headers. */\n\tmembuffer *mid_msg,\n\t/*! [in] The evented XML. */\n\tchar *propertySet,\n\t/*! [out] The response from the control point. */\n\thttp_parser_t *response)\n{\n\turi_type url;\n\tSOCKET conn_fd;\n\tmembuffer start_msg;\n\tint ret_code;\n\tint err_code;\n\tint timeout;\n\tSOCKINFO info;\n\tconst char *CRLF = \"\\r\\n\";\n\n\t/* connect */\n\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, __LINE__,\n\t\t\"gena notify to: %.*s\\n\",\n\t\t(int)destination_url->hostport.text.size,\n\t\tdestination_url->hostport.text.buff);\n\n\tconn_fd = http_Connect(destination_url, &url);\n\tif (conn_fd < 0)\n\t\t/* return UPNP error */\n\t\treturn UPNP_E_SOCKET_CONNECT;\n\tret_code = sock_init(&info, conn_fd);\n\tif (ret_code) {\n\t\tsock_destroy(&info, SD_BOTH);\n\t\treturn ret_code;\n\t}\n\t/* make start line and HOST header */\n\tmembuffer_init(&start_msg);\n\tif (http_MakeMessage(\n\t\t\t&start_msg, 1, 1,\n\t\t\t\"q\" \"s\",\n\t\t\tHTTPMETHOD_NOTIFY, &url,\n\t\t\tmid_msg->buf) != 0) {\n\t\tmembuffer_destroy(&start_msg);\n\t\tsock_destroy(&info, SD_BOTH);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\ttimeout = GENA_NOTIFICATION_SENDING_TIMEOUT;\n\t/* send msg (note: end of notification will contain \"\\r\\n\" twice) */\n\tret_code = http_SendMessage(&info, &timeout,\n\t\t\"bbb\",\n\t\tstart_msg.buf, start_msg.length,\n\t\tpropertySet, strlen(propertySet),\n\t\tCRLF, strlen(CRLF));\n\tif (ret_code) {\n\t\tmembuffer_destroy(&start_msg);\n\t\tsock_destroy(&info, SD_BOTH);\n\t\treturn ret_code;\n\t}\n\ttimeout = GENA_NOTIFICATION_ANSWERING_TIMEOUT;\n\tret_code = http_RecvMessage(&info, response,\n\t\tHTTPMETHOD_NOTIFY, &timeout, &err_code);\n\tif (ret_code) {\n\t\tmembuffer_destroy(&start_msg);\n\t\tsock_destroy(&info, SD_BOTH);\n\t\thttpmsg_destroy(&response->msg);\n\t\treturn ret_code;\n\t}\n\t/* should shutdown completely when closing socket */\n\tsock_destroy(&info, SD_BOTH);\n\tmembuffer_destroy(&start_msg);\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&start_msg"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_destroy",
          "args": [
            "&info",
            "SD_BOTH"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "sock_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "118-143",
          "snippet": "int sock_destroy(SOCKINFO *info, int ShutdownMethod)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (info->socket != INVALID_SOCKET) {\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t\tif (info->ssl) {\n\t\t\tSSL_shutdown(info->ssl);\n\t\t\tSSL_free(info->ssl);\n\t\t\tinfo->ssl = NULL;\n\t\t}\n#endif\n\t\tif (shutdown(info->socket, ShutdownMethod) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tif (sock_close(info->socket) == -1) {\n\t\t\tret = UPNP_E_SOCKET_ERROR;\n\t\t}\n\t\tinfo->socket = INVALID_SOCKET;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_destroy(SOCKINFO *info, int ShutdownMethod)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (info->socket != INVALID_SOCKET) {\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t\tif (info->ssl) {\n\t\t\tSSL_shutdown(info->ssl);\n\t\t\tSSL_free(info->ssl);\n\t\t\tinfo->ssl = NULL;\n\t\t}\n#endif\n\t\tif (shutdown(info->socket, ShutdownMethod) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tif (sock_close(info->socket) == -1) {\n\t\t\tret = UPNP_E_SOCKET_ERROR;\n\t\t}\n\t\tinfo->socket = INVALID_SOCKET;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&response->msg"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_RecvMessage",
          "args": [
            "&info",
            "response",
            "HTTPMETHOD_NOTIFY",
            "&timeout",
            "&err_code"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "http_RecvMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "344-435",
          "snippet": "int http_RecvMessage(\n\tIN SOCKINFO *info,\n\tOUT http_parser_t *parser,\n\tIN http_method_t request_method,\n\tIN OUT int *timeout_secs,\n\tOUT int *http_error_code)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tint line = 0;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar buf[2 * 1024];\n\n\tif (request_method == (http_method_t)HTTPMETHOD_UNKNOWN) {\n\t\tparser_request_init(parser);\n\t} else {\n\t\tparser_response_init(parser, request_method);\n\t}\n\n\twhile (TRUE) {\n\t\tnum_read = sock_read(info, buf, sizeof buf, timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* got data */\n\t\t\tstatus = parser_append(parser, buf, (size_t)num_read);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_SUCCESS:\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers( &parser->msg );\n\t\t\t\tif (g_maxContentLength > (size_t)0 && parser->content_length > (unsigned int)g_maxContentLength) {\n\t\t\t\t\t*http_error_code = HTTP_REQ_ENTITY_TOO_LARGE;\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_BOUNDS;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_FAILURE:\n\t\t\tcase PARSE_NO_MATCH:\n\t\t\t\t*http_error_code = parser->http_error_code;\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_INCOMPLETE_ENTITY:\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_CONTINUE_1:\n\t\t\t\t/* Web post request. */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = PARSE_SUCCESS;\n\t\t\t\tgoto ExitFunction;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*http_error_code = HTTP_BAD_REQUEST;    /* or response */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\tline = __LINE__;\n\t\t\tret = num_read;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, line,\n\t\t\t\"(http_RecvMessage): Error %d, http_error_code = %d.\\n\",\n\t\t\tret,\n\t\t\t*http_error_code);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_RecvMessage(\n\tIN SOCKINFO *info,\n\tOUT http_parser_t *parser,\n\tIN http_method_t request_method,\n\tIN OUT int *timeout_secs,\n\tOUT int *http_error_code)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tint line = 0;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar buf[2 * 1024];\n\n\tif (request_method == (http_method_t)HTTPMETHOD_UNKNOWN) {\n\t\tparser_request_init(parser);\n\t} else {\n\t\tparser_response_init(parser, request_method);\n\t}\n\n\twhile (TRUE) {\n\t\tnum_read = sock_read(info, buf, sizeof buf, timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* got data */\n\t\t\tstatus = parser_append(parser, buf, (size_t)num_read);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_SUCCESS:\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers( &parser->msg );\n\t\t\t\tif (g_maxContentLength > (size_t)0 && parser->content_length > (unsigned int)g_maxContentLength) {\n\t\t\t\t\t*http_error_code = HTTP_REQ_ENTITY_TOO_LARGE;\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_BOUNDS;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_FAILURE:\n\t\t\tcase PARSE_NO_MATCH:\n\t\t\t\t*http_error_code = parser->http_error_code;\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_INCOMPLETE_ENTITY:\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_CONTINUE_1:\n\t\t\t\t/* Web post request. */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = PARSE_SUCCESS;\n\t\t\t\tgoto ExitFunction;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*http_error_code = HTTP_BAD_REQUEST;    /* or response */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\tline = __LINE__;\n\t\t\tret = num_read;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, line,\n\t\t\t\"(http_RecvMessage): Error %d, http_error_code = %d.\\n\",\n\t\t\tret,\n\t\t\t*http_error_code);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_SendMessage",
          "args": [
            "&info",
            "&timeout",
            "\"bbb\"",
            "start_msg.buf",
            "start_msg.length",
            "propertySet",
            "strlen(propertySet)",
            "CRLF",
            "strlen(CRLF)"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "437-613",
          "snippet": "int http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CHUNK_TAIL_SIZE (size_t)10",
            "#define CHUNK_HEADER_SIZE (size_t)10",
            "#define snprintf _snprintf",
            "#define fseeko fseek"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n#define snprintf _snprintf\n#define fseeko fseek\n\nint http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "CRLF"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "propertySet"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&start_msg",
            "1",
            "1",
            "\"q\" \"s\"",
            "HTTPMETHOD_NOTIFY",
            "&url",
            "mid_msg->buf"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&start_msg"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_init",
          "args": [
            "&info",
            "conn_fd"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "sock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "73-81",
          "snippet": "int sock_init(SOCKINFO *info, SOCKET sockfd)\n{\n\tassert(info);\n\n\tmemset(info, 0, sizeof(SOCKINFO));\n\tinfo->socket = sockfd;\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_init(SOCKINFO *info, SOCKET sockfd)\n{\n\tassert(info);\n\n\tmemset(info, 0, sizeof(SOCKINFO));\n\tinfo->socket = sockfd;\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_Connect",
          "args": [
            "destination_url",
            "&url"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "http_Connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "288-323",
          "snippet": "SOCKET http_Connect(\n\tIN uri_type *destination_url,\n\tOUT uri_type *url)\n{\n\tSOCKET connfd;\n\tsocklen_t sockaddr_len;\n\tint ret_connect;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\thttp_FixUrl(destination_url, url);\n\n\tconnfd = socket((int)url->hostport.IPaddress.ss_family,\n\t\tSOCK_STREAM, 0);\n\tif (connfd == INVALID_SOCKET) {\n\t\treturn (SOCKET)(UPNP_E_OUTOF_SOCKET);\n\t}\n\tsockaddr_len = (socklen_t)(url->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in));\n\tret_connect = private_connect(connfd,\n\t\t(struct sockaddr *)&url->hostport.IPaddress, sockaddr_len);\n\tif (ret_connect == -1) {\n#ifdef WIN32\n\t\tUpnpPrintf(UPNP_CRITICAL, HTTP, __FILE__, __LINE__,\n\t\t\t\"connect error: %d\\n\", WSAGetLastError());\n#endif\n\t\tif (shutdown(connfd, SD_BOTH) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tUpnpCloseSocket(connfd);\n\t\treturn (SOCKET)(UPNP_E_SOCKET_CONNECT);\n\t}\n\n\treturn connfd;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nSOCKET http_Connect(\n\tIN uri_type *destination_url,\n\tOUT uri_type *url)\n{\n\tSOCKET connfd;\n\tsocklen_t sockaddr_len;\n\tint ret_connect;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\thttp_FixUrl(destination_url, url);\n\n\tconnfd = socket((int)url->hostport.IPaddress.ss_family,\n\t\tSOCK_STREAM, 0);\n\tif (connfd == INVALID_SOCKET) {\n\t\treturn (SOCKET)(UPNP_E_OUTOF_SOCKET);\n\t}\n\tsockaddr_len = (socklen_t)(url->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in));\n\tret_connect = private_connect(connfd,\n\t\t(struct sockaddr *)&url->hostport.IPaddress, sockaddr_len);\n\tif (ret_connect == -1) {\n#ifdef WIN32\n\t\tUpnpPrintf(UPNP_CRITICAL, HTTP, __FILE__, __LINE__,\n\t\t\t\"connect error: %d\\n\", WSAGetLastError());\n#endif\n\t\tif (shutdown(connfd, SD_BOTH) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tUpnpCloseSocket(connfd);\n\t\treturn (SOCKET)(UPNP_E_SOCKET_CONNECT);\n\t}\n\n\treturn connfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "GENA",
            "__FILE__",
            "__LINE__",
            "\"gena notify to: %.*s\\n\"",
            "(int)destination_url->hostport.text.size",
            "destination_url->hostport.text.buff"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic UPNP_INLINE int notify_send_and_recv(\n\t/*! [in] subscription callback URL (URL of the control point). */\n\turi_type *destination_url,\n\t/*! [in] Common HTTP headers. */\n\tmembuffer *mid_msg,\n\t/*! [in] The evented XML. */\n\tchar *propertySet,\n\t/*! [out] The response from the control point. */\n\thttp_parser_t *response)\n{\n\turi_type url;\n\tSOCKET conn_fd;\n\tmembuffer start_msg;\n\tint ret_code;\n\tint err_code;\n\tint timeout;\n\tSOCKINFO info;\n\tconst char *CRLF = \"\\r\\n\";\n\n\t/* connect */\n\tUpnpPrintf(UPNP_ALL, GENA, __FILE__, __LINE__,\n\t\t\"gena notify to: %.*s\\n\",\n\t\t(int)destination_url->hostport.text.size,\n\t\tdestination_url->hostport.text.buff);\n\n\tconn_fd = http_Connect(destination_url, &url);\n\tif (conn_fd < 0)\n\t\t/* return UPNP error */\n\t\treturn UPNP_E_SOCKET_CONNECT;\n\tret_code = sock_init(&info, conn_fd);\n\tif (ret_code) {\n\t\tsock_destroy(&info, SD_BOTH);\n\t\treturn ret_code;\n\t}\n\t/* make start line and HOST header */\n\tmembuffer_init(&start_msg);\n\tif (http_MakeMessage(\n\t\t\t&start_msg, 1, 1,\n\t\t\t\"q\" \"s\",\n\t\t\tHTTPMETHOD_NOTIFY, &url,\n\t\t\tmid_msg->buf) != 0) {\n\t\tmembuffer_destroy(&start_msg);\n\t\tsock_destroy(&info, SD_BOTH);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\ttimeout = GENA_NOTIFICATION_SENDING_TIMEOUT;\n\t/* send msg (note: end of notification will contain \"\\r\\n\" twice) */\n\tret_code = http_SendMessage(&info, &timeout,\n\t\t\"bbb\",\n\t\tstart_msg.buf, start_msg.length,\n\t\tpropertySet, strlen(propertySet),\n\t\tCRLF, strlen(CRLF));\n\tif (ret_code) {\n\t\tmembuffer_destroy(&start_msg);\n\t\tsock_destroy(&info, SD_BOTH);\n\t\treturn ret_code;\n\t}\n\ttimeout = GENA_NOTIFICATION_ANSWERING_TIMEOUT;\n\tret_code = http_RecvMessage(&info, response,\n\t\tHTTPMETHOD_NOTIFY, &timeout, &err_code);\n\tif (ret_code) {\n\t\tmembuffer_destroy(&start_msg);\n\t\tsock_destroy(&info, SD_BOTH);\n\t\thttpmsg_destroy(&response->msg);\n\t\treturn ret_code;\n\t}\n\t/* should shutdown completely when closing socket */\n\tsock_destroy(&info, SD_BOTH);\n\tmembuffer_destroy(&start_msg);\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "free_notify_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "144-157",
    "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "input"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "input->propertySet"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
  },
  {
    "function_name": "GeneratePropertySet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "92-138",
    "snippet": "static int GeneratePropertySet(\n\t/*! [in] Array of variable names (go in the event notify). */\n\tchar **names,\n\t/*! [in] Array of variable values (go in the event notify). */\n\tchar **values,\n\t/*! [in] number of variables. */\n\tint count,\n\t/*! [out] PropertySet node in the string format. */\n\tDOMString *out)\n{\n\tchar *buffer;\n\tint counter = 0;\n\tsize_t size = 0;\n\n\t/*size += strlen(XML_VERSION);*/\n\tsize += strlen(XML_PROPERTYSET_HEADER);\n\tsize += strlen(\"</e:propertyset>\\n\\n\");\n\tfor (counter = 0; counter < count; counter++) {\n\t\tsize += strlen( \"<e:property>\\n</e:property>\\n\" );\n\t\tsize += 2 * strlen(names[counter]) +\n\t\t\tstrlen(values[counter]) +\n\t\t\tstrlen(\"<></>\\n\");\n\t}\n\n\tbuffer = (char *)malloc(size + 1);\n\tif (buffer == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tmemset(buffer, 0, size + 1);\n\t/*\n\tstrcpy(buffer,XML_VERSION);\n\tstrcat(buffer, XML_PROPERTYSET_HEADER);\n\t*/\n\tstrcpy(buffer, XML_PROPERTYSET_HEADER);\n\tfor (counter = 0; counter < count; counter++) {\n\t\tstrcat(buffer, \"<e:property>\\n\");\n\t\tsprintf(&buffer[strlen(buffer)],\n\t\t\t\"<%s>%s</%s>\\n</e:property>\\n\",\n\t\t\tnames[counter],\n\t\t\tvalues[counter],\n\t\t\tnames[counter]);\n\t}\n\tstrcat(buffer, \"</e:propertyset>\\n\\n\");\n\t*out = ixmlCloneDOMString(buffer);\n\tfree(buffer);\n\n\treturn XML_SUCCESS;\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buffer"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlCloneDOMString",
          "args": [
            "buffer"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buffer",
            "\"</e:propertyset>\\n\\n\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "&buffer[strlen(buffer)]",
            "\"<%s>%s</%s>\\n</e:property>\\n\"",
            "names[counter]",
            "values[counter]",
            "names[counter]"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buffer",
            "\"<e:property>\\n\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "XML_PROPERTYSET_HEADER"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "size + 1"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size + 1"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"<></>\\n\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "values[counter]"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "names[counter]"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"<e:property>\\n</e:property>\\n\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"</e:propertyset>\\n\\n\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "XML_PROPERTYSET_HEADER"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic int GeneratePropertySet(\n\t/*! [in] Array of variable names (go in the event notify). */\n\tchar **names,\n\t/*! [in] Array of variable values (go in the event notify). */\n\tchar **values,\n\t/*! [in] number of variables. */\n\tint count,\n\t/*! [out] PropertySet node in the string format. */\n\tDOMString *out)\n{\n\tchar *buffer;\n\tint counter = 0;\n\tsize_t size = 0;\n\n\t/*size += strlen(XML_VERSION);*/\n\tsize += strlen(XML_PROPERTYSET_HEADER);\n\tsize += strlen(\"</e:propertyset>\\n\\n\");\n\tfor (counter = 0; counter < count; counter++) {\n\t\tsize += strlen( \"<e:property>\\n</e:property>\\n\" );\n\t\tsize += 2 * strlen(names[counter]) +\n\t\t\tstrlen(values[counter]) +\n\t\t\tstrlen(\"<></>\\n\");\n\t}\n\n\tbuffer = (char *)malloc(size + 1);\n\tif (buffer == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tmemset(buffer, 0, size + 1);\n\t/*\n\tstrcpy(buffer,XML_VERSION);\n\tstrcat(buffer, XML_PROPERTYSET_HEADER);\n\t*/\n\tstrcpy(buffer, XML_PROPERTYSET_HEADER);\n\tfor (counter = 0; counter < count; counter++) {\n\t\tstrcat(buffer, \"<e:property>\\n\");\n\t\tsprintf(&buffer[strlen(buffer)],\n\t\t\t\"<%s>%s</%s>\\n</e:property>\\n\",\n\t\t\tnames[counter],\n\t\t\tvalues[counter],\n\t\t\tnames[counter]);\n\t}\n\tstrcat(buffer, \"</e:propertyset>\\n\\n\");\n\t*out = ixmlCloneDOMString(buffer);\n\tfree(buffer);\n\n\treturn XML_SUCCESS;\n}"
  },
  {
    "function_name": "genaUnregisterDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
    "lines": "62-82",
    "snippet": "int genaUnregisterDevice(\n\t/*! [in] Device handle. */\n\tUpnpDevice_Handle device_handle)\n{\n\tint ret = 0;\n\tstruct Handle_Info *handle_info;\n\n\tHandleLock();\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, GENA, __FILE__, __LINE__,\n\t\t\t\"genaUnregisterDevice: BAD Handle: %d\\n\",\n\t\t\tdevice_handle);\n\t\tret = GENA_E_BAD_HANDLE;\n\t} else {\n\t\tfreeServiceTable(&handle_info->ServiceTable);\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tHandleUnlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"uuid.h\"",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeServiceTable",
          "args": [
            "&handle_info->ServiceTable"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "freeServiceTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "621-628",
          "snippet": "void\nfreeServiceTable( service_table * table )\n{\n    ixmlFreeDOMString( table->URLBase );\n    freeServiceList( table->serviceList );\n    table->serviceList = NULL;\n    table->endServiceList = NULL;\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nvoid\nfreeServiceTable( service_table * table )\n{\n    ixmlFreeDOMString( table->URLBase );\n    freeServiceList( table->serviceList );\n    table->serviceList = NULL;\n    table->endServiceList = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_CRITICAL",
            "GENA",
            "__FILE__",
            "__LINE__",
            "\"genaUnregisterDevice: BAD Handle: %d\\n\"",
            "device_handle"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "device_handle",
            "&handle_info"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nint genaUnregisterDevice(\n\t/*! [in] Device handle. */\n\tUpnpDevice_Handle device_handle)\n{\n\tint ret = 0;\n\tstruct Handle_Info *handle_info;\n\n\tHandleLock();\n\tif (GetHandleInfo(device_handle, &handle_info) != HND_DEVICE) {\n\t\tUpnpPrintf(UPNP_CRITICAL, GENA, __FILE__, __LINE__,\n\t\t\t\"genaUnregisterDevice: BAD Handle: %d\\n\",\n\t\t\tdevice_handle);\n\t\tret = GENA_E_BAD_HANDLE;\n\t} else {\n\t\tfreeServiceTable(&handle_info->ServiceTable);\n\t\tret = UPNP_E_SUCCESS;\n\t}\n\tHandleUnlock();\n\n\treturn ret;\n}"
  }
]