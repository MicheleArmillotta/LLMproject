[
  {
    "function_name": "uuid_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
    "lines": "283-300",
    "snippet": "int uuid_compare(uuid_upnp *u1, uuid_upnp *u2)\n{\n\tint i;\n\n\tCHECK(u1->time_low, u2->time_low);\n\tCHECK(u1->time_mid, u2->time_mid);\n\tCHECK(u1->time_hi_and_version, u2->time_hi_and_version);\n\tCHECK(u1->clock_seq_hi_and_reserved, u2->clock_seq_hi_and_reserved);\n\tCHECK(u1->clock_seq_low, u2->clock_seq_low)\n\t    for (i = 0; i < 6; i++) {\n\t\tif (u1->node[i] < u2->node[i])\n\t\t\treturn -1;\n\t\tif (u1->node[i] > u2->node[i])\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"uuid.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
      "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
      "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "u1->clock_seq_low",
            "u2->clock_seq_low"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "u1->clock_seq_hi_and_reserved",
            "u2->clock_seq_hi_and_reserved"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "u1->time_hi_and_version",
            "u2->time_hi_and_version"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "u1->time_mid",
            "u2->time_mid"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK",
          "args": [
            "u1->time_low",
            "u2->time_low"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\n\nint uuid_compare(uuid_upnp *u1, uuid_upnp *u2)\n{\n\tint i;\n\n\tCHECK(u1->time_low, u2->time_low);\n\tCHECK(u1->time_mid, u2->time_mid);\n\tCHECK(u1->time_hi_and_version, u2->time_hi_and_version);\n\tCHECK(u1->clock_seq_hi_and_reserved, u2->clock_seq_hi_and_reserved);\n\tCHECK(u1->clock_seq_low, u2->clock_seq_low)\n\t    for (i = 0; i < 6; i++) {\n\t\tif (u1->node[i] < u2->node[i])\n\t\t\treturn -1;\n\t\tif (u1->node[i] > u2->node[i])\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "format_uuid_v3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
    "lines": "256-270",
    "snippet": "void format_uuid_v3(uuid_upnp *uid, unsigned char hash[16])\n{\n\t/* Construct a version 3 uuid with the (pseudo-)random number plus a few\n\t * constants. */\n\tmemcpy(uid, hash, sizeof(uuid_upnp));\n\t/* convert UUID to local byte order. */\n\tuid->time_low = ntohl(uid->time_low);\n\tuid->time_mid = ntohs(uid->time_mid);\n\tuid->time_hi_and_version = ntohs(uid->time_hi_and_version);\n\t/* put in the variant and version bits. */\n\tuid->time_hi_and_version &= 0x0FFF;\n\tuid->time_hi_and_version |= (3 << 12);\n\tuid->clock_seq_hi_and_reserved &= 0x3F;\n\tuid->clock_seq_hi_and_reserved |= 0x80;\n}",
    "includes": [
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"uuid.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void format_uuid_v3(uuid_upnp *uid, unsigned char hash[16]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "uid->time_hi_and_version"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "uid->time_mid"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "uid->time_low"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "uid",
            "hash",
            "sizeof(uuid_upnp)"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic void format_uuid_v3(uuid_upnp *uid, unsigned char hash[16]);\n\nvoid format_uuid_v3(uuid_upnp *uid, unsigned char hash[16])\n{\n\t/* Construct a version 3 uuid with the (pseudo-)random number plus a few\n\t * constants. */\n\tmemcpy(uid, hash, sizeof(uuid_upnp));\n\t/* convert UUID to local byte order. */\n\tuid->time_low = ntohl(uid->time_low);\n\tuid->time_mid = ntohs(uid->time_mid);\n\tuid->time_hi_and_version = ntohs(uid->time_hi_and_version);\n\t/* put in the variant and version bits. */\n\tuid->time_hi_and_version &= 0x0FFF;\n\tuid->time_hi_and_version |= (3 << 12);\n\tuid->clock_seq_hi_and_reserved &= 0x3F;\n\tuid->clock_seq_hi_and_reserved |= 0x80;\n}"
  },
  {
    "function_name": "uuid_create_from_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
    "lines": "224-251",
    "snippet": "void uuid_create_from_name(\n\t/*! resulting UUID. */\n\tuuid_upnp *uid,\n\t/*! UUID to serve as context, so identical names from different name\n\t* spaces generate different UUIDs. */\n\tuuid_upnp nsid,\n\t/*! The name from which to generate a UUID. */\n\tvoid *name,\n\t/*! The length of the name. */\n\tint namelen)\n{\n\tMD5_CTX c;\n\tunsigned char hash[16];\n\tuuid_upnp net_nsid;\t/* context UUID in network byte order */\n\n\t/* put name space ID in network byte order so it hashes the same no matter\n\t * what endian machine we're on. */\n\tnet_nsid = nsid;\n\tnet_nsid.time_low = htonl(net_nsid.time_low);\n\tnet_nsid.time_mid = htons(net_nsid.time_mid);\n\tnet_nsid.time_hi_and_version = htons(net_nsid.time_hi_and_version);\n\tMD5Init(&c);\n\tMD5Update(&c, (unsigned char *)&net_nsid, sizeof(uuid_upnp));\n\tMD5Update(&c, name, (unsigned int)namelen);\n\tMD5Final(hash, &c);\n\t/* the hash is in network byte order at this point. */\n\tformat_uuid_v3(uid, hash);\n}",
    "includes": [
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"uuid.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void format_uuid_v3(uuid_upnp *uid, unsigned char hash[16]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "format_uuid_v3",
          "args": [
            "uid",
            "hash"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "format_uuid_v3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "256-270",
          "snippet": "void format_uuid_v3(uuid_upnp *uid, unsigned char hash[16])\n{\n\t/* Construct a version 3 uuid with the (pseudo-)random number plus a few\n\t * constants. */\n\tmemcpy(uid, hash, sizeof(uuid_upnp));\n\t/* convert UUID to local byte order. */\n\tuid->time_low = ntohl(uid->time_low);\n\tuid->time_mid = ntohs(uid->time_mid);\n\tuid->time_hi_and_version = ntohs(uid->time_hi_and_version);\n\t/* put in the variant and version bits. */\n\tuid->time_hi_and_version &= 0x0FFF;\n\tuid->time_hi_and_version |= (3 << 12);\n\tuid->clock_seq_hi_and_reserved &= 0x3F;\n\tuid->clock_seq_hi_and_reserved |= 0x80;\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"uuid.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void format_uuid_v3(uuid_upnp *uid, unsigned char hash[16]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic void format_uuid_v3(uuid_upnp *uid, unsigned char hash[16]);\n\nvoid format_uuid_v3(uuid_upnp *uid, unsigned char hash[16])\n{\n\t/* Construct a version 3 uuid with the (pseudo-)random number plus a few\n\t * constants. */\n\tmemcpy(uid, hash, sizeof(uuid_upnp));\n\t/* convert UUID to local byte order. */\n\tuid->time_low = ntohl(uid->time_low);\n\tuid->time_mid = ntohs(uid->time_mid);\n\tuid->time_hi_and_version = ntohs(uid->time_hi_and_version);\n\t/* put in the variant and version bits. */\n\tuid->time_hi_and_version &= 0x0FFF;\n\tuid->time_hi_and_version |= (3 << 12);\n\tuid->clock_seq_hi_and_reserved &= 0x3F;\n\tuid->clock_seq_hi_and_reserved |= 0x80;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MD5Final",
          "args": [
            "hash",
            "&c"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "163-186",
          "snippet": "void\nMD5Final(unsigned char digest[16], MD5_CTX *context)\n{\n    unsigned char bits[8];\n    unsigned int index;\n    unsigned int padLen;\n\n    /* Save number of bits */\n    Encode(bits, context->count, 8);\n\n    /* Pad out to 56 mod 64. */\n    index = (unsigned int)((context->count[0] >> 3) & 0x3f);\n    padLen = (index < 56) ? (56 - index) : (120 - index);\n    MD5Update(context, PADDING, padLen);\n\n    /* Append length (before padding) */\n    MD5Update(context, bits, 8);\n\n    /* Store state in digest */\n    Encode(digest, context->state, 16);\n\n    /* Zeroize sensitive information. */\n    MD5_memset((POINTER)context, 0, sizeof(*context));\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void Encode",
            "static void MD5_memset",
            "static unsigned char PADDING[64] = {\n    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void Encode;\nstatic void MD5_memset;\nstatic unsigned char PADDING[64] = {\n    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};\n\nvoid\nMD5Final(unsigned char digest[16], MD5_CTX *context)\n{\n    unsigned char bits[8];\n    unsigned int index;\n    unsigned int padLen;\n\n    /* Save number of bits */\n    Encode(bits, context->count, 8);\n\n    /* Pad out to 56 mod 64. */\n    index = (unsigned int)((context->count[0] >> 3) & 0x3f);\n    padLen = (index < 56) ? (56 - index) : (120 - index);\n    MD5Update(context, PADDING, padLen);\n\n    /* Append length (before padding) */\n    MD5Update(context, bits, 8);\n\n    /* Store state in digest */\n    Encode(digest, context->state, 16);\n\n    /* Zeroize sensitive information. */\n    MD5_memset((POINTER)context, 0, sizeof(*context));\n}"
        }
      },
      {
        "call_info": {
          "callee": "MD5Update",
          "args": [
            "&c",
            "name",
            "(unsigned int)namelen"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "126-157",
          "snippet": "void\nMD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen)\n{\n\tunsigned int i;\n\tunsigned int index;\n\tunsigned int partLen;\n\n\t/* Compute number of bytes mod 64 */\n\tindex = (unsigned int)((context->count[0] >> 3) & 0x3F);\n\n\t/* Update number of bits */\n\tif ((context->count[0] += ((UINT4)inputLen << 3)) < ((UINT4)inputLen << 3)) {\n\t\tcontext->count[1]++;\n\t}\n\tcontext->count[1] += ((UINT4)inputLen >> 29);\n\tpartLen = 64 - index;\n\n\t/* Transform as many times as possible. */\n\tif (inputLen >= partLen) {\n\t\tMD5_memcpy((POINTER)&context->buffer[index], (POINTER)input, partLen);\n\t\tMD5Transform(context->state, context->buffer);\n\t\tfor (i = partLen; i + 63 < inputLen; i += 64) {\n\t\t\tMD5Transform(context->state, &input[i]);\n\t\t}\n\t\tindex = 0;\n\t} else {\n\t\ti = 0;\n\t}\n\n\t/* Buffer remaining input */\n\tMD5_memcpy((POINTER)&context->buffer[index], (POINTER)&input[i], inputLen - i);\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5Transform",
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5Transform;\nstatic void MD5_memcpy;\n\nvoid\nMD5Update(MD5_CTX *context, unsigned char *input, unsigned int inputLen)\n{\n\tunsigned int i;\n\tunsigned int index;\n\tunsigned int partLen;\n\n\t/* Compute number of bytes mod 64 */\n\tindex = (unsigned int)((context->count[0] >> 3) & 0x3F);\n\n\t/* Update number of bits */\n\tif ((context->count[0] += ((UINT4)inputLen << 3)) < ((UINT4)inputLen << 3)) {\n\t\tcontext->count[1]++;\n\t}\n\tcontext->count[1] += ((UINT4)inputLen >> 29);\n\tpartLen = 64 - index;\n\n\t/* Transform as many times as possible. */\n\tif (inputLen >= partLen) {\n\t\tMD5_memcpy((POINTER)&context->buffer[index], (POINTER)input, partLen);\n\t\tMD5Transform(context->state, context->buffer);\n\t\tfor (i = partLen; i + 63 < inputLen; i += 64) {\n\t\t\tMD5Transform(context->state, &input[i]);\n\t\t}\n\t\tindex = 0;\n\t} else {\n\t\ti = 0;\n\t}\n\n\t/* Buffer remaining input */\n\tMD5_memcpy((POINTER)&context->buffer[index], (POINTER)&input[i], inputLen - i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MD5Init",
          "args": [
            "&c"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "MD5Init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "109-118",
          "snippet": "void\nMD5Init(MD5_CTX * context)\n{\n    context->count[0] = context->count[1] = 0;\n    /* Load magic initialization constants. */\n    context->state[0] = 0x67452301;\n    context->state[1] = 0xefcdab89;\n    context->state[2] = 0x98badcfe;\n    context->state[3] = 0x10325476;\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nvoid\nMD5Init(MD5_CTX * context)\n{\n    context->count[0] = context->count[1] = 0;\n    /* Load magic initialization constants. */\n    context->state[0] = 0x67452301;\n    context->state[1] = 0xefcdab89;\n    context->state[2] = 0x98badcfe;\n    context->state[3] = 0x10325476;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "net_nsid.time_hi_and_version"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "net_nsid.time_mid"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "net_nsid.time_low"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic void format_uuid_v3(uuid_upnp *uid, unsigned char hash[16]);\n\nvoid uuid_create_from_name(\n\t/*! resulting UUID. */\n\tuuid_upnp *uid,\n\t/*! UUID to serve as context, so identical names from different name\n\t* spaces generate different UUIDs. */\n\tuuid_upnp nsid,\n\t/*! The name from which to generate a UUID. */\n\tvoid *name,\n\t/*! The length of the name. */\n\tint namelen)\n{\n\tMD5_CTX c;\n\tunsigned char hash[16];\n\tuuid_upnp net_nsid;\t/* context UUID in network byte order */\n\n\t/* put name space ID in network byte order so it hashes the same no matter\n\t * what endian machine we're on. */\n\tnet_nsid = nsid;\n\tnet_nsid.time_low = htonl(net_nsid.time_low);\n\tnet_nsid.time_mid = htons(net_nsid.time_mid);\n\tnet_nsid.time_hi_and_version = htons(net_nsid.time_hi_and_version);\n\tMD5Init(&c);\n\tMD5Update(&c, (unsigned char *)&net_nsid, sizeof(uuid_upnp));\n\tMD5Update(&c, name, (unsigned int)namelen);\n\tMD5Final(hash, &c);\n\t/* the hash is in network byte order at this point. */\n\tformat_uuid_v3(uid, hash);\n}"
  },
  {
    "function_name": "true_random",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
    "lines": "205-219",
    "snippet": "static uint16_t true_random(void)\n{\n\tstatic int inited = 0;\n\tuuid_time_t time_now;\n\n\tif (!inited) {\n\t\tget_system_time(&time_now);\n\t\ttime_now = time_now / UUIDS_PER_TICK;\n\t\tsrand((unsigned int)(((time_now >> 32) ^ time_now) &\n\t\t\t\t     0xffffffff));\n\t\tinited = 1;\n\t};\n\n\treturn (uint16_t) (rand());\n}",
    "includes": [
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"uuid.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static uint16_t true_random(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "true_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "205-219",
          "snippet": "static uint16_t true_random(void)\n{\n\tstatic int inited = 0;\n\tuuid_time_t time_now;\n\n\tif (!inited) {\n\t\tget_system_time(&time_now);\n\t\ttime_now = time_now / UUIDS_PER_TICK;\n\t\tsrand((unsigned int)(((time_now >> 32) ^ time_now) &\n\t\t\t\t     0xffffffff));\n\t\tinited = 1;\n\t};\n\n\treturn (uint16_t) (rand());\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "srand",
          "args": [
            "(unsigned int)(((time_now >> 32) ^ time_now) &\n\t\t\t\t     0xffffffff)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_system_time",
          "args": [
            "&time_now"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "get_system_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/sysdep.c",
          "lines": "115-127",
          "snippet": "void get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpInet.h\"",
            "#include \"sysdep.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <string.h>\n#include \"UpnpInet.h\"\n#include \"sysdep.h\"\n#include \"config.h\"\n\nvoid get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic uint16_t true_random(void);\n\nstatic uint16_t true_random(void)\n{\n\tstatic int inited = 0;\n\tuuid_time_t time_now;\n\n\tif (!inited) {\n\t\tget_system_time(&time_now);\n\t\ttime_now = time_now / UUIDS_PER_TICK;\n\t\tsrand((unsigned int)(((time_now >> 32) ^ time_now) &\n\t\t\t\t     0xffffffff));\n\t\tinited = 1;\n\t};\n\n\treturn (uint16_t) (rand());\n}"
  },
  {
    "function_name": "get_current_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
    "lines": "171-199",
    "snippet": "void get_current_time(uuid_time_t *timestamp)\n{\n\tuuid_time_t time_now;\n\tstatic uuid_time_t time_last;\n\tstatic uint16_t uuids_this_tick;\n\tstatic int inited = 0;\n\n\tif (!inited) {\n\t\tuuids_this_tick = UUIDS_PER_TICK;\n\t\tinited = 1;\n\t};\n\twhile (1) {\n\t\tget_system_time(&time_now);\n\t\t/* if clock reading changed since last UUID generated... */\n\t\tif (time_last != time_now) {\n\t\t\t/* reset count of uuids gen'd with this clock reading. */\n\t\t\tuuids_this_tick = 0;\n\t\t\tbreak;\n\t\t};\n\t\tif (uuids_this_tick < UUIDS_PER_TICK) {\n\t\t\tuuids_this_tick++;\n\t\t\tbreak;\n\t\t};\n\t\t/* going too fast for our clock; spin. */\n\t};\n\t/* add the count of uuids to low order bits of the clock reading. */\n\t*timestamp = time_now + uuids_this_tick;\n\ttime_last = *timestamp;\n}",
    "includes": [
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"uuid.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void get_current_time(uuid_time_t *timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_system_time",
          "args": [
            "&time_now"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "get_system_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/sysdep.c",
          "lines": "115-127",
          "snippet": "void get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpInet.h\"",
            "#include \"sysdep.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <string.h>\n#include \"UpnpInet.h\"\n#include \"sysdep.h\"\n#include \"config.h\"\n\nvoid get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic void get_current_time(uuid_time_t *timestamp);\n\nvoid get_current_time(uuid_time_t *timestamp)\n{\n\tuuid_time_t time_now;\n\tstatic uuid_time_t time_last;\n\tstatic uint16_t uuids_this_tick;\n\tstatic int inited = 0;\n\n\tif (!inited) {\n\t\tuuids_this_tick = UUIDS_PER_TICK;\n\t\tinited = 1;\n\t};\n\twhile (1) {\n\t\tget_system_time(&time_now);\n\t\t/* if clock reading changed since last UUID generated... */\n\t\tif (time_last != time_now) {\n\t\t\t/* reset count of uuids gen'd with this clock reading. */\n\t\t\tuuids_this_tick = 0;\n\t\t\tbreak;\n\t\t};\n\t\tif (uuids_this_tick < UUIDS_PER_TICK) {\n\t\t\tuuids_this_tick++;\n\t\t\tbreak;\n\t\t};\n\t\t/* going too fast for our clock; spin. */\n\t};\n\t/* add the count of uuids to low order bits of the clock reading. */\n\t*timestamp = time_now + uuids_this_tick;\n\ttime_last = *timestamp;\n}"
  },
  {
    "function_name": "write_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
    "lines": "148-164",
    "snippet": "void write_state(uint16_t clockseq, uuid_time_t timestamp, uuid_node_t node)\n{\n\tstatic uuid_time_t next_save;\n\n\tif (!stateInited) {\n\t\tnext_save = timestamp;\n\t\tstateInited = 1;\n\t};\n\t/* always save state to volatile shared state. */\n\tst.cs = clockseq;\n\tst.ts = timestamp;\n\tst.node = node;\n\tif (timestamp >= next_save) {\n\t\t/* schedule next save for 10 seconds from now. */\n\t\tnext_save = timestamp + (10 * 10 * 1000 * 1000);\n\t};\n}",
    "includes": [
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"uuid.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
      "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
      "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);",
      "static void get_current_time(uuid_time_t *timestamp);",
      "static uuid_state st;",
      "static int stateInited = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\nstatic void get_current_time(uuid_time_t *timestamp);\nstatic uuid_state st;\nstatic int stateInited = 0;\n\nvoid write_state(uint16_t clockseq, uuid_time_t timestamp, uuid_node_t node)\n{\n\tstatic uuid_time_t next_save;\n\n\tif (!stateInited) {\n\t\tnext_save = timestamp;\n\t\tstateInited = 1;\n\t};\n\t/* always save state to volatile shared state. */\n\tst.cs = clockseq;\n\tst.ts = timestamp;\n\tst.node = node;\n\tif (timestamp >= next_save) {\n\t\t/* schedule next save for 10 seconds from now. */\n\t\tnext_save = timestamp + (10 * 10 * 1000 * 1000);\n\t};\n}"
  },
  {
    "function_name": "read_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
    "lines": "133-143",
    "snippet": "int read_state(uint16_t *clockseq,\n\t       uuid_time_t *timestamp, uuid_node_t *node)\n{\n\tif (!stateInited)\n\t\treturn 0;\n\t*clockseq = st.cs;\n\t*timestamp = st.ts;\n\t*node = st.node;\n\n\treturn 1;\n}",
    "includes": [
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"uuid.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
      "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
      "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);",
      "static void get_current_time(uuid_time_t *timestamp);",
      "static uuid_state st;",
      "static int stateInited = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\nstatic void get_current_time(uuid_time_t *timestamp);\nstatic uuid_state st;\nstatic int stateInited = 0;\n\nint read_state(uint16_t *clockseq,\n\t       uuid_time_t *timestamp, uuid_node_t *node)\n{\n\tif (!stateInited)\n\t\treturn 0;\n\t*clockseq = st.cs;\n\t*timestamp = st.ts;\n\t*node = st.node;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "format_uuid_v1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
    "lines": "101-115",
    "snippet": "void format_uuid_v1(uuid_upnp * uid,\n\t\t    uint16_t clock_seq,\n\t\t    uuid_time_t timestamp, uuid_node_t node)\n{\n\t/* Construct a version 1 uuid with the information we've gathered\n\t * plus a few constants. */\n\tuid->time_low = (uint32_t)(timestamp & 0xFFFFFFFF);\n\tuid->time_mid = (uint16_t)((timestamp >> 32) & 0xFFFF);\n\tuid->time_hi_and_version = (uint16_t)((timestamp >> 48) & 0x0FFF);\n\tuid->time_hi_and_version |= (1 << 12);\n\tuid->clock_seq_low = (uint8_t) (clock_seq & 0xFF);\n\tuid->clock_seq_hi_and_reserved = (uint8_t) ((clock_seq & 0x3F00) >> 8);\n\tuid->clock_seq_hi_and_reserved |= 0x80;\n\tmemcpy(&uid->node, &node, sizeof uid->node);\n}",
    "includes": [
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"uuid.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
      "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
      "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);",
      "static void get_current_time(uuid_time_t *timestamp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&uid->node",
            "&node",
            "sizeof uid->node"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\nstatic void get_current_time(uuid_time_t *timestamp);\n\nvoid format_uuid_v1(uuid_upnp * uid,\n\t\t    uint16_t clock_seq,\n\t\t    uuid_time_t timestamp, uuid_node_t node)\n{\n\t/* Construct a version 1 uuid with the information we've gathered\n\t * plus a few constants. */\n\tuid->time_low = (uint32_t)(timestamp & 0xFFFFFFFF);\n\tuid->time_mid = (uint16_t)((timestamp >> 32) & 0xFFFF);\n\tuid->time_hi_and_version = (uint16_t)((timestamp >> 48) & 0x0FFF);\n\tuid->time_hi_and_version |= (1 << 12);\n\tuid->clock_seq_low = (uint8_t) (clock_seq & 0xFF);\n\tuid->clock_seq_hi_and_reserved = (uint8_t) ((clock_seq & 0x3F00) >> 8);\n\tuid->clock_seq_hi_and_reserved |= 0x80;\n\tmemcpy(&uid->node, &node, sizeof uid->node);\n}"
  },
  {
    "function_name": "uuid_unpack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
    "lines": "85-96",
    "snippet": "void uuid_unpack(uuid_upnp * u, char *out)\n{\n\tsprintf(out,\n\t\t\"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\",\n\t\t(unsigned int)u->time_low,\n\t\tu->time_mid,\n\t\tu->time_hi_and_version,\n\t\tu->clock_seq_hi_and_reserved,\n\t\tu->clock_seq_low,\n\t\tu->node[0],\n\t\tu->node[1], u->node[2], u->node[3], u->node[4], u->node[5]);\n}",
    "includes": [
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"uuid.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
      "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
      "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "out",
            "\"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\"",
            "(unsigned int)u->time_low",
            "u->time_mid",
            "u->time_hi_and_version",
            "u->clock_seq_hi_and_reserved",
            "u->clock_seq_low",
            "u->node[0]",
            "u->node[1]",
            "u->node[2]",
            "u->node[3]",
            "u->node[4]",
            "u->node[5]"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\n\nvoid uuid_unpack(uuid_upnp * u, char *out)\n{\n\tsprintf(out,\n\t\t\"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\",\n\t\t(unsigned int)u->time_low,\n\t\tu->time_mid,\n\t\tu->time_hi_and_version,\n\t\tu->clock_seq_hi_and_reserved,\n\t\tu->clock_seq_low,\n\t\tu->node[0],\n\t\tu->node[1], u->node[2], u->node[3], u->node[4], u->node[5]);\n}"
  },
  {
    "function_name": "uuid_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
    "lines": "53-83",
    "snippet": "int uuid_create(uuid_upnp * uid)\n{\n\tuuid_time_t timestamp;\n\tuuid_time_t last_time;\n\tuint16_t clockseq;\n\tuuid_node_t node;\n\tuuid_node_t last_node;\n\tint f;\n\n\t/* acquire system wide lock so we're alone. */\n\tUUIDLock();\n\t/* get current time. */\n\tget_current_time(&timestamp);\n\t/* get node ID. */\n\tget_ieee_node_identifier(&node);\n\t/* get saved state from NV storage. */\n\tf = read_state(&clockseq, &last_time, &last_node);\n\t/* if no NV state, or if clock went backwards, or node ID changed\n\t * (e.g., net card swap) change clockseq. */\n\tif (!f || memcmp(&node, &last_node, sizeof(uuid_node_t)))\n\t\tclockseq = true_random();\n\telse if (timestamp < last_time)\n\t\tclockseq++;\n\t/* stuff fields into the UUID. */\n\tformat_uuid_v1(uid, clockseq, timestamp, node);\n\t/* save the state for next time. */\n\twrite_state(clockseq, timestamp, node);\n\tUUIDUnlock();\n\n\treturn 1;\n}",
    "includes": [
      "#include <time.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"uuid.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
      "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
      "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);",
      "static void get_current_time(uuid_time_t *timestamp);",
      "static uint16_t true_random(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UUIDUnlock",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_state",
          "args": [
            "clockseq",
            "timestamp",
            "node"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "write_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "148-164",
          "snippet": "void write_state(uint16_t clockseq, uuid_time_t timestamp, uuid_node_t node)\n{\n\tstatic uuid_time_t next_save;\n\n\tif (!stateInited) {\n\t\tnext_save = timestamp;\n\t\tstateInited = 1;\n\t};\n\t/* always save state to volatile shared state. */\n\tst.cs = clockseq;\n\tst.ts = timestamp;\n\tst.node = node;\n\tif (timestamp >= next_save) {\n\t\t/* schedule next save for 10 seconds from now. */\n\t\tnext_save = timestamp + (10 * 10 * 1000 * 1000);\n\t};\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"uuid.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
            "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
            "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);",
            "static void get_current_time(uuid_time_t *timestamp);",
            "static uuid_state st;",
            "static int stateInited = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\nstatic void get_current_time(uuid_time_t *timestamp);\nstatic uuid_state st;\nstatic int stateInited = 0;\n\nvoid write_state(uint16_t clockseq, uuid_time_t timestamp, uuid_node_t node)\n{\n\tstatic uuid_time_t next_save;\n\n\tif (!stateInited) {\n\t\tnext_save = timestamp;\n\t\tstateInited = 1;\n\t};\n\t/* always save state to volatile shared state. */\n\tst.cs = clockseq;\n\tst.ts = timestamp;\n\tst.node = node;\n\tif (timestamp >= next_save) {\n\t\t/* schedule next save for 10 seconds from now. */\n\t\tnext_save = timestamp + (10 * 10 * 1000 * 1000);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_uuid_v1",
          "args": [
            "uid",
            "clockseq",
            "timestamp",
            "node"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "format_uuid_v1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "101-115",
          "snippet": "void format_uuid_v1(uuid_upnp * uid,\n\t\t    uint16_t clock_seq,\n\t\t    uuid_time_t timestamp, uuid_node_t node)\n{\n\t/* Construct a version 1 uuid with the information we've gathered\n\t * plus a few constants. */\n\tuid->time_low = (uint32_t)(timestamp & 0xFFFFFFFF);\n\tuid->time_mid = (uint16_t)((timestamp >> 32) & 0xFFFF);\n\tuid->time_hi_and_version = (uint16_t)((timestamp >> 48) & 0x0FFF);\n\tuid->time_hi_and_version |= (1 << 12);\n\tuid->clock_seq_low = (uint8_t) (clock_seq & 0xFF);\n\tuid->clock_seq_hi_and_reserved = (uint8_t) ((clock_seq & 0x3F00) >> 8);\n\tuid->clock_seq_hi_and_reserved |= 0x80;\n\tmemcpy(&uid->node, &node, sizeof uid->node);\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"uuid.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
            "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
            "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);",
            "static void get_current_time(uuid_time_t *timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\nstatic void get_current_time(uuid_time_t *timestamp);\n\nvoid format_uuid_v1(uuid_upnp * uid,\n\t\t    uint16_t clock_seq,\n\t\t    uuid_time_t timestamp, uuid_node_t node)\n{\n\t/* Construct a version 1 uuid with the information we've gathered\n\t * plus a few constants. */\n\tuid->time_low = (uint32_t)(timestamp & 0xFFFFFFFF);\n\tuid->time_mid = (uint16_t)((timestamp >> 32) & 0xFFFF);\n\tuid->time_hi_and_version = (uint16_t)((timestamp >> 48) & 0x0FFF);\n\tuid->time_hi_and_version |= (1 << 12);\n\tuid->clock_seq_low = (uint8_t) (clock_seq & 0xFF);\n\tuid->clock_seq_hi_and_reserved = (uint8_t) ((clock_seq & 0x3F00) >> 8);\n\tuid->clock_seq_hi_and_reserved |= 0x80;\n\tmemcpy(&uid->node, &node, sizeof uid->node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "true_random",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "true_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "205-219",
          "snippet": "static uint16_t true_random(void)\n{\n\tstatic int inited = 0;\n\tuuid_time_t time_now;\n\n\tif (!inited) {\n\t\tget_system_time(&time_now);\n\t\ttime_now = time_now / UUIDS_PER_TICK;\n\t\tsrand((unsigned int)(((time_now >> 32) ^ time_now) &\n\t\t\t\t     0xffffffff));\n\t\tinited = 1;\n\t};\n\n\treturn (uint16_t) (rand());\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"uuid.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint16_t true_random(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic uint16_t true_random(void);\n\nstatic uint16_t true_random(void)\n{\n\tstatic int inited = 0;\n\tuuid_time_t time_now;\n\n\tif (!inited) {\n\t\tget_system_time(&time_now);\n\t\ttime_now = time_now / UUIDS_PER_TICK;\n\t\tsrand((unsigned int)(((time_now >> 32) ^ time_now) &\n\t\t\t\t     0xffffffff));\n\t\tinited = 1;\n\t};\n\n\treturn (uint16_t) (rand());\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&node",
            "&last_node",
            "sizeof(uuid_node_t)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_state",
          "args": [
            "&clockseq",
            "&last_time",
            "&last_node"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "read_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "133-143",
          "snippet": "int read_state(uint16_t *clockseq,\n\t       uuid_time_t *timestamp, uuid_node_t *node)\n{\n\tif (!stateInited)\n\t\treturn 0;\n\t*clockseq = st.cs;\n\t*timestamp = st.ts;\n\t*node = st.node;\n\n\treturn 1;\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"uuid.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
            "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
            "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);",
            "static void get_current_time(uuid_time_t *timestamp);",
            "static uuid_state st;",
            "static int stateInited = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\nstatic void get_current_time(uuid_time_t *timestamp);\nstatic uuid_state st;\nstatic int stateInited = 0;\n\nint read_state(uint16_t *clockseq,\n\t       uuid_time_t *timestamp, uuid_node_t *node)\n{\n\tif (!stateInited)\n\t\treturn 0;\n\t*clockseq = st.cs;\n\t*timestamp = st.ts;\n\t*node = st.node;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ieee_node_identifier",
          "args": [
            "&node"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "get_ieee_node_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/sysdep.c",
          "lines": "38-51",
          "snippet": "void get_ieee_node_identifier(uuid_node_t *node)\n{\n\tunsigned char seed[16];\n\tstatic int inited = 0;\n\tstatic uuid_node_t saved_node;\n\n\tif (!inited) {\n\t\tget_random_info(seed);\n\t\tseed[0] |= 0x80;\n\t\tmemcpy(&saved_node, seed, sizeof(uuid_node_t));\n\t\tinited = 1;\n\t};\n\t*node = saved_node;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpInet.h\"",
            "#include \"sysdep.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <string.h>\n#include \"UpnpInet.h\"\n#include \"sysdep.h\"\n#include \"config.h\"\n\nvoid get_ieee_node_identifier(uuid_node_t *node)\n{\n\tunsigned char seed[16];\n\tstatic int inited = 0;\n\tstatic uuid_node_t saved_node;\n\n\tif (!inited) {\n\t\tget_random_info(seed);\n\t\tseed[0] |= 0x80;\n\t\tmemcpy(&saved_node, seed, sizeof(uuid_node_t));\n\t\tinited = 1;\n\t};\n\t*node = saved_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_current_time",
          "args": [
            "&timestamp"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "get_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "171-199",
          "snippet": "void get_current_time(uuid_time_t *timestamp)\n{\n\tuuid_time_t time_now;\n\tstatic uuid_time_t time_last;\n\tstatic uint16_t uuids_this_tick;\n\tstatic int inited = 0;\n\n\tif (!inited) {\n\t\tuuids_this_tick = UUIDS_PER_TICK;\n\t\tinited = 1;\n\t};\n\twhile (1) {\n\t\tget_system_time(&time_now);\n\t\t/* if clock reading changed since last UUID generated... */\n\t\tif (time_last != time_now) {\n\t\t\t/* reset count of uuids gen'd with this clock reading. */\n\t\t\tuuids_this_tick = 0;\n\t\t\tbreak;\n\t\t};\n\t\tif (uuids_this_tick < UUIDS_PER_TICK) {\n\t\t\tuuids_this_tick++;\n\t\t\tbreak;\n\t\t};\n\t\t/* going too fast for our clock; spin. */\n\t};\n\t/* add the count of uuids to low order bits of the clock reading. */\n\t*timestamp = time_now + uuids_this_tick;\n\ttime_last = *timestamp;\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"uuid.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void get_current_time(uuid_time_t *timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic void get_current_time(uuid_time_t *timestamp);\n\nvoid get_current_time(uuid_time_t *timestamp)\n{\n\tuuid_time_t time_now;\n\tstatic uuid_time_t time_last;\n\tstatic uint16_t uuids_this_tick;\n\tstatic int inited = 0;\n\n\tif (!inited) {\n\t\tuuids_this_tick = UUIDS_PER_TICK;\n\t\tinited = 1;\n\t};\n\twhile (1) {\n\t\tget_system_time(&time_now);\n\t\t/* if clock reading changed since last UUID generated... */\n\t\tif (time_last != time_now) {\n\t\t\t/* reset count of uuids gen'd with this clock reading. */\n\t\t\tuuids_this_tick = 0;\n\t\t\tbreak;\n\t\t};\n\t\tif (uuids_this_tick < UUIDS_PER_TICK) {\n\t\t\tuuids_this_tick++;\n\t\t\tbreak;\n\t\t};\n\t\t/* going too fast for our clock; spin. */\n\t};\n\t/* add the count of uuids to low order bits of the clock reading. */\n\t*timestamp = time_now + uuids_this_tick;\n\ttime_last = *timestamp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UUIDLock",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\nstatic void get_current_time(uuid_time_t *timestamp);\nstatic uint16_t true_random(void);\n\nint uuid_create(uuid_upnp * uid)\n{\n\tuuid_time_t timestamp;\n\tuuid_time_t last_time;\n\tuint16_t clockseq;\n\tuuid_node_t node;\n\tuuid_node_t last_node;\n\tint f;\n\n\t/* acquire system wide lock so we're alone. */\n\tUUIDLock();\n\t/* get current time. */\n\tget_current_time(&timestamp);\n\t/* get node ID. */\n\tget_ieee_node_identifier(&node);\n\t/* get saved state from NV storage. */\n\tf = read_state(&clockseq, &last_time, &last_node);\n\t/* if no NV state, or if clock went backwards, or node ID changed\n\t * (e.g., net card swap) change clockseq. */\n\tif (!f || memcmp(&node, &last_node, sizeof(uuid_node_t)))\n\t\tclockseq = true_random();\n\telse if (timestamp < last_time)\n\t\tclockseq++;\n\t/* stuff fields into the UUID. */\n\tformat_uuid_v1(uid, clockseq, timestamp, node);\n\t/* save the state for next time. */\n\twrite_state(clockseq, timestamp, node);\n\tUUIDUnlock();\n\n\treturn 1;\n}"
  }
]