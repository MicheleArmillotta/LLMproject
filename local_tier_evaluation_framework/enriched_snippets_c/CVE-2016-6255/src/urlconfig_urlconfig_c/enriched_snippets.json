[
  {
    "function_name": "configure_urlbase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/urlconfig/urlconfig.c",
    "lines": "373-430",
    "snippet": "int\nconfigure_urlbase( INOUT IXML_Document * doc,\n                   IN const struct sockaddr *serverAddr,\n                   IN const char *alias,\n                   IN time_t last_modified,\n                   OUT char docURL[LINE_SIZE] )\n{\n    char *root_path = NULL;\n    char *new_alias = NULL;\n    char *xml_str = NULL;\n    int err_code;\n    char ipaddr_port[LINE_SIZE];\n\n    /* get IP address and port */\n    err_code = addrToString( serverAddr, ipaddr_port, sizeof(ipaddr_port) );\n    if ( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n\n    /* config url-base in 'doc' */\n    err_code = config_description_doc( doc, ipaddr_port, &root_path );\n    if( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n    /* calc alias */\n    err_code = calc_alias( alias, root_path, &new_alias );\n    if( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n    /* calc full url for desc doc */\n    err_code = calc_descURL( ipaddr_port, new_alias, docURL );\n    if( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n    /* xml doc to str */\n    xml_str = ixmlPrintDocument( doc );\n    if( xml_str == NULL ) {\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n        \"desc url: %s\\n\", docURL );\n    UpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n        \"doc = %s\\n\", xml_str );\n    /* store in web server */\n    err_code =\n        web_server_set_alias( new_alias, xml_str, strlen( xml_str ),\n                              last_modified );\n\nerror_handler:\n    free( root_path );\n    free( new_alias );\n\n    if( err_code != UPNP_E_SUCCESS ) {\n        ixmlFreeDOMString( xml_str );\n    }\n    return err_code;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"upnputil.h\"",
      "#include \"urlconfig.h\"",
      "#include \"uri.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"upnpdebug.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"membuffer.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "xml_str"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_alias"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "web_server_set_alias",
          "args": [
            "new_alias",
            "xml_str",
            "strlen( xml_str )",
            "last_modified"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "web_server_set_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/webserver.c",
          "lines": "421-465",
          "snippet": "int web_server_set_alias(const char *alias_name, \n\tconst char *alias_content, size_t alias_content_length,\n\ttime_t last_modified)\n{\n\tint ret_code;\n\tstruct xml_alias_t alias;\n\n\talias_release(&gAliasDoc);\n\tif (alias_name == NULL) {\n\t\t/* don't serve aliased doc anymore */\n\t\treturn 0;\n\t}\n\tassert(alias_content != NULL);\n\tmembuffer_init(&alias.doc);\n\tmembuffer_init(&alias.name);\n\talias.ct = NULL;\n\tdo {\n\t\t/* insert leading /, if missing */\n\t\tif (*alias_name != '/')\n\t\t\tif (membuffer_assign_str(&alias.name, \"/\") != 0)\n\t\t\t\tbreak;\t/* error; out of mem */\n\t\tret_code = membuffer_append_str(&alias.name, alias_name);\n\t\tif (ret_code != 0)\n\t\t\tbreak;\t/* error */\n\t\tif ((alias.ct = (int *)malloc(sizeof(int))) == NULL)\n\t\t\tbreak;\t/* error */\n\t\t*alias.ct = 1;\n\t\tmembuffer_attach(&alias.doc, (char *)alias_content,\n\t\t\t\t alias_content_length);\n\t\talias.last_modified = last_modified;\n\t\t/* save in module var */\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tgAliasDoc = alias;\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\treturn 0;\n\t} while (FALSE);\n\t/* error handler */\n\t/* free temp alias */\n\tmembuffer_destroy(&alias.name);\n\tmembuffer_destroy(&alias.doc);\n\tfree(alias.ct);\n\n\treturn UPNP_E_OUTOF_MEMORY;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <assert.h>",
            "#include \"VirtualDir.h\"",
            "#include \"upnputil.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"strintmap.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"FileInfo.h\"",
            "#include \"webserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"VirtualDir.h\"\n#include \"upnputil.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"strintmap.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"FileInfo.h\"\n#include \"webserver.h\"\n#include \"config.h\"\n\nint web_server_set_alias(const char *alias_name, \n\tconst char *alias_content, size_t alias_content_length,\n\ttime_t last_modified)\n{\n\tint ret_code;\n\tstruct xml_alias_t alias;\n\n\talias_release(&gAliasDoc);\n\tif (alias_name == NULL) {\n\t\t/* don't serve aliased doc anymore */\n\t\treturn 0;\n\t}\n\tassert(alias_content != NULL);\n\tmembuffer_init(&alias.doc);\n\tmembuffer_init(&alias.name);\n\talias.ct = NULL;\n\tdo {\n\t\t/* insert leading /, if missing */\n\t\tif (*alias_name != '/')\n\t\t\tif (membuffer_assign_str(&alias.name, \"/\") != 0)\n\t\t\t\tbreak;\t/* error; out of mem */\n\t\tret_code = membuffer_append_str(&alias.name, alias_name);\n\t\tif (ret_code != 0)\n\t\t\tbreak;\t/* error */\n\t\tif ((alias.ct = (int *)malloc(sizeof(int))) == NULL)\n\t\t\tbreak;\t/* error */\n\t\t*alias.ct = 1;\n\t\tmembuffer_attach(&alias.doc, (char *)alias_content,\n\t\t\t\t alias_content_length);\n\t\talias.last_modified = last_modified;\n\t\t/* save in module var */\n\t\tithread_mutex_lock(&gWebMutex);\n\t\tgAliasDoc = alias;\n\t\tithread_mutex_unlock(&gWebMutex);\n\n\t\treturn 0;\n\t} while (FALSE);\n\t/* error handler */\n\t/* free temp alias */\n\tmembuffer_destroy(&alias.name);\n\tmembuffer_destroy(&alias.doc);\n\tfree(alias.ct);\n\n\treturn UPNP_E_OUTOF_MEMORY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_str"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "API",
            "__FILE__",
            "__LINE__",
            "\"doc = %s\\n\"",
            "xml_str"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlPrintDocument",
          "args": [
            "doc"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_descURL",
          "args": [
            "ipaddr_port",
            "new_alias",
            "docURL"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "calc_descURL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/urlconfig/urlconfig.c",
          "lines": "175-194",
          "snippet": "static UPNP_INLINE int calc_descURL(\n\tIN const char *ipPortStr,\n\tIN const char *alias,\n\tOUT char descURL[LINE_SIZE])\n{\n\tsize_t len;\n\tconst char *http_scheme = \"http://\";\n\n\tassert(ipPortStr != NULL && strlen(ipPortStr) > 0);\n\tassert(alias != NULL && strlen(alias) > 0);\n\n\tlen = strlen(http_scheme) + strlen(ipPortStr) + strlen(alias) + (size_t)1;\n\tif (len > (size_t)LINE_SIZE)\n\t\treturn UPNP_E_URL_TOO_BIG;\n\tsnprintf(descURL, len, \"%s%s%s\", http_scheme, ipPortStr, alias);\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"desc url: %s\\n\", descURL);\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"upnputil.h\"",
            "#include \"urlconfig.h\"",
            "#include \"uri.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"membuffer.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"upnputil.h\"\n#include \"urlconfig.h\"\n#include \"uri.h\"\n#include \"UpnpInet.h\"\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"membuffer.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic UPNP_INLINE int calc_descURL(\n\tIN const char *ipPortStr,\n\tIN const char *alias,\n\tOUT char descURL[LINE_SIZE])\n{\n\tsize_t len;\n\tconst char *http_scheme = \"http://\";\n\n\tassert(ipPortStr != NULL && strlen(ipPortStr) > 0);\n\tassert(alias != NULL && strlen(alias) > 0);\n\n\tlen = strlen(http_scheme) + strlen(ipPortStr) + strlen(alias) + (size_t)1;\n\tif (len > (size_t)LINE_SIZE)\n\t\treturn UPNP_E_URL_TOO_BIG;\n\tsnprintf(descURL, len, \"%s%s%s\", http_scheme, ipPortStr, alias);\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"desc url: %s\\n\", descURL);\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_alias",
          "args": [
            "alias",
            "root_path",
            "&new_alias"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "calc_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/urlconfig/urlconfig.c",
          "lines": "121-155",
          "snippet": "static UPNP_INLINE int calc_alias(\n\tIN const char *alias,\n\tIN const char *rootPath,\n\tOUT char **newAlias)\n{\n\tconst char *aliasPtr;\n\tsize_t root_len;\n\tconst char *temp_str;\n\tsize_t new_alias_len;\n\tchar *alias_temp;\n\n\tassert(rootPath);\n\tassert(alias);\n\n\t/* add / suffix, if missing */\n\troot_len = strlen(rootPath);\n\tif (root_len == 0 || rootPath[root_len - 1] != '/')\n\t\ttemp_str = \"/\";\n\telse\n\t\ttemp_str = \"\";\t/* suffix already present */\n\t/* discard / prefix, if present */\n\tif (alias[0] == '/')\n\t\taliasPtr = alias + 1;\n\telse \n\t\taliasPtr = alias;\n\tnew_alias_len = root_len + strlen(temp_str) + strlen(aliasPtr) + (size_t)1;\n\talias_temp = malloc(new_alias_len);\n\tif (alias_temp == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tmemset(alias_temp, 0, new_alias_len);\n\tsnprintf(alias_temp, new_alias_len, \"%s%s%s\", rootPath, temp_str, aliasPtr);\n\n\t*newAlias = alias_temp;\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"upnputil.h\"",
            "#include \"urlconfig.h\"",
            "#include \"uri.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"membuffer.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"upnputil.h\"\n#include \"urlconfig.h\"\n#include \"uri.h\"\n#include \"UpnpInet.h\"\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"membuffer.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic UPNP_INLINE int calc_alias(\n\tIN const char *alias,\n\tIN const char *rootPath,\n\tOUT char **newAlias)\n{\n\tconst char *aliasPtr;\n\tsize_t root_len;\n\tconst char *temp_str;\n\tsize_t new_alias_len;\n\tchar *alias_temp;\n\n\tassert(rootPath);\n\tassert(alias);\n\n\t/* add / suffix, if missing */\n\troot_len = strlen(rootPath);\n\tif (root_len == 0 || rootPath[root_len - 1] != '/')\n\t\ttemp_str = \"/\";\n\telse\n\t\ttemp_str = \"\";\t/* suffix already present */\n\t/* discard / prefix, if present */\n\tif (alias[0] == '/')\n\t\taliasPtr = alias + 1;\n\telse \n\t\taliasPtr = alias;\n\tnew_alias_len = root_len + strlen(temp_str) + strlen(aliasPtr) + (size_t)1;\n\talias_temp = malloc(new_alias_len);\n\tif (alias_temp == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tmemset(alias_temp, 0, new_alias_len);\n\tsnprintf(alias_temp, new_alias_len, \"%s%s%s\", rootPath, temp_str, aliasPtr);\n\n\t*newAlias = alias_temp;\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_description_doc",
          "args": [
            "doc",
            "ipaddr_port",
            "&root_path"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "config_description_doc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/urlconfig/urlconfig.c",
          "lines": "221-341",
          "snippet": "static int config_description_doc(\n\tINOUT IXML_Document *doc,\n\tIN const char *ip_str,\n\tOUT char **root_path_str )\n{\n\tIXML_NodeList *baseList;\n\tIXML_Element *element = NULL;\n\tIXML_Node *textNode = NULL;\n\tIXML_Node *rootNode = NULL;\n\tIXML_Node *urlbase_node = NULL;\n\tconst char *urlBaseStr = \"URLBase\";\n\tconst DOMString domStr = NULL;\n\turi_type uri;\n\tint err_code;\n\tint len;\n\tmembuffer url_str;\n\tmembuffer root_path;\n\n\tmembuffer_init(&url_str);\n\tmembuffer_init(&root_path);\n\terr_code = UPNP_E_OUTOF_MEMORY;\t/* default error */\n\tbaseList = ixmlDocument_getElementsByTagName(doc, urlBaseStr);\n\tif (baseList == NULL) {\n\t\t/* urlbase not found -- create new one */\n\t\telement = ixmlDocument_createElement(doc, urlBaseStr);\n\t\tif (element == NULL) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tif (membuffer_append_str(&url_str, \"http://\") != 0 ||\n\t\t    membuffer_append_str(&url_str, ip_str) != 0 ||\n\t\t    membuffer_append_str(&url_str, \"/\") != 0 ||\n\t\t    membuffer_append_str(&root_path, \"/\") != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\trootNode = ixmlNode_getFirstChild((IXML_Node *) doc);\n\t\tif (rootNode == NULL) {\n\t\t\terr_code = UPNP_E_INVALID_DESC;\n\t\t\tgoto error_handler;\n\t\t}\n\t\terr_code =\n\t\t    ixmlNode_appendChild(rootNode, (IXML_Node *) element);\n\t\tif (err_code != IXML_SUCCESS) {\n\t\t\terr_code = UPNP_E_INVALID_DESC;\n\t\t\tgoto error_handler;\n\t\t}\n\t\ttextNode =\n\t\t    ixmlDocument_createTextNode(doc, (char *)url_str.buf);\n\t\tif (textNode == NULL) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\terr_code =\n\t\t    ixmlNode_appendChild((IXML_Node *) element, textNode);\n\t\tif (err_code != IXML_SUCCESS) {\n\t\t\terr_code = UPNP_E_INTERNAL_ERROR;\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* urlbase found */\n\t\turlbase_node = ixmlNodeList_item(baseList, 0lu);\n\t\tassert(urlbase_node != NULL);\n\t\ttextNode = ixmlNode_getFirstChild(urlbase_node);\n\t\tif (textNode == NULL) {\n\t\t\terr_code = UPNP_E_INVALID_DESC;\n\t\t\tgoto error_handler;\n\t\t}\n\t\tdomStr = ixmlNode_getNodeValue(textNode);\n\t\tif (domStr == NULL) {\n\t\t\terr_code = UPNP_E_INVALID_URL;\n\t\t\tgoto error_handler;\n\t\t}\n\t\tlen = parse_uri(domStr, strlen(domStr), &uri);\n\t\tif (len < 0 || uri.type != ABSOLUTE) {\n\t\t\terr_code = UPNP_E_INVALID_URL;\n\t\t\tgoto error_handler;\n\t\t}\n\t\tif (membuffer_assign(&url_str, uri.scheme.buff,\n\t\t\t\t     uri.scheme.size) != 0 ||\n\t\t    membuffer_append_str(&url_str, \"://\") != 0 ||\n\t\t    membuffer_append_str(&url_str, ip_str) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* add leading '/' if missing from relative path */\n\t\tif ((uri.pathquery.size > 0 && uri.pathquery.buff[0] != '/') ||\n\t\t    (uri.pathquery.size == 0)\n\t\t    ) {\n\t\t\tif (membuffer_append_str(&url_str, \"/\") != 0 ||\n\t\t\t    membuffer_append_str(&root_path, \"/\") != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\tif (membuffer_append(&url_str, uri.pathquery.buff,\n\t\t\t\t     uri.pathquery.size) != 0 ||\n\t\t    membuffer_append(&root_path, uri.pathquery.buff,\n\t\t\t\t     uri.pathquery.size) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* add trailing '/' if missing */\n\t\tif (url_str.buf[url_str.length - 1] != '/') {\n\t\t\tif (membuffer_append(&url_str, \"/\", (size_t)1) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\terr_code = ixmlNode_setNodeValue(textNode, url_str.buf);\n\t\tif (err_code != IXML_SUCCESS) {\n\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\tgoto error_handler;\n\t\t}\n\t}\n\t*root_path_str = membuffer_detach(&root_path);\t/* return path */\n\terr_code = UPNP_E_SUCCESS;\n\n error_handler:\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\tixmlElement_free(element);\n\t}\n\tixmlNodeList_free(baseList);\n\tmembuffer_destroy(&root_path);\n\tmembuffer_destroy(&url_str);\n\n\treturn err_code;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"upnputil.h\"",
            "#include \"urlconfig.h\"",
            "#include \"uri.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"membuffer.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"upnputil.h\"\n#include \"urlconfig.h\"\n#include \"uri.h\"\n#include \"UpnpInet.h\"\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"membuffer.h\"\n#include \"config.h\"\n\nstatic int config_description_doc(\n\tINOUT IXML_Document *doc,\n\tIN const char *ip_str,\n\tOUT char **root_path_str )\n{\n\tIXML_NodeList *baseList;\n\tIXML_Element *element = NULL;\n\tIXML_Node *textNode = NULL;\n\tIXML_Node *rootNode = NULL;\n\tIXML_Node *urlbase_node = NULL;\n\tconst char *urlBaseStr = \"URLBase\";\n\tconst DOMString domStr = NULL;\n\turi_type uri;\n\tint err_code;\n\tint len;\n\tmembuffer url_str;\n\tmembuffer root_path;\n\n\tmembuffer_init(&url_str);\n\tmembuffer_init(&root_path);\n\terr_code = UPNP_E_OUTOF_MEMORY;\t/* default error */\n\tbaseList = ixmlDocument_getElementsByTagName(doc, urlBaseStr);\n\tif (baseList == NULL) {\n\t\t/* urlbase not found -- create new one */\n\t\telement = ixmlDocument_createElement(doc, urlBaseStr);\n\t\tif (element == NULL) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tif (membuffer_append_str(&url_str, \"http://\") != 0 ||\n\t\t    membuffer_append_str(&url_str, ip_str) != 0 ||\n\t\t    membuffer_append_str(&url_str, \"/\") != 0 ||\n\t\t    membuffer_append_str(&root_path, \"/\") != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\trootNode = ixmlNode_getFirstChild((IXML_Node *) doc);\n\t\tif (rootNode == NULL) {\n\t\t\terr_code = UPNP_E_INVALID_DESC;\n\t\t\tgoto error_handler;\n\t\t}\n\t\terr_code =\n\t\t    ixmlNode_appendChild(rootNode, (IXML_Node *) element);\n\t\tif (err_code != IXML_SUCCESS) {\n\t\t\terr_code = UPNP_E_INVALID_DESC;\n\t\t\tgoto error_handler;\n\t\t}\n\t\ttextNode =\n\t\t    ixmlDocument_createTextNode(doc, (char *)url_str.buf);\n\t\tif (textNode == NULL) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\terr_code =\n\t\t    ixmlNode_appendChild((IXML_Node *) element, textNode);\n\t\tif (err_code != IXML_SUCCESS) {\n\t\t\terr_code = UPNP_E_INTERNAL_ERROR;\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* urlbase found */\n\t\turlbase_node = ixmlNodeList_item(baseList, 0lu);\n\t\tassert(urlbase_node != NULL);\n\t\ttextNode = ixmlNode_getFirstChild(urlbase_node);\n\t\tif (textNode == NULL) {\n\t\t\terr_code = UPNP_E_INVALID_DESC;\n\t\t\tgoto error_handler;\n\t\t}\n\t\tdomStr = ixmlNode_getNodeValue(textNode);\n\t\tif (domStr == NULL) {\n\t\t\terr_code = UPNP_E_INVALID_URL;\n\t\t\tgoto error_handler;\n\t\t}\n\t\tlen = parse_uri(domStr, strlen(domStr), &uri);\n\t\tif (len < 0 || uri.type != ABSOLUTE) {\n\t\t\terr_code = UPNP_E_INVALID_URL;\n\t\t\tgoto error_handler;\n\t\t}\n\t\tif (membuffer_assign(&url_str, uri.scheme.buff,\n\t\t\t\t     uri.scheme.size) != 0 ||\n\t\t    membuffer_append_str(&url_str, \"://\") != 0 ||\n\t\t    membuffer_append_str(&url_str, ip_str) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* add leading '/' if missing from relative path */\n\t\tif ((uri.pathquery.size > 0 && uri.pathquery.buff[0] != '/') ||\n\t\t    (uri.pathquery.size == 0)\n\t\t    ) {\n\t\t\tif (membuffer_append_str(&url_str, \"/\") != 0 ||\n\t\t\t    membuffer_append_str(&root_path, \"/\") != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\tif (membuffer_append(&url_str, uri.pathquery.buff,\n\t\t\t\t     uri.pathquery.size) != 0 ||\n\t\t    membuffer_append(&root_path, uri.pathquery.buff,\n\t\t\t\t     uri.pathquery.size) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* add trailing '/' if missing */\n\t\tif (url_str.buf[url_str.length - 1] != '/') {\n\t\t\tif (membuffer_append(&url_str, \"/\", (size_t)1) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\terr_code = ixmlNode_setNodeValue(textNode, url_str.buf);\n\t\tif (err_code != IXML_SUCCESS) {\n\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\tgoto error_handler;\n\t\t}\n\t}\n\t*root_path_str = membuffer_detach(&root_path);\t/* return path */\n\terr_code = UPNP_E_SUCCESS;\n\n error_handler:\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\tixmlElement_free(element);\n\t}\n\tixmlNodeList_free(baseList);\n\tmembuffer_destroy(&root_path);\n\tmembuffer_destroy(&url_str);\n\n\treturn err_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrToString",
          "args": [
            "serverAddr",
            "ipaddr_port",
            "sizeof(ipaddr_port)"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "addrToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/urlconfig/urlconfig.c",
          "lines": "80-102",
          "snippet": "static UPNP_INLINE int\naddrToString( IN const struct sockaddr *addr,\n              OUT char *ipaddr_port,\n              IN size_t ipaddr_port_size )\n{\n    char buf_ntop[INET6_ADDRSTRLEN];\n    int rc = 0;\n\n    if( addr->sa_family == AF_INET ) {\n        struct sockaddr_in* sa4 = (struct sockaddr_in*)addr;\n        inet_ntop(AF_INET, &sa4->sin_addr, buf_ntop, sizeof(buf_ntop) );\n        rc = snprintf( ipaddr_port, ipaddr_port_size, \"%s:%d\", buf_ntop,\n            (int)ntohs( sa4->sin_port ) );\n    } else if( addr->sa_family == AF_INET6 ) {\n        struct sockaddr_in6* sa6 = (struct sockaddr_in6*)addr;\n        inet_ntop(AF_INET6, &sa6->sin6_addr, buf_ntop, sizeof(buf_ntop) );\n        rc = snprintf( ipaddr_port, ipaddr_port_size, \"[%s]:%d\", buf_ntop,\n            (int)ntohs( sa6->sin6_port ) );\n    }\n\tif (rc < 0 || (unsigned int) rc >= ipaddr_port_size)\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"upnputil.h\"",
            "#include \"urlconfig.h\"",
            "#include \"uri.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"membuffer.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"upnputil.h\"\n#include \"urlconfig.h\"\n#include \"uri.h\"\n#include \"UpnpInet.h\"\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"membuffer.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic UPNP_INLINE int\naddrToString( IN const struct sockaddr *addr,\n              OUT char *ipaddr_port,\n              IN size_t ipaddr_port_size )\n{\n    char buf_ntop[INET6_ADDRSTRLEN];\n    int rc = 0;\n\n    if( addr->sa_family == AF_INET ) {\n        struct sockaddr_in* sa4 = (struct sockaddr_in*)addr;\n        inet_ntop(AF_INET, &sa4->sin_addr, buf_ntop, sizeof(buf_ntop) );\n        rc = snprintf( ipaddr_port, ipaddr_port_size, \"%s:%d\", buf_ntop,\n            (int)ntohs( sa4->sin_port ) );\n    } else if( addr->sa_family == AF_INET6 ) {\n        struct sockaddr_in6* sa6 = (struct sockaddr_in6*)addr;\n        inet_ntop(AF_INET6, &sa6->sin6_addr, buf_ntop, sizeof(buf_ntop) );\n        rc = snprintf( ipaddr_port, ipaddr_port_size, \"[%s]:%d\", buf_ntop,\n            (int)ntohs( sa6->sin6_port ) );\n    }\n\tif (rc < 0 || (unsigned int) rc >= ipaddr_port_size)\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"upnputil.h\"\n#include \"urlconfig.h\"\n#include \"uri.h\"\n#include \"UpnpInet.h\"\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"membuffer.h\"\n#include \"config.h\"\n\nint\nconfigure_urlbase( INOUT IXML_Document * doc,\n                   IN const struct sockaddr *serverAddr,\n                   IN const char *alias,\n                   IN time_t last_modified,\n                   OUT char docURL[LINE_SIZE] )\n{\n    char *root_path = NULL;\n    char *new_alias = NULL;\n    char *xml_str = NULL;\n    int err_code;\n    char ipaddr_port[LINE_SIZE];\n\n    /* get IP address and port */\n    err_code = addrToString( serverAddr, ipaddr_port, sizeof(ipaddr_port) );\n    if ( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n\n    /* config url-base in 'doc' */\n    err_code = config_description_doc( doc, ipaddr_port, &root_path );\n    if( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n    /* calc alias */\n    err_code = calc_alias( alias, root_path, &new_alias );\n    if( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n    /* calc full url for desc doc */\n    err_code = calc_descURL( ipaddr_port, new_alias, docURL );\n    if( err_code != UPNP_E_SUCCESS ) {\n        goto error_handler;\n    }\n    /* xml doc to str */\n    xml_str = ixmlPrintDocument( doc );\n    if( xml_str == NULL ) {\n        goto error_handler;\n    }\n\n    UpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n        \"desc url: %s\\n\", docURL );\n    UpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n        \"doc = %s\\n\", xml_str );\n    /* store in web server */\n    err_code =\n        web_server_set_alias( new_alias, xml_str, strlen( xml_str ),\n                              last_modified );\n\nerror_handler:\n    free( root_path );\n    free( new_alias );\n\n    if( err_code != UPNP_E_SUCCESS ) {\n        ixmlFreeDOMString( xml_str );\n    }\n    return err_code;\n}"
  },
  {
    "function_name": "config_description_doc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/urlconfig/urlconfig.c",
    "lines": "221-341",
    "snippet": "static int config_description_doc(\n\tINOUT IXML_Document *doc,\n\tIN const char *ip_str,\n\tOUT char **root_path_str )\n{\n\tIXML_NodeList *baseList;\n\tIXML_Element *element = NULL;\n\tIXML_Node *textNode = NULL;\n\tIXML_Node *rootNode = NULL;\n\tIXML_Node *urlbase_node = NULL;\n\tconst char *urlBaseStr = \"URLBase\";\n\tconst DOMString domStr = NULL;\n\turi_type uri;\n\tint err_code;\n\tint len;\n\tmembuffer url_str;\n\tmembuffer root_path;\n\n\tmembuffer_init(&url_str);\n\tmembuffer_init(&root_path);\n\terr_code = UPNP_E_OUTOF_MEMORY;\t/* default error */\n\tbaseList = ixmlDocument_getElementsByTagName(doc, urlBaseStr);\n\tif (baseList == NULL) {\n\t\t/* urlbase not found -- create new one */\n\t\telement = ixmlDocument_createElement(doc, urlBaseStr);\n\t\tif (element == NULL) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tif (membuffer_append_str(&url_str, \"http://\") != 0 ||\n\t\t    membuffer_append_str(&url_str, ip_str) != 0 ||\n\t\t    membuffer_append_str(&url_str, \"/\") != 0 ||\n\t\t    membuffer_append_str(&root_path, \"/\") != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\trootNode = ixmlNode_getFirstChild((IXML_Node *) doc);\n\t\tif (rootNode == NULL) {\n\t\t\terr_code = UPNP_E_INVALID_DESC;\n\t\t\tgoto error_handler;\n\t\t}\n\t\terr_code =\n\t\t    ixmlNode_appendChild(rootNode, (IXML_Node *) element);\n\t\tif (err_code != IXML_SUCCESS) {\n\t\t\terr_code = UPNP_E_INVALID_DESC;\n\t\t\tgoto error_handler;\n\t\t}\n\t\ttextNode =\n\t\t    ixmlDocument_createTextNode(doc, (char *)url_str.buf);\n\t\tif (textNode == NULL) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\terr_code =\n\t\t    ixmlNode_appendChild((IXML_Node *) element, textNode);\n\t\tif (err_code != IXML_SUCCESS) {\n\t\t\terr_code = UPNP_E_INTERNAL_ERROR;\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* urlbase found */\n\t\turlbase_node = ixmlNodeList_item(baseList, 0lu);\n\t\tassert(urlbase_node != NULL);\n\t\ttextNode = ixmlNode_getFirstChild(urlbase_node);\n\t\tif (textNode == NULL) {\n\t\t\terr_code = UPNP_E_INVALID_DESC;\n\t\t\tgoto error_handler;\n\t\t}\n\t\tdomStr = ixmlNode_getNodeValue(textNode);\n\t\tif (domStr == NULL) {\n\t\t\terr_code = UPNP_E_INVALID_URL;\n\t\t\tgoto error_handler;\n\t\t}\n\t\tlen = parse_uri(domStr, strlen(domStr), &uri);\n\t\tif (len < 0 || uri.type != ABSOLUTE) {\n\t\t\terr_code = UPNP_E_INVALID_URL;\n\t\t\tgoto error_handler;\n\t\t}\n\t\tif (membuffer_assign(&url_str, uri.scheme.buff,\n\t\t\t\t     uri.scheme.size) != 0 ||\n\t\t    membuffer_append_str(&url_str, \"://\") != 0 ||\n\t\t    membuffer_append_str(&url_str, ip_str) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* add leading '/' if missing from relative path */\n\t\tif ((uri.pathquery.size > 0 && uri.pathquery.buff[0] != '/') ||\n\t\t    (uri.pathquery.size == 0)\n\t\t    ) {\n\t\t\tif (membuffer_append_str(&url_str, \"/\") != 0 ||\n\t\t\t    membuffer_append_str(&root_path, \"/\") != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\tif (membuffer_append(&url_str, uri.pathquery.buff,\n\t\t\t\t     uri.pathquery.size) != 0 ||\n\t\t    membuffer_append(&root_path, uri.pathquery.buff,\n\t\t\t\t     uri.pathquery.size) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* add trailing '/' if missing */\n\t\tif (url_str.buf[url_str.length - 1] != '/') {\n\t\t\tif (membuffer_append(&url_str, \"/\", (size_t)1) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\terr_code = ixmlNode_setNodeValue(textNode, url_str.buf);\n\t\tif (err_code != IXML_SUCCESS) {\n\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\tgoto error_handler;\n\t\t}\n\t}\n\t*root_path_str = membuffer_detach(&root_path);\t/* return path */\n\terr_code = UPNP_E_SUCCESS;\n\n error_handler:\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\tixmlElement_free(element);\n\t}\n\tixmlNodeList_free(baseList);\n\tmembuffer_destroy(&root_path);\n\tmembuffer_destroy(&url_str);\n\n\treturn err_code;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"upnputil.h\"",
      "#include \"urlconfig.h\"",
      "#include \"uri.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"upnpdebug.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"membuffer.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&url_str"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_free",
          "args": [
            "baseList"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlElement_free",
          "args": [
            "element"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_detach",
          "args": [
            "&root_path"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "273-285",
          "snippet": "char *membuffer_detach(membuffer *m)\n{\n\tchar *buf;\n\n\tassert(m != NULL);\n\n\tbuf = m->buf;\n\n\t/* free all */\n\tmembuffer_initialize(m);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nchar *membuffer_detach(membuffer *m)\n{\n\tchar *buf;\n\n\tassert(m != NULL);\n\n\tbuf = m->buf;\n\n\t/* free all */\n\tmembuffer_initialize(m);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlNode_setNodeValue",
          "args": [
            "textNode",
            "url_str.buf"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_append",
          "args": [
            "&url_str",
            "\"/\"",
            "(size_t)1"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "200-205",
          "snippet": "int membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_append_str",
          "args": [
            "&root_path",
            "\"/\""
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "207-210",
          "snippet": "int membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_assign",
          "args": [
            "&url_str",
            "uri.scheme.buff",
            "uri.scheme.size"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "170-193",
          "snippet": "int membuffer_assign(membuffer *m, const void *buf, size_t buf_len)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\t/* set value to null */\n\tif (buf == NULL) {\n\t\tmembuffer_destroy(m);\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, buf_len);\n\tif (return_code != 0)\n\t\treturn return_code;\n\t/* copy */\n\tif (buf_len) {\n\t\tmemcpy(m->buf, buf, buf_len);\n\t\tm->buf[buf_len] = 0;\t/* null-terminate */\n\t}\n\tm->length = buf_len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_assign(membuffer *m, const void *buf, size_t buf_len)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\t/* set value to null */\n\tif (buf == NULL) {\n\t\tmembuffer_destroy(m);\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, buf_len);\n\tif (return_code != 0)\n\t\treturn return_code;\n\t/* copy */\n\tif (buf_len) {\n\t\tmemcpy(m->buf, buf, buf_len);\n\t\tm->buf[buf_len] = 0;\t/* null-terminate */\n\t}\n\tm->length = buf_len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_uri",
          "args": [
            "domStr",
            "strlen(domStr)",
            "&uri"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uri_and_unescape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "759-775",
          "snippet": "int parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "domStr"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNodeValue",
          "args": [
            "textNode"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "urlbase_node"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "urlbase_node != NULL"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNodeList_item",
          "args": [
            "baseList",
            "0lu"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_appendChild",
          "args": [
            "(IXML_Node *) element",
            "textNode"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_createTextNode",
          "args": [
            "doc",
            "(char *)url_str.buf"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_appendChild",
          "args": [
            "rootNode",
            "(IXML_Node *) element"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "(IXML_Node *) doc"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_createElement",
          "args": [
            "doc",
            "urlBaseStr"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_getElementsByTagName",
          "args": [
            "doc",
            "urlBaseStr"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&root_path"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"upnputil.h\"\n#include \"urlconfig.h\"\n#include \"uri.h\"\n#include \"UpnpInet.h\"\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"membuffer.h\"\n#include \"config.h\"\n\nstatic int config_description_doc(\n\tINOUT IXML_Document *doc,\n\tIN const char *ip_str,\n\tOUT char **root_path_str )\n{\n\tIXML_NodeList *baseList;\n\tIXML_Element *element = NULL;\n\tIXML_Node *textNode = NULL;\n\tIXML_Node *rootNode = NULL;\n\tIXML_Node *urlbase_node = NULL;\n\tconst char *urlBaseStr = \"URLBase\";\n\tconst DOMString domStr = NULL;\n\turi_type uri;\n\tint err_code;\n\tint len;\n\tmembuffer url_str;\n\tmembuffer root_path;\n\n\tmembuffer_init(&url_str);\n\tmembuffer_init(&root_path);\n\terr_code = UPNP_E_OUTOF_MEMORY;\t/* default error */\n\tbaseList = ixmlDocument_getElementsByTagName(doc, urlBaseStr);\n\tif (baseList == NULL) {\n\t\t/* urlbase not found -- create new one */\n\t\telement = ixmlDocument_createElement(doc, urlBaseStr);\n\t\tif (element == NULL) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tif (membuffer_append_str(&url_str, \"http://\") != 0 ||\n\t\t    membuffer_append_str(&url_str, ip_str) != 0 ||\n\t\t    membuffer_append_str(&url_str, \"/\") != 0 ||\n\t\t    membuffer_append_str(&root_path, \"/\") != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\trootNode = ixmlNode_getFirstChild((IXML_Node *) doc);\n\t\tif (rootNode == NULL) {\n\t\t\terr_code = UPNP_E_INVALID_DESC;\n\t\t\tgoto error_handler;\n\t\t}\n\t\terr_code =\n\t\t    ixmlNode_appendChild(rootNode, (IXML_Node *) element);\n\t\tif (err_code != IXML_SUCCESS) {\n\t\t\terr_code = UPNP_E_INVALID_DESC;\n\t\t\tgoto error_handler;\n\t\t}\n\t\ttextNode =\n\t\t    ixmlDocument_createTextNode(doc, (char *)url_str.buf);\n\t\tif (textNode == NULL) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\terr_code =\n\t\t    ixmlNode_appendChild((IXML_Node *) element, textNode);\n\t\tif (err_code != IXML_SUCCESS) {\n\t\t\terr_code = UPNP_E_INTERNAL_ERROR;\n\t\t\tgoto error_handler;\n\t\t}\n\t} else {\n\t\t/* urlbase found */\n\t\turlbase_node = ixmlNodeList_item(baseList, 0lu);\n\t\tassert(urlbase_node != NULL);\n\t\ttextNode = ixmlNode_getFirstChild(urlbase_node);\n\t\tif (textNode == NULL) {\n\t\t\terr_code = UPNP_E_INVALID_DESC;\n\t\t\tgoto error_handler;\n\t\t}\n\t\tdomStr = ixmlNode_getNodeValue(textNode);\n\t\tif (domStr == NULL) {\n\t\t\terr_code = UPNP_E_INVALID_URL;\n\t\t\tgoto error_handler;\n\t\t}\n\t\tlen = parse_uri(domStr, strlen(domStr), &uri);\n\t\tif (len < 0 || uri.type != ABSOLUTE) {\n\t\t\terr_code = UPNP_E_INVALID_URL;\n\t\t\tgoto error_handler;\n\t\t}\n\t\tif (membuffer_assign(&url_str, uri.scheme.buff,\n\t\t\t\t     uri.scheme.size) != 0 ||\n\t\t    membuffer_append_str(&url_str, \"://\") != 0 ||\n\t\t    membuffer_append_str(&url_str, ip_str) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* add leading '/' if missing from relative path */\n\t\tif ((uri.pathquery.size > 0 && uri.pathquery.buff[0] != '/') ||\n\t\t    (uri.pathquery.size == 0)\n\t\t    ) {\n\t\t\tif (membuffer_append_str(&url_str, \"/\") != 0 ||\n\t\t\t    membuffer_append_str(&root_path, \"/\") != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\tif (membuffer_append(&url_str, uri.pathquery.buff,\n\t\t\t\t     uri.pathquery.size) != 0 ||\n\t\t    membuffer_append(&root_path, uri.pathquery.buff,\n\t\t\t\t     uri.pathquery.size) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t/* add trailing '/' if missing */\n\t\tif (url_str.buf[url_str.length - 1] != '/') {\n\t\t\tif (membuffer_append(&url_str, \"/\", (size_t)1) != 0) {\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t}\n\t\terr_code = ixmlNode_setNodeValue(textNode, url_str.buf);\n\t\tif (err_code != IXML_SUCCESS) {\n\t\t\terr_code = UPNP_E_OUTOF_MEMORY;\n\t\t\tgoto error_handler;\n\t\t}\n\t}\n\t*root_path_str = membuffer_detach(&root_path);\t/* return path */\n\terr_code = UPNP_E_SUCCESS;\n\n error_handler:\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\tixmlElement_free(element);\n\t}\n\tixmlNodeList_free(baseList);\n\tmembuffer_destroy(&root_path);\n\tmembuffer_destroy(&url_str);\n\n\treturn err_code;\n}"
  },
  {
    "function_name": "calc_descURL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/urlconfig/urlconfig.c",
    "lines": "175-194",
    "snippet": "static UPNP_INLINE int calc_descURL(\n\tIN const char *ipPortStr,\n\tIN const char *alias,\n\tOUT char descURL[LINE_SIZE])\n{\n\tsize_t len;\n\tconst char *http_scheme = \"http://\";\n\n\tassert(ipPortStr != NULL && strlen(ipPortStr) > 0);\n\tassert(alias != NULL && strlen(alias) > 0);\n\n\tlen = strlen(http_scheme) + strlen(ipPortStr) + strlen(alias) + (size_t)1;\n\tif (len > (size_t)LINE_SIZE)\n\t\treturn UPNP_E_URL_TOO_BIG;\n\tsnprintf(descURL, len, \"%s%s%s\", http_scheme, ipPortStr, alias);\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"desc url: %s\\n\", descURL);\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"upnputil.h\"",
      "#include \"urlconfig.h\"",
      "#include \"uri.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"upnpdebug.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"membuffer.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "API",
            "__FILE__",
            "__LINE__",
            "\"desc url: %s\\n\"",
            "descURL"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "descURL",
            "len",
            "\"%s%s%s\"",
            "http_scheme",
            "ipPortStr",
            "alias"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "alias"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ipPortStr"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "http_scheme"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "alias != NULL && strlen(alias) > 0"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "alias"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ipPortStr != NULL && strlen(ipPortStr) > 0"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ipPortStr"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"upnputil.h\"\n#include \"urlconfig.h\"\n#include \"uri.h\"\n#include \"UpnpInet.h\"\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"membuffer.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic UPNP_INLINE int calc_descURL(\n\tIN const char *ipPortStr,\n\tIN const char *alias,\n\tOUT char descURL[LINE_SIZE])\n{\n\tsize_t len;\n\tconst char *http_scheme = \"http://\";\n\n\tassert(ipPortStr != NULL && strlen(ipPortStr) > 0);\n\tassert(alias != NULL && strlen(alias) > 0);\n\n\tlen = strlen(http_scheme) + strlen(ipPortStr) + strlen(alias) + (size_t)1;\n\tif (len > (size_t)LINE_SIZE)\n\t\treturn UPNP_E_URL_TOO_BIG;\n\tsnprintf(descURL, len, \"%s%s%s\", http_scheme, ipPortStr, alias);\n\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t   \"desc url: %s\\n\", descURL);\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "calc_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/urlconfig/urlconfig.c",
    "lines": "121-155",
    "snippet": "static UPNP_INLINE int calc_alias(\n\tIN const char *alias,\n\tIN const char *rootPath,\n\tOUT char **newAlias)\n{\n\tconst char *aliasPtr;\n\tsize_t root_len;\n\tconst char *temp_str;\n\tsize_t new_alias_len;\n\tchar *alias_temp;\n\n\tassert(rootPath);\n\tassert(alias);\n\n\t/* add / suffix, if missing */\n\troot_len = strlen(rootPath);\n\tif (root_len == 0 || rootPath[root_len - 1] != '/')\n\t\ttemp_str = \"/\";\n\telse\n\t\ttemp_str = \"\";\t/* suffix already present */\n\t/* discard / prefix, if present */\n\tif (alias[0] == '/')\n\t\taliasPtr = alias + 1;\n\telse \n\t\taliasPtr = alias;\n\tnew_alias_len = root_len + strlen(temp_str) + strlen(aliasPtr) + (size_t)1;\n\talias_temp = malloc(new_alias_len);\n\tif (alias_temp == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tmemset(alias_temp, 0, new_alias_len);\n\tsnprintf(alias_temp, new_alias_len, \"%s%s%s\", rootPath, temp_str, aliasPtr);\n\n\t*newAlias = alias_temp;\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"upnputil.h\"",
      "#include \"urlconfig.h\"",
      "#include \"uri.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"upnpdebug.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"membuffer.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "alias_temp",
            "new_alias_len",
            "\"%s%s%s\"",
            "rootPath",
            "temp_str",
            "aliasPtr"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "alias_temp",
            "0",
            "new_alias_len"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "new_alias_len"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "aliasPtr"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "temp_str"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rootPath"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "alias"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "rootPath"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"upnputil.h\"\n#include \"urlconfig.h\"\n#include \"uri.h\"\n#include \"UpnpInet.h\"\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"membuffer.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic UPNP_INLINE int calc_alias(\n\tIN const char *alias,\n\tIN const char *rootPath,\n\tOUT char **newAlias)\n{\n\tconst char *aliasPtr;\n\tsize_t root_len;\n\tconst char *temp_str;\n\tsize_t new_alias_len;\n\tchar *alias_temp;\n\n\tassert(rootPath);\n\tassert(alias);\n\n\t/* add / suffix, if missing */\n\troot_len = strlen(rootPath);\n\tif (root_len == 0 || rootPath[root_len - 1] != '/')\n\t\ttemp_str = \"/\";\n\telse\n\t\ttemp_str = \"\";\t/* suffix already present */\n\t/* discard / prefix, if present */\n\tif (alias[0] == '/')\n\t\taliasPtr = alias + 1;\n\telse \n\t\taliasPtr = alias;\n\tnew_alias_len = root_len + strlen(temp_str) + strlen(aliasPtr) + (size_t)1;\n\talias_temp = malloc(new_alias_len);\n\tif (alias_temp == NULL)\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\tmemset(alias_temp, 0, new_alias_len);\n\tsnprintf(alias_temp, new_alias_len, \"%s%s%s\", rootPath, temp_str, aliasPtr);\n\n\t*newAlias = alias_temp;\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "addrToString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/urlconfig/urlconfig.c",
    "lines": "80-102",
    "snippet": "static UPNP_INLINE int\naddrToString( IN const struct sockaddr *addr,\n              OUT char *ipaddr_port,\n              IN size_t ipaddr_port_size )\n{\n    char buf_ntop[INET6_ADDRSTRLEN];\n    int rc = 0;\n\n    if( addr->sa_family == AF_INET ) {\n        struct sockaddr_in* sa4 = (struct sockaddr_in*)addr;\n        inet_ntop(AF_INET, &sa4->sin_addr, buf_ntop, sizeof(buf_ntop) );\n        rc = snprintf( ipaddr_port, ipaddr_port_size, \"%s:%d\", buf_ntop,\n            (int)ntohs( sa4->sin_port ) );\n    } else if( addr->sa_family == AF_INET6 ) {\n        struct sockaddr_in6* sa6 = (struct sockaddr_in6*)addr;\n        inet_ntop(AF_INET6, &sa6->sin6_addr, buf_ntop, sizeof(buf_ntop) );\n        rc = snprintf( ipaddr_port, ipaddr_port_size, \"[%s]:%d\", buf_ntop,\n            (int)ntohs( sa6->sin6_port ) );\n    }\n\tif (rc < 0 || (unsigned int) rc >= ipaddr_port_size)\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/types.h>",
      "#include <stdio.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"upnputil.h\"",
      "#include \"urlconfig.h\"",
      "#include \"uri.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"upnpdebug.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"membuffer.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ipaddr_port",
            "ipaddr_port_size",
            "\"[%s]:%d\"",
            "buf_ntop",
            "(int)ntohs( sa6->sin6_port )"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "sa6->sin6_port"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "AF_INET6",
            "&sa6->sin6_addr",
            "buf_ntop",
            "sizeof(buf_ntop)"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "inet_ntop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/inet_pton.c",
          "lines": "291-305",
          "snippet": "const char *inet_ntop(int af, const void *src, char *dst,socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_ntop4(src, dst, size);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_ntop6(src, dst, size);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn NULL;\n\t}\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"inet_pton.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inet_pton.h\"\n\nconst char *inet_ntop(int af, const void *src, char *dst,socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn inet_ntop4(src, dst, size);\n#ifdef INET_IPV6\n\tcase AF_INET6:\n\t\treturn inet_ntop6(src, dst, size);\n#endif\n\tdefault:\n\t\t/*__set_errno(EAFNOSUPPORT);*/\n\t\treturn NULL;\n\t}\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ipaddr_port",
            "ipaddr_port_size",
            "\"%s:%d\"",
            "buf_ntop",
            "(int)ntohs( sa4->sin_port )"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "sa4->sin_port"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/types.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"upnputil.h\"\n#include \"urlconfig.h\"\n#include \"uri.h\"\n#include \"UpnpInet.h\"\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"membuffer.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic UPNP_INLINE int\naddrToString( IN const struct sockaddr *addr,\n              OUT char *ipaddr_port,\n              IN size_t ipaddr_port_size )\n{\n    char buf_ntop[INET6_ADDRSTRLEN];\n    int rc = 0;\n\n    if( addr->sa_family == AF_INET ) {\n        struct sockaddr_in* sa4 = (struct sockaddr_in*)addr;\n        inet_ntop(AF_INET, &sa4->sin_addr, buf_ntop, sizeof(buf_ntop) );\n        rc = snprintf( ipaddr_port, ipaddr_port_size, \"%s:%d\", buf_ntop,\n            (int)ntohs( sa4->sin_port ) );\n    } else if( addr->sa_family == AF_INET6 ) {\n        struct sockaddr_in6* sa6 = (struct sockaddr_in6*)addr;\n        inet_ntop(AF_INET6, &sa6->sin6_addr, buf_ntop, sizeof(buf_ntop) );\n        rc = snprintf( ipaddr_port, ipaddr_port_size, \"[%s]:%d\", buf_ntop,\n            (int)ntohs( sa6->sin6_port ) );\n    }\n\tif (rc < 0 || (unsigned int) rc >= ipaddr_port_size)\n\t\treturn UPNP_E_BUFFER_TOO_SMALL;\n\treturn UPNP_E_SUCCESS;\n}"
  }
]