[
  {
    "function_name": "membuffer_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "287-295",
    "snippet": "void membuffer_attach(membuffer *m, char *new_buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\tmembuffer_destroy(m);\n\tm->buf = new_buf;\n\tm->length = buf_len;\n\tm->capacity = buf_len;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "m"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m != NULL"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_attach(membuffer *m, char *new_buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\tmembuffer_destroy(m);\n\tm->buf = new_buf;\n\tm->length = buf_len;\n\tm->capacity = buf_len;\n}"
  },
  {
    "function_name": "membuffer_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "273-285",
    "snippet": "char *membuffer_detach(membuffer *m)\n{\n\tchar *buf;\n\n\tassert(m != NULL);\n\n\tbuf = m->buf;\n\n\t/* free all */\n\tmembuffer_initialize(m);\n\n\treturn buf;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_initialize",
          "args": [
            "m"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "95-102",
          "snippet": "static UPNP_INLINE void membuffer_initialize(\n\t/*! [in,out] Buffer to be initialized. */\n\tmembuffer *m)\n{\n\tm->buf = NULL;\n\tm->length = (size_t)0;\n\tm->capacity = (size_t)0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic UPNP_INLINE void membuffer_initialize(\n\t/*! [in,out] Buffer to be initialized. */\n\tmembuffer *m)\n{\n\tm->buf = NULL;\n\tm->length = (size_t)0;\n\tm->capacity = (size_t)0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m != NULL"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nchar *membuffer_detach(membuffer *m)\n{\n\tchar *buf;\n\n\tassert(m != NULL);\n\n\tbuf = m->buf;\n\n\t/* free all */\n\tmembuffer_initialize(m);\n\n\treturn buf;\n}"
  },
  {
    "function_name": "membuffer_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "240-271",
    "snippet": "void membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "return_value == 0"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_set_size",
          "args": [
            "m",
            "new_length"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_set_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "104-150",
          "snippet": "int membuffer_set_size(membuffer *m, size_t new_length)\n{\n\tsize_t diff;\n\tsize_t alloc_len;\n\tchar *temp_buf;\n\n\tif (new_length >= m->length) {\t/* increase length */\n\t\t/* need more mem? */\n\t\tif (new_length <= m->capacity) {\n\t\t\treturn 0;\t/* have enough mem; done */\n\t\t}\n\n\t\tdiff = new_length - m->length;\n\t\talloc_len = MAXVAL(m->size_inc, diff) + m->capacity;\n\t} else {\t\t/* decrease length */\n\n\t\tassert(new_length <= m->length);\n\n\t\t/* if diff is 0..m->size_inc, don't free */\n\t\tif ((m->capacity - new_length) <= m->size_inc) {\n\t\t\treturn 0;\n\t\t}\n\n\t\talloc_len = new_length + m->size_inc;\n\t}\n\n\tassert(alloc_len >= new_length);\n\n\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\n\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\tif (temp_buf == NULL) {\n\t\t/* try smaller size */\n\t\talloc_len = new_length;\n\t\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\t\tif (temp_buf == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t}\n\t/* save */\n\tm->buf = temp_buf;\n\tm->capacity = alloc_len;\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_set_size(membuffer *m, size_t new_length)\n{\n\tsize_t diff;\n\tsize_t alloc_len;\n\tchar *temp_buf;\n\n\tif (new_length >= m->length) {\t/* increase length */\n\t\t/* need more mem? */\n\t\tif (new_length <= m->capacity) {\n\t\t\treturn 0;\t/* have enough mem; done */\n\t\t}\n\n\t\tdiff = new_length - m->length;\n\t\talloc_len = MAXVAL(m->size_inc, diff) + m->capacity;\n\t} else {\t\t/* decrease length */\n\n\t\tassert(new_length <= m->length);\n\n\t\t/* if diff is 0..m->size_inc, don't free */\n\t\tif ((m->capacity - new_length) <= m->size_inc) {\n\t\t\treturn 0;\n\t\t}\n\n\t\talloc_len = new_length + m->size_inc;\n\t}\n\n\tassert(alloc_len >= new_length);\n\n\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\n\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\tif (temp_buf == NULL) {\n\t\t/* try smaller size */\n\t\talloc_len = new_length;\n\t\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\t\tif (temp_buf == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t}\n\t/* save */\n\tm->buf = temp_buf;\n\tm->capacity = alloc_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "m->buf + index",
            "m->buf + index + num_bytes",
            "copy_len"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m != NULL"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}"
  },
  {
    "function_name": "membuffer_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "212-238",
    "snippet": "int membuffer_insert(membuffer * m, const void *buf, size_t buf_len,\n\t\t     size_t index)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\tif (index > m->length)\n\t\treturn UPNP_E_OUTOF_BOUNDS;\n\tif (!buf || !buf_len) {\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, m->length + buf_len);\n\tif (return_code) {\n\t\treturn return_code;\n\t}\n\t/* insert data */\n\t/* move data to right of insertion point */\n\tmemmove(m->buf + index + buf_len, m->buf + index, m->length - index);\n\tmemcpy(m->buf + index, buf, buf_len);\n\tm->length += buf_len;\n\t/* null-terminate */\n\tm->buf[m->length] = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m->buf + index",
            "buf",
            "buf_len"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "m->buf + index + buf_len",
            "m->buf + index",
            "m->length - index"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_set_size",
          "args": [
            "m",
            "m->length + buf_len"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_set_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "104-150",
          "snippet": "int membuffer_set_size(membuffer *m, size_t new_length)\n{\n\tsize_t diff;\n\tsize_t alloc_len;\n\tchar *temp_buf;\n\n\tif (new_length >= m->length) {\t/* increase length */\n\t\t/* need more mem? */\n\t\tif (new_length <= m->capacity) {\n\t\t\treturn 0;\t/* have enough mem; done */\n\t\t}\n\n\t\tdiff = new_length - m->length;\n\t\talloc_len = MAXVAL(m->size_inc, diff) + m->capacity;\n\t} else {\t\t/* decrease length */\n\n\t\tassert(new_length <= m->length);\n\n\t\t/* if diff is 0..m->size_inc, don't free */\n\t\tif ((m->capacity - new_length) <= m->size_inc) {\n\t\t\treturn 0;\n\t\t}\n\n\t\talloc_len = new_length + m->size_inc;\n\t}\n\n\tassert(alloc_len >= new_length);\n\n\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\n\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\tif (temp_buf == NULL) {\n\t\t/* try smaller size */\n\t\talloc_len = new_length;\n\t\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\t\tif (temp_buf == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t}\n\t/* save */\n\tm->buf = temp_buf;\n\tm->capacity = alloc_len;\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_set_size(membuffer *m, size_t new_length)\n{\n\tsize_t diff;\n\tsize_t alloc_len;\n\tchar *temp_buf;\n\n\tif (new_length >= m->length) {\t/* increase length */\n\t\t/* need more mem? */\n\t\tif (new_length <= m->capacity) {\n\t\t\treturn 0;\t/* have enough mem; done */\n\t\t}\n\n\t\tdiff = new_length - m->length;\n\t\talloc_len = MAXVAL(m->size_inc, diff) + m->capacity;\n\t} else {\t\t/* decrease length */\n\n\t\tassert(new_length <= m->length);\n\n\t\t/* if diff is 0..m->size_inc, don't free */\n\t\tif ((m->capacity - new_length) <= m->size_inc) {\n\t\t\treturn 0;\n\t\t}\n\n\t\talloc_len = new_length + m->size_inc;\n\t}\n\n\tassert(alloc_len >= new_length);\n\n\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\n\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\tif (temp_buf == NULL) {\n\t\t/* try smaller size */\n\t\talloc_len = new_length;\n\t\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\t\tif (temp_buf == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t}\n\t/* save */\n\tm->buf = temp_buf;\n\tm->capacity = alloc_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m != NULL"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_insert(membuffer * m, const void *buf, size_t buf_len,\n\t\t     size_t index)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\tif (index > m->length)\n\t\treturn UPNP_E_OUTOF_BOUNDS;\n\tif (!buf || !buf_len) {\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, m->length + buf_len);\n\tif (return_code) {\n\t\treturn return_code;\n\t}\n\t/* insert data */\n\t/* move data to right of insertion point */\n\tmemmove(m->buf + index + buf_len, m->buf + index, m->length - index);\n\tmemcpy(m->buf + index, buf, buf_len);\n\tm->length += buf_len;\n\t/* null-terminate */\n\tm->buf[m->length] = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "membuffer_append_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "207-210",
    "snippet": "int membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_insert",
          "args": [
            "m",
            "c_str",
            "strlen(c_str)",
            "m->length"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "212-238",
          "snippet": "int membuffer_insert(membuffer * m, const void *buf, size_t buf_len,\n\t\t     size_t index)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\tif (index > m->length)\n\t\treturn UPNP_E_OUTOF_BOUNDS;\n\tif (!buf || !buf_len) {\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, m->length + buf_len);\n\tif (return_code) {\n\t\treturn return_code;\n\t}\n\t/* insert data */\n\t/* move data to right of insertion point */\n\tmemmove(m->buf + index + buf_len, m->buf + index, m->length - index);\n\tmemcpy(m->buf + index, buf, buf_len);\n\tm->length += buf_len;\n\t/* null-terminate */\n\tm->buf[m->length] = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_insert(membuffer * m, const void *buf, size_t buf_len,\n\t\t     size_t index)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\tif (index > m->length)\n\t\treturn UPNP_E_OUTOF_BOUNDS;\n\tif (!buf || !buf_len) {\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, m->length + buf_len);\n\tif (return_code) {\n\t\treturn return_code;\n\t}\n\t/* insert data */\n\t/* move data to right of insertion point */\n\tmemmove(m->buf + index + buf_len, m->buf + index, m->length - index);\n\tmemcpy(m->buf + index, buf, buf_len);\n\tm->length += buf_len;\n\t/* null-terminate */\n\tm->buf[m->length] = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c_str"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}"
  },
  {
    "function_name": "membuffer_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "200-205",
    "snippet": "int membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_insert",
          "args": [
            "m",
            "buf",
            "buf_len",
            "m->length"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "212-238",
          "snippet": "int membuffer_insert(membuffer * m, const void *buf, size_t buf_len,\n\t\t     size_t index)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\tif (index > m->length)\n\t\treturn UPNP_E_OUTOF_BOUNDS;\n\tif (!buf || !buf_len) {\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, m->length + buf_len);\n\tif (return_code) {\n\t\treturn return_code;\n\t}\n\t/* insert data */\n\t/* move data to right of insertion point */\n\tmemmove(m->buf + index + buf_len, m->buf + index, m->length - index);\n\tmemcpy(m->buf + index, buf, buf_len);\n\tm->length += buf_len;\n\t/* null-terminate */\n\tm->buf[m->length] = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_insert(membuffer * m, const void *buf, size_t buf_len,\n\t\t     size_t index)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\tif (index > m->length)\n\t\treturn UPNP_E_OUTOF_BOUNDS;\n\tif (!buf || !buf_len) {\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, m->length + buf_len);\n\tif (return_code) {\n\t\treturn return_code;\n\t}\n\t/* insert data */\n\t/* move data to right of insertion point */\n\tmemmove(m->buf + index + buf_len, m->buf + index, m->length - index);\n\tmemcpy(m->buf + index, buf, buf_len);\n\tm->length += buf_len;\n\t/* null-terminate */\n\tm->buf[m->length] = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m != NULL"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}"
  },
  {
    "function_name": "membuffer_assign_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "195-198",
    "snippet": "int membuffer_assign_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_assign(m, c_str, strlen(c_str));\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_assign",
          "args": [
            "m",
            "c_str",
            "strlen(c_str)"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "170-193",
          "snippet": "int membuffer_assign(membuffer *m, const void *buf, size_t buf_len)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\t/* set value to null */\n\tif (buf == NULL) {\n\t\tmembuffer_destroy(m);\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, buf_len);\n\tif (return_code != 0)\n\t\treturn return_code;\n\t/* copy */\n\tif (buf_len) {\n\t\tmemcpy(m->buf, buf, buf_len);\n\t\tm->buf[buf_len] = 0;\t/* null-terminate */\n\t}\n\tm->length = buf_len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_assign(membuffer *m, const void *buf, size_t buf_len)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\t/* set value to null */\n\tif (buf == NULL) {\n\t\tmembuffer_destroy(m);\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, buf_len);\n\tif (return_code != 0)\n\t\treturn return_code;\n\t/* copy */\n\tif (buf_len) {\n\t\tmemcpy(m->buf, buf, buf_len);\n\t\tm->buf[buf_len] = 0;\t/* null-terminate */\n\t}\n\tm->length = buf_len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c_str"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_assign_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_assign(m, c_str, strlen(c_str));\n}"
  },
  {
    "function_name": "membuffer_assign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "170-193",
    "snippet": "int membuffer_assign(membuffer *m, const void *buf, size_t buf_len)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\t/* set value to null */\n\tif (buf == NULL) {\n\t\tmembuffer_destroy(m);\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, buf_len);\n\tif (return_code != 0)\n\t\treturn return_code;\n\t/* copy */\n\tif (buf_len) {\n\t\tmemcpy(m->buf, buf, buf_len);\n\t\tm->buf[buf_len] = 0;\t/* null-terminate */\n\t}\n\tm->length = buf_len;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m->buf",
            "buf",
            "buf_len"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_set_size",
          "args": [
            "m",
            "buf_len"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_set_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "104-150",
          "snippet": "int membuffer_set_size(membuffer *m, size_t new_length)\n{\n\tsize_t diff;\n\tsize_t alloc_len;\n\tchar *temp_buf;\n\n\tif (new_length >= m->length) {\t/* increase length */\n\t\t/* need more mem? */\n\t\tif (new_length <= m->capacity) {\n\t\t\treturn 0;\t/* have enough mem; done */\n\t\t}\n\n\t\tdiff = new_length - m->length;\n\t\talloc_len = MAXVAL(m->size_inc, diff) + m->capacity;\n\t} else {\t\t/* decrease length */\n\n\t\tassert(new_length <= m->length);\n\n\t\t/* if diff is 0..m->size_inc, don't free */\n\t\tif ((m->capacity - new_length) <= m->size_inc) {\n\t\t\treturn 0;\n\t\t}\n\n\t\talloc_len = new_length + m->size_inc;\n\t}\n\n\tassert(alloc_len >= new_length);\n\n\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\n\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\tif (temp_buf == NULL) {\n\t\t/* try smaller size */\n\t\talloc_len = new_length;\n\t\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\t\tif (temp_buf == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t}\n\t/* save */\n\tm->buf = temp_buf;\n\tm->capacity = alloc_len;\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_set_size(membuffer *m, size_t new_length)\n{\n\tsize_t diff;\n\tsize_t alloc_len;\n\tchar *temp_buf;\n\n\tif (new_length >= m->length) {\t/* increase length */\n\t\t/* need more mem? */\n\t\tif (new_length <= m->capacity) {\n\t\t\treturn 0;\t/* have enough mem; done */\n\t\t}\n\n\t\tdiff = new_length - m->length;\n\t\talloc_len = MAXVAL(m->size_inc, diff) + m->capacity;\n\t} else {\t\t/* decrease length */\n\n\t\tassert(new_length <= m->length);\n\n\t\t/* if diff is 0..m->size_inc, don't free */\n\t\tif ((m->capacity - new_length) <= m->size_inc) {\n\t\t\treturn 0;\n\t\t}\n\n\t\talloc_len = new_length + m->size_inc;\n\t}\n\n\tassert(alloc_len >= new_length);\n\n\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\n\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\tif (temp_buf == NULL) {\n\t\t/* try smaller size */\n\t\talloc_len = new_length;\n\t\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\t\tif (temp_buf == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t}\n\t/* save */\n\tm->buf = temp_buf;\n\tm->capacity = alloc_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "m"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m != NULL"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_assign(membuffer *m, const void *buf, size_t buf_len)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\t/* set value to null */\n\tif (buf == NULL) {\n\t\tmembuffer_destroy(m);\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, buf_len);\n\tif (return_code != 0)\n\t\treturn return_code;\n\t/* copy */\n\tif (buf_len) {\n\t\tmemcpy(m->buf, buf, buf_len);\n\t\tm->buf[buf_len] = 0;\t/* null-terminate */\n\t}\n\tm->length = buf_len;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "membuffer_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "160-168",
    "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "m"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "m->buf"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "free_upnp_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/upnp_timeout.c",
          "lines": "50-58",
          "snippet": "void free_upnp_timeout(upnp_timeout *event)\n{\n\tif (event) {\n\t\tif (event->Event) {\n\t\t\tfree(event->Event);\n\t\t}\n\t\tfree(event);\n\t}\n}",
          "includes": [
            "#include <stdlib.h> /* for free() */",
            "#include \"upnp_timeout.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for free() */\n#include \"upnp_timeout.h\"\n#include \"config.h\"\n\nvoid free_upnp_timeout(upnp_timeout *event)\n{\n\tif (event) {\n\t\tif (event->Event) {\n\t\t\tfree(event->Event);\n\t\t}\n\t\tfree(event);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
  },
  {
    "function_name": "membuffer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "152-158",
    "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_initialize",
          "args": [
            "m"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "95-102",
          "snippet": "static UPNP_INLINE void membuffer_initialize(\n\t/*! [in,out] Buffer to be initialized. */\n\tmembuffer *m)\n{\n\tm->buf = NULL;\n\tm->length = (size_t)0;\n\tm->capacity = (size_t)0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic UPNP_INLINE void membuffer_initialize(\n\t/*! [in,out] Buffer to be initialized. */\n\tmembuffer *m)\n{\n\tm->buf = NULL;\n\tm->length = (size_t)0;\n\tm->capacity = (size_t)0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m != NULL"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
  },
  {
    "function_name": "membuffer_set_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "104-150",
    "snippet": "int membuffer_set_size(membuffer *m, size_t new_length)\n{\n\tsize_t diff;\n\tsize_t alloc_len;\n\tchar *temp_buf;\n\n\tif (new_length >= m->length) {\t/* increase length */\n\t\t/* need more mem? */\n\t\tif (new_length <= m->capacity) {\n\t\t\treturn 0;\t/* have enough mem; done */\n\t\t}\n\n\t\tdiff = new_length - m->length;\n\t\talloc_len = MAXVAL(m->size_inc, diff) + m->capacity;\n\t} else {\t\t/* decrease length */\n\n\t\tassert(new_length <= m->length);\n\n\t\t/* if diff is 0..m->size_inc, don't free */\n\t\tif ((m->capacity - new_length) <= m->size_inc) {\n\t\t\treturn 0;\n\t\t}\n\n\t\talloc_len = new_length + m->size_inc;\n\t}\n\n\tassert(alloc_len >= new_length);\n\n\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\n\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\tif (temp_buf == NULL) {\n\t\t/* try smaller size */\n\t\talloc_len = new_length;\n\t\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\t\tif (temp_buf == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t}\n\t/* save */\n\tm->buf = temp_buf;\n\tm->capacity = alloc_len;\n\treturn 0;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "m->buf",
            "alloc_len + (size_t)1"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "m->buf",
            "alloc_len + (size_t)1"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "alloc_len >= new_length"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "new_length <= m->length"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAXVAL",
          "args": [
            "m->size_inc",
            "diff"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_set_size(membuffer *m, size_t new_length)\n{\n\tsize_t diff;\n\tsize_t alloc_len;\n\tchar *temp_buf;\n\n\tif (new_length >= m->length) {\t/* increase length */\n\t\t/* need more mem? */\n\t\tif (new_length <= m->capacity) {\n\t\t\treturn 0;\t/* have enough mem; done */\n\t\t}\n\n\t\tdiff = new_length - m->length;\n\t\talloc_len = MAXVAL(m->size_inc, diff) + m->capacity;\n\t} else {\t\t/* decrease length */\n\n\t\tassert(new_length <= m->length);\n\n\t\t/* if diff is 0..m->size_inc, don't free */\n\t\tif ((m->capacity - new_length) <= m->size_inc) {\n\t\t\treturn 0;\n\t\t}\n\n\t\talloc_len = new_length + m->size_inc;\n\t}\n\n\tassert(alloc_len >= new_length);\n\n\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\n\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\tif (temp_buf == NULL) {\n\t\t/* try smaller size */\n\t\talloc_len = new_length;\n\t\ttemp_buf = realloc(m->buf, alloc_len + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/*temp_buf = Realloc( m->buf,m->length, alloc_len + 1 );LEAK_FIX_MK */\n\n\t\tif (temp_buf == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t}\n\t/* save */\n\tm->buf = temp_buf;\n\tm->capacity = alloc_len;\n\treturn 0;\n}"
  },
  {
    "function_name": "membuffer_initialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "95-102",
    "snippet": "static UPNP_INLINE void membuffer_initialize(\n\t/*! [in,out] Buffer to be initialized. */\n\tmembuffer *m)\n{\n\tm->buf = NULL;\n\tm->length = (size_t)0;\n\tm->capacity = (size_t)0;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nstatic UPNP_INLINE void membuffer_initialize(\n\t/*! [in,out] Buffer to be initialized. */\n\tmembuffer *m)\n{\n\tm->buf = NULL;\n\tm->length = (size_t)0;\n\tm->capacity = (size_t)0;\n}"
  },
  {
    "function_name": "memptr_cmp_nocase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "78-90",
    "snippet": "int memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "m->buf",
            "s",
            "m->length"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}"
  },
  {
    "function_name": "memptr_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "63-76",
    "snippet": "int memptr_cmp(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncmp(m->buf, s, m->length);\n\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "m->buf",
            "s",
            "m->length"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint memptr_cmp(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncmp(m->buf, s, m->length);\n\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}"
  },
  {
    "function_name": "str_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
    "lines": "48-61",
    "snippet": "char *str_alloc(const char *str, size_t str_len)\n{\n\tchar *s;\n\n\ts = (char *)malloc(str_len + (size_t)1);\n\tif (s == NULL) {\n\t\treturn NULL;\t/* no mem */\n\t}\n\n\tmemcpy(s, str, str_len);\n\ts[str_len] = '\\0';\n\n\treturn s;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"upnp.h\"",
      "#include \"membuffer.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <assert.h>",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s",
            "str",
            "str_len"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "str_len + (size_t)1"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nchar *str_alloc(const char *str, size_t str_len)\n{\n\tchar *s;\n\n\ts = (char *)malloc(str_len + (size_t)1);\n\tif (s == NULL) {\n\t\treturn NULL;\t/* no mem */\n\t}\n\n\tmemcpy(s, str, str_len);\n\ts[str_len] = '\\0';\n\n\treturn s;\n}"
  }
]