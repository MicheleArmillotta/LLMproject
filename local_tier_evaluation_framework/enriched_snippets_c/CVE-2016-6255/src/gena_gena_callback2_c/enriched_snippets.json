[
  {
    "function_name": "genaCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_callback2.c",
    "lines": "88-127",
    "snippet": "void\ngenaCallback( IN http_parser_t * parser,\n              IN http_message_t * request,\n              INOUT SOCKINFO * info )\n{\n    int found_function = FALSE;\n\n    if( request->method == HTTPMETHOD_SUBSCRIBE ) {\n#ifdef INCLUDE_DEVICE_APIS\n        found_function = TRUE;\n        if( httpmsg_find_hdr( request, HDR_NT, NULL ) == NULL ) {\n            /* renew subscription */\n            gena_process_subscription_renewal_request\n            ( info, request );\n\t} else {\n            /* subscribe */\n            gena_process_subscription_request( info, request );\n\t}\n        UpnpPrintf( UPNP_ALL, GENA, __FILE__, __LINE__,\n            \"got subscription request\\n\" );\n    } else if( request->method == HTTPMETHOD_UNSUBSCRIBE ) {\n        found_function = TRUE;\n        /* unsubscribe */\n        gena_process_unsubscribe_request( info, request );\n#endif\n    } else if( request->method == HTTPMETHOD_NOTIFY ) {\n#ifdef INCLUDE_CLIENT_APIS\n        found_function = TRUE;\n        /* notify */\n        gena_process_notification_event( info, request );\n#endif\n    }\n\n    if( !found_function ) {\n            /* handle missing functions of device or ctrl pt */\n            error_respond( info, HTTP_NOT_IMPLEMENTED, request );\n    }\n    return;\n    parser = parser;\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena_ctrlpt.h\"",
      "#include \"gena_device.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error_respond",
          "args": [
            "info",
            "HTTP_NOT_IMPLEMENTED",
            "request"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "error_respond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_callback2.c",
          "lines": "58-71",
          "snippet": "void\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena_ctrlpt.h\"",
            "#include \"gena_device.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena_ctrlpt.h\"\n#include \"gena_device.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nvoid\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}"
        }
      },
      {
        "call_info": {
          "callee": "gena_process_notification_event",
          "args": [
            "info",
            "request"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "gena_process_notification_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "696-824",
          "snippet": "void gena_process_notification_event(\n\tSOCKINFO *info,\n\thttp_message_t *event)\n{\n\tUpnpEvent *event_struct = UpnpEvent_new();\n\tIXML_Document *ChangedVars = NULL;\n\tint eventKey;\n\ttoken sid;\n\tGenlibClientSubscription *subscription = NULL;\n\tstruct Handle_Info *handle_info;\n\tvoid *cookie;\n\tUpnp_FunPtr callback;\n\tUpnpClient_Handle client_handle;\n\n\tmemptr sid_hdr;\n\tmemptr nt_hdr,\n\tnts_hdr;\n\tmemptr seq_hdr;\n\n\t/* get SID */\n\tif (httpmsg_find_hdr(event, HDR_SID, &sid_hdr) == NULL) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\tgoto exit_function;\n\t}\n\tsid.buff = sid_hdr.buf;\n\tsid.size = sid_hdr.length;\n\n\t/* get event key */\n\tif (httpmsg_find_hdr(event, HDR_SEQ, &seq_hdr) == NULL ||\n\t    matchstr(seq_hdr.buf, seq_hdr.length, \"%d%0\", &eventKey) != PARSE_OK) {\n\t\terror_respond( info, HTTP_BAD_REQUEST, event );\n\t\tgoto exit_function;\n\t}\n\n\t/* get NT and NTS headers */\n\tif (httpmsg_find_hdr(event, HDR_NT, &nt_hdr) == NULL ||\n\t    httpmsg_find_hdr(event, HDR_NTS, &nts_hdr) == NULL) {\n\t\terror_respond( info, HTTP_BAD_REQUEST, event );\n\t\tgoto exit_function;\n\t}\n\n\t/* verify NT and NTS headers */\n\tif (memptr_cmp(&nt_hdr, \"upnp:event\") != 0 ||\n\t    memptr_cmp(&nts_hdr, \"upnp:propchange\") != 0) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\tgoto exit_function;\n\t}\n\n\t/* parse the content (should be XML) */\n\tif (!has_xml_content_type(event) ||\n\t    event->msg.length == 0 ||\n\t    ixmlParseBufferEx(event->entity.buf, &ChangedVars) != IXML_SUCCESS) {\n\t\terror_respond(info, HTTP_BAD_REQUEST, event);\n\t\tgoto exit_function;\n\t}\n\n\tHandleLock();\n\n\t/* get client info */\n\tif (GetClientHandleInfo(&client_handle, &handle_info) != HND_CLIENT) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\t/* get subscription based on SID */\n\tsubscription = GetClientSubActualSID(handle_info->ClientSubList, &sid);\n\tif (subscription == NULL) {\n\t\tif (eventKey == 0) {\n\t\t\t/* wait until we've finished processing a subscription  */\n\t\t\t/*   (if we are in the middle) */\n\t\t\t/* this is to avoid mistakenly rejecting the first event if we  */\n\t\t\t/*   receive it before the subscription response */\n\t\t\tHandleUnlock();\n\n\t\t\t/* try and get Subscription Lock  */\n\t\t\t/*   (in case we are in the process of subscribing) */\n\t\t\tSubscribeLock();\n\n\t\t\t/* get HandleLock again */\n\t\t\tHandleLock();\n\n\t\t\tif (GetClientHandleInfo(&client_handle, &handle_info) != HND_CLIENT) {\n\t\t\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\t\t\tSubscribeUnlock();\n\t\t\t\tHandleUnlock();\n\t\t\t\tgoto exit_function;\n\t\t\t}\n\n\t\t\tsubscription = GetClientSubActualSID(handle_info->ClientSubList, &sid);\n\t\t\tif (subscription == NULL) {\n\t\t\t\terror_respond( info, HTTP_PRECONDITION_FAILED, event );\n\t\t\t\tSubscribeUnlock();\n\t\t\t\tHandleUnlock();\n\t\t\t\tgoto exit_function;\n\t\t\t}\n\n\t\t\tSubscribeUnlock();\n\t\t} else {\n\t\t\terror_respond( info, HTTP_PRECONDITION_FAILED, event );\n\t\t\tHandleUnlock();\n\t\t\tgoto exit_function;\n\t\t}\n\t}\n\n\t/* success */\n\terror_respond(info, HTTP_OK, event);\n\n\t/* fill event struct */\n\tUpnpEvent_set_EventKey(event_struct, eventKey);\n\tUpnpEvent_set_ChangedVariables(event_struct, ChangedVars);\n\tUpnpEvent_set_SID(event_struct, GenlibClientSubscription_get_SID(subscription));\n\n\t/* copy callback */\n\tcallback = handle_info->Callback;\n\tcookie = handle_info->Cookie;\n\n\tHandleUnlock();\n\n\t/* make callback with event struct */\n\t/* In future, should find a way of mainting */\n\t/* that the handle is not unregistered in the middle of a */\n\t/* callback */\n\tcallback(UPNP_EVENT_RECEIVED, event_struct, cookie);\n\nexit_function:\n\tixmlDocument_free(ChangedVars);\n\tUpnpEvent_delete(event_struct);\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nvoid gena_process_notification_event(\n\tSOCKINFO *info,\n\thttp_message_t *event)\n{\n\tUpnpEvent *event_struct = UpnpEvent_new();\n\tIXML_Document *ChangedVars = NULL;\n\tint eventKey;\n\ttoken sid;\n\tGenlibClientSubscription *subscription = NULL;\n\tstruct Handle_Info *handle_info;\n\tvoid *cookie;\n\tUpnp_FunPtr callback;\n\tUpnpClient_Handle client_handle;\n\n\tmemptr sid_hdr;\n\tmemptr nt_hdr,\n\tnts_hdr;\n\tmemptr seq_hdr;\n\n\t/* get SID */\n\tif (httpmsg_find_hdr(event, HDR_SID, &sid_hdr) == NULL) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\tgoto exit_function;\n\t}\n\tsid.buff = sid_hdr.buf;\n\tsid.size = sid_hdr.length;\n\n\t/* get event key */\n\tif (httpmsg_find_hdr(event, HDR_SEQ, &seq_hdr) == NULL ||\n\t    matchstr(seq_hdr.buf, seq_hdr.length, \"%d%0\", &eventKey) != PARSE_OK) {\n\t\terror_respond( info, HTTP_BAD_REQUEST, event );\n\t\tgoto exit_function;\n\t}\n\n\t/* get NT and NTS headers */\n\tif (httpmsg_find_hdr(event, HDR_NT, &nt_hdr) == NULL ||\n\t    httpmsg_find_hdr(event, HDR_NTS, &nts_hdr) == NULL) {\n\t\terror_respond( info, HTTP_BAD_REQUEST, event );\n\t\tgoto exit_function;\n\t}\n\n\t/* verify NT and NTS headers */\n\tif (memptr_cmp(&nt_hdr, \"upnp:event\") != 0 ||\n\t    memptr_cmp(&nts_hdr, \"upnp:propchange\") != 0) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\tgoto exit_function;\n\t}\n\n\t/* parse the content (should be XML) */\n\tif (!has_xml_content_type(event) ||\n\t    event->msg.length == 0 ||\n\t    ixmlParseBufferEx(event->entity.buf, &ChangedVars) != IXML_SUCCESS) {\n\t\terror_respond(info, HTTP_BAD_REQUEST, event);\n\t\tgoto exit_function;\n\t}\n\n\tHandleLock();\n\n\t/* get client info */\n\tif (GetClientHandleInfo(&client_handle, &handle_info) != HND_CLIENT) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\t/* get subscription based on SID */\n\tsubscription = GetClientSubActualSID(handle_info->ClientSubList, &sid);\n\tif (subscription == NULL) {\n\t\tif (eventKey == 0) {\n\t\t\t/* wait until we've finished processing a subscription  */\n\t\t\t/*   (if we are in the middle) */\n\t\t\t/* this is to avoid mistakenly rejecting the first event if we  */\n\t\t\t/*   receive it before the subscription response */\n\t\t\tHandleUnlock();\n\n\t\t\t/* try and get Subscription Lock  */\n\t\t\t/*   (in case we are in the process of subscribing) */\n\t\t\tSubscribeLock();\n\n\t\t\t/* get HandleLock again */\n\t\t\tHandleLock();\n\n\t\t\tif (GetClientHandleInfo(&client_handle, &handle_info) != HND_CLIENT) {\n\t\t\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\t\t\tSubscribeUnlock();\n\t\t\t\tHandleUnlock();\n\t\t\t\tgoto exit_function;\n\t\t\t}\n\n\t\t\tsubscription = GetClientSubActualSID(handle_info->ClientSubList, &sid);\n\t\t\tif (subscription == NULL) {\n\t\t\t\terror_respond( info, HTTP_PRECONDITION_FAILED, event );\n\t\t\t\tSubscribeUnlock();\n\t\t\t\tHandleUnlock();\n\t\t\t\tgoto exit_function;\n\t\t\t}\n\n\t\t\tSubscribeUnlock();\n\t\t} else {\n\t\t\terror_respond( info, HTTP_PRECONDITION_FAILED, event );\n\t\t\tHandleUnlock();\n\t\t\tgoto exit_function;\n\t\t}\n\t}\n\n\t/* success */\n\terror_respond(info, HTTP_OK, event);\n\n\t/* fill event struct */\n\tUpnpEvent_set_EventKey(event_struct, eventKey);\n\tUpnpEvent_set_ChangedVariables(event_struct, ChangedVars);\n\tUpnpEvent_set_SID(event_struct, GenlibClientSubscription_get_SID(subscription));\n\n\t/* copy callback */\n\tcallback = handle_info->Callback;\n\tcookie = handle_info->Cookie;\n\n\tHandleUnlock();\n\n\t/* make callback with event struct */\n\t/* In future, should find a way of mainting */\n\t/* that the handle is not unregistered in the middle of a */\n\t/* callback */\n\tcallback(UPNP_EVENT_RECEIVED, event_struct, cookie);\n\nexit_function:\n\tixmlDocument_free(ChangedVars);\n\tUpnpEvent_delete(event_struct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gena_process_unsubscribe_request",
          "args": [
            "info",
            "request"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "gena_process_unsubscribe_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "1485-1547",
          "snippet": "void gena_process_unsubscribe_request(\n\tSOCKINFO *info,\n\thttp_message_t *request)\n{\n    Upnp_SID sid;\n    service_info *service;\n    struct Handle_Info *handle_info;\n    UpnpDevice_Handle device_handle;\n\n    memptr temp_hdr;\n    membuffer event_url_path;\n\n    /* if a CALLBACK or NT header is present, then it is an error */\n    if( httpmsg_find_hdr( request, HDR_CALLBACK, NULL ) != NULL ||\n        httpmsg_find_hdr( request, HDR_NT, NULL ) != NULL ) {\n        error_respond( info, HTTP_BAD_REQUEST, request );\n        return;\n    }\n    /* get SID */\n    if( httpmsg_find_hdr( request, HDR_SID, &temp_hdr ) == NULL ||\n        temp_hdr.length > SID_SIZE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        return;\n    }\n    memcpy( sid, temp_hdr.buf, temp_hdr.length );\n    sid[temp_hdr.length] = '\\0';\n\n    /* lookup service by eventURL */\n    membuffer_init( &event_url_path );\n    if( membuffer_append( &event_url_path, request->uri.pathquery.buff,\n                          request->uri.pathquery.size ) != 0 ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return;\n    }\n\n    HandleLock();\n\n    /* CURRENTLY, ONLY SUPPORT ONE DEVICE */\n    if( GetDeviceHandleInfo( info->foreign_sockaddr.ss_family,\n        &device_handle, &handle_info ) != HND_DEVICE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        membuffer_destroy( &event_url_path );\n        HandleUnlock();\n        return;\n    }\n    service = FindServiceEventURLPath( &handle_info->ServiceTable,\n                                       event_url_path.buf );\n    membuffer_destroy( &event_url_path );\n\n    /* validate service */\n    if( service == NULL ||\n        !service->active || GetSubscriptionSID( sid, service ) == NULL )\n    {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        HandleUnlock();\n        return;\n    }\n\n    RemoveSubscriptionSID(sid, service);\n    error_respond(info, HTTP_OK, request);    /* success */\n\n    HandleUnlock();\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nvoid gena_process_unsubscribe_request(\n\tSOCKINFO *info,\n\thttp_message_t *request)\n{\n    Upnp_SID sid;\n    service_info *service;\n    struct Handle_Info *handle_info;\n    UpnpDevice_Handle device_handle;\n\n    memptr temp_hdr;\n    membuffer event_url_path;\n\n    /* if a CALLBACK or NT header is present, then it is an error */\n    if( httpmsg_find_hdr( request, HDR_CALLBACK, NULL ) != NULL ||\n        httpmsg_find_hdr( request, HDR_NT, NULL ) != NULL ) {\n        error_respond( info, HTTP_BAD_REQUEST, request );\n        return;\n    }\n    /* get SID */\n    if( httpmsg_find_hdr( request, HDR_SID, &temp_hdr ) == NULL ||\n        temp_hdr.length > SID_SIZE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        return;\n    }\n    memcpy( sid, temp_hdr.buf, temp_hdr.length );\n    sid[temp_hdr.length] = '\\0';\n\n    /* lookup service by eventURL */\n    membuffer_init( &event_url_path );\n    if( membuffer_append( &event_url_path, request->uri.pathquery.buff,\n                          request->uri.pathquery.size ) != 0 ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return;\n    }\n\n    HandleLock();\n\n    /* CURRENTLY, ONLY SUPPORT ONE DEVICE */\n    if( GetDeviceHandleInfo( info->foreign_sockaddr.ss_family,\n        &device_handle, &handle_info ) != HND_DEVICE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        membuffer_destroy( &event_url_path );\n        HandleUnlock();\n        return;\n    }\n    service = FindServiceEventURLPath( &handle_info->ServiceTable,\n                                       event_url_path.buf );\n    membuffer_destroy( &event_url_path );\n\n    /* validate service */\n    if( service == NULL ||\n        !service->active || GetSubscriptionSID( sid, service ) == NULL )\n    {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        HandleUnlock();\n        return;\n    }\n\n    RemoveSubscriptionSID(sid, service);\n    error_respond(info, HTTP_OK, request);    /* success */\n\n    HandleUnlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "GENA",
            "__FILE__",
            "__LINE__",
            "\"got subscription request\\n\""
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gena_process_subscription_request",
          "args": [
            "info",
            "request"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "gena_process_subscription_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "1186-1369",
          "snippet": "void gena_process_subscription_request(\n\tSOCKINFO *info,\n\thttp_message_t *request)\n{\n\tUpnpSubscriptionRequest *request_struct = UpnpSubscriptionRequest_new();\n\tUpnp_SID temp_sid;\n\tint return_code = 1;\n\tint time_out = 1801;\n\tservice_info *service;\n\tsubscription *sub;\n\tuuid_upnp uid;\n\tstruct Handle_Info *handle_info;\n\tvoid *cookie;\n\tUpnp_FunPtr callback_fun;\n\tUpnpDevice_Handle device_handle;\n\tmemptr nt_hdr;\n\tchar *event_url_path = NULL;\n\tmemptr callback_hdr;\n\tmemptr timeout_hdr;\n\tint rc = 0;\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"Subscription Request Received:\\n\");\n\n\tif (httpmsg_find_hdr(request, HDR_NT, &nt_hdr) == NULL) {\n\t\terror_respond(info, HTTP_BAD_REQUEST, request);\n\t\tgoto exit_function;\n\t}\n\n\t/* check NT header */\n\t/* Windows Millenium Interoperability: */\n\t/* we accept either upnp:event, or upnp:propchange for the NT header */\n\tif (memptr_cmp_nocase(&nt_hdr, \"upnp:event\") != 0) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, request);\n\t\tgoto exit_function;\n\t}\n\n\t/* if a SID is present then the we have a bad request \"incompatible headers\" */\n\tif (httpmsg_find_hdr(request, HDR_SID, NULL) != NULL) {\n\t\terror_respond(info, HTTP_BAD_REQUEST, request);\n\t\tgoto exit_function;\n\t}\n\t/* look up service by eventURL */\n\tevent_url_path = str_alloc(request->uri.pathquery.buff, request->uri.pathquery.size);\n\tif (event_url_path == NULL) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"SubscriptionRequest for event URL path: %s\\n\",\n\t\tevent_url_path);\n\n\tHandleLock();\n\n\t/* CURRENTLY, ONLY ONE DEVICE */\n\tif (GetDeviceHandleInfo(info->foreign_sockaddr.ss_family , \n\t    &device_handle, &handle_info) != HND_DEVICE) {\n\t\tfree(event_url_path);\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\tservice = FindServiceEventURLPath(&handle_info->ServiceTable, event_url_path);\n\tfree(event_url_path);\n\n\tif (service == NULL || !service->active) {\n\t\terror_respond(info, HTTP_NOT_FOUND, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"Subscription Request: Number of Subscriptions already %d\\n \"\n\t\t\"Max Subscriptions allowed: %d\\n\",\n\t\tservice->TotalSubscriptions,\n\t\thandle_info->MaxSubscriptions);\n\n\t/* too many subscriptions */\n\tif (handle_info->MaxSubscriptions != -1 &&\n\t    service->TotalSubscriptions >= handle_info->MaxSubscriptions) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\t/* generate new subscription */\n\tsub = (subscription *)malloc(sizeof (subscription));\n\tif (sub == NULL) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\tsub->eventKey = 0;\n\tsub->ToSendEventKey = 0;\n\tsub->active = 0;\n\tsub->next = NULL;\n\tsub->DeliveryURLs.size = 0;\n\tsub->DeliveryURLs.URLs = NULL;\n\tsub->DeliveryURLs.parsedURLs = NULL;\n\n\t/* check for valid callbacks */\n\tif (httpmsg_find_hdr( request, HDR_CALLBACK, &callback_hdr) == NULL) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, request);\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\treturn_code = create_url_list(&callback_hdr, &sub->DeliveryURLs);\n\tif (return_code == 0) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, request);\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\tif (return_code == UPNP_E_OUTOF_MEMORY) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\t/* set the timeout */\n\tif (httpmsg_find_hdr(request, HDR_TIMEOUT, &timeout_hdr) != NULL) {\n\t\tif (matchstr(timeout_hdr.buf, timeout_hdr.length,\n\t\t    \"%iSecond-%d%0\", &time_out) == PARSE_OK) {\n\t\t\t/* nothing */\n\t\t} else if(memptr_cmp_nocase(&timeout_hdr, \"Second-infinite\") == 0) {\n\t\t\t/* infinite timeout */\n\t\t\ttime_out = -1;\n\t\t} else {\n\t\t\t/* default is > 1800 seconds */\n\t\t\ttime_out = DEFAULT_TIMEOUT;\n\t\t}\n\t}\n\t/* replace infinite timeout with max timeout, if possible */\n\tif (handle_info->MaxSubscriptionTimeOut != -1) {\n\t\tif (time_out == -1 ||\n\t\t    time_out > handle_info->MaxSubscriptionTimeOut) {\n\t\t\ttime_out = handle_info->MaxSubscriptionTimeOut;\n\t\t}\n\t}\n\tif (time_out >= 0) {\n\t\tsub->expireTime = time(NULL) + time_out;\n\t} else {\n\t\t/* infinite time */\n\t\tsub->expireTime = 0;\n\t}\n\n\t/* generate SID */\n\tuuid_create(&uid);\n\tuuid_unpack(&uid, temp_sid);\n\trc = snprintf(sub->sid, sizeof(sub->sid), \"uuid:%s\", temp_sid);\n\n\t/* respond OK */\n\tif (rc < 0 || (unsigned int) rc >= sizeof(sub->sid) ||\n\t\t(respond_ok(info, time_out,\n\t\tsub, request) != UPNP_E_SUCCESS)) {\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\t/* add to subscription list */\n\tsub->next = service->subscriptionList;\n\tservice->subscriptionList = sub;\n\tservice->TotalSubscriptions++;\n\n\t/* finally generate callback for init table dump */\n\tUpnpSubscriptionRequest_strcpy_ServiceId(request_struct, service->serviceId);\n\tUpnpSubscriptionRequest_strcpy_UDN(request_struct, service->UDN);\n\tUpnpSubscriptionRequest_strcpy_SID(request_struct, sub->sid);\n\n\t/* copy callback */\n\tcallback_fun = handle_info->Callback;\n\tcookie = handle_info->Cookie;\n\n\tHandleUnlock();\n\n\t/* make call back with request struct */\n\t/* in the future should find a way of mainting that the handle */\n\t/* is not unregistered in the middle of a callback */\n\tcallback_fun(UPNP_EVENT_SUBSCRIPTION_REQUEST, request_struct, cookie);\n\nexit_function:\n\tUpnpSubscriptionRequest_delete(request_struct);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nvoid gena_process_subscription_request(\n\tSOCKINFO *info,\n\thttp_message_t *request)\n{\n\tUpnpSubscriptionRequest *request_struct = UpnpSubscriptionRequest_new();\n\tUpnp_SID temp_sid;\n\tint return_code = 1;\n\tint time_out = 1801;\n\tservice_info *service;\n\tsubscription *sub;\n\tuuid_upnp uid;\n\tstruct Handle_Info *handle_info;\n\tvoid *cookie;\n\tUpnp_FunPtr callback_fun;\n\tUpnpDevice_Handle device_handle;\n\tmemptr nt_hdr;\n\tchar *event_url_path = NULL;\n\tmemptr callback_hdr;\n\tmemptr timeout_hdr;\n\tint rc = 0;\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"Subscription Request Received:\\n\");\n\n\tif (httpmsg_find_hdr(request, HDR_NT, &nt_hdr) == NULL) {\n\t\terror_respond(info, HTTP_BAD_REQUEST, request);\n\t\tgoto exit_function;\n\t}\n\n\t/* check NT header */\n\t/* Windows Millenium Interoperability: */\n\t/* we accept either upnp:event, or upnp:propchange for the NT header */\n\tif (memptr_cmp_nocase(&nt_hdr, \"upnp:event\") != 0) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, request);\n\t\tgoto exit_function;\n\t}\n\n\t/* if a SID is present then the we have a bad request \"incompatible headers\" */\n\tif (httpmsg_find_hdr(request, HDR_SID, NULL) != NULL) {\n\t\terror_respond(info, HTTP_BAD_REQUEST, request);\n\t\tgoto exit_function;\n\t}\n\t/* look up service by eventURL */\n\tevent_url_path = str_alloc(request->uri.pathquery.buff, request->uri.pathquery.size);\n\tif (event_url_path == NULL) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"SubscriptionRequest for event URL path: %s\\n\",\n\t\tevent_url_path);\n\n\tHandleLock();\n\n\t/* CURRENTLY, ONLY ONE DEVICE */\n\tif (GetDeviceHandleInfo(info->foreign_sockaddr.ss_family , \n\t    &device_handle, &handle_info) != HND_DEVICE) {\n\t\tfree(event_url_path);\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\tservice = FindServiceEventURLPath(&handle_info->ServiceTable, event_url_path);\n\tfree(event_url_path);\n\n\tif (service == NULL || !service->active) {\n\t\terror_respond(info, HTTP_NOT_FOUND, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__,\n\t\t\"Subscription Request: Number of Subscriptions already %d\\n \"\n\t\t\"Max Subscriptions allowed: %d\\n\",\n\t\tservice->TotalSubscriptions,\n\t\thandle_info->MaxSubscriptions);\n\n\t/* too many subscriptions */\n\tif (handle_info->MaxSubscriptions != -1 &&\n\t    service->TotalSubscriptions >= handle_info->MaxSubscriptions) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\t/* generate new subscription */\n\tsub = (subscription *)malloc(sizeof (subscription));\n\tif (sub == NULL) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\tsub->eventKey = 0;\n\tsub->ToSendEventKey = 0;\n\tsub->active = 0;\n\tsub->next = NULL;\n\tsub->DeliveryURLs.size = 0;\n\tsub->DeliveryURLs.URLs = NULL;\n\tsub->DeliveryURLs.parsedURLs = NULL;\n\n\t/* check for valid callbacks */\n\tif (httpmsg_find_hdr( request, HDR_CALLBACK, &callback_hdr) == NULL) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, request);\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\treturn_code = create_url_list(&callback_hdr, &sub->DeliveryURLs);\n\tif (return_code == 0) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, request);\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\tif (return_code == UPNP_E_OUTOF_MEMORY) {\n\t\terror_respond(info, HTTP_INTERNAL_SERVER_ERROR, request);\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\t/* set the timeout */\n\tif (httpmsg_find_hdr(request, HDR_TIMEOUT, &timeout_hdr) != NULL) {\n\t\tif (matchstr(timeout_hdr.buf, timeout_hdr.length,\n\t\t    \"%iSecond-%d%0\", &time_out) == PARSE_OK) {\n\t\t\t/* nothing */\n\t\t} else if(memptr_cmp_nocase(&timeout_hdr, \"Second-infinite\") == 0) {\n\t\t\t/* infinite timeout */\n\t\t\ttime_out = -1;\n\t\t} else {\n\t\t\t/* default is > 1800 seconds */\n\t\t\ttime_out = DEFAULT_TIMEOUT;\n\t\t}\n\t}\n\t/* replace infinite timeout with max timeout, if possible */\n\tif (handle_info->MaxSubscriptionTimeOut != -1) {\n\t\tif (time_out == -1 ||\n\t\t    time_out > handle_info->MaxSubscriptionTimeOut) {\n\t\t\ttime_out = handle_info->MaxSubscriptionTimeOut;\n\t\t}\n\t}\n\tif (time_out >= 0) {\n\t\tsub->expireTime = time(NULL) + time_out;\n\t} else {\n\t\t/* infinite time */\n\t\tsub->expireTime = 0;\n\t}\n\n\t/* generate SID */\n\tuuid_create(&uid);\n\tuuid_unpack(&uid, temp_sid);\n\trc = snprintf(sub->sid, sizeof(sub->sid), \"uuid:%s\", temp_sid);\n\n\t/* respond OK */\n\tif (rc < 0 || (unsigned int) rc >= sizeof(sub->sid) ||\n\t\t(respond_ok(info, time_out,\n\t\tsub, request) != UPNP_E_SUCCESS)) {\n\t\tfreeSubscriptionList(sub);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\t/* add to subscription list */\n\tsub->next = service->subscriptionList;\n\tservice->subscriptionList = sub;\n\tservice->TotalSubscriptions++;\n\n\t/* finally generate callback for init table dump */\n\tUpnpSubscriptionRequest_strcpy_ServiceId(request_struct, service->serviceId);\n\tUpnpSubscriptionRequest_strcpy_UDN(request_struct, service->UDN);\n\tUpnpSubscriptionRequest_strcpy_SID(request_struct, sub->sid);\n\n\t/* copy callback */\n\tcallback_fun = handle_info->Callback;\n\tcookie = handle_info->Cookie;\n\n\tHandleUnlock();\n\n\t/* make call back with request struct */\n\t/* in the future should find a way of mainting that the handle */\n\t/* is not unregistered in the middle of a callback */\n\tcallback_fun(UPNP_EVENT_SUBSCRIPTION_REQUEST, request_struct, cookie);\n\nexit_function:\n\tUpnpSubscriptionRequest_delete(request_struct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gena_process_subscription_renewal_request",
          "args": [
            "info",
            "request"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "gena_process_subscription_renewal_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "1372-1482",
          "snippet": "void gena_process_subscription_renewal_request(\n\tSOCKINFO *info,\n\thttp_message_t *request)\n{\n    Upnp_SID sid;\n    subscription *sub;\n    int time_out = 1801;\n    service_info *service;\n    struct Handle_Info *handle_info;\n    UpnpDevice_Handle device_handle;\n    memptr temp_hdr;\n    membuffer event_url_path;\n    memptr timeout_hdr;\n\n    /* if a CALLBACK or NT header is present, then it is an error */\n    if( httpmsg_find_hdr( request, HDR_CALLBACK, NULL ) != NULL ||\n        httpmsg_find_hdr( request, HDR_NT, NULL ) != NULL ) {\n        error_respond( info, HTTP_BAD_REQUEST, request );\n        return;\n    }\n    /* get SID */\n    if( httpmsg_find_hdr( request, HDR_SID, &temp_hdr ) == NULL ||\n        temp_hdr.length > SID_SIZE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        return;\n    }\n    memcpy( sid, temp_hdr.buf, temp_hdr.length );\n    sid[temp_hdr.length] = '\\0';\n\n    /* lookup service by eventURL */\n    membuffer_init( &event_url_path );\n    if( membuffer_append( &event_url_path, request->uri.pathquery.buff,\n                          request->uri.pathquery.size ) != 0 ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return;\n    }\n\n    HandleLock();\n\n    /* CURRENTLY, ONLY SUPPORT ONE DEVICE */\n    if( GetDeviceHandleInfo( info->foreign_sockaddr.ss_family,\n        &device_handle, &handle_info ) != HND_DEVICE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        membuffer_destroy( &event_url_path );\n        HandleUnlock();\n        return;\n    }\n    service = FindServiceEventURLPath( &handle_info->ServiceTable,\n                                       event_url_path.buf );\n    membuffer_destroy( &event_url_path );\n\n    /* get subscription */\n    if( service == NULL ||\n        !service->active ||\n        ( ( sub = GetSubscriptionSID( sid, service ) ) == NULL ) ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        HandleUnlock();\n        return;\n    }\n\n    UpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__,\n        \"Renew request: Number of subscriptions already: %d\\n \"\n        \"Max Subscriptions allowed:%d\\n\",\n        service->TotalSubscriptions,\n        handle_info->MaxSubscriptions );\n    /* too many subscriptions */\n    if( handle_info->MaxSubscriptions != -1 &&\n            service->TotalSubscriptions > handle_info->MaxSubscriptions ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        RemoveSubscriptionSID( sub->sid, service );\n        HandleUnlock();\n        return;\n    }\n    /* set the timeout */\n    if( httpmsg_find_hdr( request, HDR_TIMEOUT, &timeout_hdr ) != NULL ) {\n        if( matchstr( timeout_hdr.buf, timeout_hdr.length,\n                      \"%iSecond-%d%0\", &time_out ) == PARSE_OK ) {\n\n            /*nothing */\n\n        } else if( memptr_cmp_nocase( &timeout_hdr, \"Second-infinite\" ) ==\n                   0 ) {\n\n            time_out = -1;      /* inifinite timeout */\n\n        } else {\n            time_out = DEFAULT_TIMEOUT; /* default is > 1800 seconds */\n\n        }\n    }\n\n    /* replace infinite timeout with max timeout, if possible */\n    if( handle_info->MaxSubscriptionTimeOut != -1 ) {\n        if( time_out == -1 ||\n            time_out > handle_info->MaxSubscriptionTimeOut ) {\n            time_out = handle_info->MaxSubscriptionTimeOut;\n        }\n    }\n\n    if( time_out == -1 ) {\n        sub->expireTime = 0;\n    } else {\n        sub->expireTime = time( NULL ) + time_out;\n    }\n\n    if( respond_ok( info, time_out, sub, request ) != UPNP_E_SUCCESS ) {\n        RemoveSubscriptionSID( sub->sid, service );\n    }\n\n    HandleUnlock();\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nvoid gena_process_subscription_renewal_request(\n\tSOCKINFO *info,\n\thttp_message_t *request)\n{\n    Upnp_SID sid;\n    subscription *sub;\n    int time_out = 1801;\n    service_info *service;\n    struct Handle_Info *handle_info;\n    UpnpDevice_Handle device_handle;\n    memptr temp_hdr;\n    membuffer event_url_path;\n    memptr timeout_hdr;\n\n    /* if a CALLBACK or NT header is present, then it is an error */\n    if( httpmsg_find_hdr( request, HDR_CALLBACK, NULL ) != NULL ||\n        httpmsg_find_hdr( request, HDR_NT, NULL ) != NULL ) {\n        error_respond( info, HTTP_BAD_REQUEST, request );\n        return;\n    }\n    /* get SID */\n    if( httpmsg_find_hdr( request, HDR_SID, &temp_hdr ) == NULL ||\n        temp_hdr.length > SID_SIZE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        return;\n    }\n    memcpy( sid, temp_hdr.buf, temp_hdr.length );\n    sid[temp_hdr.length] = '\\0';\n\n    /* lookup service by eventURL */\n    membuffer_init( &event_url_path );\n    if( membuffer_append( &event_url_path, request->uri.pathquery.buff,\n                          request->uri.pathquery.size ) != 0 ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        return;\n    }\n\n    HandleLock();\n\n    /* CURRENTLY, ONLY SUPPORT ONE DEVICE */\n    if( GetDeviceHandleInfo( info->foreign_sockaddr.ss_family,\n        &device_handle, &handle_info ) != HND_DEVICE ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        membuffer_destroy( &event_url_path );\n        HandleUnlock();\n        return;\n    }\n    service = FindServiceEventURLPath( &handle_info->ServiceTable,\n                                       event_url_path.buf );\n    membuffer_destroy( &event_url_path );\n\n    /* get subscription */\n    if( service == NULL ||\n        !service->active ||\n        ( ( sub = GetSubscriptionSID( sid, service ) ) == NULL ) ) {\n        error_respond( info, HTTP_PRECONDITION_FAILED, request );\n        HandleUnlock();\n        return;\n    }\n\n    UpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__,\n        \"Renew request: Number of subscriptions already: %d\\n \"\n        \"Max Subscriptions allowed:%d\\n\",\n        service->TotalSubscriptions,\n        handle_info->MaxSubscriptions );\n    /* too many subscriptions */\n    if( handle_info->MaxSubscriptions != -1 &&\n            service->TotalSubscriptions > handle_info->MaxSubscriptions ) {\n        error_respond( info, HTTP_INTERNAL_SERVER_ERROR, request );\n        RemoveSubscriptionSID( sub->sid, service );\n        HandleUnlock();\n        return;\n    }\n    /* set the timeout */\n    if( httpmsg_find_hdr( request, HDR_TIMEOUT, &timeout_hdr ) != NULL ) {\n        if( matchstr( timeout_hdr.buf, timeout_hdr.length,\n                      \"%iSecond-%d%0\", &time_out ) == PARSE_OK ) {\n\n            /*nothing */\n\n        } else if( memptr_cmp_nocase( &timeout_hdr, \"Second-infinite\" ) ==\n                   0 ) {\n\n            time_out = -1;      /* inifinite timeout */\n\n        } else {\n            time_out = DEFAULT_TIMEOUT; /* default is > 1800 seconds */\n\n        }\n    }\n\n    /* replace infinite timeout with max timeout, if possible */\n    if( handle_info->MaxSubscriptionTimeOut != -1 ) {\n        if( time_out == -1 ||\n            time_out > handle_info->MaxSubscriptionTimeOut ) {\n            time_out = handle_info->MaxSubscriptionTimeOut;\n        }\n    }\n\n    if( time_out == -1 ) {\n        sub->expireTime = 0;\n    } else {\n        sub->expireTime = time( NULL ) + time_out;\n    }\n\n    if( respond_ok( info, time_out, sub, request ) != UPNP_E_SUCCESS ) {\n        RemoveSubscriptionSID( sub->sid, service );\n    }\n\n    HandleUnlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "request",
            "HDR_NT",
            "NULL"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena_ctrlpt.h\"\n#include \"gena_device.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nvoid\ngenaCallback( IN http_parser_t * parser,\n              IN http_message_t * request,\n              INOUT SOCKINFO * info )\n{\n    int found_function = FALSE;\n\n    if( request->method == HTTPMETHOD_SUBSCRIBE ) {\n#ifdef INCLUDE_DEVICE_APIS\n        found_function = TRUE;\n        if( httpmsg_find_hdr( request, HDR_NT, NULL ) == NULL ) {\n            /* renew subscription */\n            gena_process_subscription_renewal_request\n            ( info, request );\n\t} else {\n            /* subscribe */\n            gena_process_subscription_request( info, request );\n\t}\n        UpnpPrintf( UPNP_ALL, GENA, __FILE__, __LINE__,\n            \"got subscription request\\n\" );\n    } else if( request->method == HTTPMETHOD_UNSUBSCRIBE ) {\n        found_function = TRUE;\n        /* unsubscribe */\n        gena_process_unsubscribe_request( info, request );\n#endif\n    } else if( request->method == HTTPMETHOD_NOTIFY ) {\n#ifdef INCLUDE_CLIENT_APIS\n        found_function = TRUE;\n        /* notify */\n        gena_process_notification_event( info, request );\n#endif\n    }\n\n    if( !found_function ) {\n            /* handle missing functions of device or ctrl pt */\n            error_respond( info, HTTP_NOT_IMPLEMENTED, request );\n    }\n    return;\n    parser = parser;\n}"
  },
  {
    "function_name": "error_respond",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_callback2.c",
    "lines": "58-71",
    "snippet": "void\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}",
    "includes": [
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena_ctrlpt.h\"",
      "#include \"gena_device.h\"",
      "#include \"gena.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_SendStatusResponse",
          "args": [
            "info",
            "error_code",
            "major",
            "minor"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendStatusResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1445-1468",
          "snippet": "int http_SendStatusResponse(IN SOCKINFO *info, IN int http_status_code,\n\tIN int request_major_version, IN int request_minor_version)\n{\n\tint response_major, response_minor;\n\tmembuffer membuf;\n\tint ret;\n\tint timeout;\n\n\thttp_CalcResponseVersion(request_major_version, request_minor_version,\n\t\t\t\t &response_major, &response_minor);\n\tmembuffer_init(&membuf);\n\tmembuf.size_inc = (size_t)70;\n\t/* response start line */\n\tret = http_MakeMessage(&membuf, response_major, response_minor, \"RSCB\",\n\t\t\t       http_status_code, http_status_code);\n\tif (ret == 0) {\n\t\ttimeout = HTTP_DEFAULT_TIMEOUT;\n\t\tret = http_SendMessage(info, &timeout, \"b\",\n\t\t       membuf.buf, membuf.length);\n\t}\n\tmembuffer_destroy(&membuf);\n\n\treturn ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_SendStatusResponse(IN SOCKINFO *info, IN int http_status_code,\n\tIN int request_major_version, IN int request_minor_version)\n{\n\tint response_major, response_minor;\n\tmembuffer membuf;\n\tint ret;\n\tint timeout;\n\n\thttp_CalcResponseVersion(request_major_version, request_minor_version,\n\t\t\t\t &response_major, &response_minor);\n\tmembuffer_init(&membuf);\n\tmembuf.size_inc = (size_t)70;\n\t/* response start line */\n\tret = http_MakeMessage(&membuf, response_major, response_minor, \"RSCB\",\n\t\t\t       http_status_code, http_status_code);\n\tif (ret == 0) {\n\t\ttimeout = HTTP_DEFAULT_TIMEOUT;\n\t\tret = http_SendMessage(info, &timeout, \"b\",\n\t\t       membuf.buf, membuf.length);\n\t}\n\tmembuffer_destroy(&membuf);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_CalcResponseVersion",
          "args": [
            "hmsg->major_version",
            "hmsg->minor_version",
            "&major",
            "&minor"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "http_CalcResponseVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1720-1733",
          "snippet": "void http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nvoid http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena_ctrlpt.h\"\n#include \"gena_device.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nvoid\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}"
  }
]