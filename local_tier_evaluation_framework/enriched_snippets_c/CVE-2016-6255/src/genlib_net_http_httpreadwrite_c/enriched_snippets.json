[
  {
    "function_name": "get_sdk_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1982-2011",
    "snippet": "void get_sdk_info(OUT char *info, IN size_t infoSize)\n{\n#ifdef UPNP_ENABLE_UNSPECIFIED_SERVER\n\tsnprintf(info, infoSize, \"Unspecified, UPnP/1.0, Unspecified\\r\\n\");\n#else /* UPNP_ENABLE_UNSPECIFIED_SERVER */\n#ifdef WIN32\n\tOSVERSIONINFO versioninfo;\n\tversioninfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n\n\tif (GetVersionEx(&versioninfo) != 0)\n\t\tsnprintf(info, infoSize,\n\t\t\t\"%d.%d.%d %d/%s, UPnP/1.0, Portable SDK for UPnP devices/\"\n\t\t\tPACKAGE_VERSION \"\\r\\n\", versioninfo.dwMajorVersion,\n\t\t\tversioninfo.dwMinorVersion, versioninfo.dwBuildNumber,\n\t\t\tversioninfo.dwPlatformId, versioninfo.szCSDVersion);\n\telse\n\t\t*info = '\\0';\n#else\n\tint ret_code;\n\tstruct utsname sys_info;\n\n\tret_code = uname(&sys_info);\n\tif (ret_code == -1)\n\t\t*info = '\\0';\n\tsnprintf(info, infoSize,\n\t\t\"%s/%s, UPnP/1.0, Portable SDK for UPnP devices/\"\n\t\tPACKAGE_VERSION \"\\r\\n\", sys_info.sysname, sys_info.release);\n#endif\n#endif /* UPNP_ENABLE_UNSPECIFIED_SERVER */\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "info",
            "infoSize",
            "\"%s/%s, UPnP/1.0, Portable SDK for UPnP devices/\"\n\t\tPACKAGE_VERSION \"\\r\\n\"",
            "sys_info.sysname",
            "sys_info.release"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uname",
          "args": [
            "&sys_info"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "info",
            "infoSize",
            "\"%d.%d.%d %d/%s, UPnP/1.0, Portable SDK for UPnP devices/\"\n\t\t\tPACKAGE_VERSION \"\\r\\n\"",
            "versioninfo.dwMajorVersion",
            "versioninfo.dwMinorVersion",
            "versioninfo.dwBuildNumber",
            "versioninfo.dwPlatformId",
            "versioninfo.szCSDVersion"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetVersionEx",
          "args": [
            "&versioninfo"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "info",
            "infoSize",
            "\"Unspecified, UPnP/1.0, Unspecified\\r\\n\""
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nvoid get_sdk_info(OUT char *info, IN size_t infoSize)\n{\n#ifdef UPNP_ENABLE_UNSPECIFIED_SERVER\n\tsnprintf(info, infoSize, \"Unspecified, UPnP/1.0, Unspecified\\r\\n\");\n#else /* UPNP_ENABLE_UNSPECIFIED_SERVER */\n#ifdef WIN32\n\tOSVERSIONINFO versioninfo;\n\tversioninfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n\n\tif (GetVersionEx(&versioninfo) != 0)\n\t\tsnprintf(info, infoSize,\n\t\t\t\"%d.%d.%d %d/%s, UPnP/1.0, Portable SDK for UPnP devices/\"\n\t\t\tPACKAGE_VERSION \"\\r\\n\", versioninfo.dwMajorVersion,\n\t\t\tversioninfo.dwMinorVersion, versioninfo.dwBuildNumber,\n\t\t\tversioninfo.dwPlatformId, versioninfo.szCSDVersion);\n\telse\n\t\t*info = '\\0';\n#else\n\tint ret_code;\n\tstruct utsname sys_info;\n\n\tret_code = uname(&sys_info);\n\tif (ret_code == -1)\n\t\t*info = '\\0';\n\tsnprintf(info, infoSize,\n\t\t\"%s/%s, UPnP/1.0, Portable SDK for UPnP devices/\"\n\t\tPACKAGE_VERSION \"\\r\\n\", sys_info.sysname, sys_info.release);\n#endif\n#endif /* UPNP_ENABLE_UNSPECIFIED_SERVER */\n}"
  },
  {
    "function_name": "http_OpenHttpGetEx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1842-1965",
    "snippet": "int http_OpenHttpGetEx(\n\tIN const char *url_str,\n\tIN OUT void **Handle,\n\tIN OUT char **contentType,\n\tOUT int *contentLength,\n\tOUT int *httpStatus,\n\tIN int lowRange,\n\tIN int highRange,\n\tIN int timeout)\n{\n\tint http_error_code;\n\tmemptr ctype;\n\tSOCKET tcp_connection;\n\tsize_t sockaddr_len;\n\tmembuffer request;\n\thttp_connection_handle_t *handle = NULL;\n\turi_type url;\n\tparse_status_t status;\n\tint errCode = UPNP_E_SUCCESS;\n\t/* char rangeBuf[SIZE_RANGE_BUFFER]; */\n\tstruct SendInstruction rangeBuf;\n\tint rc = 0;\n\n\tmembuffer_init(&request);\n\n\tdo {\n\t\t/* Checking Input parameters */\n\t\tif (!url_str || !Handle || !contentType || !httpStatus ) {\n\t\t\terrCode = UPNP_E_INVALID_PARAM;\n\t\t\tbreak;\n\t\t}\n\t\t/* Initialize output parameters */\n\t\t*httpStatus = 0;\n\t\t*Handle = handle;\n\t\t*contentType = NULL;\n\t\t*contentLength = 0;\n\t\tif (lowRange > highRange) {\n\t\t\terrCode = UPNP_E_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(&rangeBuf, 0, sizeof(rangeBuf));\n\t\trc = snprintf(rangeBuf.RangeHeader, sizeof(rangeBuf.RangeHeader),\n\t\t\t\"Range: bytes=%d-%d\\r\\n\", lowRange, highRange);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(rangeBuf.RangeHeader))\n\t\t\tbreak;\n\t\tmembuffer_init(&request);\n\t\terrCode = MakeGetMessageEx(url_str, &request, &url, &rangeBuf);\n\t\tif (errCode != UPNP_E_SUCCESS)\n\t\t\tbreak;\n\t\thandle = (http_connection_handle_t *)malloc(sizeof(http_connection_handle_t));\n\t\tif (!handle) {\n\t\t\terrCode = UPNP_E_OUTOF_MEMORY;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(handle, 0, sizeof(*handle));\n\t\tparser_response_init(&handle->response, HTTPMETHOD_GET);\n\t\ttcp_connection = socket((int)url.hostport.IPaddress.ss_family,\n\t\t\tSOCK_STREAM, 0);\n\t\tif (tcp_connection == INVALID_SOCKET) {\n\t\t\terrCode = UPNP_E_SOCKET_ERROR;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tif (sock_init(&handle->sock_info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\terrCode = UPNP_E_SOCKET_ERROR;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tsockaddr_len = url.hostport.IPaddress.ss_family == AF_INET6 ?\n\t\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\t\terrCode  = private_connect(handle->sock_info.socket,\n\t\t\t(struct sockaddr *)&(url.hostport.IPaddress),\n\t\t\t(socklen_t)sockaddr_len);\n\t\tif (errCode == -1) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\terrCode = UPNP_E_SOCKET_CONNECT;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\t/* send request */\n\t\terrCode = http_SendMessage(&handle->sock_info, &timeout,\n\t\t\t\"b\", request.buf, request.length);\n\t\tif (errCode != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tif (ReadResponseLineAndHeaders(&handle->sock_info,\n\t\t\t&handle->response, &timeout, &http_error_code) != (int)PARSE_OK) {\n\t\t\terrCode = UPNP_E_BAD_RESPONSE;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tstatus = parser_get_entity_read_method(&handle->response);\n\t\tif (status != (parse_status_t)PARSE_CONTINUE_1 &&\n\t\t\tstatus != (parse_status_t)PARSE_SUCCESS) {\n\t\t\terrCode = UPNP_E_BAD_RESPONSE;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\t*httpStatus = handle->response.msg.status_code;\n\t\terrCode = UPNP_E_SUCCESS;\n\n\t\tif (!httpmsg_find_hdr(&handle->response.msg, HDR_CONTENT_TYPE, &ctype))\n\t\t\t/* no content-type */\n\t\t\t*contentType = NULL;\n\t\telse\n\t\t\t*contentType = ctype.buf;\n\t\tif (handle->response.position == (parser_pos_t)POS_COMPLETE)\n\t\t\t*contentLength = 0;\n\t\telse if(handle->response.ent_position == ENTREAD_USING_CHUNKED)\n\t\t\t*contentLength = UPNP_USING_CHUNKED;\n\t\telse if(handle->response.ent_position == ENTREAD_USING_CLEN)\n\t\t\t*contentLength = (int)handle->response.content_length;\n\t\telse if(handle->response.ent_position == ENTREAD_UNTIL_CLOSE)\n\t\t\t*contentLength = UPNP_UNTIL_CLOSE;\n\t\t*Handle = handle;\n\t} while (0);\n\n\tmembuffer_destroy(&request);\n\n\treturn errCode;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SIZE_RANGE_BUFFER 50",
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&request"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "&handle->response.msg",
            "HDR_CONTENT_TYPE",
            "&ctype"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "handle"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_get_entity_read_method",
          "args": [
            "&handle->response"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "parser_get_entity_read_method",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1808-1894",
          "snippet": "UPNP_INLINE parse_status_t\nparser_get_entity_read_method( INOUT http_parser_t * parser )\n{\n    http_message_t *hmsg = &parser->msg;\n    int response_code;\n    memptr hdr_value;\n\n    assert( parser->ent_position == ENTREAD_DETERMINE_READ_METHOD );\n\n    /* entity points to start of msg body */\n    parser->msg.entity.buf = scanner_get_str( &parser->scanner );\n    parser->msg.entity.length = ( size_t ) 0;\n\n    /* remember start of body */\n    parser->entity_start_position = parser->scanner.cursor;\n\n    /* std http rules for determining content length */\n\n    /* * no body for 1xx, 204, 304 and HEAD, GET, */\n    /*      SUBSCRIBE, UNSUBSCRIBE */\n    if( hmsg->is_request ) {\n        switch ( hmsg->method ) {\n            case HTTPMETHOD_HEAD:\n            case HTTPMETHOD_GET:\n                /*case HTTPMETHOD_POST: */\n            case HTTPMETHOD_SUBSCRIBE:\n            case HTTPMETHOD_UNSUBSCRIBE:\n            case HTTPMETHOD_MSEARCH:\n                /* no body; mark as done */\n                parser->position = POS_COMPLETE;\n                return PARSE_SUCCESS;\n                break;\n\n            default:\n                ;               /* do nothing */\n        }\n    } else                      /* response */\n    {\n        response_code = hmsg->status_code;\n\n        if( response_code == 204 ||\n            response_code == 304 ||\n            ( response_code >= 100 && response_code <= 199 ) ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_HEAD ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_MSEARCH ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_SUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_UNSUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->position = POS_COMPLETE;\n            return PARSE_SUCCESS;\n        }\n    }\n\n    /* * transfer-encoding -- used to indicate chunked data */\n    if( httpmsg_find_hdr( hmsg, HDR_TRANSFER_ENCODING, &hdr_value ) ) {\n        if( raw_find_str( &hdr_value, \"chunked\" ) >= 0 ) {\n            /* read method to use chunked transfer encoding */\n            parser->ent_position = ENTREAD_USING_CHUNKED;\n            UpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n                \"Found Chunked Encoding ....\\n\" );\n\n            return PARSE_CONTINUE_1;\n        }\n    }\n    /* * use content length */\n    if( httpmsg_find_hdr( hmsg, HDR_CONTENT_LENGTH, &hdr_value ) ) {\n        parser->content_length = (unsigned int)raw_to_int(&hdr_value, 10);\n        parser->ent_position = ENTREAD_USING_CLEN;\n        return PARSE_CONTINUE_1;\n    }\n    /* * multi-part/byteranges not supported (yet) */\n\n    /* * read until connection is closed */\n    if( hmsg->is_request ) {\n        /* set hack flag for NOTIFY methods; if set to true this is */\n        /*  a valid SSDP notify msg */\n        if( hmsg->method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->valid_ssdp_notify_hack = TRUE;\n        }\n\n        parser->http_error_code = HTTP_LENGTH_REQUIRED;\n        return PARSE_FAILURE;\n    }\n\n    parser->ent_position = ENTREAD_UNTIL_CLOSE;\n    return PARSE_CONTINUE_1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nUPNP_INLINE parse_status_t\nparser_get_entity_read_method( INOUT http_parser_t * parser )\n{\n    http_message_t *hmsg = &parser->msg;\n    int response_code;\n    memptr hdr_value;\n\n    assert( parser->ent_position == ENTREAD_DETERMINE_READ_METHOD );\n\n    /* entity points to start of msg body */\n    parser->msg.entity.buf = scanner_get_str( &parser->scanner );\n    parser->msg.entity.length = ( size_t ) 0;\n\n    /* remember start of body */\n    parser->entity_start_position = parser->scanner.cursor;\n\n    /* std http rules for determining content length */\n\n    /* * no body for 1xx, 204, 304 and HEAD, GET, */\n    /*      SUBSCRIBE, UNSUBSCRIBE */\n    if( hmsg->is_request ) {\n        switch ( hmsg->method ) {\n            case HTTPMETHOD_HEAD:\n            case HTTPMETHOD_GET:\n                /*case HTTPMETHOD_POST: */\n            case HTTPMETHOD_SUBSCRIBE:\n            case HTTPMETHOD_UNSUBSCRIBE:\n            case HTTPMETHOD_MSEARCH:\n                /* no body; mark as done */\n                parser->position = POS_COMPLETE;\n                return PARSE_SUCCESS;\n                break;\n\n            default:\n                ;               /* do nothing */\n        }\n    } else                      /* response */\n    {\n        response_code = hmsg->status_code;\n\n        if( response_code == 204 ||\n            response_code == 304 ||\n            ( response_code >= 100 && response_code <= 199 ) ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_HEAD ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_MSEARCH ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_SUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_UNSUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->position = POS_COMPLETE;\n            return PARSE_SUCCESS;\n        }\n    }\n\n    /* * transfer-encoding -- used to indicate chunked data */\n    if( httpmsg_find_hdr( hmsg, HDR_TRANSFER_ENCODING, &hdr_value ) ) {\n        if( raw_find_str( &hdr_value, \"chunked\" ) >= 0 ) {\n            /* read method to use chunked transfer encoding */\n            parser->ent_position = ENTREAD_USING_CHUNKED;\n            UpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n                \"Found Chunked Encoding ....\\n\" );\n\n            return PARSE_CONTINUE_1;\n        }\n    }\n    /* * use content length */\n    if( httpmsg_find_hdr( hmsg, HDR_CONTENT_LENGTH, &hdr_value ) ) {\n        parser->content_length = (unsigned int)raw_to_int(&hdr_value, 10);\n        parser->ent_position = ENTREAD_USING_CLEN;\n        return PARSE_CONTINUE_1;\n    }\n    /* * multi-part/byteranges not supported (yet) */\n\n    /* * read until connection is closed */\n    if( hmsg->is_request ) {\n        /* set hack flag for NOTIFY methods; if set to true this is */\n        /*  a valid SSDP notify msg */\n        if( hmsg->method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->valid_ssdp_notify_hack = TRUE;\n        }\n\n        parser->http_error_code = HTTP_LENGTH_REQUIRED;\n        return PARSE_FAILURE;\n    }\n\n    parser->ent_position = ENTREAD_UNTIL_CLOSE;\n    return PARSE_CONTINUE_1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadResponseLineAndHeaders",
          "args": [
            "&handle->sock_info",
            "&handle->response",
            "&timeout",
            "&http_error_code"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "ReadResponseLineAndHeaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "941-1044",
          "snippet": "static int ReadResponseLineAndHeaders(\n\t/*! Socket information object. */\n\tIN SOCKINFO *info,\n\t/*! HTTP Parser object. */\n\tIN OUT http_parser_t *parser,\n\t/*! Time out value. */\n\tIN OUT int *timeout_secs,\n\t/*! HTTP errror code returned. */\n\tIN OUT int *http_error_code)\n{\n\tparse_status_t status;\n\tint num_read;\n\tchar buf[2 * 1024];\n\tint done = 0;\n\tint ret_code = 0;\n\n\t/*read response line */\n\tstatus = parser_parse_responseline(parser);\n\tswitch (status) {\n\tcase PARSE_OK:\n\t\tdone = 1;\n\t\tbreak;\n\tcase PARSE_INCOMPLETE:\n\t\tdone = 0;\n\t\tbreak;\n\tdefault:\n\t\t/*error */\n\t\treturn status;\n\t}\n\twhile (!done) {\n\t\tnum_read = sock_read(info, buf, sizeof(buf), timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code =\n\t\t\t\tmembuffer_append(&parser->msg.msg, buf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_responseline(parser);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_OK:\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_INCOMPLETE:\n\t\t\t\tdone = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*error */\n\t\t\t\treturn status;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\t/* partial msg */\n\t\t\t*http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\tstatus = parser_parse_headers(parser);\n\tif ((status == (parse_status_t)PARSE_OK) &&\n\t\t(parser->position == (parser_pos_t)POS_ENTITY))\n\t\tdone = 1;\n\telse if (status == (parse_status_t)PARSE_INCOMPLETE)\n\t\tdone = 0;\n\telse\n\t\t/*error */\n\t\treturn status;\n\t/*read headers */\n\twhile (!done) {\n\t\tnum_read = sock_read(info, buf, sizeof(buf), timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code =\n\t\t\t    membuffer_append(&parser->msg.msg, buf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_headers(parser);\n\t\t\tif (status == (parse_status_t)PARSE_OK &&\n\t\t\t\tparser->position == (parser_pos_t)POS_ENTITY)\n\t\t\t\tdone = 1;\n\t\t\telse if (status == (parse_status_t)PARSE_INCOMPLETE)\n\t\t\t\tdone = 0;\n\t\t\telse\n\t\t\t\t/*error */\n\t\t\t\treturn status;\n\t\t} else if (num_read == 0) {\n\t\t\t/* partial msg */\n\t\t\t*http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\n\treturn PARSE_OK;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstatic int ReadResponseLineAndHeaders(\n\t/*! Socket information object. */\n\tIN SOCKINFO *info,\n\t/*! HTTP Parser object. */\n\tIN OUT http_parser_t *parser,\n\t/*! Time out value. */\n\tIN OUT int *timeout_secs,\n\t/*! HTTP errror code returned. */\n\tIN OUT int *http_error_code)\n{\n\tparse_status_t status;\n\tint num_read;\n\tchar buf[2 * 1024];\n\tint done = 0;\n\tint ret_code = 0;\n\n\t/*read response line */\n\tstatus = parser_parse_responseline(parser);\n\tswitch (status) {\n\tcase PARSE_OK:\n\t\tdone = 1;\n\t\tbreak;\n\tcase PARSE_INCOMPLETE:\n\t\tdone = 0;\n\t\tbreak;\n\tdefault:\n\t\t/*error */\n\t\treturn status;\n\t}\n\twhile (!done) {\n\t\tnum_read = sock_read(info, buf, sizeof(buf), timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code =\n\t\t\t\tmembuffer_append(&parser->msg.msg, buf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_responseline(parser);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_OK:\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_INCOMPLETE:\n\t\t\t\tdone = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*error */\n\t\t\t\treturn status;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\t/* partial msg */\n\t\t\t*http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\tstatus = parser_parse_headers(parser);\n\tif ((status == (parse_status_t)PARSE_OK) &&\n\t\t(parser->position == (parser_pos_t)POS_ENTITY))\n\t\tdone = 1;\n\telse if (status == (parse_status_t)PARSE_INCOMPLETE)\n\t\tdone = 0;\n\telse\n\t\t/*error */\n\t\treturn status;\n\t/*read headers */\n\twhile (!done) {\n\t\tnum_read = sock_read(info, buf, sizeof(buf), timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code =\n\t\t\t    membuffer_append(&parser->msg.msg, buf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_headers(parser);\n\t\t\tif (status == (parse_status_t)PARSE_OK &&\n\t\t\t\tparser->position == (parser_pos_t)POS_ENTITY)\n\t\t\t\tdone = 1;\n\t\t\telse if (status == (parse_status_t)PARSE_INCOMPLETE)\n\t\t\t\tdone = 0;\n\t\t\telse\n\t\t\t\t/*error */\n\t\t\t\treturn status;\n\t\t} else if (num_read == 0) {\n\t\t\t/* partial msg */\n\t\t\t*http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\n\treturn PARSE_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_destroy",
          "args": [
            "&handle->sock_info",
            "SD_BOTH"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "sock_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "118-143",
          "snippet": "int sock_destroy(SOCKINFO *info, int ShutdownMethod)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (info->socket != INVALID_SOCKET) {\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t\tif (info->ssl) {\n\t\t\tSSL_shutdown(info->ssl);\n\t\t\tSSL_free(info->ssl);\n\t\t\tinfo->ssl = NULL;\n\t\t}\n#endif\n\t\tif (shutdown(info->socket, ShutdownMethod) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tif (sock_close(info->socket) == -1) {\n\t\t\tret = UPNP_E_SOCKET_ERROR;\n\t\t}\n\t\tinfo->socket = INVALID_SOCKET;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_destroy(SOCKINFO *info, int ShutdownMethod)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (info->socket != INVALID_SOCKET) {\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t\tif (info->ssl) {\n\t\t\tSSL_shutdown(info->ssl);\n\t\t\tSSL_free(info->ssl);\n\t\t\tinfo->ssl = NULL;\n\t\t}\n#endif\n\t\tif (shutdown(info->socket, ShutdownMethod) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tif (sock_close(info->socket) == -1) {\n\t\t\tret = UPNP_E_SOCKET_ERROR;\n\t\t}\n\t\tinfo->socket = INVALID_SOCKET;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_SendMessage",
          "args": [
            "&handle->sock_info",
            "&timeout",
            "\"b\"",
            "request.buf",
            "request.length"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "437-613",
          "snippet": "int http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CHUNK_TAIL_SIZE (size_t)10",
            "#define CHUNK_HEADER_SIZE (size_t)10",
            "#define snprintf _snprintf",
            "#define fseeko fseek"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n#define snprintf _snprintf\n#define fseeko fseek\n\nint http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "private_connect",
          "args": [
            "handle->sock_info.socket",
            "(struct sockaddr *)&(url.hostport.IPaddress)",
            "(socklen_t)sockaddr_len"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "private_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "146-165",
          "snippet": "static int private_connect(\n\tSOCKET sockfd,\n\tconst struct sockaddr *serv_addr,\n\tsocklen_t addrlen)\n{\n#ifndef UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS\n\tint ret = sock_make_no_blocking(sockfd);\n\tif (ret != - 1) {\n\t\tret = connect(sockfd, serv_addr, addrlen);\n\t\tret = Check_Connect_And_Wait_Connection(sockfd, ret);\n\t\tif (ret != - 1) {\n\t\t\tret = sock_make_blocking(sockfd);\n\t\t}\n\t}\n\n\treturn ret;\n#else\n\treturn connect(sockfd, serv_addr, addrlen);\n#endif /* UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS */\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstatic int private_connect(\n\tSOCKET sockfd,\n\tconst struct sockaddr *serv_addr,\n\tsocklen_t addrlen)\n{\n#ifndef UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS\n\tint ret = sock_make_no_blocking(sockfd);\n\tif (ret != - 1) {\n\t\tret = connect(sockfd, serv_addr, addrlen);\n\t\tret = Check_Connect_And_Wait_Connection(sockfd, ret);\n\t\tif (ret != - 1) {\n\t\t\tret = sock_make_blocking(sockfd);\n\t\t}\n\t}\n\n\treturn ret;\n#else\n\treturn connect(sockfd, serv_addr, addrlen);\n#endif /* UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_init",
          "args": [
            "&handle->sock_info",
            "tcp_connection"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "sock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "73-81",
          "snippet": "int sock_init(SOCKINFO *info, SOCKET sockfd)\n{\n\tassert(info);\n\n\tmemset(info, 0, sizeof(SOCKINFO));\n\tinfo->socket = sockfd;\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_init(SOCKINFO *info, SOCKET sockfd)\n{\n\tassert(info);\n\n\tmemset(info, 0, sizeof(SOCKINFO));\n\tinfo->socket = sockfd;\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "(int)url.hostport.IPaddress.ss_family",
            "SOCK_STREAM",
            "0"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_response_init",
          "args": [
            "&handle->response",
            "HTTPMETHOD_GET"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "parser_response_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1985-1994",
          "snippet": "void\nparser_response_init( OUT http_parser_t * parser,\n                      IN http_method_t request_method )\n{\n    parser_init( parser );\n    parser->msg.is_request = FALSE;\n    parser->msg.request_method = request_method;\n    parser->msg.amount_discarded = (size_t)0;\n    parser->position = POS_RESPONSE_LINE;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid\nparser_response_init( OUT http_parser_t * parser,\n                      IN http_method_t request_method )\n{\n    parser_init( parser );\n    parser->msg.is_request = FALSE;\n    parser->msg.request_method = request_method;\n    parser->msg.amount_discarded = (size_t)0;\n    parser->position = POS_RESPONSE_LINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "handle",
            "0",
            "sizeof(*handle)"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(http_connection_handle_t)"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeGetMessageEx",
          "args": [
            "url_str",
            "&request",
            "&url",
            "&rangeBuf"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "MakeGetMessageEx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1752-1813",
          "snippet": "int MakeGetMessageEx( const char *url_str,\n                  membuffer * request,\n                  uri_type * url,\n                  struct SendInstruction *pRangeSpecifier)\n{\n\tint errCode = UPNP_E_SUCCESS;\n\tchar *urlPath = NULL;\n\tsize_t hostlen = (size_t)0;\n\tchar *hoststr, *temp;\n\n\tdo {\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"DOWNLOAD URL : %s\\n\", url_str);\n\t\tif ((errCode = http_FixStrUrl((char *)url_str,\n\t\t\t\t\t      strlen(url_str),\n\t\t\t\t\t      url)) != UPNP_E_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t\t/* make msg */\n\t\tmembuffer_init(request);\n\t\turlPath = alloca(strlen(url_str) + (size_t)1);\n\t\tif (!urlPath) {\n\t\t\terrCode = UPNP_E_OUTOF_MEMORY;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(urlPath, 0, strlen(url_str) + (size_t)1);\n\t\tstrncpy(urlPath, url_str, strlen(url_str));\n\t\thoststr = strstr(urlPath, \"//\");\n\t\tif (hoststr == NULL) {\n\t\t\terrCode = UPNP_E_INVALID_URL;\n\t\t\tbreak;\n\t\t}\n\t\thoststr += 2;\n\t\ttemp = strchr(hoststr, '/');\n\t\tif (temp == NULL) {\n\t\t\terrCode = UPNP_E_INVALID_URL;\n\t\t\tbreak;\n\t\t}\n\t\t*temp = '\\0';\n\t\thostlen = strlen(hoststr);\n\t\t*temp = '/';\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"HOSTNAME : %s Length : %\" PRIzu \"\\n\",\n\t\t\t   hoststr, hostlen);\n\t\terrCode = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t   \"Q\" \"s\" \"bc\" \"GDCUc\",\n\t\t\t\t\t   HTTPMETHOD_GET, url->pathquery.buff,\n\t\t\t\t\t   url->pathquery.size, \"HOST: \",\n\t\t\t\t\t   hoststr, hostlen, pRangeSpecifier);\n\t\tif (errCode != 0) {\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"HTTP Makemessage failed\\n\");\n\t\t\tmembuffer_destroy(request);\n\t\t\treturn errCode;\n\t\t}\n\t} while (0);\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\",\n\t\t   request->buf);\n\n\treturn errCode;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint MakeGetMessageEx( const char *url_str,\n                  membuffer * request,\n                  uri_type * url,\n                  struct SendInstruction *pRangeSpecifier)\n{\n\tint errCode = UPNP_E_SUCCESS;\n\tchar *urlPath = NULL;\n\tsize_t hostlen = (size_t)0;\n\tchar *hoststr, *temp;\n\n\tdo {\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"DOWNLOAD URL : %s\\n\", url_str);\n\t\tif ((errCode = http_FixStrUrl((char *)url_str,\n\t\t\t\t\t      strlen(url_str),\n\t\t\t\t\t      url)) != UPNP_E_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t\t/* make msg */\n\t\tmembuffer_init(request);\n\t\turlPath = alloca(strlen(url_str) + (size_t)1);\n\t\tif (!urlPath) {\n\t\t\terrCode = UPNP_E_OUTOF_MEMORY;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(urlPath, 0, strlen(url_str) + (size_t)1);\n\t\tstrncpy(urlPath, url_str, strlen(url_str));\n\t\thoststr = strstr(urlPath, \"//\");\n\t\tif (hoststr == NULL) {\n\t\t\terrCode = UPNP_E_INVALID_URL;\n\t\t\tbreak;\n\t\t}\n\t\thoststr += 2;\n\t\ttemp = strchr(hoststr, '/');\n\t\tif (temp == NULL) {\n\t\t\terrCode = UPNP_E_INVALID_URL;\n\t\t\tbreak;\n\t\t}\n\t\t*temp = '\\0';\n\t\thostlen = strlen(hoststr);\n\t\t*temp = '/';\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"HOSTNAME : %s Length : %\" PRIzu \"\\n\",\n\t\t\t   hoststr, hostlen);\n\t\terrCode = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t   \"Q\" \"s\" \"bc\" \"GDCUc\",\n\t\t\t\t\t   HTTPMETHOD_GET, url->pathquery.buff,\n\t\t\t\t\t   url->pathquery.size, \"HOST: \",\n\t\t\t\t\t   hoststr, hostlen, pRangeSpecifier);\n\t\tif (errCode != 0) {\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"HTTP Makemessage failed\\n\");\n\t\t\tmembuffer_destroy(request);\n\t\t\treturn errCode;\n\t\t}\n\t} while (0);\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\",\n\t\t   request->buf);\n\n\treturn errCode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&request"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "rangeBuf.RangeHeader",
            "sizeof(rangeBuf.RangeHeader)",
            "\"Range: bytes=%d-%d\\r\\n\"",
            "lowRange",
            "highRange"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define SIZE_RANGE_BUFFER 50\n#define snprintf _snprintf\n\nint http_OpenHttpGetEx(\n\tIN const char *url_str,\n\tIN OUT void **Handle,\n\tIN OUT char **contentType,\n\tOUT int *contentLength,\n\tOUT int *httpStatus,\n\tIN int lowRange,\n\tIN int highRange,\n\tIN int timeout)\n{\n\tint http_error_code;\n\tmemptr ctype;\n\tSOCKET tcp_connection;\n\tsize_t sockaddr_len;\n\tmembuffer request;\n\thttp_connection_handle_t *handle = NULL;\n\turi_type url;\n\tparse_status_t status;\n\tint errCode = UPNP_E_SUCCESS;\n\t/* char rangeBuf[SIZE_RANGE_BUFFER]; */\n\tstruct SendInstruction rangeBuf;\n\tint rc = 0;\n\n\tmembuffer_init(&request);\n\n\tdo {\n\t\t/* Checking Input parameters */\n\t\tif (!url_str || !Handle || !contentType || !httpStatus ) {\n\t\t\terrCode = UPNP_E_INVALID_PARAM;\n\t\t\tbreak;\n\t\t}\n\t\t/* Initialize output parameters */\n\t\t*httpStatus = 0;\n\t\t*Handle = handle;\n\t\t*contentType = NULL;\n\t\t*contentLength = 0;\n\t\tif (lowRange > highRange) {\n\t\t\terrCode = UPNP_E_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(&rangeBuf, 0, sizeof(rangeBuf));\n\t\trc = snprintf(rangeBuf.RangeHeader, sizeof(rangeBuf.RangeHeader),\n\t\t\t\"Range: bytes=%d-%d\\r\\n\", lowRange, highRange);\n\t\tif (rc < 0 || (unsigned int) rc >= sizeof(rangeBuf.RangeHeader))\n\t\t\tbreak;\n\t\tmembuffer_init(&request);\n\t\terrCode = MakeGetMessageEx(url_str, &request, &url, &rangeBuf);\n\t\tif (errCode != UPNP_E_SUCCESS)\n\t\t\tbreak;\n\t\thandle = (http_connection_handle_t *)malloc(sizeof(http_connection_handle_t));\n\t\tif (!handle) {\n\t\t\terrCode = UPNP_E_OUTOF_MEMORY;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(handle, 0, sizeof(*handle));\n\t\tparser_response_init(&handle->response, HTTPMETHOD_GET);\n\t\ttcp_connection = socket((int)url.hostport.IPaddress.ss_family,\n\t\t\tSOCK_STREAM, 0);\n\t\tif (tcp_connection == INVALID_SOCKET) {\n\t\t\terrCode = UPNP_E_SOCKET_ERROR;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tif (sock_init(&handle->sock_info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\terrCode = UPNP_E_SOCKET_ERROR;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tsockaddr_len = url.hostport.IPaddress.ss_family == AF_INET6 ?\n\t\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\t\terrCode  = private_connect(handle->sock_info.socket,\n\t\t\t(struct sockaddr *)&(url.hostport.IPaddress),\n\t\t\t(socklen_t)sockaddr_len);\n\t\tif (errCode == -1) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\terrCode = UPNP_E_SOCKET_CONNECT;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\t/* send request */\n\t\terrCode = http_SendMessage(&handle->sock_info, &timeout,\n\t\t\t\"b\", request.buf, request.length);\n\t\tif (errCode != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tif (ReadResponseLineAndHeaders(&handle->sock_info,\n\t\t\t&handle->response, &timeout, &http_error_code) != (int)PARSE_OK) {\n\t\t\terrCode = UPNP_E_BAD_RESPONSE;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\tstatus = parser_get_entity_read_method(&handle->response);\n\t\tif (status != (parse_status_t)PARSE_CONTINUE_1 &&\n\t\t\tstatus != (parse_status_t)PARSE_SUCCESS) {\n\t\t\terrCode = UPNP_E_BAD_RESPONSE;\n\t\t\tfree(handle);\n\t\t\tbreak;\n\t\t}\n\t\t*httpStatus = handle->response.msg.status_code;\n\t\terrCode = UPNP_E_SUCCESS;\n\n\t\tif (!httpmsg_find_hdr(&handle->response.msg, HDR_CONTENT_TYPE, &ctype))\n\t\t\t/* no content-type */\n\t\t\t*contentType = NULL;\n\t\telse\n\t\t\t*contentType = ctype.buf;\n\t\tif (handle->response.position == (parser_pos_t)POS_COMPLETE)\n\t\t\t*contentLength = 0;\n\t\telse if(handle->response.ent_position == ENTREAD_USING_CHUNKED)\n\t\t\t*contentLength = UPNP_USING_CHUNKED;\n\t\telse if(handle->response.ent_position == ENTREAD_USING_CLEN)\n\t\t\t*contentLength = (int)handle->response.content_length;\n\t\telse if(handle->response.ent_position == ENTREAD_UNTIL_CLOSE)\n\t\t\t*contentLength = UPNP_UNTIL_CLOSE;\n\t\t*Handle = handle;\n\t} while (0);\n\n\tmembuffer_destroy(&request);\n\n\treturn errCode;\n}"
  },
  {
    "function_name": "MakeGetMessageEx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1752-1813",
    "snippet": "int MakeGetMessageEx( const char *url_str,\n                  membuffer * request,\n                  uri_type * url,\n                  struct SendInstruction *pRangeSpecifier)\n{\n\tint errCode = UPNP_E_SUCCESS;\n\tchar *urlPath = NULL;\n\tsize_t hostlen = (size_t)0;\n\tchar *hoststr, *temp;\n\n\tdo {\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"DOWNLOAD URL : %s\\n\", url_str);\n\t\tif ((errCode = http_FixStrUrl((char *)url_str,\n\t\t\t\t\t      strlen(url_str),\n\t\t\t\t\t      url)) != UPNP_E_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t\t/* make msg */\n\t\tmembuffer_init(request);\n\t\turlPath = alloca(strlen(url_str) + (size_t)1);\n\t\tif (!urlPath) {\n\t\t\terrCode = UPNP_E_OUTOF_MEMORY;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(urlPath, 0, strlen(url_str) + (size_t)1);\n\t\tstrncpy(urlPath, url_str, strlen(url_str));\n\t\thoststr = strstr(urlPath, \"//\");\n\t\tif (hoststr == NULL) {\n\t\t\terrCode = UPNP_E_INVALID_URL;\n\t\t\tbreak;\n\t\t}\n\t\thoststr += 2;\n\t\ttemp = strchr(hoststr, '/');\n\t\tif (temp == NULL) {\n\t\t\terrCode = UPNP_E_INVALID_URL;\n\t\t\tbreak;\n\t\t}\n\t\t*temp = '\\0';\n\t\thostlen = strlen(hoststr);\n\t\t*temp = '/';\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"HOSTNAME : %s Length : %\" PRIzu \"\\n\",\n\t\t\t   hoststr, hostlen);\n\t\terrCode = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t   \"Q\" \"s\" \"bc\" \"GDCUc\",\n\t\t\t\t\t   HTTPMETHOD_GET, url->pathquery.buff,\n\t\t\t\t\t   url->pathquery.size, \"HOST: \",\n\t\t\t\t\t   hoststr, hostlen, pRangeSpecifier);\n\t\tif (errCode != 0) {\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"HTTP Makemessage failed\\n\");\n\t\t\tmembuffer_destroy(request);\n\t\t\treturn errCode;\n\t\t}\n\t} while (0);\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\",\n\t\t   request->buf);\n\n\treturn errCode;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "HTTP",
            "__FILE__",
            "__LINE__",
            "\"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\"",
            "request->buf"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "request"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "request",
            "1",
            "1",
            "\"Q\" \"s\" \"bc\" \"GDCUc\"",
            "HTTPMETHOD_GET",
            "url->pathquery.buff",
            "url->pathquery.size",
            "\"HOST: \"",
            "hoststr",
            "hostlen",
            "pRangeSpecifier"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hoststr"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "hoststr",
            "'/'"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "urlPath",
            "\"//\""
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "urlPath",
            "url_str",
            "strlen(url_str)"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "urlPath",
            "0",
            "strlen(url_str) + (size_t)1"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(url_str) + (size_t)1"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "request"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_FixStrUrl",
          "args": [
            "(char *)url_str",
            "strlen(url_str)",
            "url"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "http_FixStrUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "259-271",
          "snippet": "int http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint MakeGetMessageEx( const char *url_str,\n                  membuffer * request,\n                  uri_type * url,\n                  struct SendInstruction *pRangeSpecifier)\n{\n\tint errCode = UPNP_E_SUCCESS;\n\tchar *urlPath = NULL;\n\tsize_t hostlen = (size_t)0;\n\tchar *hoststr, *temp;\n\n\tdo {\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"DOWNLOAD URL : %s\\n\", url_str);\n\t\tif ((errCode = http_FixStrUrl((char *)url_str,\n\t\t\t\t\t      strlen(url_str),\n\t\t\t\t\t      url)) != UPNP_E_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t\t/* make msg */\n\t\tmembuffer_init(request);\n\t\turlPath = alloca(strlen(url_str) + (size_t)1);\n\t\tif (!urlPath) {\n\t\t\terrCode = UPNP_E_OUTOF_MEMORY;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(urlPath, 0, strlen(url_str) + (size_t)1);\n\t\tstrncpy(urlPath, url_str, strlen(url_str));\n\t\thoststr = strstr(urlPath, \"//\");\n\t\tif (hoststr == NULL) {\n\t\t\terrCode = UPNP_E_INVALID_URL;\n\t\t\tbreak;\n\t\t}\n\t\thoststr += 2;\n\t\ttemp = strchr(hoststr, '/');\n\t\tif (temp == NULL) {\n\t\t\terrCode = UPNP_E_INVALID_URL;\n\t\t\tbreak;\n\t\t}\n\t\t*temp = '\\0';\n\t\thostlen = strlen(hoststr);\n\t\t*temp = '/';\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"HOSTNAME : %s Length : %\" PRIzu \"\\n\",\n\t\t\t   hoststr, hostlen);\n\t\terrCode = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t   \"Q\" \"s\" \"bc\" \"GDCUc\",\n\t\t\t\t\t   HTTPMETHOD_GET, url->pathquery.buff,\n\t\t\t\t\t   url->pathquery.size, \"HOST: \",\n\t\t\t\t\t   hoststr, hostlen, pRangeSpecifier);\n\t\tif (errCode != 0) {\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"HTTP Makemessage failed\\n\");\n\t\t\tmembuffer_destroy(request);\n\t\t\treturn errCode;\n\t\t}\n\t} while (0);\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\",\n\t\t   request->buf);\n\n\treturn errCode;\n}"
  },
  {
    "function_name": "http_CalcResponseVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1720-1733",
    "snippet": "void http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nvoid http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}"
  },
  {
    "function_name": "http_MakeMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1470-1703",
    "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "argp"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "buf"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "buf",
            "http_major_version",
            "http_minor_version",
            "\"ssc\"",
            "\"CONTENT-TYPE: \"",
            "temp_str"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "constchar *"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_FixUrl",
          "args": [
            "uri_ptr",
            "&url"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "http_FixUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "230-257",
          "snippet": "int http_FixUrl(IN uri_type *url, OUT uri_type *fixed_url)\n{\n\tconst char *temp_path = \"/\";\n\n\t*fixed_url = *url;\n#ifdef UPNP_ENABLE_OPEN_SSL\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0 &&\n\t    token_string_casecmp(&fixed_url->scheme, \"https\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#else\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#endif\n\tif( fixed_url->hostport.text.size == ( size_t ) 0 ) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\t/* set pathquery to \"/\" if it is empty */\n\tif (fixed_url->pathquery.size == (size_t)0) {\n\t\tfixed_url->pathquery.buff = temp_path;\n\t\tfixed_url->pathquery.size = (size_t)1;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixUrl(IN uri_type *url, OUT uri_type *fixed_url)\n{\n\tconst char *temp_path = \"/\";\n\n\t*fixed_url = *url;\n#ifdef UPNP_ENABLE_OPEN_SSL\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0 &&\n\t    token_string_casecmp(&fixed_url->scheme, \"https\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#else\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#endif\n\tif( fixed_url->hostport.text.size == ( size_t ) 0 ) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\t/* set pathquery to \"/\" if it is empty */\n\tif (fixed_url->pathquery.size == (size_t)0) {\n\t\tfixed_url->pathquery.buff = temp_path;\n\t\tfixed_url->pathquery.size = (size_t)1;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "uri_ptr"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "uri_type*"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "http_method_t"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "size_t"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "constchar *"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method_to_str",
          "args": [
            "method"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "method_to_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "2184-2193",
          "snippet": "const char *method_to_str(IN http_method_t method)\n{\n    int index;\n\n    index = map_int_to_str( method, Http_Method_Table, NUM_HTTP_METHODS );\n\n    assert( index != -1 );\n\n    return index == -1 ? NULL : Http_Method_Table[index].name;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HTTP_METHODS 11"
          ],
          "globals_used": [
            "static str_int_entry Http_Method_Table[NUM_HTTP_METHODS] = {\n\t{\"DELETE\", HTTPMETHOD_DELETE},\n\t{\"GET\", HTTPMETHOD_GET},\n\t{\"HEAD\", HTTPMETHOD_HEAD},\n\t{\"M-POST\", HTTPMETHOD_MPOST},\n\t{\"M-SEARCH\", HTTPMETHOD_MSEARCH},\n\t{\"NOTIFY\", HTTPMETHOD_NOTIFY},\n\t{\"POST\", HTTPMETHOD_POST},\n\t{\"SUBSCRIBE\", HTTPMETHOD_SUBSCRIBE},\n\t{\"UNSUBSCRIBE\", HTTPMETHOD_UNSUBSCRIBE},\n\t{\"POST\", SOAPMETHOD_POST},\n\t{\"PUT\", HTTPMETHOD_PUT}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define NUM_HTTP_METHODS 11\n\nstatic str_int_entry Http_Method_Table[NUM_HTTP_METHODS] = {\n\t{\"DELETE\", HTTPMETHOD_DELETE},\n\t{\"GET\", HTTPMETHOD_GET},\n\t{\"HEAD\", HTTPMETHOD_HEAD},\n\t{\"M-POST\", HTTPMETHOD_MPOST},\n\t{\"M-SEARCH\", HTTPMETHOD_MSEARCH},\n\t{\"NOTIFY\", HTTPMETHOD_NOTIFY},\n\t{\"POST\", HTTPMETHOD_POST},\n\t{\"SUBSCRIBE\", HTTPMETHOD_SUBSCRIBE},\n\t{\"UNSUBSCRIBE\", HTTPMETHOD_UNSUBSCRIBE},\n\t{\"POST\", SOAPMETHOD_POST},\n\t{\"PUT\", HTTPMETHOD_PUT}\n};\n\nconst char *method_to_str(IN http_method_t method)\n{\n    int index;\n\n    index = map_int_to_str( method, Http_Method_Table, NUM_HTTP_METHODS );\n\n    assert( index != -1 );\n\n    return index == -1 ? NULL : Http_Method_Table[index].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "http_method_t"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tempbuf"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tempbuf",
            "sizeof(tempbuf)",
            "\"%s%d %s%s\"",
            "\"<html><body><h1>\"",
            "status_code",
            "http_get_code_text(status_code)",
            "\"</h1></body></html>\""
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_get_code_text",
          "args": [
            "status_code"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "http_get_code_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/statcodes.c",
          "lines": "178-216",
          "snippet": "const char *\nhttp_get_code_text( int statusCode )\n{\n    int index;\n    int table_num;\n\n    if( !gInitialized ) {\n        init_tables();\n    }\n\n    if( statusCode < 100 || statusCode >= 600 ) {\n        return NULL;\n    }\n\n    index = statusCode % 100;\n    table_num = statusCode / 100;\n\n    if( table_num == 1 && index < NUM_1XX_CODES ) {\n        return Http1xxCodes[index];\n    }\n\n    if( table_num == 2 && index < NUM_2XX_CODES ) {\n        return Http2xxCodes[index];\n    }\n\n    if( table_num == 3 && index < NUM_3XX_CODES ) {\n        return Http3xxCodes[index];\n    }\n\n    if( table_num == 4 && index < NUM_4XX_CODES ) {\n        return Http4xxCodes[index];\n    }\n\n    if( table_num == 5 && index < NUM_5XX_CODES ) {\n        return Http5xxCodes[index];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"upnputil.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_5XX_CODES   11",
            "#define NUM_4XX_CODES   18",
            "#define NUM_3XX_CODES   8",
            "#define NUM_2XX_CODES   7",
            "#define NUM_1XX_CODES   2"
          ],
          "globals_used": [
            "static const char *Http1xxCodes[NUM_1XX_CODES];",
            "static const char *Http2xxCodes[NUM_2XX_CODES];",
            "static const char *Http3xxCodes[NUM_3XX_CODES];",
            "static const char *Http4xxCodes[NUM_4XX_CODES];",
            "static const char *Http5xxCodes[NUM_5XX_CODES];",
            "static int gInitialized = FALSE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"upnputil.h\"\n#include <string.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NUM_5XX_CODES   11\n#define NUM_4XX_CODES   18\n#define NUM_3XX_CODES   8\n#define NUM_2XX_CODES   7\n#define NUM_1XX_CODES   2\n\nstatic const char *Http1xxCodes[NUM_1XX_CODES];\nstatic const char *Http2xxCodes[NUM_2XX_CODES];\nstatic const char *Http3xxCodes[NUM_3XX_CODES];\nstatic const char *Http4xxCodes[NUM_4XX_CODES];\nstatic const char *Http5xxCodes[NUM_5XX_CODES];\nstatic int gInitialized = FALSE;\n\nconst char *\nhttp_get_code_text( int statusCode )\n{\n    int index;\n    int table_num;\n\n    if( !gInitialized ) {\n        init_tables();\n    }\n\n    if( statusCode < 100 || statusCode >= 600 ) {\n        return NULL;\n    }\n\n    index = statusCode % 100;\n    table_num = statusCode / 100;\n\n    if( table_num == 1 && index < NUM_1XX_CODES ) {\n        return Http1xxCodes[index];\n    }\n\n    if( table_num == 2 && index < NUM_2XX_CODES ) {\n        return Http2xxCodes[index];\n    }\n\n    if( table_num == 3 && index < NUM_3XX_CODES ) {\n        return Http3xxCodes[index];\n    }\n\n    if( table_num == 4 && index < NUM_4XX_CODES ) {\n        return Http4xxCodes[index];\n    }\n\n    if( table_num == 5 && index < NUM_5XX_CODES ) {\n        return Http5xxCodes[index];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "int"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tempbuf",
            "sizeof(tempbuf)",
            "\"HTTP/%d.%d %d \"",
            "http_major_version",
            "http_minor_version",
            "status_code"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "status_code > 0"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "int"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_append",
          "args": [
            "buf",
            "s",
            "strlen(s)"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "200-205",
          "snippet": "int membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_append_str",
          "args": [
            "buf",
            "\"X-User-Agent: \""
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "207-210",
          "snippet": "int membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "s"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "char*"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sdk_info",
          "args": [
            "tempbuf",
            "sizeof(tempbuf)"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "get_sdk_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1982-2011",
          "snippet": "void get_sdk_info(OUT char *info, IN size_t infoSize)\n{\n#ifdef UPNP_ENABLE_UNSPECIFIED_SERVER\n\tsnprintf(info, infoSize, \"Unspecified, UPnP/1.0, Unspecified\\r\\n\");\n#else /* UPNP_ENABLE_UNSPECIFIED_SERVER */\n#ifdef WIN32\n\tOSVERSIONINFO versioninfo;\n\tversioninfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n\n\tif (GetVersionEx(&versioninfo) != 0)\n\t\tsnprintf(info, infoSize,\n\t\t\t\"%d.%d.%d %d/%s, UPnP/1.0, Portable SDK for UPnP devices/\"\n\t\t\tPACKAGE_VERSION \"\\r\\n\", versioninfo.dwMajorVersion,\n\t\t\tversioninfo.dwMinorVersion, versioninfo.dwBuildNumber,\n\t\t\tversioninfo.dwPlatformId, versioninfo.szCSDVersion);\n\telse\n\t\t*info = '\\0';\n#else\n\tint ret_code;\n\tstruct utsname sys_info;\n\n\tret_code = uname(&sys_info);\n\tif (ret_code == -1)\n\t\t*info = '\\0';\n\tsnprintf(info, infoSize,\n\t\t\"%s/%s, UPnP/1.0, Portable SDK for UPnP devices/\"\n\t\tPACKAGE_VERSION \"\\r\\n\", sys_info.sysname, sys_info.release);\n#endif\n#endif /* UPNP_ENABLE_UNSPECIFIED_SERVER */\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nvoid get_sdk_info(OUT char *info, IN size_t infoSize)\n{\n#ifdef UPNP_ENABLE_UNSPECIFIED_SERVER\n\tsnprintf(info, infoSize, \"Unspecified, UPnP/1.0, Unspecified\\r\\n\");\n#else /* UPNP_ENABLE_UNSPECIFIED_SERVER */\n#ifdef WIN32\n\tOSVERSIONINFO versioninfo;\n\tversioninfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n\n\tif (GetVersionEx(&versioninfo) != 0)\n\t\tsnprintf(info, infoSize,\n\t\t\t\"%d.%d.%d %d/%s, UPnP/1.0, Portable SDK for UPnP devices/\"\n\t\t\tPACKAGE_VERSION \"\\r\\n\", versioninfo.dwMajorVersion,\n\t\t\tversioninfo.dwMinorVersion, versioninfo.dwBuildNumber,\n\t\t\tversioninfo.dwPlatformId, versioninfo.szCSDVersion);\n\telse\n\t\t*info = '\\0';\n#else\n\tint ret_code;\n\tstruct utsname sys_info;\n\n\tret_code = uname(&sys_info);\n\tif (ret_code == -1)\n\t\t*info = '\\0';\n\tsnprintf(info, infoSize,\n\t\t\"%s/%s, UPnP/1.0, Portable SDK for UPnP devices/\"\n\t\tPACKAGE_VERSION \"\\r\\n\", sys_info.sysname, sys_info.release);\n#endif\n#endif /* UPNP_ENABLE_UNSPECIFIED_SERVER */\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "bignum >= 0"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "off_t"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "WEB_SERVER_CONTENT_LANGUAGE",
            "\"\""
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "RespInstr->AcceptLanguageHeader",
            "\"\""
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "RespInstr"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "structSendInstruction*"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tempbuf"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tempbuf",
            "sizeof(tempbuf)",
            "\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\"",
            "start_str",
            "&weekday_str[date->tm_wday * 4]",
            "date->tm_mday",
            "&month_str[date->tm_mon * 4]",
            "date->tm_year + 1900",
            "date->tm_hour",
            "date->tm_min",
            "date->tm_sec",
            "end_str"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_gmtime_r",
          "args": [
            "loc_time",
            "&date_storage"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "http_gmtime_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "168-176",
          "snippet": "struct tm *http_gmtime_r(const time_t *clock, struct tm *result)\n{\n\tif (clock == NULL || *clock < 0 || result == NULL)\n\t\treturn NULL;\n\n\t/* gmtime in VC runtime is thread safe. */\n\t*result = *gmtime(clock);\n\treturn result;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstruct tm *http_gmtime_r(const time_t *clock, struct tm *result)\n{\n\tif (clock == NULL || *clock < 0 || result == NULL)\n\t\treturn NULL;\n\n\t/* gmtime in VC runtime is thread safe. */\n\t*result = *gmtime(clock);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "loc_time"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "time_t*"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "get_system_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/sysdep.c",
          "lines": "115-127",
          "snippet": "void get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpInet.h\"",
            "#include \"sysdep.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <string.h>\n#include \"UpnpInet.h\"\n#include \"sysdep.h\"\n#include \"config.h\"\n\nvoid get_system_time(uuid_time_t *uuid_time)\n{\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, (struct timezone *)0);\n\t/* Offset between UUID formatted times and Unix formatted times.\n\t * UUID UTC base time is October 15, 1582.\n\t * Unix base time is January 1, 1970. */\n\t*uuid_time =\n\t\t(uuid_time_t)tp.tv_sec * 10000000 +\n\t\t(uuid_time_t)tp.tv_usec * 10 +\n\t\t0x01B21DD213814000LL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tempbuf"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tempbuf",
            "sizeof(tempbuf)",
            "\"%\" PRId64",
            "(int64_t) bignum"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "off_t"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tempbuf"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tempbuf",
            "sizeof(tempbuf)",
            "\"%\" PRIzu",
            "num"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "int"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "size_t"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "s"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "HTTP",
            "__FILE__",
            "__LINE__",
            "\"Adding a char Buffer starting with: %c\\n\"",
            "(int)s[0]"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "char*"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "RespInstr->RangeHeader"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "RespInstr"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "structSendInstruction*"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"Transfer-Encoding: chunked\\r\\n\""
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "s"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "char*"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "argp",
            "fmt"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tempbuf",
            "0",
            "sizeof(tempbuf)"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
  },
  {
    "function_name": "http_SendStatusResponse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1445-1468",
    "snippet": "int http_SendStatusResponse(IN SOCKINFO *info, IN int http_status_code,\n\tIN int request_major_version, IN int request_minor_version)\n{\n\tint response_major, response_minor;\n\tmembuffer membuf;\n\tint ret;\n\tint timeout;\n\n\thttp_CalcResponseVersion(request_major_version, request_minor_version,\n\t\t\t\t &response_major, &response_minor);\n\tmembuffer_init(&membuf);\n\tmembuf.size_inc = (size_t)70;\n\t/* response start line */\n\tret = http_MakeMessage(&membuf, response_major, response_minor, \"RSCB\",\n\t\t\t       http_status_code, http_status_code);\n\tif (ret == 0) {\n\t\ttimeout = HTTP_DEFAULT_TIMEOUT;\n\t\tret = http_SendMessage(info, &timeout, \"b\",\n\t\t       membuf.buf, membuf.length);\n\t}\n\tmembuffer_destroy(&membuf);\n\n\treturn ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&membuf"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_SendMessage",
          "args": [
            "info",
            "&timeout",
            "\"b\"",
            "membuf.buf",
            "membuf.length"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "437-613",
          "snippet": "int http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CHUNK_TAIL_SIZE (size_t)10",
            "#define CHUNK_HEADER_SIZE (size_t)10",
            "#define snprintf _snprintf",
            "#define fseeko fseek"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n#define snprintf _snprintf\n#define fseeko fseek\n\nint http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&membuf",
            "response_major",
            "response_minor",
            "\"RSCB\"",
            "http_status_code",
            "http_status_code"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&membuf"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_CalcResponseVersion",
          "args": [
            "request_major_version",
            "request_minor_version",
            "&response_major",
            "&response_minor"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "http_CalcResponseVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1720-1733",
          "snippet": "void http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nvoid http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_SendStatusResponse(IN SOCKINFO *info, IN int http_status_code,\n\tIN int request_major_version, IN int request_minor_version)\n{\n\tint response_major, response_minor;\n\tmembuffer membuf;\n\tint ret;\n\tint timeout;\n\n\thttp_CalcResponseVersion(request_major_version, request_minor_version,\n\t\t\t\t &response_major, &response_minor);\n\tmembuffer_init(&membuf);\n\tmembuf.size_inc = (size_t)70;\n\t/* response start line */\n\tret = http_MakeMessage(&membuf, response_major, response_minor, \"RSCB\",\n\t\t\t       http_status_code, http_status_code);\n\tif (ret == 0) {\n\t\ttimeout = HTTP_DEFAULT_TIMEOUT;\n\t\tret = http_SendMessage(info, &timeout, \"b\",\n\t\t       membuf.buf, membuf.length);\n\t}\n\tmembuffer_destroy(&membuf);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "http_CloseHttpConnection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1413-1423",
    "snippet": "int http_CloseHttpConnection(void *Handle)\n{\n\thttp_connection_handle_t *handle = Handle;\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t/*should shutdown completely */\n\tsock_destroy(&handle->sock_info, SD_BOTH);\n\thttpmsg_destroy(&handle->response.msg);\n\tfree(handle);\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "handle"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&handle->response.msg"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_destroy",
          "args": [
            "&handle->sock_info",
            "SD_BOTH"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "sock_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "118-143",
          "snippet": "int sock_destroy(SOCKINFO *info, int ShutdownMethod)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (info->socket != INVALID_SOCKET) {\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t\tif (info->ssl) {\n\t\t\tSSL_shutdown(info->ssl);\n\t\t\tSSL_free(info->ssl);\n\t\t\tinfo->ssl = NULL;\n\t\t}\n#endif\n\t\tif (shutdown(info->socket, ShutdownMethod) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tif (sock_close(info->socket) == -1) {\n\t\t\tret = UPNP_E_SOCKET_ERROR;\n\t\t}\n\t\tinfo->socket = INVALID_SOCKET;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_destroy(SOCKINFO *info, int ShutdownMethod)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (info->socket != INVALID_SOCKET) {\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t\tif (info->ssl) {\n\t\t\tSSL_shutdown(info->ssl);\n\t\t\tSSL_free(info->ssl);\n\t\t\tinfo->ssl = NULL;\n\t\t}\n#endif\n\t\tif (shutdown(info->socket, ShutdownMethod) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tif (sock_close(info->socket) == -1) {\n\t\t\tret = UPNP_E_SOCKET_ERROR;\n\t\t}\n\t\tinfo->socket = INVALID_SOCKET;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_CloseHttpConnection(void *Handle)\n{\n\thttp_connection_handle_t *handle = Handle;\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t/*should shutdown completely */\n\tsock_destroy(&handle->sock_info, SD_BOTH);\n\thttpmsg_destroy(&handle->response.msg);\n\tfree(handle);\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "http_ReadHttpResponse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1315-1411",
    "snippet": "int http_ReadHttpResponse(void *Handle, char *buf, size_t *size, int timeout)\n{\n\thttp_connection_handle_t *handle = Handle;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar tempbuf[2 * 1024];\n\tint ret_code = 0;\n\n\tif (!handle || !size || (*size > 0 && !buf)) {\n\t\tif (size)\n\t\t\t*size = 0;\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\t/* first parse what has already been gotten */\n\tif (handle->response.position != POS_COMPLETE)\n\t\tstatus = parser_parse_entity(&handle->response);\n\telse\n\t\tstatus = PARSE_SUCCESS;\n\tif (status == PARSE_INCOMPLETE_ENTITY)\n\t\t/* read until close */\n\t\tok_on_close = TRUE;\n\telse if ((status != PARSE_SUCCESS)\n\t\t && (status != PARSE_CONTINUE_1)\n\t\t && (status != PARSE_INCOMPLETE)) {\n\t\t/*error */\n\t\t*size = 0;\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\t/* read more if necessary entity */\n\twhile (handle->response.msg.amount_discarded + *size >\n\t       handle->response.msg.entity.length &&\n\t       !handle->cancel &&\n\t       handle->response.position != POS_COMPLETE) {\n\t\tnum_read = sock_read(&handle->sock_info, tempbuf,\n\t\t\t\t     sizeof(tempbuf), &timeout);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code = membuffer_append(&handle->response.msg.msg,\n\t\t\t\t\t\t    tempbuf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\thandle->response.http_error_code =\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t*size = 0;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_entity(&handle->response);\n\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t/*error */\n\t\t\t\t*size = 0;\n\t\t\t\treturn UPNP_E_BAD_RESPONSE;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t   handle->response.msg.msg.buf);\n\t\t\t\thandle->response.position = POS_COMPLETE;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*size = 0;\n\t\t\t\thandle->response.http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t\t}\n\t\t} else {\n\t\t\t*size = 0;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\tif (handle->cancel) {\n\t\treturn UPNP_E_CANCELED;\n\t}\n\t/* truncate size to fall within available data */\n\tif (handle->response.msg.amount_discarded + *size >\n\t    handle->response.msg.entity.length)\n\t\t*size = handle->response.msg.entity.length -\n\t\t\thandle->response.msg.amount_discarded;\n\t/* copy data to user buffer. delete copied data */\n\tif (*size > 0) {\n\t\tmemcpy(buf, &handle->response.msg.msg.buf[handle->response.entity_start_position],\n\t\t       *size);\n\t\tmembuffer_delete(&handle->response.msg.msg,\n\t\t\t\t handle->response.entity_start_position, *size);\n\t\t/* update scanner position. needed for chunked transfers */\n\t\thandle->response.scanner.cursor -= *size;\n\t\t/* update amount discarded */\n\t\thandle->response.msg.amount_discarded += *size;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_delete",
          "args": [
            "&handle->response.msg.msg",
            "handle->response.entity_start_position",
            "*size"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "240-271",
          "snippet": "void membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_delete(membuffer * m, size_t index, size_t num_bytes)\n{\n\tint return_value;\n\tsize_t new_length;\n\tsize_t copy_len;\n\n\tassert(m != NULL);\n\n\tif (!m || !m->length)\n\t\treturn;\n\t/* shrink count if it goes beyond buffer */\n\tif (index + num_bytes > m->length) {\n\t\tnum_bytes = m->length - index;\n\t\t/* every thing at and after index purged */\n\t\tcopy_len = (size_t)0;\n\t} else {\n\t\t/* calc num bytes after deleted string */\n\t\tcopy_len = m->length - (index + num_bytes);\n\t}\n\tmemmove(m->buf + index, m->buf + index + num_bytes, copy_len);\n\tnew_length = m->length - num_bytes;\n\t/* trim buffer */\n\treturn_value = membuffer_set_size(m, new_length);\n\t/* shrinking should always work */\n\tassert(return_value == 0);\n\tif (return_value != 0)\n\t\treturn;\n\n\t/* don't modify until buffer is set */\n\tm->length = new_length;\n\tm->buf[new_length] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&handle->response.msg.msg.buf[handle->response.entity_start_position]",
            "*size"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "HTTP",
            "__FILE__",
            "__LINE__",
            "\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\"",
            "handle->response.msg.msg.buf"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse_entity",
          "args": [
            "&handle->response"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1911-1952",
          "snippet": "UPNP_INLINE parse_status_t\nparser_parse_entity( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    assert( parser->position == POS_ENTITY );\n\n    do {\n        switch ( parser->ent_position ) {\n            case ENTREAD_USING_CLEN:\n                status = parser_parse_entity_using_clen( parser );\n                break;\n\n            case ENTREAD_USING_CHUNKED:\n                status = parser_parse_chunky_entity( parser );\n                break;\n\n            case ENTREAD_CHUNKY_BODY:\n                status = parser_parse_chunky_body( parser );\n                break;\n\n            case ENTREAD_CHUNKY_HEADERS:\n                status = parser_parse_chunky_headers( parser );\n                break;\n\n            case ENTREAD_UNTIL_CLOSE:\n                status = parser_parse_entity_until_close( parser );\n                break;\n\n            case ENTREAD_DETERMINE_READ_METHOD:\n                status = parser_get_entity_read_method( parser );\n                break;\n\n            default:\n\t\tstatus = PARSE_FAILURE;\n                assert( 0 );\n        }\n\n    } while( status == ( parse_status_t ) PARSE_CONTINUE_1 );\n\n    return status;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nUPNP_INLINE parse_status_t\nparser_parse_entity( INOUT http_parser_t * parser )\n{\n    parse_status_t status;\n\n    assert( parser->position == POS_ENTITY );\n\n    do {\n        switch ( parser->ent_position ) {\n            case ENTREAD_USING_CLEN:\n                status = parser_parse_entity_using_clen( parser );\n                break;\n\n            case ENTREAD_USING_CHUNKED:\n                status = parser_parse_chunky_entity( parser );\n                break;\n\n            case ENTREAD_CHUNKY_BODY:\n                status = parser_parse_chunky_body( parser );\n                break;\n\n            case ENTREAD_CHUNKY_HEADERS:\n                status = parser_parse_chunky_headers( parser );\n                break;\n\n            case ENTREAD_UNTIL_CLOSE:\n                status = parser_parse_entity_until_close( parser );\n                break;\n\n            case ENTREAD_DETERMINE_READ_METHOD:\n                status = parser_get_entity_read_method( parser );\n                break;\n\n            default:\n\t\tstatus = PARSE_FAILURE;\n                assert( 0 );\n        }\n\n    } while( status == ( parse_status_t ) PARSE_CONTINUE_1 );\n\n    return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_append",
          "args": [
            "&handle->response.msg.msg",
            "tempbuf",
            "(size_t)num_read"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "200-205",
          "snippet": "int membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_read",
          "args": [
            "&handle->sock_info",
            "tempbuf",
            "sizeof(tempbuf)",
            "&timeout"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "sock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "266-269",
          "snippet": "int sock_read(SOCKINFO *info, char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\treturn sock_read_write(info, buffer, bufsize, timeoutSecs, TRUE);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_read(SOCKINFO *info, char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\treturn sock_read_write(info, buffer, bufsize, timeoutSecs, TRUE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_ReadHttpResponse(void *Handle, char *buf, size_t *size, int timeout)\n{\n\thttp_connection_handle_t *handle = Handle;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar tempbuf[2 * 1024];\n\tint ret_code = 0;\n\n\tif (!handle || !size || (*size > 0 && !buf)) {\n\t\tif (size)\n\t\t\t*size = 0;\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\t/* first parse what has already been gotten */\n\tif (handle->response.position != POS_COMPLETE)\n\t\tstatus = parser_parse_entity(&handle->response);\n\telse\n\t\tstatus = PARSE_SUCCESS;\n\tif (status == PARSE_INCOMPLETE_ENTITY)\n\t\t/* read until close */\n\t\tok_on_close = TRUE;\n\telse if ((status != PARSE_SUCCESS)\n\t\t && (status != PARSE_CONTINUE_1)\n\t\t && (status != PARSE_INCOMPLETE)) {\n\t\t/*error */\n\t\t*size = 0;\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\t/* read more if necessary entity */\n\twhile (handle->response.msg.amount_discarded + *size >\n\t       handle->response.msg.entity.length &&\n\t       !handle->cancel &&\n\t       handle->response.position != POS_COMPLETE) {\n\t\tnum_read = sock_read(&handle->sock_info, tempbuf,\n\t\t\t\t     sizeof(tempbuf), &timeout);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code = membuffer_append(&handle->response.msg.msg,\n\t\t\t\t\t\t    tempbuf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\thandle->response.http_error_code =\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t*size = 0;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_entity(&handle->response);\n\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t/*error */\n\t\t\t\t*size = 0;\n\t\t\t\treturn UPNP_E_BAD_RESPONSE;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t   handle->response.msg.msg.buf);\n\t\t\t\thandle->response.position = POS_COMPLETE;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*size = 0;\n\t\t\t\thandle->response.http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t\t}\n\t\t} else {\n\t\t\t*size = 0;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\tif (handle->cancel) {\n\t\treturn UPNP_E_CANCELED;\n\t}\n\t/* truncate size to fall within available data */\n\tif (handle->response.msg.amount_discarded + *size >\n\t    handle->response.msg.entity.length)\n\t\t*size = handle->response.msg.entity.length -\n\t\t\thandle->response.msg.amount_discarded;\n\t/* copy data to user buffer. delete copied data */\n\tif (*size > 0) {\n\t\tmemcpy(buf, &handle->response.msg.msg.buf[handle->response.entity_start_position],\n\t\t       *size);\n\t\tmembuffer_delete(&handle->response.msg.msg,\n\t\t\t\t handle->response.entity_start_position, *size);\n\t\t/* update scanner position. needed for chunked transfers */\n\t\thandle->response.scanner.cursor -= *size;\n\t\t/* update amount discarded */\n\t\thandle->response.msg.amount_discarded += *size;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "http_GetHttpResponse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1256-1313",
    "snippet": "int http_GetHttpResponse(void *Handle, UpnpString *headers,\n\t\t\t char **contentType, int *contentLength,\n\t\t\t int *httpStatus, int timeout)\n{\n\tint ret_code;\n\tint http_error_code;\n\tmemptr ctype;\n\thttp_connection_handle_t *handle = Handle;\n\tparse_status_t status;\n\n\tstatus = ReadResponseLineAndHeaders(&handle->sock_info,\n\t\t\t\t\t    &handle->response, &timeout,\n\t\t\t\t\t    &http_error_code);\n\tif (status != (parse_status_t)PARSE_OK) {\n\t\tret_code = UPNP_E_BAD_RESPONSE;\n\t\tgoto errorHandler;\n\t}\n\tstatus = parser_get_entity_read_method(&handle->response);\n\tswitch (status) {\n\tcase PARSE_CONTINUE_1:\n\tcase PARSE_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tret_code = UPNP_E_BAD_RESPONSE;\n\t\tgoto errorHandler;\n\t}\n\tret_code = UPNP_E_SUCCESS;\n\tif (httpStatus) {\n\t\t*httpStatus = handle->response.msg.status_code;\n\t}\n\tif (contentType) {\n\t\tif (!httpmsg_find_hdr(&handle->response.msg, HDR_CONTENT_TYPE, &ctype))\n\t\t\t/* no content-type */\n\t\t\t*contentType = NULL;\n\t\telse\n\t\t\t*contentType = ctype.buf;\n\t}\n\tif (contentLength) {\n\t\tif (handle->response.position == (parser_pos_t)POS_COMPLETE)\n\t\t\t*contentLength = 0;\n\t\telse if (handle->response.ent_position == ENTREAD_USING_CHUNKED)\n\t\t\t*contentLength = UPNP_USING_CHUNKED;\n\t\telse if (handle->response.ent_position == ENTREAD_USING_CLEN)\n\t\t\t*contentLength = (int)handle->response.content_length;\n\t\telse if (handle->response.ent_position == ENTREAD_UNTIL_CLOSE)\n\t\t\t*contentLength = UPNP_UNTIL_CLOSE;\n\t}\n\n\tif (headers) {\n\t\tcopy_msg_headers(&handle->response.msg.headers, headers);\n\n\t}\n\nerrorHandler:\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\thttpmsg_destroy(&handle->response.msg);\n\treturn ret_code;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&handle->response.msg"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_msg_headers",
          "args": [
            "&handle->response.msg.headers",
            "headers"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "copy_msg_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "200-227",
          "snippet": "static void copy_msg_headers(IN LinkedList *msgHeaders,\n                             OUT UpnpString *headers)\n{\n\treturn;\n/* TODO: */\n#if 0\n\tListNode *node;\n\tUpnpHttpHeader *header;\n\thttp_header_t *msgHeader;\n\tif (headers) {\n\t\tListInit(headers, NULL, (free_function) UpnpHttpHeader_delete);\n\t\tnode = ListHead(msgHeaders);\n\t\twhile(node) {\n\t\t\tmsgHeader = (http_header_t*) node->item;\n\t\t\theader = UpnpHttpHeader_new();\n\t\t\tUpnpHttpHeader_strncpy_Name(\n\t\t\t\theader,\n\t\t\t\tmsgHeader->name.buf,\n\t\t\t\tmsgHeader->name.length);\n\t\t\tUpnpHttpHeader_strncpy_Value(\n\t\t\t\theader,\n\t\t\t\tmsgHeader->value.buf,\n\t\t\t\tmsgHeader->value.length);\n\t\t\tnode = ListNext(msgHeaders, node);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstatic void copy_msg_headers(IN LinkedList *msgHeaders,\n                             OUT UpnpString *headers)\n{\n\treturn;\n/* TODO: */\n#if 0\n\tListNode *node;\n\tUpnpHttpHeader *header;\n\thttp_header_t *msgHeader;\n\tif (headers) {\n\t\tListInit(headers, NULL, (free_function) UpnpHttpHeader_delete);\n\t\tnode = ListHead(msgHeaders);\n\t\twhile(node) {\n\t\t\tmsgHeader = (http_header_t*) node->item;\n\t\t\theader = UpnpHttpHeader_new();\n\t\t\tUpnpHttpHeader_strncpy_Name(\n\t\t\t\theader,\n\t\t\t\tmsgHeader->name.buf,\n\t\t\t\tmsgHeader->name.length);\n\t\t\tUpnpHttpHeader_strncpy_Value(\n\t\t\t\theader,\n\t\t\t\tmsgHeader->value.buf,\n\t\t\t\tmsgHeader->value.length);\n\t\t\tnode = ListNext(msgHeaders, node);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "&handle->response.msg",
            "HDR_CONTENT_TYPE",
            "&ctype"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_get_entity_read_method",
          "args": [
            "&handle->response"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "parser_get_entity_read_method",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1808-1894",
          "snippet": "UPNP_INLINE parse_status_t\nparser_get_entity_read_method( INOUT http_parser_t * parser )\n{\n    http_message_t *hmsg = &parser->msg;\n    int response_code;\n    memptr hdr_value;\n\n    assert( parser->ent_position == ENTREAD_DETERMINE_READ_METHOD );\n\n    /* entity points to start of msg body */\n    parser->msg.entity.buf = scanner_get_str( &parser->scanner );\n    parser->msg.entity.length = ( size_t ) 0;\n\n    /* remember start of body */\n    parser->entity_start_position = parser->scanner.cursor;\n\n    /* std http rules for determining content length */\n\n    /* * no body for 1xx, 204, 304 and HEAD, GET, */\n    /*      SUBSCRIBE, UNSUBSCRIBE */\n    if( hmsg->is_request ) {\n        switch ( hmsg->method ) {\n            case HTTPMETHOD_HEAD:\n            case HTTPMETHOD_GET:\n                /*case HTTPMETHOD_POST: */\n            case HTTPMETHOD_SUBSCRIBE:\n            case HTTPMETHOD_UNSUBSCRIBE:\n            case HTTPMETHOD_MSEARCH:\n                /* no body; mark as done */\n                parser->position = POS_COMPLETE;\n                return PARSE_SUCCESS;\n                break;\n\n            default:\n                ;               /* do nothing */\n        }\n    } else                      /* response */\n    {\n        response_code = hmsg->status_code;\n\n        if( response_code == 204 ||\n            response_code == 304 ||\n            ( response_code >= 100 && response_code <= 199 ) ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_HEAD ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_MSEARCH ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_SUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_UNSUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->position = POS_COMPLETE;\n            return PARSE_SUCCESS;\n        }\n    }\n\n    /* * transfer-encoding -- used to indicate chunked data */\n    if( httpmsg_find_hdr( hmsg, HDR_TRANSFER_ENCODING, &hdr_value ) ) {\n        if( raw_find_str( &hdr_value, \"chunked\" ) >= 0 ) {\n            /* read method to use chunked transfer encoding */\n            parser->ent_position = ENTREAD_USING_CHUNKED;\n            UpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n                \"Found Chunked Encoding ....\\n\" );\n\n            return PARSE_CONTINUE_1;\n        }\n    }\n    /* * use content length */\n    if( httpmsg_find_hdr( hmsg, HDR_CONTENT_LENGTH, &hdr_value ) ) {\n        parser->content_length = (unsigned int)raw_to_int(&hdr_value, 10);\n        parser->ent_position = ENTREAD_USING_CLEN;\n        return PARSE_CONTINUE_1;\n    }\n    /* * multi-part/byteranges not supported (yet) */\n\n    /* * read until connection is closed */\n    if( hmsg->is_request ) {\n        /* set hack flag for NOTIFY methods; if set to true this is */\n        /*  a valid SSDP notify msg */\n        if( hmsg->method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->valid_ssdp_notify_hack = TRUE;\n        }\n\n        parser->http_error_code = HTTP_LENGTH_REQUIRED;\n        return PARSE_FAILURE;\n    }\n\n    parser->ent_position = ENTREAD_UNTIL_CLOSE;\n    return PARSE_CONTINUE_1;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nUPNP_INLINE parse_status_t\nparser_get_entity_read_method( INOUT http_parser_t * parser )\n{\n    http_message_t *hmsg = &parser->msg;\n    int response_code;\n    memptr hdr_value;\n\n    assert( parser->ent_position == ENTREAD_DETERMINE_READ_METHOD );\n\n    /* entity points to start of msg body */\n    parser->msg.entity.buf = scanner_get_str( &parser->scanner );\n    parser->msg.entity.length = ( size_t ) 0;\n\n    /* remember start of body */\n    parser->entity_start_position = parser->scanner.cursor;\n\n    /* std http rules for determining content length */\n\n    /* * no body for 1xx, 204, 304 and HEAD, GET, */\n    /*      SUBSCRIBE, UNSUBSCRIBE */\n    if( hmsg->is_request ) {\n        switch ( hmsg->method ) {\n            case HTTPMETHOD_HEAD:\n            case HTTPMETHOD_GET:\n                /*case HTTPMETHOD_POST: */\n            case HTTPMETHOD_SUBSCRIBE:\n            case HTTPMETHOD_UNSUBSCRIBE:\n            case HTTPMETHOD_MSEARCH:\n                /* no body; mark as done */\n                parser->position = POS_COMPLETE;\n                return PARSE_SUCCESS;\n                break;\n\n            default:\n                ;               /* do nothing */\n        }\n    } else                      /* response */\n    {\n        response_code = hmsg->status_code;\n\n        if( response_code == 204 ||\n            response_code == 304 ||\n            ( response_code >= 100 && response_code <= 199 ) ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_HEAD ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_MSEARCH ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_SUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_UNSUBSCRIBE ||\n            hmsg->request_method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->position = POS_COMPLETE;\n            return PARSE_SUCCESS;\n        }\n    }\n\n    /* * transfer-encoding -- used to indicate chunked data */\n    if( httpmsg_find_hdr( hmsg, HDR_TRANSFER_ENCODING, &hdr_value ) ) {\n        if( raw_find_str( &hdr_value, \"chunked\" ) >= 0 ) {\n            /* read method to use chunked transfer encoding */\n            parser->ent_position = ENTREAD_USING_CHUNKED;\n            UpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n                \"Found Chunked Encoding ....\\n\" );\n\n            return PARSE_CONTINUE_1;\n        }\n    }\n    /* * use content length */\n    if( httpmsg_find_hdr( hmsg, HDR_CONTENT_LENGTH, &hdr_value ) ) {\n        parser->content_length = (unsigned int)raw_to_int(&hdr_value, 10);\n        parser->ent_position = ENTREAD_USING_CLEN;\n        return PARSE_CONTINUE_1;\n    }\n    /* * multi-part/byteranges not supported (yet) */\n\n    /* * read until connection is closed */\n    if( hmsg->is_request ) {\n        /* set hack flag for NOTIFY methods; if set to true this is */\n        /*  a valid SSDP notify msg */\n        if( hmsg->method == ( http_method_t ) HTTPMETHOD_NOTIFY ) {\n            parser->valid_ssdp_notify_hack = TRUE;\n        }\n\n        parser->http_error_code = HTTP_LENGTH_REQUIRED;\n        return PARSE_FAILURE;\n    }\n\n    parser->ent_position = ENTREAD_UNTIL_CLOSE;\n    return PARSE_CONTINUE_1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadResponseLineAndHeaders",
          "args": [
            "&handle->sock_info",
            "&handle->response",
            "&timeout",
            "&http_error_code"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "ReadResponseLineAndHeaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "941-1044",
          "snippet": "static int ReadResponseLineAndHeaders(\n\t/*! Socket information object. */\n\tIN SOCKINFO *info,\n\t/*! HTTP Parser object. */\n\tIN OUT http_parser_t *parser,\n\t/*! Time out value. */\n\tIN OUT int *timeout_secs,\n\t/*! HTTP errror code returned. */\n\tIN OUT int *http_error_code)\n{\n\tparse_status_t status;\n\tint num_read;\n\tchar buf[2 * 1024];\n\tint done = 0;\n\tint ret_code = 0;\n\n\t/*read response line */\n\tstatus = parser_parse_responseline(parser);\n\tswitch (status) {\n\tcase PARSE_OK:\n\t\tdone = 1;\n\t\tbreak;\n\tcase PARSE_INCOMPLETE:\n\t\tdone = 0;\n\t\tbreak;\n\tdefault:\n\t\t/*error */\n\t\treturn status;\n\t}\n\twhile (!done) {\n\t\tnum_read = sock_read(info, buf, sizeof(buf), timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code =\n\t\t\t\tmembuffer_append(&parser->msg.msg, buf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_responseline(parser);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_OK:\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_INCOMPLETE:\n\t\t\t\tdone = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*error */\n\t\t\t\treturn status;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\t/* partial msg */\n\t\t\t*http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\tstatus = parser_parse_headers(parser);\n\tif ((status == (parse_status_t)PARSE_OK) &&\n\t\t(parser->position == (parser_pos_t)POS_ENTITY))\n\t\tdone = 1;\n\telse if (status == (parse_status_t)PARSE_INCOMPLETE)\n\t\tdone = 0;\n\telse\n\t\t/*error */\n\t\treturn status;\n\t/*read headers */\n\twhile (!done) {\n\t\tnum_read = sock_read(info, buf, sizeof(buf), timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code =\n\t\t\t    membuffer_append(&parser->msg.msg, buf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_headers(parser);\n\t\t\tif (status == (parse_status_t)PARSE_OK &&\n\t\t\t\tparser->position == (parser_pos_t)POS_ENTITY)\n\t\t\t\tdone = 1;\n\t\t\telse if (status == (parse_status_t)PARSE_INCOMPLETE)\n\t\t\t\tdone = 0;\n\t\t\telse\n\t\t\t\t/*error */\n\t\t\t\treturn status;\n\t\t} else if (num_read == 0) {\n\t\t\t/* partial msg */\n\t\t\t*http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\n\treturn PARSE_OK;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstatic int ReadResponseLineAndHeaders(\n\t/*! Socket information object. */\n\tIN SOCKINFO *info,\n\t/*! HTTP Parser object. */\n\tIN OUT http_parser_t *parser,\n\t/*! Time out value. */\n\tIN OUT int *timeout_secs,\n\t/*! HTTP errror code returned. */\n\tIN OUT int *http_error_code)\n{\n\tparse_status_t status;\n\tint num_read;\n\tchar buf[2 * 1024];\n\tint done = 0;\n\tint ret_code = 0;\n\n\t/*read response line */\n\tstatus = parser_parse_responseline(parser);\n\tswitch (status) {\n\tcase PARSE_OK:\n\t\tdone = 1;\n\t\tbreak;\n\tcase PARSE_INCOMPLETE:\n\t\tdone = 0;\n\t\tbreak;\n\tdefault:\n\t\t/*error */\n\t\treturn status;\n\t}\n\twhile (!done) {\n\t\tnum_read = sock_read(info, buf, sizeof(buf), timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code =\n\t\t\t\tmembuffer_append(&parser->msg.msg, buf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_responseline(parser);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_OK:\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_INCOMPLETE:\n\t\t\t\tdone = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*error */\n\t\t\t\treturn status;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\t/* partial msg */\n\t\t\t*http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\tstatus = parser_parse_headers(parser);\n\tif ((status == (parse_status_t)PARSE_OK) &&\n\t\t(parser->position == (parser_pos_t)POS_ENTITY))\n\t\tdone = 1;\n\telse if (status == (parse_status_t)PARSE_INCOMPLETE)\n\t\tdone = 0;\n\telse\n\t\t/*error */\n\t\treturn status;\n\t/*read headers */\n\twhile (!done) {\n\t\tnum_read = sock_read(info, buf, sizeof(buf), timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code =\n\t\t\t    membuffer_append(&parser->msg.msg, buf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_headers(parser);\n\t\t\tif (status == (parse_status_t)PARSE_OK &&\n\t\t\t\tparser->position == (parser_pos_t)POS_ENTITY)\n\t\t\t\tdone = 1;\n\t\t\telse if (status == (parse_status_t)PARSE_INCOMPLETE)\n\t\t\t\tdone = 0;\n\t\t\telse\n\t\t\t\t/*error */\n\t\t\t\treturn status;\n\t\t} else if (num_read == 0) {\n\t\t\t/* partial msg */\n\t\t\t*http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\n\treturn PARSE_OK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_GetHttpResponse(void *Handle, UpnpString *headers,\n\t\t\t char **contentType, int *contentLength,\n\t\t\t int *httpStatus, int timeout)\n{\n\tint ret_code;\n\tint http_error_code;\n\tmemptr ctype;\n\thttp_connection_handle_t *handle = Handle;\n\tparse_status_t status;\n\n\tstatus = ReadResponseLineAndHeaders(&handle->sock_info,\n\t\t\t\t\t    &handle->response, &timeout,\n\t\t\t\t\t    &http_error_code);\n\tif (status != (parse_status_t)PARSE_OK) {\n\t\tret_code = UPNP_E_BAD_RESPONSE;\n\t\tgoto errorHandler;\n\t}\n\tstatus = parser_get_entity_read_method(&handle->response);\n\tswitch (status) {\n\tcase PARSE_CONTINUE_1:\n\tcase PARSE_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tret_code = UPNP_E_BAD_RESPONSE;\n\t\tgoto errorHandler;\n\t}\n\tret_code = UPNP_E_SUCCESS;\n\tif (httpStatus) {\n\t\t*httpStatus = handle->response.msg.status_code;\n\t}\n\tif (contentType) {\n\t\tif (!httpmsg_find_hdr(&handle->response.msg, HDR_CONTENT_TYPE, &ctype))\n\t\t\t/* no content-type */\n\t\t\t*contentType = NULL;\n\t\telse\n\t\t\t*contentType = ctype.buf;\n\t}\n\tif (contentLength) {\n\t\tif (handle->response.position == (parser_pos_t)POS_COMPLETE)\n\t\t\t*contentLength = 0;\n\t\telse if (handle->response.ent_position == ENTREAD_USING_CHUNKED)\n\t\t\t*contentLength = UPNP_USING_CHUNKED;\n\t\telse if (handle->response.ent_position == ENTREAD_USING_CLEN)\n\t\t\t*contentLength = (int)handle->response.content_length;\n\t\telse if (handle->response.ent_position == ENTREAD_UNTIL_CLOSE)\n\t\t\t*contentLength = UPNP_UNTIL_CLOSE;\n\t}\n\n\tif (headers) {\n\t\tcopy_msg_headers(&handle->response.msg.headers, headers);\n\n\t}\n\nerrorHandler:\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\thttpmsg_destroy(&handle->response.msg);\n\treturn ret_code;\n}"
  },
  {
    "function_name": "http_EndHttpRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1238-1254",
    "snippet": "int http_EndHttpRequest(void *Handle, int timeout)\n{\n\tint retc = 0;\n\tconst char *zcrlf = \"0\\r\\n\\r\\n\";\n\thttp_connection_handle_t *handle = Handle;\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tif (!handle->requestStarted) {\n\t\treturn UPNP_E_SUCCESS;\n\t}\n\thandle->requestStarted = 0;\n\tif (handle->contentLength == UPNP_USING_CHUNKED)\n\t\t/*send last chunk */\n\t\tretc = sock_write(&handle->sock_info, zcrlf, strlen(zcrlf), &timeout);\n\n\treturn retc >= 0 ? UPNP_E_SUCCESS : UPNP_E_SOCKET_WRITE;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_write",
          "args": [
            "&handle->sock_info",
            "zcrlf",
            "strlen(zcrlf)",
            "&timeout"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "sock_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "271-275",
          "snippet": "int sock_write(SOCKINFO *info, const char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\t/* Consciently removing constness. */\n\treturn sock_read_write(info, (char *)buffer, bufsize, timeoutSecs, FALSE);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_write(SOCKINFO *info, const char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\t/* Consciently removing constness. */\n\treturn sock_read_write(info, (char *)buffer, bufsize, timeoutSecs, FALSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "zcrlf"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_EndHttpRequest(void *Handle, int timeout)\n{\n\tint retc = 0;\n\tconst char *zcrlf = \"0\\r\\n\\r\\n\";\n\thttp_connection_handle_t *handle = Handle;\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tif (!handle->requestStarted) {\n\t\treturn UPNP_E_SUCCESS;\n\t}\n\thandle->requestStarted = 0;\n\tif (handle->contentLength == UPNP_USING_CHUNKED)\n\t\t/*send last chunk */\n\t\tretc = sock_write(&handle->sock_info, zcrlf, strlen(zcrlf), &timeout);\n\n\treturn retc >= 0 ? UPNP_E_SUCCESS : UPNP_E_SOCKET_WRITE;\n}"
  },
  {
    "function_name": "http_WriteHttpRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1191-1236",
    "snippet": "int http_WriteHttpRequest(void *Handle, char *buf,\n\t\t\t  size_t *size, int timeout)\n{\n\thttp_connection_handle_t *handle = (http_connection_handle_t *)Handle;\n\tchar *tempbuf = NULL;\n\tsize_t tempbufSize = 0;\n\tint freeTempbuf = 0;\n\tint numWritten = 0;\n\n\tif (!handle || !size || !buf) {\n\t\tif (size)\n\t\t\t*size = 0;\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\tif (handle->contentLength == UPNP_USING_CHUNKED) {\n\t\tif (*size) {\n\t\t\tsize_t tempSize = 0;\n\t\t\ttempbuf = malloc(*size +\n\t\t\t\t\t CHUNK_HEADER_SIZE + CHUNK_TAIL_SIZE);\n\t\t\tif (!tempbuf)\n\t\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t\t/* begin chunk */\n\t\t\tsprintf(tempbuf, \"%zx\\r\\n\", *size);\n\t\t\ttempSize = strlen(tempbuf);\n\t\t\tmemcpy(tempbuf + tempSize, buf, *size);\n\t\t\tmemcpy(tempbuf + tempSize + *size, \"\\r\\n\", 2);\n\t\t\t/* end of chunk */\n\t\t\ttempbufSize = tempSize + *size + 2;\n\t\t\tfreeTempbuf = 1;\n\t\t}\n\t} else {\n\t\ttempbuf = buf;\n\t\ttempbufSize = *size;\n\t}\n\tnumWritten =\n\t\tsock_write(&handle->sock_info, tempbuf, tempbufSize, &timeout);\n\tif (freeTempbuf)\n\t\tfree(tempbuf);\n\tif (numWritten < 0) {\n\t\t*size = 0;\n\t\treturn numWritten;\n\t} else {\n\t\t*size = (size_t)numWritten;\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CHUNK_TAIL_SIZE (size_t)10",
      "#define CHUNK_HEADER_SIZE (size_t)10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tempbuf"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_write",
          "args": [
            "&handle->sock_info",
            "tempbuf",
            "tempbufSize",
            "&timeout"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "sock_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "271-275",
          "snippet": "int sock_write(SOCKINFO *info, const char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\t/* Consciently removing constness. */\n\treturn sock_read_write(info, (char *)buffer, bufsize, timeoutSecs, FALSE);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_write(SOCKINFO *info, const char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\t/* Consciently removing constness. */\n\treturn sock_read_write(info, (char *)buffer, bufsize, timeoutSecs, FALSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tempbuf + tempSize + *size",
            "\"\\r\\n\"",
            "2"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tempbuf"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tempbuf",
            "\"%zx\\r\\n\"",
            "*size"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "*size +\n\t\t\t\t\t CHUNK_HEADER_SIZE + CHUNK_TAIL_SIZE"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n\nint http_WriteHttpRequest(void *Handle, char *buf,\n\t\t\t  size_t *size, int timeout)\n{\n\thttp_connection_handle_t *handle = (http_connection_handle_t *)Handle;\n\tchar *tempbuf = NULL;\n\tsize_t tempbufSize = 0;\n\tint freeTempbuf = 0;\n\tint numWritten = 0;\n\n\tif (!handle || !size || !buf) {\n\t\tif (size)\n\t\t\t*size = 0;\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\tif (handle->contentLength == UPNP_USING_CHUNKED) {\n\t\tif (*size) {\n\t\t\tsize_t tempSize = 0;\n\t\t\ttempbuf = malloc(*size +\n\t\t\t\t\t CHUNK_HEADER_SIZE + CHUNK_TAIL_SIZE);\n\t\t\tif (!tempbuf)\n\t\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t\t/* begin chunk */\n\t\t\tsprintf(tempbuf, \"%zx\\r\\n\", *size);\n\t\t\ttempSize = strlen(tempbuf);\n\t\t\tmemcpy(tempbuf + tempSize, buf, *size);\n\t\t\tmemcpy(tempbuf + tempSize + *size, \"\\r\\n\", 2);\n\t\t\t/* end of chunk */\n\t\t\ttempbufSize = tempSize + *size + 2;\n\t\t\tfreeTempbuf = 1;\n\t\t}\n\t} else {\n\t\ttempbuf = buf;\n\t\ttempbufSize = *size;\n\t}\n\tnumWritten =\n\t\tsock_write(&handle->sock_info, tempbuf, tempbufSize, &timeout);\n\tif (freeTempbuf)\n\t\tfree(tempbuf);\n\tif (numWritten < 0) {\n\t\t*size = 0;\n\t\treturn numWritten;\n\t} else {\n\t\t*size = (size_t)numWritten;\n\t\treturn UPNP_E_SUCCESS;\n\t}\n}"
  },
  {
    "function_name": "http_MakeHttpRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1162-1189",
    "snippet": "int http_MakeHttpRequest(Upnp_HttpMethod method,\n\t\t\t const char *url_str, void *Handle, UpnpString *headers,\n\t\t\t const char *contentType, int contentLength,\n\t\t\t int timeout)\n{\n\tint ret_code;\n\tmembuffer request;\n\thttp_connection_handle_t *handle = Handle;\n\turi_type url;\n\tif (!url_str || !Handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tif (handle->requestStarted) {\n\t\t/* TODO: Log an error that a previous request is already in progress. */\n\t}\n\thandle->requestStarted = 1;\n\thandle->cancel = 0;\n\tret_code = MakeGenericMessage(method, url_str, &request, &url, contentLength,\n\t\t\t\t      contentType, headers);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* send request */\n\tret_code = http_SendMessage(&handle->sock_info, &timeout, \"b\",\n\t\t\t\t    request.buf, request.length);\n\tmembuffer_destroy(&request);\n\thttpmsg_destroy(&handle->response.msg);\n\tparser_response_init(&handle->response, method);\n\treturn ret_code;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parser_response_init",
          "args": [
            "&handle->response",
            "method"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "parser_response_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1985-1994",
          "snippet": "void\nparser_response_init( OUT http_parser_t * parser,\n                      IN http_method_t request_method )\n{\n    parser_init( parser );\n    parser->msg.is_request = FALSE;\n    parser->msg.request_method = request_method;\n    parser->msg.amount_discarded = (size_t)0;\n    parser->position = POS_RESPONSE_LINE;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid\nparser_response_init( OUT http_parser_t * parser,\n                      IN http_method_t request_method )\n{\n    parser_init( parser );\n    parser->msg.is_request = FALSE;\n    parser->msg.request_method = request_method;\n    parser->msg.amount_discarded = (size_t)0;\n    parser->position = POS_RESPONSE_LINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&handle->response.msg"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&request"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_SendMessage",
          "args": [
            "&handle->sock_info",
            "&timeout",
            "\"b\"",
            "request.buf",
            "request.length"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "437-613",
          "snippet": "int http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CHUNK_TAIL_SIZE (size_t)10",
            "#define CHUNK_HEADER_SIZE (size_t)10",
            "#define snprintf _snprintf",
            "#define fseeko fseek"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n#define snprintf _snprintf\n#define fseeko fseek\n\nint http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MakeGenericMessage",
          "args": [
            "method",
            "url_str",
            "&request",
            "&url",
            "contentLength",
            "contentType",
            "headers"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "MakeGenericMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "852-920",
          "snippet": "int MakeGenericMessage(http_method_t method,\n\t\t       const char *url_str, membuffer *request,\n\t\t       uri_type *url, int contentLength, const char *contentType,\n\t\t       const UpnpString *headers)\n{\n\tint ret_code = 0;\n\tsize_t hostlen = (size_t)0;\n\tchar *hoststr;\n\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"URL: %s method: %d\\n\", url_str, method);\n\tret_code = http_FixStrUrl(url_str, strlen(url_str), url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* make msg */\n\tmembuffer_init(request);\n\tret_code = http_MakeMessage(request, 1, 1, \"Q\",\n\t\t\t\t    method,\n\t\t\t\t    url->pathquery.buff,\n\t\t\t\t    url->pathquery.size);\n\t/* add request headers if specified, otherwise use default headers */\n\tif (ret_code == 0) {\n\t\tif (headers) {\n\t\t\tret_code = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t\t    \"s\",\n\t\t\t\t\t\t    UpnpString_get_String(headers));\n\t\t}\n\t\telse {\n\t\t\tret_code = get_hoststr(url_str, &hoststr, &hostlen);\n\t\t\tif (ret_code != UPNP_E_SUCCESS)\n\t\t\t\treturn ret_code;\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"HOSTNAME : %s Length : %\" PRIzu \"\\n\", hoststr, hostlen);\n\t\t\tret_code = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t\t    \"s\" \"bcDCU\",\n\t\t\t\t\t\t    \"HOST: \", hoststr, hostlen);\n\t\t}\n\t}\n\n\t/* add the content-type header */\n\tif (ret_code == 0 && contentType) {\n\t\tret_code = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t    \"T\",\n\t\t\t\t\t    contentType);\n\t}\n\t/* add content-length header. */\n\tif (ret_code == 0) {\n\t\tif (contentLength >= 0)\n\t\t\tret_code = http_MakeMessage(request, 1, 1, \"Nc\",\n\t\t\t\t\t\t    (off_t) contentLength);\n\t\telse if (contentLength == UPNP_USING_CHUNKED)\n\t\t\tret_code = http_MakeMessage(request, 1, 1, \"Kc\");\n\t\telse if (contentLength == UPNP_UNTIL_CLOSE)\n\t\t\tret_code = http_MakeMessage(request, 1, 1, \"c\");\n\t\telse\n\t\t\tret_code = UPNP_E_INVALID_PARAM;\n\t}\n\tif (ret_code != 0) {\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"HTTP Makemessage failed\\n\");\n\t\tmembuffer_destroy(request);\n\t\treturn ret_code;\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\",\n\t\t   request->buf);\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint MakeGenericMessage(http_method_t method,\n\t\t       const char *url_str, membuffer *request,\n\t\t       uri_type *url, int contentLength, const char *contentType,\n\t\t       const UpnpString *headers)\n{\n\tint ret_code = 0;\n\tsize_t hostlen = (size_t)0;\n\tchar *hoststr;\n\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"URL: %s method: %d\\n\", url_str, method);\n\tret_code = http_FixStrUrl(url_str, strlen(url_str), url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* make msg */\n\tmembuffer_init(request);\n\tret_code = http_MakeMessage(request, 1, 1, \"Q\",\n\t\t\t\t    method,\n\t\t\t\t    url->pathquery.buff,\n\t\t\t\t    url->pathquery.size);\n\t/* add request headers if specified, otherwise use default headers */\n\tif (ret_code == 0) {\n\t\tif (headers) {\n\t\t\tret_code = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t\t    \"s\",\n\t\t\t\t\t\t    UpnpString_get_String(headers));\n\t\t}\n\t\telse {\n\t\t\tret_code = get_hoststr(url_str, &hoststr, &hostlen);\n\t\t\tif (ret_code != UPNP_E_SUCCESS)\n\t\t\t\treturn ret_code;\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"HOSTNAME : %s Length : %\" PRIzu \"\\n\", hoststr, hostlen);\n\t\t\tret_code = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t\t    \"s\" \"bcDCU\",\n\t\t\t\t\t\t    \"HOST: \", hoststr, hostlen);\n\t\t}\n\t}\n\n\t/* add the content-type header */\n\tif (ret_code == 0 && contentType) {\n\t\tret_code = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t    \"T\",\n\t\t\t\t\t    contentType);\n\t}\n\t/* add content-length header. */\n\tif (ret_code == 0) {\n\t\tif (contentLength >= 0)\n\t\t\tret_code = http_MakeMessage(request, 1, 1, \"Nc\",\n\t\t\t\t\t\t    (off_t) contentLength);\n\t\telse if (contentLength == UPNP_USING_CHUNKED)\n\t\t\tret_code = http_MakeMessage(request, 1, 1, \"Kc\");\n\t\telse if (contentLength == UPNP_UNTIL_CLOSE)\n\t\t\tret_code = http_MakeMessage(request, 1, 1, \"c\");\n\t\telse\n\t\t\tret_code = UPNP_E_INVALID_PARAM;\n\t}\n\tif (ret_code != 0) {\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"HTTP Makemessage failed\\n\");\n\t\tmembuffer_destroy(request);\n\t\treturn ret_code;\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\",\n\t\t   request->buf);\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_MakeHttpRequest(Upnp_HttpMethod method,\n\t\t\t const char *url_str, void *Handle, UpnpString *headers,\n\t\t\t const char *contentType, int contentLength,\n\t\t\t int timeout)\n{\n\tint ret_code;\n\tmembuffer request;\n\thttp_connection_handle_t *handle = Handle;\n\turi_type url;\n\tif (!url_str || !Handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\tif (handle->requestStarted) {\n\t\t/* TODO: Log an error that a previous request is already in progress. */\n\t}\n\thandle->requestStarted = 1;\n\thandle->cancel = 0;\n\tret_code = MakeGenericMessage(method, url_str, &request, &url, contentLength,\n\t\t\t\t      contentType, headers);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* send request */\n\tret_code = http_SendMessage(&handle->sock_info, &timeout, \"b\",\n\t\t\t\t    request.buf, request.length);\n\tmembuffer_destroy(&request);\n\thttpmsg_destroy(&handle->response.msg);\n\tparser_response_init(&handle->response, method);\n\treturn ret_code;\n}"
  },
  {
    "function_name": "http_OpenHttpConnection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1103-1160",
    "snippet": "int http_OpenHttpConnection(const char *url_str, void **Handle, int timeout)\n{\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tSOCKET tcp_connection;\n\thttp_connection_handle_t *handle = NULL;\n\turi_type url;\n\tif (!url_str || !Handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t*Handle = handle;\n\t/* parse url_str */\n\tret_code = http_FixStrUrl(url_str, strlen(url_str), &url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* create the handle */\n\thandle = malloc(sizeof(http_connection_handle_t));\n\tif (!handle) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thandle->requestStarted = 0;\n\tmemset(&handle->response, 0, sizeof(handle->response));\n\t/* connect to the server */\n\ttcp_connection = socket(url.hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto errorHandler;\n\t}\n\tif (sock_init(&handle->sock_info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto errorHandler;\n\t}\n\tsockaddr_len = url.hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(handle->sock_info.socket,\n\t\t\t\t   (struct sockaddr *)&(url.hostport.IPaddress),\n\t\t\t\t   (socklen_t) sockaddr_len);\n\tif (ret_code == -1) {\n\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto errorHandler;\n\t}\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t/* For HTTPS connections start the TLS/SSL handshake. */\n\tif (token_string_casecmp(&url.scheme, \"https\") == 0) {\n\t\tret_code = sock_ssl_connect(&handle->sock_info);\n\t\tif (ret_code != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\tgoto errorHandler;\n\t\t}\n\t}\n#endif\nerrorHandler:\n\t*Handle = handle;\n\treturn ret_code;\n\t/* Unused parameter */\n\ttimeout = timeout;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_destroy",
          "args": [
            "&handle->sock_info",
            "SD_BOTH"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "sock_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "118-143",
          "snippet": "int sock_destroy(SOCKINFO *info, int ShutdownMethod)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (info->socket != INVALID_SOCKET) {\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t\tif (info->ssl) {\n\t\t\tSSL_shutdown(info->ssl);\n\t\t\tSSL_free(info->ssl);\n\t\t\tinfo->ssl = NULL;\n\t\t}\n#endif\n\t\tif (shutdown(info->socket, ShutdownMethod) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tif (sock_close(info->socket) == -1) {\n\t\t\tret = UPNP_E_SOCKET_ERROR;\n\t\t}\n\t\tinfo->socket = INVALID_SOCKET;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_destroy(SOCKINFO *info, int ShutdownMethod)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (info->socket != INVALID_SOCKET) {\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t\tif (info->ssl) {\n\t\t\tSSL_shutdown(info->ssl);\n\t\t\tSSL_free(info->ssl);\n\t\t\tinfo->ssl = NULL;\n\t\t}\n#endif\n\t\tif (shutdown(info->socket, ShutdownMethod) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tif (sock_close(info->socket) == -1) {\n\t\t\tret = UPNP_E_SOCKET_ERROR;\n\t\t}\n\t\tinfo->socket = INVALID_SOCKET;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_ssl_connect",
          "args": [
            "&handle->sock_info"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "sock_ssl_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "100-115",
          "snippet": "int sock_ssl_connect(SOCKINFO *info)\n{\n\tint status = 0;\n\tinfo->ssl = SSL_new(gSslCtx);\n\tif (!info->ssl) {\n\t\treturn UPNP_E_SOCKET_ERROR;\n\t}\n\tstatus = SSL_set_fd(info->ssl, info->socket);\n\tif (status == 1) {\n\t\tstatus = SSL_connect(info->ssl);\n\t}\n\tif (status == 1) {\n\t\treturn UPNP_E_SUCCESS;\n\t}\n\treturn UPNP_E_SOCKET_ERROR;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_ssl_connect(SOCKINFO *info)\n{\n\tint status = 0;\n\tinfo->ssl = SSL_new(gSslCtx);\n\tif (!info->ssl) {\n\t\treturn UPNP_E_SOCKET_ERROR;\n\t}\n\tstatus = SSL_set_fd(info->ssl, info->socket);\n\tif (status == 1) {\n\t\tstatus = SSL_connect(info->ssl);\n\t}\n\tif (status == 1) {\n\t\treturn UPNP_E_SUCCESS;\n\t}\n\treturn UPNP_E_SOCKET_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "token_string_casecmp",
          "args": [
            "&url.scheme",
            "\"https\""
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "token_string_casecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "289-296",
          "snippet": "int token_string_casecmp(token *in1, const char *in2)\n{\n\tsize_t in2_length = strlen(in2);\n\tif (in1->size != in2_length)\n\t\treturn 1;\n\telse\n\t\treturn strncasecmp(in1->buff, in2, in1->size);\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint token_string_casecmp(token *in1, const char *in2)\n{\n\tsize_t in2_length = strlen(in2);\n\tif (in1->size != in2_length)\n\t\treturn 1;\n\telse\n\t\treturn strncasecmp(in1->buff, in2, in1->size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "private_connect",
          "args": [
            "handle->sock_info.socket",
            "(struct sockaddr *)&(url.hostport.IPaddress)",
            "(socklen_t) sockaddr_len"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "private_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "146-165",
          "snippet": "static int private_connect(\n\tSOCKET sockfd,\n\tconst struct sockaddr *serv_addr,\n\tsocklen_t addrlen)\n{\n#ifndef UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS\n\tint ret = sock_make_no_blocking(sockfd);\n\tif (ret != - 1) {\n\t\tret = connect(sockfd, serv_addr, addrlen);\n\t\tret = Check_Connect_And_Wait_Connection(sockfd, ret);\n\t\tif (ret != - 1) {\n\t\t\tret = sock_make_blocking(sockfd);\n\t\t}\n\t}\n\n\treturn ret;\n#else\n\treturn connect(sockfd, serv_addr, addrlen);\n#endif /* UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS */\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstatic int private_connect(\n\tSOCKET sockfd,\n\tconst struct sockaddr *serv_addr,\n\tsocklen_t addrlen)\n{\n#ifndef UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS\n\tint ret = sock_make_no_blocking(sockfd);\n\tif (ret != - 1) {\n\t\tret = connect(sockfd, serv_addr, addrlen);\n\t\tret = Check_Connect_And_Wait_Connection(sockfd, ret);\n\t\tif (ret != - 1) {\n\t\t\tret = sock_make_blocking(sockfd);\n\t\t}\n\t}\n\n\treturn ret;\n#else\n\treturn connect(sockfd, serv_addr, addrlen);\n#endif /* UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_init",
          "args": [
            "&handle->sock_info",
            "tcp_connection"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "sock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "73-81",
          "snippet": "int sock_init(SOCKINFO *info, SOCKET sockfd)\n{\n\tassert(info);\n\n\tmemset(info, 0, sizeof(SOCKINFO));\n\tinfo->socket = sockfd;\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_init(SOCKINFO *info, SOCKET sockfd)\n{\n\tassert(info);\n\n\tmemset(info, 0, sizeof(SOCKINFO));\n\tinfo->socket = sockfd;\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "url.hostport.IPaddress.ss_family",
            "SOCK_STREAM",
            "0"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&handle->response",
            "0",
            "sizeof(handle->response)"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(http_connection_handle_t)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_FixStrUrl",
          "args": [
            "url_str",
            "strlen(url_str)",
            "&url"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "http_FixStrUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "259-271",
          "snippet": "int http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_OpenHttpConnection(const char *url_str, void **Handle, int timeout)\n{\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tSOCKET tcp_connection;\n\thttp_connection_handle_t *handle = NULL;\n\turi_type url;\n\tif (!url_str || !Handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\t*Handle = handle;\n\t/* parse url_str */\n\tret_code = http_FixStrUrl(url_str, strlen(url_str), &url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* create the handle */\n\thandle = malloc(sizeof(http_connection_handle_t));\n\tif (!handle) {\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thandle->requestStarted = 0;\n\tmemset(&handle->response, 0, sizeof(handle->response));\n\t/* connect to the server */\n\ttcp_connection = socket(url.hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto errorHandler;\n\t}\n\tif (sock_init(&handle->sock_info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto errorHandler;\n\t}\n\tsockaddr_len = url.hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(handle->sock_info.socket,\n\t\t\t\t   (struct sockaddr *)&(url.hostport.IPaddress),\n\t\t\t\t   (socklen_t) sockaddr_len);\n\tif (ret_code == -1) {\n\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto errorHandler;\n\t}\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t/* For HTTPS connections start the TLS/SSL handshake. */\n\tif (token_string_casecmp(&url.scheme, \"https\") == 0) {\n\t\tret_code = sock_ssl_connect(&handle->sock_info);\n\t\tif (ret_code != UPNP_E_SUCCESS) {\n\t\t\tsock_destroy(&handle->sock_info, SD_BOTH);\n\t\t\tgoto errorHandler;\n\t\t}\n\t}\n#endif\nerrorHandler:\n\t*Handle = handle;\n\treturn ret_code;\n\t/* Unused parameter */\n\ttimeout = timeout;\n}"
  },
  {
    "function_name": "http_CancelHttpGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1091-1100",
    "snippet": "int http_CancelHttpGet(IN void *Handle)\n{\n\thttp_connection_handle_t *handle = Handle;\n\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\thandle->cancel = 1;\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_CancelHttpGet(IN void *Handle)\n{\n\thttp_connection_handle_t *handle = Handle;\n\n\tif (!handle)\n\t\treturn UPNP_E_INVALID_PARAM;\n\thandle->cancel = 1;\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "http_HttpGetProgress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "1062-1076",
    "snippet": "int http_HttpGetProgress(\n\tIN void *Handle,\n\tOUT size_t *length,\n\tOUT size_t *total)\n{\n\thttp_connection_handle_t *handle = Handle;\n\n\tif (!handle || !length || !total) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\t*length = handle->response.msg.entity.length;\n\t*total = handle->response.content_length;\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_HttpGetProgress(\n\tIN void *Handle,\n\tOUT size_t *length,\n\tOUT size_t *total)\n{\n\thttp_connection_handle_t *handle = Handle;\n\n\tif (!handle || !length || !total) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\t*length = handle->response.msg.entity.length;\n\t*total = handle->response.content_length;\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "ReadResponseLineAndHeaders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "941-1044",
    "snippet": "static int ReadResponseLineAndHeaders(\n\t/*! Socket information object. */\n\tIN SOCKINFO *info,\n\t/*! HTTP Parser object. */\n\tIN OUT http_parser_t *parser,\n\t/*! Time out value. */\n\tIN OUT int *timeout_secs,\n\t/*! HTTP errror code returned. */\n\tIN OUT int *http_error_code)\n{\n\tparse_status_t status;\n\tint num_read;\n\tchar buf[2 * 1024];\n\tint done = 0;\n\tint ret_code = 0;\n\n\t/*read response line */\n\tstatus = parser_parse_responseline(parser);\n\tswitch (status) {\n\tcase PARSE_OK:\n\t\tdone = 1;\n\t\tbreak;\n\tcase PARSE_INCOMPLETE:\n\t\tdone = 0;\n\t\tbreak;\n\tdefault:\n\t\t/*error */\n\t\treturn status;\n\t}\n\twhile (!done) {\n\t\tnum_read = sock_read(info, buf, sizeof(buf), timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code =\n\t\t\t\tmembuffer_append(&parser->msg.msg, buf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_responseline(parser);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_OK:\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_INCOMPLETE:\n\t\t\t\tdone = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*error */\n\t\t\t\treturn status;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\t/* partial msg */\n\t\t\t*http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\tstatus = parser_parse_headers(parser);\n\tif ((status == (parse_status_t)PARSE_OK) &&\n\t\t(parser->position == (parser_pos_t)POS_ENTITY))\n\t\tdone = 1;\n\telse if (status == (parse_status_t)PARSE_INCOMPLETE)\n\t\tdone = 0;\n\telse\n\t\t/*error */\n\t\treturn status;\n\t/*read headers */\n\twhile (!done) {\n\t\tnum_read = sock_read(info, buf, sizeof(buf), timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code =\n\t\t\t    membuffer_append(&parser->msg.msg, buf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_headers(parser);\n\t\t\tif (status == (parse_status_t)PARSE_OK &&\n\t\t\t\tparser->position == (parser_pos_t)POS_ENTITY)\n\t\t\t\tdone = 1;\n\t\t\telse if (status == (parse_status_t)PARSE_INCOMPLETE)\n\t\t\t\tdone = 0;\n\t\t\telse\n\t\t\t\t/*error */\n\t\t\t\treturn status;\n\t\t} else if (num_read == 0) {\n\t\t\t/* partial msg */\n\t\t\t*http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\n\treturn PARSE_OK;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parser_parse_headers",
          "args": [
            "parser"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1446-1573",
          "snippet": "parse_status_t parser_parse_headers(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\tmemptr token;\n\tmemptr hdr_value;\n\ttoken_type_t tok_type;\n\tscanner_t *scanner = &parser->scanner;\n\tsize_t save_pos;\n\thttp_header_t *header;\n\tint header_id;\n\tint ret = 0;\n\tint index;\n\thttp_header_t *orig_header;\n\tchar save_char;\n\tint ret2;\n\n\tassert(parser->position == (parser_pos_t)POS_HEADERS ||\n\t       parser->ent_position == ENTREAD_CHUNKY_HEADERS);\n\n\twhile (TRUE) {\n\t\tsave_pos = scanner->cursor;\n\t\t/* check end of headers */\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\tswitch (tok_type) {\n\t\tcase TT_CRLF:\n\t\t\t/* end of headers */\n\t\t\tif ((parser->msg.is_request)\n\t\t\t    && (parser->msg.method == (http_method_t)HTTPMETHOD_POST)) {\n\t\t\t\tparser->position = POS_COMPLETE;\t/*post entity parsing */\n\t\t\t\t/*is handled separately  */\n\t\t\t\treturn PARSE_SUCCESS;\n\t\t\t}\n\t\t\tparser->position = POS_ENTITY;\t/* read entity next */\n\t\t\treturn PARSE_OK;\n\t\tcase TT_IDENTIFIER:\n\t\t\t/* not end; read header */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn PARSE_FAILURE;\t/* didn't see header name */\n\t\t}\n\t\tstatus = match(scanner, \" : %R%c\", &hdr_value);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\t/* add header */\n\t\t/* find header */\n\t\tindex =\n\t\t    map_str_to_int(token.buf, token.length, Http_Header_Names,\n\t\t\t\t   NUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (index != -1) {\n\t\t\t/*Check if it is a soap header */\n\t\t\tif (Http_Header_Names[index].id == HDR_SOAPACTION) {\n\t\t\t\tparser->msg.method = SOAPMETHOD_POST;\n\t\t\t}\n\t\t\theader_id = Http_Header_Names[index].id;\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr(&parser->msg, header_id, NULL);\n\t\t} else {\n\t\t\theader_id = HDR_UNKNOWN;\n\t\t\tsave_char = token.buf[token.length];\n\t\t\ttoken.buf[token.length] = '\\0';\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr_str(&parser->msg, token.buf);\n\t\t\ttoken.buf[token.length] = save_char;\t/* restore */\n\t\t}\n\t\tif (orig_header == NULL) {\n\t\t\t/* add new header */\n\t\t\theader =\n\t\t\t    (http_header_t *) malloc(sizeof(http_header_t));\n\t\t\tif (header == NULL) {\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tmembuffer_init(&header->name_buf);\n\t\t\tmembuffer_init(&header->value);\n\t\t\t/* value can be 0 length */\n\t\t\tif (hdr_value.length == (size_t)0) {\n\t\t\t\t/* FIXME: Is this a bug? buf is not const. */\n\t\t\t\thdr_value.buf = \"\\0\";\n\t\t\t\thdr_value.length = (size_t)1;\n\t\t\t}\n\t\t\t/* save in header in buffers */\n\t\t\tif (membuffer_assign(&header->name_buf, token.buf, token.length) ||\n\t\t\t    membuffer_assign(&header->value, hdr_value.buf, hdr_value.length)) {\n\t\t\t\t/* not enough mem */\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\theader->name.buf = header->name_buf.buf;\n\t\t\theader->name.length = header->name_buf.length;\n\t\t\theader->name_id = header_id;\n\t\t\tif (!ListAddTail(&parser->msg.headers, header)) {\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t} else if (hdr_value.length > (size_t)0) {\n\t\t\t/* append value to existing header */\n\t\t\t/* append space */\n\t\t\tret = membuffer_append_str(&orig_header->value, \", \");\n\t\t\t/* append continuation of header value */\n\t\t\tret2 = membuffer_append(&orig_header->value,\n\t\t\t\t\t\thdr_value.buf,\n\t\t\t\t\t\thdr_value.length);\n\t\t\tif (ret == UPNP_E_OUTOF_MEMORY\n\t\t\t    || ret2 == UPNP_E_OUTOF_MEMORY) {\n\t\t\t\t/* not enuf mem */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* end while */\n\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HTTP_HEADER_NAMES 33"
          ],
          "globals_used": [
            "str_int_entry Http_Header_Names[NUM_HTTP_HEADER_NAMES] = {\n\t{\"ACCEPT\", HDR_ACCEPT},\n\t{\"ACCEPT-CHARSET\", HDR_ACCEPT_CHARSET},\n\t{\"ACCEPT-ENCODING\", HDR_ACCEPT_ENCODING},\n\t{\"ACCEPT-LANGUAGE\", HDR_ACCEPT_LANGUAGE},\n\t{\"ACCEPT-RANGES\", HDR_ACCEPT_RANGE},\n\t{\"CACHE-CONTROL\", HDR_CACHE_CONTROL},\n\t{\"CALLBACK\", HDR_CALLBACK},\n\t{\"CONTENT-ENCODING\", HDR_CONTENT_ENCODING},\n\t{\"CONTENT-LANGUAGE\", HDR_CONTENT_LANGUAGE},\n\t{\"CONTENT-LENGTH\", HDR_CONTENT_LENGTH},\n\t{\"CONTENT-LOCATION\", HDR_CONTENT_LOCATION},\n\t{\"CONTENT-RANGE\", HDR_CONTENT_RANGE},\n\t{\"CONTENT-TYPE\", HDR_CONTENT_TYPE},\n\t{\"DATE\", HDR_DATE},\n\t{\"EXT\", HDR_EXT},\n\t{\"HOST\", HDR_HOST},\n\t{\"IF-RANGE\", HDR_IF_RANGE},\n\t{\"LOCATION\", HDR_LOCATION},\n\t{\"MAN\", HDR_MAN},\n\t{\"MX\", HDR_MX},\n\t{\"NT\", HDR_NT},\n\t{\"NTS\", HDR_NTS},\n\t{\"RANGE\", HDR_RANGE},\n\t{\"SEQ\", HDR_SEQ},\n\t{\"SERVER\", HDR_SERVER},\n\t{\"SID\", HDR_SID},\n\t{\"SOAPACTION\", HDR_SOAPACTION},\n\t{\"ST\", HDR_ST},\n\t{\"TE\", HDR_TE},\n\t{\"TIMEOUT\", HDR_TIMEOUT},\n\t{\"TRANSFER-ENCODING\", HDR_TRANSFER_ENCODING},\n\t{\"USER-AGENT\", HDR_USER_AGENT},\n\t{\"USN\", HDR_USN},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\n#define NUM_HTTP_HEADER_NAMES 33\n\nstr_int_entry Http_Header_Names[NUM_HTTP_HEADER_NAMES] = {\n\t{\"ACCEPT\", HDR_ACCEPT},\n\t{\"ACCEPT-CHARSET\", HDR_ACCEPT_CHARSET},\n\t{\"ACCEPT-ENCODING\", HDR_ACCEPT_ENCODING},\n\t{\"ACCEPT-LANGUAGE\", HDR_ACCEPT_LANGUAGE},\n\t{\"ACCEPT-RANGES\", HDR_ACCEPT_RANGE},\n\t{\"CACHE-CONTROL\", HDR_CACHE_CONTROL},\n\t{\"CALLBACK\", HDR_CALLBACK},\n\t{\"CONTENT-ENCODING\", HDR_CONTENT_ENCODING},\n\t{\"CONTENT-LANGUAGE\", HDR_CONTENT_LANGUAGE},\n\t{\"CONTENT-LENGTH\", HDR_CONTENT_LENGTH},\n\t{\"CONTENT-LOCATION\", HDR_CONTENT_LOCATION},\n\t{\"CONTENT-RANGE\", HDR_CONTENT_RANGE},\n\t{\"CONTENT-TYPE\", HDR_CONTENT_TYPE},\n\t{\"DATE\", HDR_DATE},\n\t{\"EXT\", HDR_EXT},\n\t{\"HOST\", HDR_HOST},\n\t{\"IF-RANGE\", HDR_IF_RANGE},\n\t{\"LOCATION\", HDR_LOCATION},\n\t{\"MAN\", HDR_MAN},\n\t{\"MX\", HDR_MX},\n\t{\"NT\", HDR_NT},\n\t{\"NTS\", HDR_NTS},\n\t{\"RANGE\", HDR_RANGE},\n\t{\"SEQ\", HDR_SEQ},\n\t{\"SERVER\", HDR_SERVER},\n\t{\"SID\", HDR_SID},\n\t{\"SOAPACTION\", HDR_SOAPACTION},\n\t{\"ST\", HDR_ST},\n\t{\"TE\", HDR_TE},\n\t{\"TIMEOUT\", HDR_TIMEOUT},\n\t{\"TRANSFER-ENCODING\", HDR_TRANSFER_ENCODING},\n\t{\"USER-AGENT\", HDR_USER_AGENT},\n\t{\"USN\", HDR_USN},\n};\n\nparse_status_t parser_parse_headers(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\tmemptr token;\n\tmemptr hdr_value;\n\ttoken_type_t tok_type;\n\tscanner_t *scanner = &parser->scanner;\n\tsize_t save_pos;\n\thttp_header_t *header;\n\tint header_id;\n\tint ret = 0;\n\tint index;\n\thttp_header_t *orig_header;\n\tchar save_char;\n\tint ret2;\n\n\tassert(parser->position == (parser_pos_t)POS_HEADERS ||\n\t       parser->ent_position == ENTREAD_CHUNKY_HEADERS);\n\n\twhile (TRUE) {\n\t\tsave_pos = scanner->cursor;\n\t\t/* check end of headers */\n\t\tstatus = scanner_get_token(scanner, &token, &tok_type);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\tswitch (tok_type) {\n\t\tcase TT_CRLF:\n\t\t\t/* end of headers */\n\t\t\tif ((parser->msg.is_request)\n\t\t\t    && (parser->msg.method == (http_method_t)HTTPMETHOD_POST)) {\n\t\t\t\tparser->position = POS_COMPLETE;\t/*post entity parsing */\n\t\t\t\t/*is handled separately  */\n\t\t\t\treturn PARSE_SUCCESS;\n\t\t\t}\n\t\t\tparser->position = POS_ENTITY;\t/* read entity next */\n\t\t\treturn PARSE_OK;\n\t\tcase TT_IDENTIFIER:\n\t\t\t/* not end; read header */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn PARSE_FAILURE;\t/* didn't see header name */\n\t\t}\n\t\tstatus = match(scanner, \" : %R%c\", &hdr_value);\n\t\tif (status != (parse_status_t)PARSE_OK) {\n\t\t\t/* pushback tokens; useful only on INCOMPLETE error */\n\t\t\tscanner->cursor = save_pos;\n\t\t\treturn status;\n\t\t}\n\t\t/* add header */\n\t\t/* find header */\n\t\tindex =\n\t\t    map_str_to_int(token.buf, token.length, Http_Header_Names,\n\t\t\t\t   NUM_HTTP_HEADER_NAMES, FALSE);\n\t\tif (index != -1) {\n\t\t\t/*Check if it is a soap header */\n\t\t\tif (Http_Header_Names[index].id == HDR_SOAPACTION) {\n\t\t\t\tparser->msg.method = SOAPMETHOD_POST;\n\t\t\t}\n\t\t\theader_id = Http_Header_Names[index].id;\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr(&parser->msg, header_id, NULL);\n\t\t} else {\n\t\t\theader_id = HDR_UNKNOWN;\n\t\t\tsave_char = token.buf[token.length];\n\t\t\ttoken.buf[token.length] = '\\0';\n\t\t\torig_header =\n\t\t\t    httpmsg_find_hdr_str(&parser->msg, token.buf);\n\t\t\ttoken.buf[token.length] = save_char;\t/* restore */\n\t\t}\n\t\tif (orig_header == NULL) {\n\t\t\t/* add new header */\n\t\t\theader =\n\t\t\t    (http_header_t *) malloc(sizeof(http_header_t));\n\t\t\tif (header == NULL) {\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tmembuffer_init(&header->name_buf);\n\t\t\tmembuffer_init(&header->value);\n\t\t\t/* value can be 0 length */\n\t\t\tif (hdr_value.length == (size_t)0) {\n\t\t\t\t/* FIXME: Is this a bug? buf is not const. */\n\t\t\t\thdr_value.buf = \"\\0\";\n\t\t\t\thdr_value.length = (size_t)1;\n\t\t\t}\n\t\t\t/* save in header in buffers */\n\t\t\tif (membuffer_assign(&header->name_buf, token.buf, token.length) ||\n\t\t\t    membuffer_assign(&header->value, hdr_value.buf, hdr_value.length)) {\n\t\t\t\t/* not enough mem */\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\theader->name.buf = header->name_buf.buf;\n\t\t\theader->name.length = header->name_buf.length;\n\t\t\theader->name_id = header_id;\n\t\t\tif (!ListAddTail(&parser->msg.headers, header)) {\n\t\t\t\tmembuffer_destroy(&header->value);\n\t\t\t\tmembuffer_destroy(&header->name_buf);\n\t\t\t\tfree(header);\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t} else if (hdr_value.length > (size_t)0) {\n\t\t\t/* append value to existing header */\n\t\t\t/* append space */\n\t\t\tret = membuffer_append_str(&orig_header->value, \", \");\n\t\t\t/* append continuation of header value */\n\t\t\tret2 = membuffer_append(&orig_header->value,\n\t\t\t\t\t\thdr_value.buf,\n\t\t\t\t\t\thdr_value.length);\n\t\t\tif (ret == UPNP_E_OUTOF_MEMORY\n\t\t\t    || ret2 == UPNP_E_OUTOF_MEMORY) {\n\t\t\t\t/* not enuf mem */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t}\n\t}\t\t\t/* end while */\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_append",
          "args": [
            "&parser->msg.msg",
            "buf",
            "(size_t)num_read"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "200-205",
          "snippet": "int membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append(membuffer *m, const void *buf, size_t buf_len)\n{\n\tassert(m != NULL);\n\n\treturn membuffer_insert(m, buf, buf_len, m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_read",
          "args": [
            "info",
            "buf",
            "sizeof(buf)",
            "timeout_secs"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "sock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "266-269",
          "snippet": "int sock_read(SOCKINFO *info, char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\treturn sock_read_write(info, buffer, bufsize, timeoutSecs, TRUE);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_read(SOCKINFO *info, char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\treturn sock_read_write(info, buffer, bufsize, timeoutSecs, TRUE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_parse_responseline",
          "args": [
            "parser"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "parser_parse_responseline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1367-1429",
          "snippet": "parse_status_t parser_parse_responseline(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\thttp_message_t *hmsg = &parser->msg;\n\tmemptr line;\n\tchar save_char;\n\tint num_scanned;\n\tint i;\n\tsize_t n;\n\tchar *p;\n\n\tassert(parser->position == POS_RESPONSE_LINE);\n\n\tstatus = skip_blank_lines(&parser->scanner);\n\tif (status != ( parse_status_t) PARSE_OK)\n\t\treturn status;\n\t/* response line */\n\t/*status = match( &parser->scanner, \"%ihttp%w/%w%d\\t.\\t%d\\t%d\\t%L%c\", */\n\t/*  &hmsg->major_version, &hmsg->minor_version, */\n\t/*  &hmsg->status_code, &hmsg->status_msg ); */\n\tstatus = match(&parser->scanner, \"%ihttp%w/%w%L%c\", &line);\n\tif (status != ( parse_status_t ) PARSE_OK)\n\t\treturn status;\n\tsave_char = line.buf[line.length];\n\tline.buf[line.length] = '\\0';\t/* null-terminate */\n\t/* scan http version and ret code */\n\tnum_scanned = sscanf(line.buf, \"%d . %d %d\",\n\t\t\t     &hmsg->major_version, &hmsg->minor_version,\n\t\t\t     &hmsg->status_code);\n\tline.buf[line.length] = save_char;\t/* restore */\n\tif (num_scanned != 3 ||\n\t    hmsg->major_version < 0 || hmsg->minor_version < 0 ||\n\t    hmsg->status_code < 0)\n\t\t/* bad response line */\n\t\treturn PARSE_FAILURE;\n\t/* point to status msg */\n\tp = line.buf;\n\t/* skip 3 ints */\n\tfor (i = 0; i < 3; i++) {\n\t\t/* go to start of num */\n\t\twhile (!isdigit(*p))\n\t\t\tp++;\n\t\t/* skip int */\n\t\twhile (isdigit(*p))\n\t\t\tp++;\n\t}\n\t/* whitespace must exist after status code */\n\tif (*p != ' ' && *p != '\\t')\n\t\treturn PARSE_FAILURE;\n\t/* skip whitespace */\n\twhile (*p == ' ' || *p == '\\t')\n\t\tp++;\n\t/* now, p is at start of status msg */\n\tn = line.length - ((size_t)p - (size_t)line.buf);\n\tif (membuffer_assign(&hmsg->status_msg, p, n) != 0) {\n\t\t/* out of mem */\n\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\treturn PARSE_FAILURE;\n\t}\n\tparser->position = POS_HEADERS;\t/* move to headers */\n\n\treturn PARSE_OK;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t parser_parse_responseline(INOUT http_parser_t *parser)\n{\n\tparse_status_t status;\n\thttp_message_t *hmsg = &parser->msg;\n\tmemptr line;\n\tchar save_char;\n\tint num_scanned;\n\tint i;\n\tsize_t n;\n\tchar *p;\n\n\tassert(parser->position == POS_RESPONSE_LINE);\n\n\tstatus = skip_blank_lines(&parser->scanner);\n\tif (status != ( parse_status_t) PARSE_OK)\n\t\treturn status;\n\t/* response line */\n\t/*status = match( &parser->scanner, \"%ihttp%w/%w%d\\t.\\t%d\\t%d\\t%L%c\", */\n\t/*  &hmsg->major_version, &hmsg->minor_version, */\n\t/*  &hmsg->status_code, &hmsg->status_msg ); */\n\tstatus = match(&parser->scanner, \"%ihttp%w/%w%L%c\", &line);\n\tif (status != ( parse_status_t ) PARSE_OK)\n\t\treturn status;\n\tsave_char = line.buf[line.length];\n\tline.buf[line.length] = '\\0';\t/* null-terminate */\n\t/* scan http version and ret code */\n\tnum_scanned = sscanf(line.buf, \"%d . %d %d\",\n\t\t\t     &hmsg->major_version, &hmsg->minor_version,\n\t\t\t     &hmsg->status_code);\n\tline.buf[line.length] = save_char;\t/* restore */\n\tif (num_scanned != 3 ||\n\t    hmsg->major_version < 0 || hmsg->minor_version < 0 ||\n\t    hmsg->status_code < 0)\n\t\t/* bad response line */\n\t\treturn PARSE_FAILURE;\n\t/* point to status msg */\n\tp = line.buf;\n\t/* skip 3 ints */\n\tfor (i = 0; i < 3; i++) {\n\t\t/* go to start of num */\n\t\twhile (!isdigit(*p))\n\t\t\tp++;\n\t\t/* skip int */\n\t\twhile (isdigit(*p))\n\t\t\tp++;\n\t}\n\t/* whitespace must exist after status code */\n\tif (*p != ' ' && *p != '\\t')\n\t\treturn PARSE_FAILURE;\n\t/* skip whitespace */\n\twhile (*p == ' ' || *p == '\\t')\n\t\tp++;\n\t/* now, p is at start of status msg */\n\tn = line.length - ((size_t)p - (size_t)line.buf);\n\tif (membuffer_assign(&hmsg->status_msg, p, n) != 0) {\n\t\t/* out of mem */\n\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\treturn PARSE_FAILURE;\n\t}\n\tparser->position = POS_HEADERS;\t/* move to headers */\n\n\treturn PARSE_OK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstatic int ReadResponseLineAndHeaders(\n\t/*! Socket information object. */\n\tIN SOCKINFO *info,\n\t/*! HTTP Parser object. */\n\tIN OUT http_parser_t *parser,\n\t/*! Time out value. */\n\tIN OUT int *timeout_secs,\n\t/*! HTTP errror code returned. */\n\tIN OUT int *http_error_code)\n{\n\tparse_status_t status;\n\tint num_read;\n\tchar buf[2 * 1024];\n\tint done = 0;\n\tint ret_code = 0;\n\n\t/*read response line */\n\tstatus = parser_parse_responseline(parser);\n\tswitch (status) {\n\tcase PARSE_OK:\n\t\tdone = 1;\n\t\tbreak;\n\tcase PARSE_INCOMPLETE:\n\t\tdone = 0;\n\t\tbreak;\n\tdefault:\n\t\t/*error */\n\t\treturn status;\n\t}\n\twhile (!done) {\n\t\tnum_read = sock_read(info, buf, sizeof(buf), timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code =\n\t\t\t\tmembuffer_append(&parser->msg.msg, buf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\tparser->http_error_code =\n\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_responseline(parser);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_OK:\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_INCOMPLETE:\n\t\t\t\tdone = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*error */\n\t\t\t\treturn status;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\t/* partial msg */\n\t\t\t*http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\tstatus = parser_parse_headers(parser);\n\tif ((status == (parse_status_t)PARSE_OK) &&\n\t\t(parser->position == (parser_pos_t)POS_ENTITY))\n\t\tdone = 1;\n\telse if (status == (parse_status_t)PARSE_INCOMPLETE)\n\t\tdone = 0;\n\telse\n\t\t/*error */\n\t\treturn status;\n\t/*read headers */\n\twhile (!done) {\n\t\tnum_read = sock_read(info, buf, sizeof(buf), timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* append data to buffer */\n\t\t\tret_code =\n\t\t\t    membuffer_append(&parser->msg.msg, buf, (size_t)num_read);\n\t\t\tif (ret_code != 0) {\n\t\t\t\t/* set failure status */\n\t\t\t\tparser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\treturn PARSE_FAILURE;\n\t\t\t}\n\t\t\tstatus = parser_parse_headers(parser);\n\t\t\tif (status == (parse_status_t)PARSE_OK &&\n\t\t\t\tparser->position == (parser_pos_t)POS_ENTITY)\n\t\t\t\tdone = 1;\n\t\t\telse if (status == (parse_status_t)PARSE_INCOMPLETE)\n\t\t\t\tdone = 0;\n\t\t\telse\n\t\t\t\t/*error */\n\t\t\t\treturn status;\n\t\t} else if (num_read == 0) {\n\t\t\t/* partial msg */\n\t\t\t*http_error_code = HTTP_BAD_REQUEST;\t/* or response */\n\t\t\treturn UPNP_E_BAD_HTTPMSG;\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\treturn num_read;\n\t\t}\n\t}\n\n\treturn PARSE_OK;\n}"
  },
  {
    "function_name": "MakeGenericMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "852-920",
    "snippet": "int MakeGenericMessage(http_method_t method,\n\t\t       const char *url_str, membuffer *request,\n\t\t       uri_type *url, int contentLength, const char *contentType,\n\t\t       const UpnpString *headers)\n{\n\tint ret_code = 0;\n\tsize_t hostlen = (size_t)0;\n\tchar *hoststr;\n\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"URL: %s method: %d\\n\", url_str, method);\n\tret_code = http_FixStrUrl(url_str, strlen(url_str), url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* make msg */\n\tmembuffer_init(request);\n\tret_code = http_MakeMessage(request, 1, 1, \"Q\",\n\t\t\t\t    method,\n\t\t\t\t    url->pathquery.buff,\n\t\t\t\t    url->pathquery.size);\n\t/* add request headers if specified, otherwise use default headers */\n\tif (ret_code == 0) {\n\t\tif (headers) {\n\t\t\tret_code = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t\t    \"s\",\n\t\t\t\t\t\t    UpnpString_get_String(headers));\n\t\t}\n\t\telse {\n\t\t\tret_code = get_hoststr(url_str, &hoststr, &hostlen);\n\t\t\tif (ret_code != UPNP_E_SUCCESS)\n\t\t\t\treturn ret_code;\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"HOSTNAME : %s Length : %\" PRIzu \"\\n\", hoststr, hostlen);\n\t\t\tret_code = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t\t    \"s\" \"bcDCU\",\n\t\t\t\t\t\t    \"HOST: \", hoststr, hostlen);\n\t\t}\n\t}\n\n\t/* add the content-type header */\n\tif (ret_code == 0 && contentType) {\n\t\tret_code = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t    \"T\",\n\t\t\t\t\t    contentType);\n\t}\n\t/* add content-length header. */\n\tif (ret_code == 0) {\n\t\tif (contentLength >= 0)\n\t\t\tret_code = http_MakeMessage(request, 1, 1, \"Nc\",\n\t\t\t\t\t\t    (off_t) contentLength);\n\t\telse if (contentLength == UPNP_USING_CHUNKED)\n\t\t\tret_code = http_MakeMessage(request, 1, 1, \"Kc\");\n\t\telse if (contentLength == UPNP_UNTIL_CLOSE)\n\t\t\tret_code = http_MakeMessage(request, 1, 1, \"c\");\n\t\telse\n\t\t\tret_code = UPNP_E_INVALID_PARAM;\n\t}\n\tif (ret_code != 0) {\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"HTTP Makemessage failed\\n\");\n\t\tmembuffer_destroy(request);\n\t\treturn ret_code;\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\",\n\t\t   request->buf);\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "HTTP",
            "__FILE__",
            "__LINE__",
            "\"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\"",
            "request->buf"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "request"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "request",
            "1",
            "1",
            "\"c\""
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hoststr",
          "args": [
            "url_str",
            "&hoststr",
            "&hostlen"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "get_hoststr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "179-198",
          "snippet": "static int get_hoststr(const char* url_str,\n                       char **hoststr,\n                       size_t *hostlen)\n{\n\tchar *urlPath = alloca(strlen(url_str) + 1);\n\tchar *temp;\n\tmemset(urlPath, 0, strlen(url_str) + 1);\n\tstrncpy(urlPath, url_str, strlen(url_str));\n\t*hoststr = strstr(urlPath, \"//\");\n\tif (*hoststr == NULL)\n\t\treturn UPNP_E_INVALID_URL;\n\t*hoststr += 2;\n\ttemp = strchr(*hoststr, '/');\n\tif (temp == NULL)\n\t\treturn UPNP_E_INVALID_URL;\n\t*temp = '\\0';\n\t*hostlen = strlen(*hoststr);\n\t*temp = '/';\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstatic int get_hoststr(const char* url_str,\n                       char **hoststr,\n                       size_t *hostlen)\n{\n\tchar *urlPath = alloca(strlen(url_str) + 1);\n\tchar *temp;\n\tmemset(urlPath, 0, strlen(url_str) + 1);\n\tstrncpy(urlPath, url_str, strlen(url_str));\n\t*hoststr = strstr(urlPath, \"//\");\n\tif (*hoststr == NULL)\n\t\treturn UPNP_E_INVALID_URL;\n\t*hoststr += 2;\n\ttemp = strchr(*hoststr, '/');\n\tif (temp == NULL)\n\t\treturn UPNP_E_INVALID_URL;\n\t*temp = '\\0';\n\t*hostlen = strlen(*hoststr);\n\t*temp = '/';\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpString_get_String",
          "args": [
            "headers"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_get_String",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "155-158",
          "snippet": "const char *UpnpString_get_String(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_string;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nconst char *UpnpString_get_String(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_string;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "request"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_FixStrUrl",
          "args": [
            "url_str",
            "strlen(url_str)",
            "url"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "http_FixStrUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "259-271",
          "snippet": "int http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint MakeGenericMessage(http_method_t method,\n\t\t       const char *url_str, membuffer *request,\n\t\t       uri_type *url, int contentLength, const char *contentType,\n\t\t       const UpnpString *headers)\n{\n\tint ret_code = 0;\n\tsize_t hostlen = (size_t)0;\n\tchar *hoststr;\n\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"URL: %s method: %d\\n\", url_str, method);\n\tret_code = http_FixStrUrl(url_str, strlen(url_str), url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* make msg */\n\tmembuffer_init(request);\n\tret_code = http_MakeMessage(request, 1, 1, \"Q\",\n\t\t\t\t    method,\n\t\t\t\t    url->pathquery.buff,\n\t\t\t\t    url->pathquery.size);\n\t/* add request headers if specified, otherwise use default headers */\n\tif (ret_code == 0) {\n\t\tif (headers) {\n\t\t\tret_code = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t\t    \"s\",\n\t\t\t\t\t\t    UpnpString_get_String(headers));\n\t\t}\n\t\telse {\n\t\t\tret_code = get_hoststr(url_str, &hoststr, &hostlen);\n\t\t\tif (ret_code != UPNP_E_SUCCESS)\n\t\t\t\treturn ret_code;\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"HOSTNAME : %s Length : %\" PRIzu \"\\n\", hoststr, hostlen);\n\t\t\tret_code = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t\t    \"s\" \"bcDCU\",\n\t\t\t\t\t\t    \"HOST: \", hoststr, hostlen);\n\t\t}\n\t}\n\n\t/* add the content-type header */\n\tif (ret_code == 0 && contentType) {\n\t\tret_code = http_MakeMessage(request, 1, 1,\n\t\t\t\t\t    \"T\",\n\t\t\t\t\t    contentType);\n\t}\n\t/* add content-length header. */\n\tif (ret_code == 0) {\n\t\tif (contentLength >= 0)\n\t\t\tret_code = http_MakeMessage(request, 1, 1, \"Nc\",\n\t\t\t\t\t\t    (off_t) contentLength);\n\t\telse if (contentLength == UPNP_USING_CHUNKED)\n\t\t\tret_code = http_MakeMessage(request, 1, 1, \"Kc\");\n\t\telse if (contentLength == UPNP_UNTIL_CLOSE)\n\t\t\tret_code = http_MakeMessage(request, 1, 1, \"c\");\n\t\telse\n\t\t\tret_code = UPNP_E_INVALID_PARAM;\n\t}\n\tif (ret_code != 0) {\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"HTTP Makemessage failed\\n\");\n\t\tmembuffer_destroy(request);\n\t\treturn ret_code;\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\",\n\t\t   request->buf);\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "http_Download",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "712-829",
    "snippet": "int http_Download( IN const char *url_str,\n               IN int timeout_secs,\n               OUT char **document,\n               OUT size_t *doc_length,\n               OUT char *content_type )\n{\n\tint ret_code;\n\turi_type url;\n\tchar *msg_start;\n\tchar *entity_start;\n\tchar *hoststr;\n\tchar *temp;\n\thttp_parser_t response;\n\tsize_t msg_length;\n\tsize_t hostlen;\n\tmemptr ctype;\n\tsize_t copy_len;\n\tmembuffer request;\n\tchar *urlPath = alloca(strlen(url_str) + (size_t)1);\n\n\t/*ret_code = parse_uri( (char*)url_str, strlen(url_str), &url ); */\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"DOWNLOAD URL : %s\\n\", url_str);\n\tret_code = http_FixStrUrl((char *)url_str, strlen(url_str), &url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* make msg */\n\tmembuffer_init(&request);\n\tmemset(urlPath, 0, strlen(url_str) + (size_t)1);\n\tstrncpy(urlPath, url_str, strlen(url_str));\n\thoststr = strstr(urlPath, \"//\");\n\tif (hoststr == NULL)\n\t\treturn UPNP_E_INVALID_URL;\n\thoststr += 2;\n\ttemp = strchr(hoststr, '/');\n\tif (temp) {\n\t\t*temp = '\\0';\n\t\thostlen = strlen(hoststr);\n\t\t*temp = '/';\n\t} else {\n\t\thostlen = strlen(hoststr);\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HOSTNAME : %s Length : %\" PRIzu \"\\n\", hoststr, hostlen);\n\tret_code = http_MakeMessage(&request, 1, 1,\n\t\t\t\t    \"Q\" \"s\" \"bcDCUc\",\n\t\t\t\t    HTTPMETHOD_GET, url.pathquery.buff,\n\t\t\t\t    url.pathquery.size, \"HOST: \", hoststr,\n\t\t\t\t    hostlen);\n\tif (ret_code != 0) {\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"HTTP Makemessage failed\\n\");\n\t\tmembuffer_destroy(&request);\n\t\treturn ret_code;\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\", request.buf);\n\t/* get doc msg */\n\tret_code =\n\t    http_RequestAndResponse(&url, request.buf, request.length,\n\t\t\t\t    HTTPMETHOD_GET, timeout_secs, &response);\n\n\tif (ret_code != 0) {\n\t\thttpmsg_destroy(&response.msg);\n\t\tmembuffer_destroy(&request);\n\t\treturn ret_code;\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__, \"Response\\n\");\n\tprint_http_headers(&response.msg);\n\t/* optional content-type */\n\tif (content_type) {\n\t\tif (httpmsg_find_hdr(&response.msg, HDR_CONTENT_TYPE, &ctype) ==\n\t\t    NULL) {\n\t\t\t*content_type = '\\0';\t/* no content-type */\n\t\t} else {\n\t\t\t/* safety */\n\t\t\tcopy_len = ctype.length < LINE_SIZE - (size_t)1 ?\n\t\t\t    ctype.length : LINE_SIZE - (size_t)1;\n\n\t\t\tmemcpy(content_type, ctype.buf, copy_len);\n\t\t\tcontent_type[copy_len] = '\\0';\n\t\t}\n\t}\n\t/* extract doc from msg */\n\tif ((*doc_length = response.msg.entity.length) == (size_t)0) {\n\t\t/* 0-length msg */\n\t\t*document = NULL;\n\t} else if (response.msg.status_code == HTTP_OK) {\n\t\t/*LEAK_FIX_MK */\n\t\t/* copy entity */\n\t\tentity_start = response.msg.entity.buf;\t/* what we want */\n\t\tmsg_length = response.msg.msg.length;\t/* save for posterity    */\n\t\tmsg_start = membuffer_detach(&response.msg.msg);\t/* whole msg */\n\t\t/* move entity to the start; copy null-terminator too */\n\t\tmemmove(msg_start, entity_start, *doc_length + (size_t)1);\n\t\t/* save mem for body only */\n\t\t*document = realloc(msg_start, *doc_length + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/* *document = Realloc( msg_start,msg_length, *doc_length + 1 ); LEAK_FIX_MK */\n\t\t/* shrink can't fail */\n\t\tassert(msg_length > *doc_length);\n\t\tassert(*document != NULL);\n\t\tif (msg_length <= *doc_length || *document == NULL)\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"msg_length(%\" PRIzu \") <= *doc_length(%\"\n\t\t\t\tPRIzu \") or document is NULL\",\n\t\t\t\tmsg_length, *doc_length);\n\t}\n\tif (response.msg.status_code == HTTP_OK) {\n\t\tret_code = 0;\t/* success */\n\t} else {\n\t\t/* server sent error msg (not requested doc) */\n\t\tret_code = response.msg.status_code;\n\t}\n\thttpmsg_destroy(&response.msg);\n\tmembuffer_destroy(&request);\n\n\treturn ret_code;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&request"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&response.msg"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "HTTP",
            "__FILE__",
            "__LINE__",
            "\"msg_length(%\" PRIzu \") <= *doc_length(%\"\n\t\t\t\tPRIzu \") or document is NULL\"",
            "msg_length",
            "*doc_length"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "*document != NULL"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "msg_length > *doc_length"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "msg_start",
            "*doc_length + (size_t)1"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "msg_start",
            "entity_start",
            "*doc_length + (size_t)1"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_detach",
          "args": [
            "&response.msg.msg"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "273-285",
          "snippet": "char *membuffer_detach(membuffer *m)\n{\n\tchar *buf;\n\n\tassert(m != NULL);\n\n\tbuf = m->buf;\n\n\t/* free all */\n\tmembuffer_initialize(m);\n\n\treturn buf;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nchar *membuffer_detach(membuffer *m)\n{\n\tchar *buf;\n\n\tassert(m != NULL);\n\n\tbuf = m->buf;\n\n\t/* free all */\n\tmembuffer_initialize(m);\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "content_type",
            "ctype.buf",
            "copy_len"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "&response.msg",
            "HDR_CONTENT_TYPE",
            "&ctype"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_http_headers",
          "args": [
            "&response.msg"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "print_http_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "2197-2227",
          "snippet": "void print_http_headers(http_message_t *hmsg)\n{\n    ListNode *node;\n    /* NNS:  dlist_node *node; */\n    http_header_t *header;\n\n    /* print start line */\n    if( hmsg->is_request ) {\n        printf( \"method = %d, version = %d.%d, url = %.*s\\n\", \n            hmsg->method, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->uri.pathquery.size, hmsg->uri.pathquery.buff);\n    } else {\n        printf( \"resp status = %d, version = %d.%d, status msg = %.*s\\n\",\n            hmsg->status_code, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->status_msg.length, hmsg->status_msg.buf);\n    }\n\n    /* print headers */\n    node = ListHead( &hmsg->headers );\n    /* NNS: node = dlist_first_node( &hmsg->headers ); */\n    while( node != NULL ) {\n        header = ( http_header_t * ) node->item;\n        /* NNS: header = (http_header_t *)node->data; */\n        printf( \"hdr name: %.*s, value: %.*s\\n\", \n            (int)header->name.length, header->name.buf,\n            (int)header->value.length, header->value.buf );\n\n        node = ListNext( &hmsg->headers, node );\n        /* NNS: node = dlist_next( &hmsg->headers, node ); */\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid print_http_headers(http_message_t *hmsg)\n{\n    ListNode *node;\n    /* NNS:  dlist_node *node; */\n    http_header_t *header;\n\n    /* print start line */\n    if( hmsg->is_request ) {\n        printf( \"method = %d, version = %d.%d, url = %.*s\\n\", \n            hmsg->method, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->uri.pathquery.size, hmsg->uri.pathquery.buff);\n    } else {\n        printf( \"resp status = %d, version = %d.%d, status msg = %.*s\\n\",\n            hmsg->status_code, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->status_msg.length, hmsg->status_msg.buf);\n    }\n\n    /* print headers */\n    node = ListHead( &hmsg->headers );\n    /* NNS: node = dlist_first_node( &hmsg->headers ); */\n    while( node != NULL ) {\n        header = ( http_header_t * ) node->item;\n        /* NNS: header = (http_header_t *)node->data; */\n        printf( \"hdr name: %.*s, value: %.*s\\n\", \n            (int)header->name.length, header->name.buf,\n            (int)header->value.length, header->value.buf );\n\n        node = ListNext( &hmsg->headers, node );\n        /* NNS: node = dlist_next( &hmsg->headers, node ); */\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_RequestAndResponse",
          "args": [
            "&url",
            "request.buf",
            "request.length",
            "HTTPMETHOD_GET",
            "timeout_secs",
            "&response"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "http_RequestAndResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "638-690",
          "snippet": "int http_RequestAndResponse(\n\tIN uri_type *destination,\n\tIN const char *request,\n\tIN size_t request_length,\n\tIN http_method_t req_method,\n\tIN int timeout_secs,\n\tOUT http_parser_t *response)\n{\n\tSOCKET tcp_connection;\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tint http_error_code;\n\tSOCKINFO info;\n\n\ttcp_connection = socket(\n\t\t(int)destination->hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tparser_response_init(response, req_method);\n\t\treturn UPNP_E_SOCKET_ERROR;\n\t}\n\tif (sock_init(&info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto end_function;\n\t}\n\t/* connect */\n\tsockaddr_len = destination->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(info.socket,\n\t\t(struct sockaddr *)&(destination->hostport.IPaddress),\n\t\t(socklen_t)sockaddr_len);\n\tif (ret_code == -1) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto end_function;\n\t}\n\t/* send request */\n\tret_code = http_SendMessage(&info, &timeout_secs, \"b\",\n\t\trequest, request_length);\n\tif (ret_code != 0) {\n\t\tparser_response_init(response, req_method);\n\t\tgoto end_function;\n\t}\n\t/* recv response */\n\tret_code = http_RecvMessage(&info, response, req_method,\n\t\t&timeout_secs, &http_error_code);\n\nend_function:\n\t/* should shutdown completely */\n\tsock_destroy(&info, SD_BOTH);\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_RequestAndResponse(\n\tIN uri_type *destination,\n\tIN const char *request,\n\tIN size_t request_length,\n\tIN http_method_t req_method,\n\tIN int timeout_secs,\n\tOUT http_parser_t *response)\n{\n\tSOCKET tcp_connection;\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tint http_error_code;\n\tSOCKINFO info;\n\n\ttcp_connection = socket(\n\t\t(int)destination->hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tparser_response_init(response, req_method);\n\t\treturn UPNP_E_SOCKET_ERROR;\n\t}\n\tif (sock_init(&info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto end_function;\n\t}\n\t/* connect */\n\tsockaddr_len = destination->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(info.socket,\n\t\t(struct sockaddr *)&(destination->hostport.IPaddress),\n\t\t(socklen_t)sockaddr_len);\n\tif (ret_code == -1) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto end_function;\n\t}\n\t/* send request */\n\tret_code = http_SendMessage(&info, &timeout_secs, \"b\",\n\t\trequest, request_length);\n\tif (ret_code != 0) {\n\t\tparser_response_init(response, req_method);\n\t\tgoto end_function;\n\t}\n\t/* recv response */\n\tret_code = http_RecvMessage(&info, response, req_method,\n\t\t&timeout_secs, &http_error_code);\n\nend_function:\n\t/* should shutdown completely */\n\tsock_destroy(&info, SD_BOTH);\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&request",
            "1",
            "1",
            "\"Q\" \"s\" \"bcDCUc\"",
            "HTTPMETHOD_GET",
            "url.pathquery.buff",
            "url.pathquery.size",
            "\"HOST: \"",
            "hoststr",
            "hostlen"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hoststr"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hoststr"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "hoststr",
            "'/'"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "urlPath",
            "\"//\""
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "urlPath",
            "url_str",
            "strlen(url_str)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "urlPath",
            "0",
            "strlen(url_str) + (size_t)1"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&request"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_FixStrUrl",
          "args": [
            "(char *)url_str",
            "strlen(url_str)",
            "&url"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "http_FixStrUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "259-271",
          "snippet": "int http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(url_str) + (size_t)1"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_Download( IN const char *url_str,\n               IN int timeout_secs,\n               OUT char **document,\n               OUT size_t *doc_length,\n               OUT char *content_type )\n{\n\tint ret_code;\n\turi_type url;\n\tchar *msg_start;\n\tchar *entity_start;\n\tchar *hoststr;\n\tchar *temp;\n\thttp_parser_t response;\n\tsize_t msg_length;\n\tsize_t hostlen;\n\tmemptr ctype;\n\tsize_t copy_len;\n\tmembuffer request;\n\tchar *urlPath = alloca(strlen(url_str) + (size_t)1);\n\n\t/*ret_code = parse_uri( (char*)url_str, strlen(url_str), &url ); */\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"DOWNLOAD URL : %s\\n\", url_str);\n\tret_code = http_FixStrUrl((char *)url_str, strlen(url_str), &url);\n\tif (ret_code != UPNP_E_SUCCESS)\n\t\treturn ret_code;\n\t/* make msg */\n\tmembuffer_init(&request);\n\tmemset(urlPath, 0, strlen(url_str) + (size_t)1);\n\tstrncpy(urlPath, url_str, strlen(url_str));\n\thoststr = strstr(urlPath, \"//\");\n\tif (hoststr == NULL)\n\t\treturn UPNP_E_INVALID_URL;\n\thoststr += 2;\n\ttemp = strchr(hoststr, '/');\n\tif (temp) {\n\t\t*temp = '\\0';\n\t\thostlen = strlen(hoststr);\n\t\t*temp = '/';\n\t} else {\n\t\thostlen = strlen(hoststr);\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HOSTNAME : %s Length : %\" PRIzu \"\\n\", hoststr, hostlen);\n\tret_code = http_MakeMessage(&request, 1, 1,\n\t\t\t\t    \"Q\" \"s\" \"bcDCUc\",\n\t\t\t\t    HTTPMETHOD_GET, url.pathquery.buff,\n\t\t\t\t    url.pathquery.size, \"HOST: \", hoststr,\n\t\t\t\t    hostlen);\n\tif (ret_code != 0) {\n\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t   \"HTTP Makemessage failed\\n\");\n\t\tmembuffer_destroy(&request);\n\t\treturn ret_code;\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t   \"HTTP Buffer:\\n%s\\n\" \"----------END--------\\n\", request.buf);\n\t/* get doc msg */\n\tret_code =\n\t    http_RequestAndResponse(&url, request.buf, request.length,\n\t\t\t\t    HTTPMETHOD_GET, timeout_secs, &response);\n\n\tif (ret_code != 0) {\n\t\thttpmsg_destroy(&response.msg);\n\t\tmembuffer_destroy(&request);\n\t\treturn ret_code;\n\t}\n\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__, \"Response\\n\");\n\tprint_http_headers(&response.msg);\n\t/* optional content-type */\n\tif (content_type) {\n\t\tif (httpmsg_find_hdr(&response.msg, HDR_CONTENT_TYPE, &ctype) ==\n\t\t    NULL) {\n\t\t\t*content_type = '\\0';\t/* no content-type */\n\t\t} else {\n\t\t\t/* safety */\n\t\t\tcopy_len = ctype.length < LINE_SIZE - (size_t)1 ?\n\t\t\t    ctype.length : LINE_SIZE - (size_t)1;\n\n\t\t\tmemcpy(content_type, ctype.buf, copy_len);\n\t\t\tcontent_type[copy_len] = '\\0';\n\t\t}\n\t}\n\t/* extract doc from msg */\n\tif ((*doc_length = response.msg.entity.length) == (size_t)0) {\n\t\t/* 0-length msg */\n\t\t*document = NULL;\n\t} else if (response.msg.status_code == HTTP_OK) {\n\t\t/*LEAK_FIX_MK */\n\t\t/* copy entity */\n\t\tentity_start = response.msg.entity.buf;\t/* what we want */\n\t\tmsg_length = response.msg.msg.length;\t/* save for posterity    */\n\t\tmsg_start = membuffer_detach(&response.msg.msg);\t/* whole msg */\n\t\t/* move entity to the start; copy null-terminator too */\n\t\tmemmove(msg_start, entity_start, *doc_length + (size_t)1);\n\t\t/* save mem for body only */\n\t\t*document = realloc(msg_start, *doc_length + (size_t)1);\t/*LEAK_FIX_MK */\n\t\t/* *document = Realloc( msg_start,msg_length, *doc_length + 1 ); LEAK_FIX_MK */\n\t\t/* shrink can't fail */\n\t\tassert(msg_length > *doc_length);\n\t\tassert(*document != NULL);\n\t\tif (msg_length <= *doc_length || *document == NULL)\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"msg_length(%\" PRIzu \") <= *doc_length(%\"\n\t\t\t\tPRIzu \") or document is NULL\",\n\t\t\t\tmsg_length, *doc_length);\n\t}\n\tif (response.msg.status_code == HTTP_OK) {\n\t\tret_code = 0;\t/* success */\n\t} else {\n\t\t/* server sent error msg (not requested doc) */\n\t\tret_code = response.msg.status_code;\n\t}\n\thttpmsg_destroy(&response.msg);\n\tmembuffer_destroy(&request);\n\n\treturn ret_code;\n}"
  },
  {
    "function_name": "http_RequestAndResponse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "638-690",
    "snippet": "int http_RequestAndResponse(\n\tIN uri_type *destination,\n\tIN const char *request,\n\tIN size_t request_length,\n\tIN http_method_t req_method,\n\tIN int timeout_secs,\n\tOUT http_parser_t *response)\n{\n\tSOCKET tcp_connection;\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tint http_error_code;\n\tSOCKINFO info;\n\n\ttcp_connection = socket(\n\t\t(int)destination->hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tparser_response_init(response, req_method);\n\t\treturn UPNP_E_SOCKET_ERROR;\n\t}\n\tif (sock_init(&info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto end_function;\n\t}\n\t/* connect */\n\tsockaddr_len = destination->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(info.socket,\n\t\t(struct sockaddr *)&(destination->hostport.IPaddress),\n\t\t(socklen_t)sockaddr_len);\n\tif (ret_code == -1) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto end_function;\n\t}\n\t/* send request */\n\tret_code = http_SendMessage(&info, &timeout_secs, \"b\",\n\t\trequest, request_length);\n\tif (ret_code != 0) {\n\t\tparser_response_init(response, req_method);\n\t\tgoto end_function;\n\t}\n\t/* recv response */\n\tret_code = http_RecvMessage(&info, response, req_method,\n\t\t&timeout_secs, &http_error_code);\n\nend_function:\n\t/* should shutdown completely */\n\tsock_destroy(&info, SD_BOTH);\n\n\treturn ret_code;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sock_destroy",
          "args": [
            "&info",
            "SD_BOTH"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "sock_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "118-143",
          "snippet": "int sock_destroy(SOCKINFO *info, int ShutdownMethod)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (info->socket != INVALID_SOCKET) {\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t\tif (info->ssl) {\n\t\t\tSSL_shutdown(info->ssl);\n\t\t\tSSL_free(info->ssl);\n\t\t\tinfo->ssl = NULL;\n\t\t}\n#endif\n\t\tif (shutdown(info->socket, ShutdownMethod) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tif (sock_close(info->socket) == -1) {\n\t\t\tret = UPNP_E_SOCKET_ERROR;\n\t\t}\n\t\tinfo->socket = INVALID_SOCKET;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_destroy(SOCKINFO *info, int ShutdownMethod)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\tif (info->socket != INVALID_SOCKET) {\n#ifdef UPNP_ENABLE_OPEN_SSL\n\t\tif (info->ssl) {\n\t\t\tSSL_shutdown(info->ssl);\n\t\t\tSSL_free(info->ssl);\n\t\t\tinfo->ssl = NULL;\n\t\t}\n#endif\n\t\tif (shutdown(info->socket, ShutdownMethod) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tif (sock_close(info->socket) == -1) {\n\t\t\tret = UPNP_E_SOCKET_ERROR;\n\t\t}\n\t\tinfo->socket = INVALID_SOCKET;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_RecvMessage",
          "args": [
            "&info",
            "response",
            "req_method",
            "&timeout_secs",
            "&http_error_code"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "http_RecvMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "344-435",
          "snippet": "int http_RecvMessage(\n\tIN SOCKINFO *info,\n\tOUT http_parser_t *parser,\n\tIN http_method_t request_method,\n\tIN OUT int *timeout_secs,\n\tOUT int *http_error_code)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tint line = 0;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar buf[2 * 1024];\n\n\tif (request_method == (http_method_t)HTTPMETHOD_UNKNOWN) {\n\t\tparser_request_init(parser);\n\t} else {\n\t\tparser_response_init(parser, request_method);\n\t}\n\n\twhile (TRUE) {\n\t\tnum_read = sock_read(info, buf, sizeof buf, timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* got data */\n\t\t\tstatus = parser_append(parser, buf, (size_t)num_read);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_SUCCESS:\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers( &parser->msg );\n\t\t\t\tif (g_maxContentLength > (size_t)0 && parser->content_length > (unsigned int)g_maxContentLength) {\n\t\t\t\t\t*http_error_code = HTTP_REQ_ENTITY_TOO_LARGE;\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_BOUNDS;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_FAILURE:\n\t\t\tcase PARSE_NO_MATCH:\n\t\t\t\t*http_error_code = parser->http_error_code;\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_INCOMPLETE_ENTITY:\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_CONTINUE_1:\n\t\t\t\t/* Web post request. */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = PARSE_SUCCESS;\n\t\t\t\tgoto ExitFunction;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*http_error_code = HTTP_BAD_REQUEST;    /* or response */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\tline = __LINE__;\n\t\t\tret = num_read;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, line,\n\t\t\t\"(http_RecvMessage): Error %d, http_error_code = %d.\\n\",\n\t\t\tret,\n\t\t\t*http_error_code);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_RecvMessage(\n\tIN SOCKINFO *info,\n\tOUT http_parser_t *parser,\n\tIN http_method_t request_method,\n\tIN OUT int *timeout_secs,\n\tOUT int *http_error_code)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tint line = 0;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar buf[2 * 1024];\n\n\tif (request_method == (http_method_t)HTTPMETHOD_UNKNOWN) {\n\t\tparser_request_init(parser);\n\t} else {\n\t\tparser_response_init(parser, request_method);\n\t}\n\n\twhile (TRUE) {\n\t\tnum_read = sock_read(info, buf, sizeof buf, timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* got data */\n\t\t\tstatus = parser_append(parser, buf, (size_t)num_read);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_SUCCESS:\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers( &parser->msg );\n\t\t\t\tif (g_maxContentLength > (size_t)0 && parser->content_length > (unsigned int)g_maxContentLength) {\n\t\t\t\t\t*http_error_code = HTTP_REQ_ENTITY_TOO_LARGE;\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_BOUNDS;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_FAILURE:\n\t\t\tcase PARSE_NO_MATCH:\n\t\t\t\t*http_error_code = parser->http_error_code;\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_INCOMPLETE_ENTITY:\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_CONTINUE_1:\n\t\t\t\t/* Web post request. */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = PARSE_SUCCESS;\n\t\t\t\tgoto ExitFunction;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*http_error_code = HTTP_BAD_REQUEST;    /* or response */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\tline = __LINE__;\n\t\t\tret = num_read;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, line,\n\t\t\t\"(http_RecvMessage): Error %d, http_error_code = %d.\\n\",\n\t\t\tret,\n\t\t\t*http_error_code);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_response_init",
          "args": [
            "response",
            "req_method"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "parser_response_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1985-1994",
          "snippet": "void\nparser_response_init( OUT http_parser_t * parser,\n                      IN http_method_t request_method )\n{\n    parser_init( parser );\n    parser->msg.is_request = FALSE;\n    parser->msg.request_method = request_method;\n    parser->msg.amount_discarded = (size_t)0;\n    parser->position = POS_RESPONSE_LINE;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid\nparser_response_init( OUT http_parser_t * parser,\n                      IN http_method_t request_method )\n{\n    parser_init( parser );\n    parser->msg.is_request = FALSE;\n    parser->msg.request_method = request_method;\n    parser->msg.amount_discarded = (size_t)0;\n    parser->position = POS_RESPONSE_LINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_SendMessage",
          "args": [
            "&info",
            "&timeout_secs",
            "\"b\"",
            "request",
            "request_length"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "437-613",
          "snippet": "int http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CHUNK_TAIL_SIZE (size_t)10",
            "#define CHUNK_HEADER_SIZE (size_t)10",
            "#define snprintf _snprintf",
            "#define fseeko fseek"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n#define snprintf _snprintf\n#define fseeko fseek\n\nint http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "private_connect",
          "args": [
            "info.socket",
            "(struct sockaddr *)&(destination->hostport.IPaddress)",
            "(socklen_t)sockaddr_len"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "private_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "146-165",
          "snippet": "static int private_connect(\n\tSOCKET sockfd,\n\tconst struct sockaddr *serv_addr,\n\tsocklen_t addrlen)\n{\n#ifndef UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS\n\tint ret = sock_make_no_blocking(sockfd);\n\tif (ret != - 1) {\n\t\tret = connect(sockfd, serv_addr, addrlen);\n\t\tret = Check_Connect_And_Wait_Connection(sockfd, ret);\n\t\tif (ret != - 1) {\n\t\t\tret = sock_make_blocking(sockfd);\n\t\t}\n\t}\n\n\treturn ret;\n#else\n\treturn connect(sockfd, serv_addr, addrlen);\n#endif /* UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS */\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstatic int private_connect(\n\tSOCKET sockfd,\n\tconst struct sockaddr *serv_addr,\n\tsocklen_t addrlen)\n{\n#ifndef UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS\n\tint ret = sock_make_no_blocking(sockfd);\n\tif (ret != - 1) {\n\t\tret = connect(sockfd, serv_addr, addrlen);\n\t\tret = Check_Connect_And_Wait_Connection(sockfd, ret);\n\t\tif (ret != - 1) {\n\t\t\tret = sock_make_blocking(sockfd);\n\t\t}\n\t}\n\n\treturn ret;\n#else\n\treturn connect(sockfd, serv_addr, addrlen);\n#endif /* UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_init",
          "args": [
            "&info",
            "tcp_connection"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "sock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "73-81",
          "snippet": "int sock_init(SOCKINFO *info, SOCKET sockfd)\n{\n\tassert(info);\n\n\tmemset(info, 0, sizeof(SOCKINFO));\n\tinfo->socket = sockfd;\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_init(SOCKINFO *info, SOCKET sockfd)\n{\n\tassert(info);\n\n\tmemset(info, 0, sizeof(SOCKINFO));\n\tinfo->socket = sockfd;\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "(int)destination->hostport.IPaddress.ss_family",
            "SOCK_STREAM",
            "0"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_RequestAndResponse(\n\tIN uri_type *destination,\n\tIN const char *request,\n\tIN size_t request_length,\n\tIN http_method_t req_method,\n\tIN int timeout_secs,\n\tOUT http_parser_t *response)\n{\n\tSOCKET tcp_connection;\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tint http_error_code;\n\tSOCKINFO info;\n\n\ttcp_connection = socket(\n\t\t(int)destination->hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tparser_response_init(response, req_method);\n\t\treturn UPNP_E_SOCKET_ERROR;\n\t}\n\tif (sock_init(&info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto end_function;\n\t}\n\t/* connect */\n\tsockaddr_len = destination->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(info.socket,\n\t\t(struct sockaddr *)&(destination->hostport.IPaddress),\n\t\t(socklen_t)sockaddr_len);\n\tif (ret_code == -1) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto end_function;\n\t}\n\t/* send request */\n\tret_code = http_SendMessage(&info, &timeout_secs, \"b\",\n\t\trequest, request_length);\n\tif (ret_code != 0) {\n\t\tparser_response_init(response, req_method);\n\t\tgoto end_function;\n\t}\n\t/* recv response */\n\tret_code = http_RecvMessage(&info, response, req_method,\n\t\t&timeout_secs, &http_error_code);\n\nend_function:\n\t/* should shutdown completely */\n\tsock_destroy(&info, SD_BOTH);\n\n\treturn ret_code;\n}"
  },
  {
    "function_name": "http_SendMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "437-613",
    "snippet": "int http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CHUNK_TAIL_SIZE (size_t)10",
      "#define CHUNK_HEADER_SIZE (size_t)10",
      "#define snprintf _snprintf",
      "#define fseeko fseek"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ChunkBuf"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "httpheader_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "381-388",
          "snippet": "static void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nstatic void httpheader_free(void *msg)\n{\n    http_header_t *hdr = ( http_header_t * ) msg;\n\n    membuffer_destroy( &hdr->name_buf );\n    membuffer_destroy( &hdr->value );\n    free( hdr );\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "argp"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "HTTP",
            "__FILE__",
            "__LINE__",
            "\">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\"",
            "(int)buf_length",
            "buf",
            "buf_length",
            "num_written"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_write",
          "args": [
            "info",
            "buf",
            "buf_length",
            "TimeOut"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "sock_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "271-275",
          "snippet": "int sock_write(SOCKINFO *info, const char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\t/* Consciently removing constness. */\n\treturn sock_read_write(info, (char *)buffer, bufsize, timeoutSecs, FALSE);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_write(SOCKINFO *info, const char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\t/* Consciently removing constness. */\n\treturn sock_read_write(info, (char *)buffer, bufsize, timeoutSecs, FALSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "size_t"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "char*"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "Fp"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virtualDirCallback.close",
          "args": [
            "Fp"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "Chunk_Header"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "Chunk_Header"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "Chunk_Header"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "file_buf - strlen(Chunk_Header)",
            "Chunk_Header",
            "strlen(Chunk_Header)"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "333-340",
          "snippet": "static void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memcpy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memcpy;\n\nstatic void\nMD5_memcpy(POINTER  output, POINTER  input, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\toutput[i] = input[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "Chunk_Header"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "Chunk_Header"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "Chunk_Header",
            "sizeof(Chunk_Header)",
            "\"%\" PRIzx \"\\r\\n\"",
            "num_read"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "Chunk_Header",
            "0",
            "sizeof(Chunk_Header)"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "file_buf",
            "(size_t)1",
            "Data_Buf_Size",
            "Fp"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "file_buf",
            "(size_t)1",
            "n",
            "Fp"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virtualDirCallback.read",
          "args": [
            "Fp",
            "file_buf",
            "n"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseeko",
          "args": [
            "Fp",
            "Instr->RangeOffset",
            "SEEK_CUR"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virtualDirCallback.seek",
          "args": [
            "Fp",
            "Instr->RangeOffset",
            "SEEK_CUR"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "filename",
            "\"rb\""
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "filename",
            "UPNP_READ"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "char*"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "structSendInstruction*"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "argp",
            "fmt"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n#define snprintf _snprintf\n#define fseeko fseek\n\nint http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}"
  },
  {
    "function_name": "http_RecvMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "344-435",
    "snippet": "int http_RecvMessage(\n\tIN SOCKINFO *info,\n\tOUT http_parser_t *parser,\n\tIN http_method_t request_method,\n\tIN OUT int *timeout_secs,\n\tOUT int *http_error_code)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tint line = 0;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar buf[2 * 1024];\n\n\tif (request_method == (http_method_t)HTTPMETHOD_UNKNOWN) {\n\t\tparser_request_init(parser);\n\t} else {\n\t\tparser_response_init(parser, request_method);\n\t}\n\n\twhile (TRUE) {\n\t\tnum_read = sock_read(info, buf, sizeof buf, timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* got data */\n\t\t\tstatus = parser_append(parser, buf, (size_t)num_read);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_SUCCESS:\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers( &parser->msg );\n\t\t\t\tif (g_maxContentLength > (size_t)0 && parser->content_length > (unsigned int)g_maxContentLength) {\n\t\t\t\t\t*http_error_code = HTTP_REQ_ENTITY_TOO_LARGE;\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_BOUNDS;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_FAILURE:\n\t\t\tcase PARSE_NO_MATCH:\n\t\t\t\t*http_error_code = parser->http_error_code;\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_INCOMPLETE_ENTITY:\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_CONTINUE_1:\n\t\t\t\t/* Web post request. */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = PARSE_SUCCESS;\n\t\t\t\tgoto ExitFunction;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*http_error_code = HTTP_BAD_REQUEST;    /* or response */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\tline = __LINE__;\n\t\t\tret = num_read;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, line,\n\t\t\t\"(http_RecvMessage): Error %d, http_error_code = %d.\\n\",\n\t\t\tret,\n\t\t\t*http_error_code);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_ALL",
            "HTTP",
            "__FILE__",
            "line",
            "\"(http_RecvMessage): Error %d, http_error_code = %d.\\n\"",
            "ret",
            "*http_error_code"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_http_headers",
          "args": [
            "&parser->msg"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "print_http_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "2197-2227",
          "snippet": "void print_http_headers(http_message_t *hmsg)\n{\n    ListNode *node;\n    /* NNS:  dlist_node *node; */\n    http_header_t *header;\n\n    /* print start line */\n    if( hmsg->is_request ) {\n        printf( \"method = %d, version = %d.%d, url = %.*s\\n\", \n            hmsg->method, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->uri.pathquery.size, hmsg->uri.pathquery.buff);\n    } else {\n        printf( \"resp status = %d, version = %d.%d, status msg = %.*s\\n\",\n            hmsg->status_code, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->status_msg.length, hmsg->status_msg.buf);\n    }\n\n    /* print headers */\n    node = ListHead( &hmsg->headers );\n    /* NNS: node = dlist_first_node( &hmsg->headers ); */\n    while( node != NULL ) {\n        header = ( http_header_t * ) node->item;\n        /* NNS: header = (http_header_t *)node->data; */\n        printf( \"hdr name: %.*s, value: %.*s\\n\", \n            (int)header->name.length, header->name.buf,\n            (int)header->value.length, header->value.buf );\n\n        node = ListNext( &hmsg->headers, node );\n        /* NNS: node = dlist_next( &hmsg->headers, node ); */\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid print_http_headers(http_message_t *hmsg)\n{\n    ListNode *node;\n    /* NNS:  dlist_node *node; */\n    http_header_t *header;\n\n    /* print start line */\n    if( hmsg->is_request ) {\n        printf( \"method = %d, version = %d.%d, url = %.*s\\n\", \n            hmsg->method, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->uri.pathquery.size, hmsg->uri.pathquery.buff);\n    } else {\n        printf( \"resp status = %d, version = %d.%d, status msg = %.*s\\n\",\n            hmsg->status_code, hmsg->major_version, hmsg->minor_version,\n            (int)hmsg->status_msg.length, hmsg->status_msg.buf);\n    }\n\n    /* print headers */\n    node = ListHead( &hmsg->headers );\n    /* NNS: node = dlist_first_node( &hmsg->headers ); */\n    while( node != NULL ) {\n        header = ( http_header_t * ) node->item;\n        /* NNS: header = (http_header_t *)node->data; */\n        printf( \"hdr name: %.*s, value: %.*s\\n\", \n            (int)header->name.length, header->name.buf,\n            (int)header->value.length, header->value.buf );\n\n        node = ListNext( &hmsg->headers, node );\n        /* NNS: node = dlist_next( &hmsg->headers, node ); */\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_append",
          "args": [
            "parser",
            "buf",
            "(size_t)num_read"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "parser_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "2074-2093",
          "snippet": "parse_status_t\nparser_append( INOUT http_parser_t * parser,\n               IN const char *buf,\n               IN size_t buf_length )\n{\n    int ret_code;\n\n    assert( parser != NULL );\n    assert( buf != NULL );\n\n    /* append data to buffer */\n    ret_code = membuffer_append( &parser->msg.msg, buf, buf_length );\n    if( ret_code != 0 ) {\n        /* set failure status */\n        parser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n        return PARSE_FAILURE;\n    }\n\n    return parser_parse( parser );\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nparser_append( INOUT http_parser_t * parser,\n               IN const char *buf,\n               IN size_t buf_length )\n{\n    int ret_code;\n\n    assert( parser != NULL );\n    assert( buf != NULL );\n\n    /* append data to buffer */\n    ret_code = membuffer_append( &parser->msg.msg, buf, buf_length );\n    if( ret_code != 0 ) {\n        /* set failure status */\n        parser->http_error_code = HTTP_INTERNAL_SERVER_ERROR;\n        return PARSE_FAILURE;\n    }\n\n    return parser_parse( parser );\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock_read",
          "args": [
            "info",
            "buf",
            "sizeof buf",
            "timeout_secs"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "sock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "266-269",
          "snippet": "int sock_read(SOCKINFO *info, char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\treturn sock_read_write(info, buffer, bufsize, timeoutSecs, TRUE);\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_read(SOCKINFO *info, char *buffer, size_t bufsize, int *timeoutSecs)\n{\n\treturn sock_read_write(info, buffer, bufsize, timeoutSecs, TRUE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_response_init",
          "args": [
            "parser",
            "request_method"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "parser_response_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1985-1994",
          "snippet": "void\nparser_response_init( OUT http_parser_t * parser,\n                      IN http_method_t request_method )\n{\n    parser_init( parser );\n    parser->msg.is_request = FALSE;\n    parser->msg.request_method = request_method;\n    parser->msg.amount_discarded = (size_t)0;\n    parser->position = POS_RESPONSE_LINE;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid\nparser_response_init( OUT http_parser_t * parser,\n                      IN http_method_t request_method )\n{\n    parser_init( parser );\n    parser->msg.is_request = FALSE;\n    parser->msg.request_method = request_method;\n    parser->msg.amount_discarded = (size_t)0;\n    parser->position = POS_RESPONSE_LINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser_request_init",
          "args": [
            "parser"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "parser_request_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1965-1971",
          "snippet": "void\nparser_request_init( OUT http_parser_t * parser )\n{\n    parser_init( parser );\n    parser->msg.is_request = TRUE;\n    parser->position = POS_REQUEST_LINE;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid\nparser_request_init( OUT http_parser_t * parser )\n{\n    parser_init( parser );\n    parser->msg.is_request = TRUE;\n    parser->position = POS_REQUEST_LINE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_RecvMessage(\n\tIN SOCKINFO *info,\n\tOUT http_parser_t *parser,\n\tIN http_method_t request_method,\n\tIN OUT int *timeout_secs,\n\tOUT int *http_error_code)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tint line = 0;\n\tparse_status_t status;\n\tint num_read;\n\tint ok_on_close = FALSE;\n\tchar buf[2 * 1024];\n\n\tif (request_method == (http_method_t)HTTPMETHOD_UNKNOWN) {\n\t\tparser_request_init(parser);\n\t} else {\n\t\tparser_response_init(parser, request_method);\n\t}\n\n\twhile (TRUE) {\n\t\tnum_read = sock_read(info, buf, sizeof buf, timeout_secs);\n\t\tif (num_read > 0) {\n\t\t\t/* got data */\n\t\t\tstatus = parser_append(parser, buf, (size_t)num_read);\n\t\t\tswitch (status) {\n\t\t\tcase PARSE_SUCCESS:\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers( &parser->msg );\n\t\t\t\tif (g_maxContentLength > (size_t)0 && parser->content_length > (unsigned int)g_maxContentLength) {\n\t\t\t\t\t*http_error_code = HTTP_REQ_ENTITY_TOO_LARGE;\n\t\t\t\t\tline = __LINE__;\n\t\t\t\t\tret = UPNP_E_OUTOF_BOUNDS;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_FAILURE:\n\t\t\tcase PARSE_NO_MATCH:\n\t\t\t\t*http_error_code = parser->http_error_code;\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\tcase PARSE_INCOMPLETE_ENTITY:\n\t\t\t\t/* read until close */\n\t\t\t\tok_on_close = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase PARSE_CONTINUE_1:\n\t\t\t\t/* Web post request. */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = PARSE_SUCCESS;\n\t\t\t\tgoto ExitFunction;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (num_read == 0) {\n\t\t\tif (ok_on_close) {\n\t\t\t\tUpnpPrintf( UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\tparser->msg.msg.buf );\n\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = 0;\n\t\t\t\tgoto ExitFunction;\n\t\t\t} else {\n\t\t\t\t/* partial msg */\n\t\t\t\t*http_error_code = HTTP_BAD_REQUEST;    /* or response */\n\t\t\t\tline = __LINE__;\n\t\t\t\tret = UPNP_E_BAD_HTTPMSG;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\t*http_error_code = parser->http_error_code;\n\t\t\tline = __LINE__;\n\t\t\tret = num_read;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t}\n\nExitFunction:\n\tif (ret != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, line,\n\t\t\t\"(http_RecvMessage): Error %d, http_error_code = %d.\\n\",\n\t\t\tret,\n\t\t\t*http_error_code);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "http_Connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "288-323",
    "snippet": "SOCKET http_Connect(\n\tIN uri_type *destination_url,\n\tOUT uri_type *url)\n{\n\tSOCKET connfd;\n\tsocklen_t sockaddr_len;\n\tint ret_connect;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\thttp_FixUrl(destination_url, url);\n\n\tconnfd = socket((int)url->hostport.IPaddress.ss_family,\n\t\tSOCK_STREAM, 0);\n\tif (connfd == INVALID_SOCKET) {\n\t\treturn (SOCKET)(UPNP_E_OUTOF_SOCKET);\n\t}\n\tsockaddr_len = (socklen_t)(url->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in));\n\tret_connect = private_connect(connfd,\n\t\t(struct sockaddr *)&url->hostport.IPaddress, sockaddr_len);\n\tif (ret_connect == -1) {\n#ifdef WIN32\n\t\tUpnpPrintf(UPNP_CRITICAL, HTTP, __FILE__, __LINE__,\n\t\t\t\"connect error: %d\\n\", WSAGetLastError());\n#endif\n\t\tif (shutdown(connfd, SD_BOTH) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tUpnpCloseSocket(connfd);\n\t\treturn (SOCKET)(UPNP_E_SOCKET_CONNECT);\n\t}\n\n\treturn connfd;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "UPNP_E_SOCKET_CONNECT"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpCloseSocket",
          "args": [
            "connfd"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "HTTP",
            "__FILE__",
            "__LINE__",
            "\"Error in shutdown: %s\\n\"",
            "errorBuffer"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errno",
            "errorBuffer",
            "ERROR_BUFFER_LEN"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "connfd",
            "SD_BOTH"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "private_connect",
          "args": [
            "connfd",
            "(struct sockaddr *)&url->hostport.IPaddress",
            "sockaddr_len"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "private_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "146-165",
          "snippet": "static int private_connect(\n\tSOCKET sockfd,\n\tconst struct sockaddr *serv_addr,\n\tsocklen_t addrlen)\n{\n#ifndef UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS\n\tint ret = sock_make_no_blocking(sockfd);\n\tif (ret != - 1) {\n\t\tret = connect(sockfd, serv_addr, addrlen);\n\t\tret = Check_Connect_And_Wait_Connection(sockfd, ret);\n\t\tif (ret != - 1) {\n\t\t\tret = sock_make_blocking(sockfd);\n\t\t}\n\t}\n\n\treturn ret;\n#else\n\treturn connect(sockfd, serv_addr, addrlen);\n#endif /* UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS */\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstatic int private_connect(\n\tSOCKET sockfd,\n\tconst struct sockaddr *serv_addr,\n\tsocklen_t addrlen)\n{\n#ifndef UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS\n\tint ret = sock_make_no_blocking(sockfd);\n\tif (ret != - 1) {\n\t\tret = connect(sockfd, serv_addr, addrlen);\n\t\tret = Check_Connect_And_Wait_Connection(sockfd, ret);\n\t\tif (ret != - 1) {\n\t\t\tret = sock_make_blocking(sockfd);\n\t\t}\n\t}\n\n\treturn ret;\n#else\n\treturn connect(sockfd, serv_addr, addrlen);\n#endif /* UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "url->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in)"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "UPNP_E_OUTOF_SOCKET"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "(int)url->hostport.IPaddress.ss_family",
            "SOCK_STREAM",
            "0"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "get_miniserver_sockets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/miniserver/miniserver.c",
          "lines": "500-786",
          "snippet": "static int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */",
            "#include \"ThreadPool.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"ithread.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"miniserver.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define APPLICATION_LISTENING_PORT 49152"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\" /* for socklen_t, EAFNOSUPPORT */\n#include \"ThreadPool.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"ithread.h\"\n#include \"httpreadwrite.h\"\n#include \"miniserver.h\"\n#include \"config.h\"\n\n#define APPLICATION_LISTENING_PORT 49152\n\nstatic int get_miniserver_sockets(\n\t/*! [in] Socket Array. */\n\tMiniServerSockArray *out,\n\t/*! [in] port on which the server is listening for incoming IPv4\n\t * connections. */\n\tuint16_t listen_port4\n#ifdef UPNP_ENABLE_IPV6\n\t,\n\t/*! [in] port on which the server is listening for incoming IPv6\n\t * connections. */\n\tuint16_t listen_port6\n#endif\n\t)\n{\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\tstruct sockaddr_storage __ss_v4;\n\tstruct sockaddr_in* serverAddr4 = (struct sockaddr_in*)&__ss_v4;\n\tSOCKET listenfd4;\n\tuint16_t actual_port4 = 0u;\n#ifdef UPNP_ENABLE_IPV6\n\tstruct sockaddr_storage __ss_v6;\n\tstruct sockaddr_in6* serverAddr6 = (struct sockaddr_in6*)&__ss_v6;\n\tSOCKET listenfd6;\n\tuint16_t actual_port6 = 0u;\n#endif\n\tint ret_code;\n\tint reuseaddr_on = 0;\n\tint sockError = UPNP_E_SUCCESS;\n\tint errCode = 0;\n\n\t/* Create listen socket for IPv4/IPv6. An error here may indicate\n\t * that we don't have an IPv4/IPv6 stack. */\n\tlistenfd4 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (listenfd4 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv4 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tlistenfd6 = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (listenfd6 == INVALID_SOCKET) {\n\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: IPv6 socket not available: %s\\n\",\n\t\t\terrorBuffer);\n\t} else {\n\t\tint onOff = 1;\n\t\tsockError = setsockopt(listenfd6, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t\t\t\t\t   (char *)&onOff, sizeof(onOff));\n\t\tif (sockError == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"get_miniserver_sockets: unable to set IPv6 socket protocol: %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd6);\n\t\t\tlistenfd6 = INVALID_SOCKET;\n\t\t}\n\t}\n#endif\n\tif (listenfd4 == INVALID_SOCKET\n#ifdef UPNP_ENABLE_IPV6\n\t    && listenfd6 == INVALID_SOCKET\n#endif\n\t) {\n\t\tUpnpPrintf(UPNP_CRITICAL, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: no protocols available\\n\");\n\t\treturn UPNP_E_OUTOF_SOCKET;\n\t}\n\t/* As per the IANA specifications for the use of ports by applications\n\t * override the listen port passed in with the first available. */\n\tif (listen_port4 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port4 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listen_port6 < APPLICATION_LISTENING_PORT) {\n\t\tlisten_port6 = (uint16_t)APPLICATION_LISTENING_PORT;\n\t}\n#endif\n\tmemset(&__ss_v4, 0, sizeof (__ss_v4));\n\tserverAddr4->sin_family = (sa_family_t)AF_INET;\n\tinet_pton(AF_INET, gIF_IPV4, &serverAddr4->sin_addr);\n#ifdef UPNP_ENABLE_IPV6\n\tmemset(&__ss_v6, 0, sizeof (__ss_v6));\n\tserverAddr6->sin6_family = (sa_family_t)AF_INET6;\n\tinet_pton(AF_INET6, gIF_IPV6, &serverAddr6->sin6_addr);\n#endif\n\t/* Getting away with implementation of re-using address:port and\n\t * instead choosing to increment port numbers.\n\t * Keeping the re-use address code as an optional behaviour that\n\t * can be turned on if necessary.\n\t * TURN ON the reuseaddr_on option to use the option. */\n\tif (reuseaddr_on) {\n\t\t/* THIS IS ALLOWS US TO BIND AGAIN IMMEDIATELY\n\t\t * AFTER OUR SERVER HAS BEEN CLOSED\n\t\t * THIS MAY CAUSE TCP TO BECOME LESS RELIABLE\n\t\t * HOWEVER IT HAS BEEN SUGESTED FOR TCP SERVERS. */\n\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\"get_miniserver_sockets: resuseaddr is set.\\n\");\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd4, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr4->sin_port = htons(listen_port4);\n\t\t\tsockError = bind(listenfd4,\n\t\t\t\t(struct sockaddr *)&__ss_v4,\n\t\t\t\tsizeof (__ss_v4));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tsockError = setsockopt(listenfd6, SOL_SOCKET,\n\t\t\t\tSO_REUSEADDR,\n\t\t\t(const char *)&reuseaddr_on, sizeof (int));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t\tserverAddr6->sin6_port = htons(listen_port6);\n\t\t\tsockError = bind(listenfd6,\n\t\t\t\t(struct sockaddr *)&__ss_v6,\n\t\t\t\tsizeof (__ss_v6));\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\", \n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failed */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif  /* IPv6 */\n\t} else {\n\t\tif (listenfd4 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port4 = listen_port4;\n\t\t\tdo {\n\t\t\t\tserverAddr4->sin_port = htons(listen_port4++);\n\t\t\t\tsockError = bind(listenfd4,\n\t\t\t\t\t(struct sockaddr *)serverAddr4,\n\t\t\t\t\tsizeof(*serverAddr4));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno;\n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port4 >= orig_listen_port4);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv4 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\t\tsock_close(listenfd6);\n#endif\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#ifdef UPNP_ENABLE_IPV6\n\t\tif (listenfd6 != INVALID_SOCKET) {\n\t\t\tuint16_t orig_listen_port6 = listen_port6;\n\t\t\tdo {\n\t\t\t\tserverAddr6->sin6_port = htons(listen_port6++);\n\t\t\t\tsockError = bind(listenfd6,\n\t\t\t\t\t(struct sockaddr *)serverAddr6,\n\t\t\t\t\tsizeof(*serverAddr6));\n\t\t\t\tif (sockError == SOCKET_ERROR) {\n#ifdef WIN32\n\t\t\t\t\terrCode = WSAGetLastError();\n#else\n\t\t\t\t\terrCode = errno; \n#endif\n\t\t\t\t\tif (errno == EADDRINUSE) {\n\t\t\t\t\t\terrCode = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrCode = 0;\n\t\t\t\t}\n\t\t\t} while (errCode != 0 &&\n\t\t\t\t listen_port6 >= orig_listen_port6);\n\t\t\tif (sockError == SOCKET_ERROR) {\n\t\t\t\tstrerror_r(errno, errorBuffer,\n\t\t\t\t\tERROR_BUFFER_LEN);\n\t\t\t\tUpnpPrintf(UPNP_INFO, MSERV,\n\t\t\t\t\t__FILE__, __LINE__,\n\t\t\t\t\t\"get_miniserver_sockets: \"\n\t\t\t\t\t\"Error in IPv6 bind(): %s\\n\",\n\t\t\t\t\terrorBuffer);\n\t\t\t\tsock_close(listenfd4);\n\t\t\t\tsock_close(listenfd6);\n\t\t\t\t/* Bind failied. */\n\t\t\t\treturn UPNP_E_SOCKET_BIND;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\"get_miniserver_sockets: bind successful\\n\");\n\tif (listenfd4 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd4, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv4 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd4, &actual_port4);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n#ifdef UPNP_ENABLE_IPV6\n\t\t\tsock_close(listenfd6);\n#endif\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort4 = actual_port4;\n\t}\n#ifdef UPNP_ENABLE_IPV6\n\tif (listenfd6 != INVALID_SOCKET) {\n\t\tret_code = listen(listenfd6, SOMAXCONN);\n\t\tif (ret_code == SOCKET_ERROR) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, MSERV, __FILE__, __LINE__,\n\t\t\t\t\"mserv start: Error in IPv6 listen(): %s\\n\",\n\t\t\t\terrorBuffer);\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_LISTEN;\n\t\t}\n\t\tret_code = get_port(listenfd6, &actual_port6);\n\t\tif (ret_code < 0) {\n\t\t\tsock_close(listenfd4);\n\t\t\tsock_close(listenfd6);\n\t\t\treturn UPNP_E_INTERNAL_ERROR;\n\t\t}\n\t\tout->miniServerPort6 = actual_port6;\n\t}\n#endif\n\tout->miniServerSock4 = listenfd4;\n#ifdef UPNP_ENABLE_IPV6\n\tout->miniServerSock6 = listenfd6;\n#endif\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_FixUrl",
          "args": [
            "destination_url",
            "url"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "http_FixUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "230-257",
          "snippet": "int http_FixUrl(IN uri_type *url, OUT uri_type *fixed_url)\n{\n\tconst char *temp_path = \"/\";\n\n\t*fixed_url = *url;\n#ifdef UPNP_ENABLE_OPEN_SSL\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0 &&\n\t    token_string_casecmp(&fixed_url->scheme, \"https\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#else\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#endif\n\tif( fixed_url->hostport.text.size == ( size_t ) 0 ) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\t/* set pathquery to \"/\" if it is empty */\n\tif (fixed_url->pathquery.size == (size_t)0) {\n\t\tfixed_url->pathquery.buff = temp_path;\n\t\tfixed_url->pathquery.size = (size_t)1;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixUrl(IN uri_type *url, OUT uri_type *fixed_url)\n{\n\tconst char *temp_path = \"/\";\n\n\t*fixed_url = *url;\n#ifdef UPNP_ENABLE_OPEN_SSL\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0 &&\n\t    token_string_casecmp(&fixed_url->scheme, \"https\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#else\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#endif\n\tif( fixed_url->hostport.text.size == ( size_t ) 0 ) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\t/* set pathquery to \"/\" if it is empty */\n\tif (fixed_url->pathquery.size == (size_t)0) {\n\t\tfixed_url->pathquery.buff = temp_path;\n\t\tfixed_url->pathquery.size = (size_t)1;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nSOCKET http_Connect(\n\tIN uri_type *destination_url,\n\tOUT uri_type *url)\n{\n\tSOCKET connfd;\n\tsocklen_t sockaddr_len;\n\tint ret_connect;\n\tchar errorBuffer[ERROR_BUFFER_LEN];\n\n\thttp_FixUrl(destination_url, url);\n\n\tconnfd = socket((int)url->hostport.IPaddress.ss_family,\n\t\tSOCK_STREAM, 0);\n\tif (connfd == INVALID_SOCKET) {\n\t\treturn (SOCKET)(UPNP_E_OUTOF_SOCKET);\n\t}\n\tsockaddr_len = (socklen_t)(url->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in));\n\tret_connect = private_connect(connfd,\n\t\t(struct sockaddr *)&url->hostport.IPaddress, sockaddr_len);\n\tif (ret_connect == -1) {\n#ifdef WIN32\n\t\tUpnpPrintf(UPNP_CRITICAL, HTTP, __FILE__, __LINE__,\n\t\t\t\"connect error: %d\\n\", WSAGetLastError());\n#endif\n\t\tif (shutdown(connfd, SD_BOTH) == -1) {\n\t\t\tstrerror_r(errno, errorBuffer, ERROR_BUFFER_LEN);\n\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Error in shutdown: %s\\n\", errorBuffer);\n\t\t}\n\t\tUpnpCloseSocket(connfd);\n\t\treturn (SOCKET)(UPNP_E_SOCKET_CONNECT);\n\t}\n\n\treturn connfd;\n}"
  },
  {
    "function_name": "http_FixStrUrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "259-271",
    "snippet": "int http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_FixUrl",
          "args": [
            "&url",
            "fixed_url"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "http_FixUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "230-257",
          "snippet": "int http_FixUrl(IN uri_type *url, OUT uri_type *fixed_url)\n{\n\tconst char *temp_path = \"/\";\n\n\t*fixed_url = *url;\n#ifdef UPNP_ENABLE_OPEN_SSL\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0 &&\n\t    token_string_casecmp(&fixed_url->scheme, \"https\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#else\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#endif\n\tif( fixed_url->hostport.text.size == ( size_t ) 0 ) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\t/* set pathquery to \"/\" if it is empty */\n\tif (fixed_url->pathquery.size == (size_t)0) {\n\t\tfixed_url->pathquery.buff = temp_path;\n\t\tfixed_url->pathquery.size = (size_t)1;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixUrl(IN uri_type *url, OUT uri_type *fixed_url)\n{\n\tconst char *temp_path = \"/\";\n\n\t*fixed_url = *url;\n#ifdef UPNP_ENABLE_OPEN_SSL\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0 &&\n\t    token_string_casecmp(&fixed_url->scheme, \"https\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#else\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#endif\n\tif( fixed_url->hostport.text.size == ( size_t ) 0 ) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\t/* set pathquery to \"/\" if it is empty */\n\tif (fixed_url->pathquery.size == (size_t)0) {\n\t\tfixed_url->pathquery.buff = temp_path;\n\t\tfixed_url->pathquery.size = (size_t)1;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_uri",
          "args": [
            "urlstr",
            "urlstrlen",
            "&url"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "parse_uri_and_unescape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "759-775",
          "snippet": "int parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint parse_uri_and_unescape(char *in, size_t max, uri_type *out)\n{\n\tint ret = parse_uri(in, max, out);\n\n\tif (ret != HTTP_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (out->pathquery.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->pathquery.buff, &out->pathquery.size);\n\t}\n\tif (out->fragment.size > (size_t)0) {\n\t\tremove_escaped_chars((char *)out->fragment.buff, &out->fragment.size);\n\t}\n\n\treturn HTTP_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}"
  },
  {
    "function_name": "http_FixUrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "230-257",
    "snippet": "int http_FixUrl(IN uri_type *url, OUT uri_type *fixed_url)\n{\n\tconst char *temp_path = \"/\";\n\n\t*fixed_url = *url;\n#ifdef UPNP_ENABLE_OPEN_SSL\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0 &&\n\t    token_string_casecmp(&fixed_url->scheme, \"https\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#else\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#endif\n\tif( fixed_url->hostport.text.size == ( size_t ) 0 ) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\t/* set pathquery to \"/\" if it is empty */\n\tif (fixed_url->pathquery.size == (size_t)0) {\n\t\tfixed_url->pathquery.buff = temp_path;\n\t\tfixed_url->pathquery.size = (size_t)1;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "token_string_casecmp",
          "args": [
            "&fixed_url->scheme",
            "\"http\""
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "token_string_casecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "289-296",
          "snippet": "int token_string_casecmp(token *in1, const char *in2)\n{\n\tsize_t in2_length = strlen(in2);\n\tif (in1->size != in2_length)\n\t\treturn 1;\n\telse\n\t\treturn strncasecmp(in1->buff, in2, in1->size);\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\nint token_string_casecmp(token *in1, const char *in2)\n{\n\tsize_t in2_length = strlen(in2);\n\tif (in1->size != in2_length)\n\t\treturn 1;\n\telse\n\t\treturn strncasecmp(in1->buff, in2, in1->size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixUrl(IN uri_type *url, OUT uri_type *fixed_url)\n{\n\tconst char *temp_path = \"/\";\n\n\t*fixed_url = *url;\n#ifdef UPNP_ENABLE_OPEN_SSL\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0 &&\n\t    token_string_casecmp(&fixed_url->scheme, \"https\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#else\n\tif (token_string_casecmp(&fixed_url->scheme, \"http\") != 0)\n\t{\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n#endif\n\tif( fixed_url->hostport.text.size == ( size_t ) 0 ) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\t/* set pathquery to \"/\" if it is empty */\n\tif (fixed_url->pathquery.size == (size_t)0) {\n\t\tfixed_url->pathquery.buff = temp_path;\n\t\tfixed_url->pathquery.size = (size_t)1;\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "copy_msg_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "200-227",
    "snippet": "static void copy_msg_headers(IN LinkedList *msgHeaders,\n                             OUT UpnpString *headers)\n{\n\treturn;\n/* TODO: */\n#if 0\n\tListNode *node;\n\tUpnpHttpHeader *header;\n\thttp_header_t *msgHeader;\n\tif (headers) {\n\t\tListInit(headers, NULL, (free_function) UpnpHttpHeader_delete);\n\t\tnode = ListHead(msgHeaders);\n\t\twhile(node) {\n\t\t\tmsgHeader = (http_header_t*) node->item;\n\t\t\theader = UpnpHttpHeader_new();\n\t\t\tUpnpHttpHeader_strncpy_Name(\n\t\t\t\theader,\n\t\t\t\tmsgHeader->name.buf,\n\t\t\t\tmsgHeader->name.length);\n\t\t\tUpnpHttpHeader_strncpy_Value(\n\t\t\t\theader,\n\t\t\t\tmsgHeader->value.buf,\n\t\t\t\tmsgHeader->value.length);\n\t\t\tnode = ListNext(msgHeaders, node);\n\t\t}\n\t}\n#endif\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListNext",
          "args": [
            "msgHeaders",
            "node"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpHttpHeader_strncpy_Value",
          "args": [
            "header",
            "msgHeader->value.buf",
            "msgHeader->value.length"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpHttpHeader_strncpy_Name",
          "args": [
            "header",
            "msgHeader->name.buf",
            "msgHeader->name.length"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpHttpHeader_new",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListHead",
          "args": [
            "msgHeaders"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListInit",
          "args": [
            "headers",
            "NULL",
            "(free_function) UpnpHttpHeader_delete"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstatic void copy_msg_headers(IN LinkedList *msgHeaders,\n                             OUT UpnpString *headers)\n{\n\treturn;\n/* TODO: */\n#if 0\n\tListNode *node;\n\tUpnpHttpHeader *header;\n\thttp_header_t *msgHeader;\n\tif (headers) {\n\t\tListInit(headers, NULL, (free_function) UpnpHttpHeader_delete);\n\t\tnode = ListHead(msgHeaders);\n\t\twhile(node) {\n\t\t\tmsgHeader = (http_header_t*) node->item;\n\t\t\theader = UpnpHttpHeader_new();\n\t\t\tUpnpHttpHeader_strncpy_Name(\n\t\t\t\theader,\n\t\t\t\tmsgHeader->name.buf,\n\t\t\t\tmsgHeader->name.length);\n\t\t\tUpnpHttpHeader_strncpy_Value(\n\t\t\t\theader,\n\t\t\t\tmsgHeader->value.buf,\n\t\t\t\tmsgHeader->value.length);\n\t\t\tnode = ListNext(msgHeaders, node);\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "function_name": "get_hoststr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "179-198",
    "snippet": "static int get_hoststr(const char* url_str,\n                       char **hoststr,\n                       size_t *hostlen)\n{\n\tchar *urlPath = alloca(strlen(url_str) + 1);\n\tchar *temp;\n\tmemset(urlPath, 0, strlen(url_str) + 1);\n\tstrncpy(urlPath, url_str, strlen(url_str));\n\t*hoststr = strstr(urlPath, \"//\");\n\tif (*hoststr == NULL)\n\t\treturn UPNP_E_INVALID_URL;\n\t*hoststr += 2;\n\ttemp = strchr(*hoststr, '/');\n\tif (temp == NULL)\n\t\treturn UPNP_E_INVALID_URL;\n\t*temp = '\\0';\n\t*hostlen = strlen(*hoststr);\n\t*temp = '/';\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*hoststr"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "*hoststr",
            "'/'"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "urlPath",
            "\"//\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "urlPath",
            "url_str",
            "strlen(url_str)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "urlPath",
            "0",
            "strlen(url_str) + 1"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloca",
          "args": [
            "strlen(url_str) + 1"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "url_str"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstatic int get_hoststr(const char* url_str,\n                       char **hoststr,\n                       size_t *hostlen)\n{\n\tchar *urlPath = alloca(strlen(url_str) + 1);\n\tchar *temp;\n\tmemset(urlPath, 0, strlen(url_str) + 1);\n\tstrncpy(urlPath, url_str, strlen(url_str));\n\t*hoststr = strstr(urlPath, \"//\");\n\tif (*hoststr == NULL)\n\t\treturn UPNP_E_INVALID_URL;\n\t*hoststr += 2;\n\ttemp = strchr(*hoststr, '/');\n\tif (temp == NULL)\n\t\treturn UPNP_E_INVALID_URL;\n\t*temp = '\\0';\n\t*hostlen = strlen(*hoststr);\n\t*temp = '/';\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "http_gmtime_r",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "168-176",
    "snippet": "struct tm *http_gmtime_r(const time_t *clock, struct tm *result)\n{\n\tif (clock == NULL || *clock < 0 || result == NULL)\n\t\treturn NULL;\n\n\t/* gmtime in VC runtime is thread safe. */\n\t*result = *gmtime(clock);\n\treturn result;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gmtime",
          "args": [
            "clock"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstruct tm *http_gmtime_r(const time_t *clock, struct tm *result)\n{\n\tif (clock == NULL || *clock < 0 || result == NULL)\n\t\treturn NULL;\n\n\t/* gmtime in VC runtime is thread safe. */\n\t*result = *gmtime(clock);\n\treturn result;\n}"
  },
  {
    "function_name": "private_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
    "lines": "146-165",
    "snippet": "static int private_connect(\n\tSOCKET sockfd,\n\tconst struct sockaddr *serv_addr,\n\tsocklen_t addrlen)\n{\n#ifndef UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS\n\tint ret = sock_make_no_blocking(sockfd);\n\tif (ret != - 1) {\n\t\tret = connect(sockfd, serv_addr, addrlen);\n\t\tret = Check_Connect_And_Wait_Connection(sockfd, ret);\n\t\tif (ret != - 1) {\n\t\t\tret = sock_make_blocking(sockfd);\n\t\t}\n\t}\n\n\treturn ret;\n#else\n\treturn connect(sockfd, serv_addr, addrlen);\n#endif /* UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS */\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <sys/wait.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <arpa/inet.h>",
      "#include <malloc.h>",
      "#include <stdarg.h>",
      "#include <assert.h>",
      "#include \"webserver.h\"",
      "#include \"UpnpStdInt.h\"",
      "#include \"UpnpIntTypes.h\"",
      "#include \"UpnpInet.h\"",
      "#include \"sock.h\"",
      "#include \"statcodes.h\"",
      "#include \"uri.h\"",
      "#include \"membuffer.h\"",
      "#include \"upnpapi.h\"",
      "#include \"upnp.h\"",
      "#include \"unixutil.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sockfd",
            "serv_addr",
            "addrlen"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "private_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "146-165",
          "snippet": "static int private_connect(\n\tSOCKET sockfd,\n\tconst struct sockaddr *serv_addr,\n\tsocklen_t addrlen)\n{\n#ifndef UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS\n\tint ret = sock_make_no_blocking(sockfd);\n\tif (ret != - 1) {\n\t\tret = connect(sockfd, serv_addr, addrlen);\n\t\tret = Check_Connect_And_Wait_Connection(sockfd, ret);\n\t\tif (ret != - 1) {\n\t\t\tret = sock_make_blocking(sockfd);\n\t\t}\n\t}\n\n\treturn ret;\n#else\n\treturn connect(sockfd, serv_addr, addrlen);\n#endif /* UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS */\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sock_make_blocking",
          "args": [
            "sockfd"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "sock_make_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "277-291",
          "snippet": "int sock_make_blocking(SOCKET sock)\n{\n#ifdef WIN32\n\tu_long val = 0;\n\treturn ioctlsocket(sock, FIONBIO, &val);\n#else\n\tint val;\n\n\tval = fcntl(sock, F_GETFL, 0);\n\tif (fcntl(sock, F_SETFL, val & ~O_NONBLOCK) == -1) {\n\t\treturn -1;\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_make_blocking(SOCKET sock)\n{\n#ifdef WIN32\n\tu_long val = 0;\n\treturn ioctlsocket(sock, FIONBIO, &val);\n#else\n\tint val;\n\n\tval = fcntl(sock, F_GETFL, 0);\n\tif (fcntl(sock, F_SETFL, val & ~O_NONBLOCK) == -1) {\n\t\treturn -1;\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Check_Connect_And_Wait_Connection",
          "args": [
            "sockfd",
            "ret"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_make_no_blocking",
          "args": [
            "sockfd"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "sock_make_no_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/sock.c",
          "lines": "294-308",
          "snippet": "int sock_make_no_blocking(SOCKET sock)\n{\n#ifdef WIN32\n\tu_long val = 1;\n\treturn ioctlsocket(sock, FIONBIO, &val);\n#else /* WIN32 */\n\tint val;\n\n\tval = fcntl(sock, F_GETFL, 0);\n\tif (fcntl(sock, F_SETFL, val | O_NONBLOCK) == -1) {\n\t\treturn -1;\n\t}\n#endif /* WIN32 */\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <string.h>",
            "#include <time.h>",
            "#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"upnputil.h\"",
            "#include \"upnpdebug.h\"",
            "#include \"UpnpStdInt.h\" /* for ssize_t */",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */",
            "#include \"sock.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\t/* for F_GETFL, F_SETFL, O_NONBLOCK */\n#include <errno.h>\n#include <assert.h>\n#include \"upnputil.h\"\n#include \"upnpdebug.h\"\n#include \"UpnpStdInt.h\" /* for ssize_t */\n#include \"upnp.h\"\n#include \"unixutil.h\"\t/* for socklen_t, EAFNOSUPPORT */\n#include \"sock.h\"\n#include \"config.h\"\n\nint sock_make_no_blocking(SOCKET sock)\n{\n#ifdef WIN32\n\tu_long val = 1;\n\treturn ioctlsocket(sock, FIONBIO, &val);\n#else /* WIN32 */\n\tint val;\n\n\tval = fcntl(sock, F_GETFL, 0);\n\tif (fcntl(sock, F_SETFL, val | O_NONBLOCK) == -1) {\n\t\treturn -1;\n\t}\n#endif /* WIN32 */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nstatic int private_connect(\n\tSOCKET sockfd,\n\tconst struct sockaddr *serv_addr,\n\tsocklen_t addrlen)\n{\n#ifndef UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS\n\tint ret = sock_make_no_blocking(sockfd);\n\tif (ret != - 1) {\n\t\tret = connect(sockfd, serv_addr, addrlen);\n\t\tret = Check_Connect_And_Wait_Connection(sockfd, ret);\n\t\tif (ret != - 1) {\n\t\t\tret = sock_make_blocking(sockfd);\n\t\t}\n\t}\n\n\treturn ret;\n#else\n\treturn connect(sockfd, serv_addr, addrlen);\n#endif /* UPNP_ENABLE_BLOCKING_TCP_CONNECTIONS */\n}"
  }
]