[
  {
    "function_name": "gena_process_notification_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
    "lines": "696-824",
    "snippet": "void gena_process_notification_event(\n\tSOCKINFO *info,\n\thttp_message_t *event)\n{\n\tUpnpEvent *event_struct = UpnpEvent_new();\n\tIXML_Document *ChangedVars = NULL;\n\tint eventKey;\n\ttoken sid;\n\tGenlibClientSubscription *subscription = NULL;\n\tstruct Handle_Info *handle_info;\n\tvoid *cookie;\n\tUpnp_FunPtr callback;\n\tUpnpClient_Handle client_handle;\n\n\tmemptr sid_hdr;\n\tmemptr nt_hdr,\n\tnts_hdr;\n\tmemptr seq_hdr;\n\n\t/* get SID */\n\tif (httpmsg_find_hdr(event, HDR_SID, &sid_hdr) == NULL) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\tgoto exit_function;\n\t}\n\tsid.buff = sid_hdr.buf;\n\tsid.size = sid_hdr.length;\n\n\t/* get event key */\n\tif (httpmsg_find_hdr(event, HDR_SEQ, &seq_hdr) == NULL ||\n\t    matchstr(seq_hdr.buf, seq_hdr.length, \"%d%0\", &eventKey) != PARSE_OK) {\n\t\terror_respond( info, HTTP_BAD_REQUEST, event );\n\t\tgoto exit_function;\n\t}\n\n\t/* get NT and NTS headers */\n\tif (httpmsg_find_hdr(event, HDR_NT, &nt_hdr) == NULL ||\n\t    httpmsg_find_hdr(event, HDR_NTS, &nts_hdr) == NULL) {\n\t\terror_respond( info, HTTP_BAD_REQUEST, event );\n\t\tgoto exit_function;\n\t}\n\n\t/* verify NT and NTS headers */\n\tif (memptr_cmp(&nt_hdr, \"upnp:event\") != 0 ||\n\t    memptr_cmp(&nts_hdr, \"upnp:propchange\") != 0) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\tgoto exit_function;\n\t}\n\n\t/* parse the content (should be XML) */\n\tif (!has_xml_content_type(event) ||\n\t    event->msg.length == 0 ||\n\t    ixmlParseBufferEx(event->entity.buf, &ChangedVars) != IXML_SUCCESS) {\n\t\terror_respond(info, HTTP_BAD_REQUEST, event);\n\t\tgoto exit_function;\n\t}\n\n\tHandleLock();\n\n\t/* get client info */\n\tif (GetClientHandleInfo(&client_handle, &handle_info) != HND_CLIENT) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\t/* get subscription based on SID */\n\tsubscription = GetClientSubActualSID(handle_info->ClientSubList, &sid);\n\tif (subscription == NULL) {\n\t\tif (eventKey == 0) {\n\t\t\t/* wait until we've finished processing a subscription  */\n\t\t\t/*   (if we are in the middle) */\n\t\t\t/* this is to avoid mistakenly rejecting the first event if we  */\n\t\t\t/*   receive it before the subscription response */\n\t\t\tHandleUnlock();\n\n\t\t\t/* try and get Subscription Lock  */\n\t\t\t/*   (in case we are in the process of subscribing) */\n\t\t\tSubscribeLock();\n\n\t\t\t/* get HandleLock again */\n\t\t\tHandleLock();\n\n\t\t\tif (GetClientHandleInfo(&client_handle, &handle_info) != HND_CLIENT) {\n\t\t\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\t\t\tSubscribeUnlock();\n\t\t\t\tHandleUnlock();\n\t\t\t\tgoto exit_function;\n\t\t\t}\n\n\t\t\tsubscription = GetClientSubActualSID(handle_info->ClientSubList, &sid);\n\t\t\tif (subscription == NULL) {\n\t\t\t\terror_respond( info, HTTP_PRECONDITION_FAILED, event );\n\t\t\t\tSubscribeUnlock();\n\t\t\t\tHandleUnlock();\n\t\t\t\tgoto exit_function;\n\t\t\t}\n\n\t\t\tSubscribeUnlock();\n\t\t} else {\n\t\t\terror_respond( info, HTTP_PRECONDITION_FAILED, event );\n\t\t\tHandleUnlock();\n\t\t\tgoto exit_function;\n\t\t}\n\t}\n\n\t/* success */\n\terror_respond(info, HTTP_OK, event);\n\n\t/* fill event struct */\n\tUpnpEvent_set_EventKey(event_struct, eventKey);\n\tUpnpEvent_set_ChangedVariables(event_struct, ChangedVars);\n\tUpnpEvent_set_SID(event_struct, GenlibClientSubscription_get_SID(subscription));\n\n\t/* copy callback */\n\tcallback = handle_info->Callback;\n\tcookie = handle_info->Cookie;\n\n\tHandleUnlock();\n\n\t/* make callback with event struct */\n\t/* In future, should find a way of mainting */\n\t/* that the handle is not unregistered in the middle of a */\n\t/* callback */\n\tcallback(UPNP_EVENT_RECEIVED, event_struct, cookie);\n\nexit_function:\n\tixmlDocument_free(ChangedVars);\n\tUpnpEvent_delete(event_struct);\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uuid.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"EventSubscribe.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpEvent_delete",
          "args": [
            "event_struct"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "ChangedVars"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callback",
          "args": [
            "UPNP_EVENT_RECEIVED",
            "event_struct",
            "cookie"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "soap_device_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "701-780",
          "snippet": "void soap_device_callback(\n\t/*! [in] Parsed request received by the device. */\n\thttp_parser_t *parser,\n\t/*! [in] HTTP request. */\n\thttp_message_t *request,\n\t/*! [in,out] Socket info. */\n\tSOCKINFO *info)\n{\n\tint err_code;\n\tIXML_Document *xml_doc = NULL;\n\tsoap_devserv_t *soap_info = NULL;\n\tIXML_Node *req_node = NULL;\n\n\t/* get device/service identified by the request-URI */\n\tsoap_info = malloc(sizeof(soap_devserv_t));\n\tif (NULL == soap_info) {\n\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\tgoto error_handler;\n\t}\n\tif (get_dev_service(request,\n\t\t\tinfo->foreign_sockaddr.ss_family, soap_info) < 0) {\n\t\terr_code = HTTP_NOT_FOUND;\n\t\tgoto error_handler;\n\t}\n\t/* validate: content-type == text/xml */\n\tif (!has_xml_content_type(request)) {\n\t\terr_code = HTTP_UNSUPPORTED_MEDIA_TYPE;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAPACTION HTTP header */\n\terr_code = check_soapaction_hdr(request, soap_info);\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\tswitch (err_code) {\n\t\tcase SREQ_NOT_EXTENDED:\n\t\t\terr_code = HTTP_NOT_EXTENDED;\n\t\t\tbreak;\n\t\tcase UPNP_E_OUTOF_MEMORY:\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\t\tbreak;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* parse XML */\n\terr_code = ixmlParseBufferEx(request->entity.buf, &xml_doc);\n\tif (err_code != IXML_SUCCESS) {\n\t\tif (IXML_INSUFFICIENT_MEMORY == err_code)\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\telse\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAP body */\n\tif (check_soap_request(soap_info, xml_doc, &req_node) < 0)\n\t{\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* process SOAP request */\n\tif (NULL == soap_info->action_name.buf)\n\t\t/* query var */\n\t\thandle_query_variable(info, request, soap_info, req_node);\n\telse\n\t\t/* invoke action */\n\t\thandle_invoke_action(info, request, soap_info, req_node);\n\n\terr_code = HTTP_OK;\n\nerror_handler:\n\tixmlDocument_free(xml_doc);\n\tfree(soap_info);\n\tif (err_code != HTTP_OK) {\n\t\thttp_SendStatusResponse(info, err_code, request->major_version,\n\t\t\t\trequest->minor_version);\n\t}\n\treturn;\n\tparser = parser;\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SREQ_NOT_EXTENDED\t -3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SREQ_NOT_EXTENDED\t -3\n\nvoid soap_device_callback(\n\t/*! [in] Parsed request received by the device. */\n\thttp_parser_t *parser,\n\t/*! [in] HTTP request. */\n\thttp_message_t *request,\n\t/*! [in,out] Socket info. */\n\tSOCKINFO *info)\n{\n\tint err_code;\n\tIXML_Document *xml_doc = NULL;\n\tsoap_devserv_t *soap_info = NULL;\n\tIXML_Node *req_node = NULL;\n\n\t/* get device/service identified by the request-URI */\n\tsoap_info = malloc(sizeof(soap_devserv_t));\n\tif (NULL == soap_info) {\n\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\tgoto error_handler;\n\t}\n\tif (get_dev_service(request,\n\t\t\tinfo->foreign_sockaddr.ss_family, soap_info) < 0) {\n\t\terr_code = HTTP_NOT_FOUND;\n\t\tgoto error_handler;\n\t}\n\t/* validate: content-type == text/xml */\n\tif (!has_xml_content_type(request)) {\n\t\terr_code = HTTP_UNSUPPORTED_MEDIA_TYPE;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAPACTION HTTP header */\n\terr_code = check_soapaction_hdr(request, soap_info);\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\tswitch (err_code) {\n\t\tcase SREQ_NOT_EXTENDED:\n\t\t\terr_code = HTTP_NOT_EXTENDED;\n\t\t\tbreak;\n\t\tcase UPNP_E_OUTOF_MEMORY:\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\t\tbreak;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* parse XML */\n\terr_code = ixmlParseBufferEx(request->entity.buf, &xml_doc);\n\tif (err_code != IXML_SUCCESS) {\n\t\tif (IXML_INSUFFICIENT_MEMORY == err_code)\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\telse\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAP body */\n\tif (check_soap_request(soap_info, xml_doc, &req_node) < 0)\n\t{\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* process SOAP request */\n\tif (NULL == soap_info->action_name.buf)\n\t\t/* query var */\n\t\thandle_query_variable(info, request, soap_info, req_node);\n\telse\n\t\t/* invoke action */\n\t\thandle_invoke_action(info, request, soap_info, req_node);\n\n\terr_code = HTTP_OK;\n\nerror_handler:\n\tixmlDocument_free(xml_doc);\n\tfree(soap_info);\n\tif (err_code != HTTP_OK) {\n\t\thttp_SendStatusResponse(info, err_code, request->major_version,\n\t\t\t\trequest->minor_version);\n\t}\n\treturn;\n\tparser = parser;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEvent_set_SID",
          "args": [
            "event_struct",
            "GenlibClientSubscription_get_SID(subscription)"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_get_SID",
          "args": [
            "subscription"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEvent_set_ChangedVariables",
          "args": [
            "event_struct",
            "ChangedVars"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEvent_set_EventKey",
          "args": [
            "event_struct",
            "eventKey"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_respond",
          "args": [
            "info",
            "HTTP_OK",
            "event"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "error_respond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_callback2.c",
          "lines": "58-71",
          "snippet": "void\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena_ctrlpt.h\"",
            "#include \"gena_device.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena_ctrlpt.h\"\n#include \"gena_device.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nvoid\nerror_respond( IN SOCKINFO * info,\n               IN int error_code,\n               IN http_message_t * hmsg )\n{\n    int major,\n      minor;\n\n    /* retrieve the minor and major version from the GENA request */\n    http_CalcResponseVersion( hmsg->major_version,\n                              hmsg->minor_version, &major, &minor );\n\n    http_SendStatusResponse( info, error_code, major, minor );\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SubscribeUnlock",
          "args": [],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SubscribeUnlock",
          "args": [],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetClientSubActualSID",
          "args": [
            "handle_info->ClientSubList",
            "&sid"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "GetClientSubActualSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/client_table/client_table.c",
          "lines": "101-115",
          "snippet": "GenlibClientSubscription *GetClientSubActualSID(GenlibClientSubscription *head, token *sid)\n{\n\tGenlibClientSubscription *next = head;\n\twhile (next) {\n\t\tif (!memcmp(\n\t\t\tGenlibClientSubscription_get_ActualSID_cstr(next),\n\t\t\tsid->buff, sid->size)) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tnext = GenlibClientSubscription_get_Next(next);\n\t\t}\n\t}\n\n\treturn next;\n}",
          "includes": [
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"client_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for calloc(), free() */\n#include \"client_table.h\"\n#include \"config.h\"\n\nGenlibClientSubscription *GetClientSubActualSID(GenlibClientSubscription *head, token *sid)\n{\n\tGenlibClientSubscription *next = head;\n\twhile (next) {\n\t\tif (!memcmp(\n\t\t\tGenlibClientSubscription_get_ActualSID_cstr(next),\n\t\t\tsid->buff, sid->size)) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tnext = GenlibClientSubscription_get_Next(next);\n\t\t}\n\t}\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SubscribeUnlock",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetClientHandleInfo",
          "args": [
            "&client_handle",
            "&handle_info"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "GetClientHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3822-3846",
          "snippet": "Upnp_Handle_Type GetClientHandleInfo(\n\tUpnpClient_Handle *client_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_CLIENT;\n\tUpnpClient_Handle client;\n\n\tswitch (GetHandleInfo(1, HndInfo)) {\n\tcase HND_CLIENT:\n\t\tclient = 1;\n\t\tbreak;\n\tdefault:\n\t\tswitch (GetHandleInfo(2, HndInfo)) {\n\t\tcase HND_CLIENT:\n\t\t\tclient = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclient = -1;\n\t\t\tret = HND_INVALID;\n\t\t}\n\t}\n\n\t*client_handle_out = client;\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\nUpnp_Handle_Type GetClientHandleInfo(\n\tUpnpClient_Handle *client_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_CLIENT;\n\tUpnpClient_Handle client;\n\n\tswitch (GetHandleInfo(1, HndInfo)) {\n\tcase HND_CLIENT:\n\t\tclient = 1;\n\t\tbreak;\n\tdefault:\n\t\tswitch (GetHandleInfo(2, HndInfo)) {\n\t\tcase HND_CLIENT:\n\t\t\tclient = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclient = -1;\n\t\t\tret = HND_INVALID;\n\t\t}\n\t}\n\n\t*client_handle_out = client;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SubscribeLock",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "event->entity.buf",
            "&ChangedVars"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_xml_content_type",
          "args": [
            "event"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "has_xml_content_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/parsetools.c",
          "lines": "48-64",
          "snippet": "int has_xml_content_type(http_message_t *hmsg)\n{\n\tmemptr hdr_value;\n\n\tassert(hmsg);\n\n\t/* find 'content-type' header which must have text/xml */\n\tif (httpmsg_find_hdr(hmsg, HDR_CONTENT_TYPE, &hdr_value)) {\n\t\tswitch (matchstr(hdr_value.buf, hdr_value.length, \"%itext%w/%wxml\" )) {\n\t\tcase PARSE_OK:\n\t\t\treturn TRUE;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn FALSE;\n}",
          "includes": [
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnputil.h\"",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"upnputil.h\"\n#include <assert.h>\n#include \"config.h\"\n\nint has_xml_content_type(http_message_t *hmsg)\n{\n\tmemptr hdr_value;\n\n\tassert(hmsg);\n\n\t/* find 'content-type' header which must have text/xml */\n\tif (httpmsg_find_hdr(hmsg, HDR_CONTENT_TYPE, &hdr_value)) {\n\t\tswitch (matchstr(hdr_value.buf, hdr_value.length, \"%itext%w/%wxml\" )) {\n\t\tcase PARSE_OK:\n\t\t\treturn TRUE;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memptr_cmp",
          "args": [
            "&nts_hdr",
            "\"upnp:propchange\""
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "memptr_cmp_nocase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "78-90",
          "snippet": "int memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "event",
            "HDR_NTS",
            "&nts_hdr"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "matchstr",
          "args": [
            "seq_hdr.buf",
            "seq_hdr.length",
            "\"%d%0\"",
            "&eventKey"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "matchstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1168-1203",
          "snippet": "parse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpEvent_new",
          "args": [],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nvoid gena_process_notification_event(\n\tSOCKINFO *info,\n\thttp_message_t *event)\n{\n\tUpnpEvent *event_struct = UpnpEvent_new();\n\tIXML_Document *ChangedVars = NULL;\n\tint eventKey;\n\ttoken sid;\n\tGenlibClientSubscription *subscription = NULL;\n\tstruct Handle_Info *handle_info;\n\tvoid *cookie;\n\tUpnp_FunPtr callback;\n\tUpnpClient_Handle client_handle;\n\n\tmemptr sid_hdr;\n\tmemptr nt_hdr,\n\tnts_hdr;\n\tmemptr seq_hdr;\n\n\t/* get SID */\n\tif (httpmsg_find_hdr(event, HDR_SID, &sid_hdr) == NULL) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\tgoto exit_function;\n\t}\n\tsid.buff = sid_hdr.buf;\n\tsid.size = sid_hdr.length;\n\n\t/* get event key */\n\tif (httpmsg_find_hdr(event, HDR_SEQ, &seq_hdr) == NULL ||\n\t    matchstr(seq_hdr.buf, seq_hdr.length, \"%d%0\", &eventKey) != PARSE_OK) {\n\t\terror_respond( info, HTTP_BAD_REQUEST, event );\n\t\tgoto exit_function;\n\t}\n\n\t/* get NT and NTS headers */\n\tif (httpmsg_find_hdr(event, HDR_NT, &nt_hdr) == NULL ||\n\t    httpmsg_find_hdr(event, HDR_NTS, &nts_hdr) == NULL) {\n\t\terror_respond( info, HTTP_BAD_REQUEST, event );\n\t\tgoto exit_function;\n\t}\n\n\t/* verify NT and NTS headers */\n\tif (memptr_cmp(&nt_hdr, \"upnp:event\") != 0 ||\n\t    memptr_cmp(&nts_hdr, \"upnp:propchange\") != 0) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\tgoto exit_function;\n\t}\n\n\t/* parse the content (should be XML) */\n\tif (!has_xml_content_type(event) ||\n\t    event->msg.length == 0 ||\n\t    ixmlParseBufferEx(event->entity.buf, &ChangedVars) != IXML_SUCCESS) {\n\t\terror_respond(info, HTTP_BAD_REQUEST, event);\n\t\tgoto exit_function;\n\t}\n\n\tHandleLock();\n\n\t/* get client info */\n\tif (GetClientHandleInfo(&client_handle, &handle_info) != HND_CLIENT) {\n\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\t/* get subscription based on SID */\n\tsubscription = GetClientSubActualSID(handle_info->ClientSubList, &sid);\n\tif (subscription == NULL) {\n\t\tif (eventKey == 0) {\n\t\t\t/* wait until we've finished processing a subscription  */\n\t\t\t/*   (if we are in the middle) */\n\t\t\t/* this is to avoid mistakenly rejecting the first event if we  */\n\t\t\t/*   receive it before the subscription response */\n\t\t\tHandleUnlock();\n\n\t\t\t/* try and get Subscription Lock  */\n\t\t\t/*   (in case we are in the process of subscribing) */\n\t\t\tSubscribeLock();\n\n\t\t\t/* get HandleLock again */\n\t\t\tHandleLock();\n\n\t\t\tif (GetClientHandleInfo(&client_handle, &handle_info) != HND_CLIENT) {\n\t\t\t\terror_respond(info, HTTP_PRECONDITION_FAILED, event);\n\t\t\t\tSubscribeUnlock();\n\t\t\t\tHandleUnlock();\n\t\t\t\tgoto exit_function;\n\t\t\t}\n\n\t\t\tsubscription = GetClientSubActualSID(handle_info->ClientSubList, &sid);\n\t\t\tif (subscription == NULL) {\n\t\t\t\terror_respond( info, HTTP_PRECONDITION_FAILED, event );\n\t\t\t\tSubscribeUnlock();\n\t\t\t\tHandleUnlock();\n\t\t\t\tgoto exit_function;\n\t\t\t}\n\n\t\t\tSubscribeUnlock();\n\t\t} else {\n\t\t\terror_respond( info, HTTP_PRECONDITION_FAILED, event );\n\t\t\tHandleUnlock();\n\t\t\tgoto exit_function;\n\t\t}\n\t}\n\n\t/* success */\n\terror_respond(info, HTTP_OK, event);\n\n\t/* fill event struct */\n\tUpnpEvent_set_EventKey(event_struct, eventKey);\n\tUpnpEvent_set_ChangedVariables(event_struct, ChangedVars);\n\tUpnpEvent_set_SID(event_struct, GenlibClientSubscription_get_SID(subscription));\n\n\t/* copy callback */\n\tcallback = handle_info->Callback;\n\tcookie = handle_info->Cookie;\n\n\tHandleUnlock();\n\n\t/* make callback with event struct */\n\t/* In future, should find a way of mainting */\n\t/* that the handle is not unregistered in the middle of a */\n\t/* callback */\n\tcallback(UPNP_EVENT_RECEIVED, event_struct, cookie);\n\nexit_function:\n\tixmlDocument_free(ChangedVars);\n\tUpnpEvent_delete(event_struct);\n}"
  },
  {
    "function_name": "genaRenewSubscription",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
    "lines": "598-693",
    "snippet": "int genaRenewSubscription(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid,\n\tint *TimeOut)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *sub = NULL;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\tstruct Handle_Info *handle_info;\n\tUpnpString *ActualSID = UpnpString_new();\n\tThreadPoolJob tempJob;\n\n\tHandleLock();\n\n\t/* validate handle and sid */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* remove old events */\n\tif (TimerThreadRemove(\n\t\t&gTimerThread,\n\t\tGenlibClientSubscription_get_RenewEventId(sub),\n\t\t&tempJob) == 0 ) {\n\t\tfree_upnp_timeout((upnp_timeout *)tempJob.arg);\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"REMOVED AUTO RENEW  EVENT\");\n\n\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\n\tHandleUnlock();\n\n\treturn_code = gena_subscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tTimeOut,\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\tActualSID);\n\n\tHandleLock();\n\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\t/* we just called GetHandleInfo, so we don't check for return value */\n\t/*GetHandleInfo(client_handle, &handle_info); */\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\t/* network failure (remove client sub) */\n\t\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\t/* get subscription */\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* store actual sid */\n\tGenlibClientSubscription_set_ActualSID(sub, ActualSID);\n\n\t/* start renew subscription timer */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, sub);\n\tif (return_code != GENA_SUCCESS) {\n\t\tRemoveClientSubClientSID(\n\t\t\t&handle_info->ClientSubList,\n\t\t\tGenlibClientSubscription_get_SID(sub));\n\t}\n\tfree_client_subscription(sub_copy);\n\tHandleUnlock();\n\nexit_function:\n\tUpnpString_delete(ActualSID);\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uuid.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"EventSubscribe.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GenlibClientSubscription_delete",
          "args": [
            "sub_copy"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_delete",
          "args": [
            "ActualSID"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "99-111",
          "snippet": "void UpnpString_delete(UpnpString *p)\n{\n\tstruct SUpnpString *q = (struct SUpnpString *)p;\n\t\t\n\tif (!q) return;\n\n\tq->m_length = (size_t)0;\n\n\tfree(q->m_string);\n\tq->m_string = NULL;\n\n\tfree(p);\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nvoid UpnpString_delete(UpnpString *p)\n{\n\tstruct SUpnpString *q = (struct SUpnpString *)p;\n\t\t\n\tif (!q) return;\n\n\tq->m_length = (size_t)0;\n\n\tfree(q->m_string);\n\tq->m_string = NULL;\n\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_client_subscription",
          "args": [
            "sub_copy"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_subscription",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/client_table/client_table.c",
          "lines": "22-40",
          "snippet": "void free_client_subscription(GenlibClientSubscription *sub)\n{\n\tupnp_timeout *event;\n\tThreadPoolJob tempJob;\n\tif (sub) {\n\t\tint renewEventId = GenlibClientSubscription_get_RenewEventId(sub);\n\t\tGenlibClientSubscription_strcpy_ActualSID(sub, \"\");\n\t\tGenlibClientSubscription_strcpy_EventURL(sub, \"\");\n\t\tif (renewEventId != -1) {\n\t\t\t/* do not remove timer event of copy */\n\t\t\t/* invalid timer event id */\n\t\t\tif (TimerThreadRemove(&gTimerThread, renewEventId, &tempJob) == 0) {\n\t\t\t\tevent = (upnp_timeout *)tempJob.arg;\n\t\t\t\tfree_upnp_timeout(event);\n\t\t\t}\n\t\t}\n\t\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\t}\n}",
          "includes": [
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"client_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for calloc(), free() */\n#include \"client_table.h\"\n#include \"config.h\"\n\nvoid free_client_subscription(GenlibClientSubscription *sub)\n{\n\tupnp_timeout *event;\n\tThreadPoolJob tempJob;\n\tif (sub) {\n\t\tint renewEventId = GenlibClientSubscription_get_RenewEventId(sub);\n\t\tGenlibClientSubscription_strcpy_ActualSID(sub, \"\");\n\t\tGenlibClientSubscription_strcpy_EventURL(sub, \"\");\n\t\tif (renewEventId != -1) {\n\t\t\t/* do not remove timer event of copy */\n\t\t\t/* invalid timer event id */\n\t\t\tif (TimerThreadRemove(&gTimerThread, renewEventId, &tempJob) == 0) {\n\t\t\t\tevent = (upnp_timeout *)tempJob.arg;\n\t\t\t\tfree_upnp_timeout(event);\n\t\t\t}\n\t\t}\n\t\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RemoveClientSubClientSID",
          "args": [
            "&handle_info->ClientSubList",
            "GenlibClientSubscription_get_SID(sub)"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "RemoveClientSubClientSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/client_table/client_table.c",
          "lines": "55-79",
          "snippet": "void RemoveClientSubClientSID(GenlibClientSubscription **head, const UpnpString *sid)\n{\n\tGenlibClientSubscription *finger = *head;\n\tGenlibClientSubscription *previous = NULL;\n\tint found = 0;\n\twhile (finger) {\n\t\tfound = !strcmp(\n\t\t\tUpnpString_get_String(sid),\n\t\t\tGenlibClientSubscription_get_SID_cstr(finger));\n\t\tif (found) {\n\t\t\tif (previous) {\n\t\t\t\tGenlibClientSubscription_set_Next(previous,\n\t\t\t\t\tGenlibClientSubscription_get_Next(finger));\n\t\t\t} else {\n\t\t\t\t*head = GenlibClientSubscription_get_Next(finger);\n\t\t\t}\n\t\t\tGenlibClientSubscription_set_Next(finger, NULL);\n\t\t\tfreeClientSubList(finger);\n\t\t\tfinger = NULL;\n\t\t} else {\n\t\t\tprevious = finger;\n\t\t\tfinger = GenlibClientSubscription_get_Next(finger);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"client_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for calloc(), free() */\n#include \"client_table.h\"\n#include \"config.h\"\n\nvoid RemoveClientSubClientSID(GenlibClientSubscription **head, const UpnpString *sid)\n{\n\tGenlibClientSubscription *finger = *head;\n\tGenlibClientSubscription *previous = NULL;\n\tint found = 0;\n\twhile (finger) {\n\t\tfound = !strcmp(\n\t\t\tUpnpString_get_String(sid),\n\t\t\tGenlibClientSubscription_get_SID_cstr(finger));\n\t\tif (found) {\n\t\t\tif (previous) {\n\t\t\t\tGenlibClientSubscription_set_Next(previous,\n\t\t\t\t\tGenlibClientSubscription_get_Next(finger));\n\t\t\t} else {\n\t\t\t\t*head = GenlibClientSubscription_get_Next(finger);\n\t\t\t}\n\t\t\tGenlibClientSubscription_set_Next(finger, NULL);\n\t\t\tfreeClientSubList(finger);\n\t\t\tfinger = NULL;\n\t\t} else {\n\t\t\tprevious = finger;\n\t\t\tfinger = GenlibClientSubscription_get_Next(finger);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_get_SID",
          "args": [
            "sub"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScheduleGenaAutoRenew",
          "args": [
            "client_handle",
            "*TimeOut",
            "sub"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "ScheduleGenaAutoRenew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "132-200",
          "snippet": "static int ScheduleGenaAutoRenew(\n\t/*! [in] Handle that also contains the subscription list. */\n\tIN int client_handle,\n\t/*! [in] The time out value of the subscription. */\n\tIN int TimeOut,\n\t/*! [in] Subscription being renewed. */\n\tIN GenlibClientSubscription *sub)\n{\n\tUpnpEventSubscribe *RenewEventStruct = NULL;\n\tupnp_timeout *RenewEvent = NULL;\n\tint return_code = GENA_SUCCESS;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tif (TimeOut == UPNP_INFINITE) {\n\t\treturn_code = GENA_SUCCESS;\n\t\tgoto end_function;\n\t}\n\n\tRenewEventStruct = UpnpEventSubscribe_new();\n\tif (RenewEventStruct == NULL) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto end_function;\n\t}\n\n\tRenewEvent = (upnp_timeout *) malloc(sizeof(upnp_timeout));\n\tif (RenewEvent == NULL) {\n\t\tfree(RenewEventStruct);\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto end_function;\n\t}\n\tmemset(RenewEvent, 0, sizeof(upnp_timeout));\n\n\t/* schedule expire event */\n\tUpnpEventSubscribe_set_ErrCode(RenewEventStruct, UPNP_E_SUCCESS);\n\tUpnpEventSubscribe_set_TimeOut(RenewEventStruct, TimeOut);\n\tUpnpEventSubscribe_set_SID(RenewEventStruct, GenlibClientSubscription_get_SID(sub));\n\tUpnpEventSubscribe_set_PublisherUrl(RenewEventStruct, GenlibClientSubscription_get_EventURL(sub));\n\n\t/* RenewEvent->EventType=UPNP_EVENT_SUBSCRIPTION_EXPIRE; */\n\tRenewEvent->handle = client_handle;\n\tRenewEvent->Event = RenewEventStruct;\n\n\tTPJobInit(&job, (start_routine) GenaAutoRenewSubscription, RenewEvent);\n\tTPJobSetFreeFunction(&job, (free_routine)free_upnp_timeout);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t/* Schedule the job */\n\treturn_code = TimerThreadSchedule(\n\t\t&gTimerThread,\n\t\tTimeOut - AUTO_RENEW_TIME,\n\t\tREL_SEC,\n\t\t&job, SHORT_TERM,\n\t\t&(RenewEvent->eventId));\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\tfree(RenewEvent);\n\t\tfree(RenewEventStruct);\n\t\tgoto end_function;\n\t}\n\n\tGenlibClientSubscription_set_RenewEventId(sub, RenewEvent->eventId);\n\n\treturn_code = GENA_SUCCESS;\n\nend_function:\n\n\treturn return_code;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nstatic int ScheduleGenaAutoRenew(\n\t/*! [in] Handle that also contains the subscription list. */\n\tIN int client_handle,\n\t/*! [in] The time out value of the subscription. */\n\tIN int TimeOut,\n\t/*! [in] Subscription being renewed. */\n\tIN GenlibClientSubscription *sub)\n{\n\tUpnpEventSubscribe *RenewEventStruct = NULL;\n\tupnp_timeout *RenewEvent = NULL;\n\tint return_code = GENA_SUCCESS;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tif (TimeOut == UPNP_INFINITE) {\n\t\treturn_code = GENA_SUCCESS;\n\t\tgoto end_function;\n\t}\n\n\tRenewEventStruct = UpnpEventSubscribe_new();\n\tif (RenewEventStruct == NULL) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto end_function;\n\t}\n\n\tRenewEvent = (upnp_timeout *) malloc(sizeof(upnp_timeout));\n\tif (RenewEvent == NULL) {\n\t\tfree(RenewEventStruct);\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto end_function;\n\t}\n\tmemset(RenewEvent, 0, sizeof(upnp_timeout));\n\n\t/* schedule expire event */\n\tUpnpEventSubscribe_set_ErrCode(RenewEventStruct, UPNP_E_SUCCESS);\n\tUpnpEventSubscribe_set_TimeOut(RenewEventStruct, TimeOut);\n\tUpnpEventSubscribe_set_SID(RenewEventStruct, GenlibClientSubscription_get_SID(sub));\n\tUpnpEventSubscribe_set_PublisherUrl(RenewEventStruct, GenlibClientSubscription_get_EventURL(sub));\n\n\t/* RenewEvent->EventType=UPNP_EVENT_SUBSCRIPTION_EXPIRE; */\n\tRenewEvent->handle = client_handle;\n\tRenewEvent->Event = RenewEventStruct;\n\n\tTPJobInit(&job, (start_routine) GenaAutoRenewSubscription, RenewEvent);\n\tTPJobSetFreeFunction(&job, (free_routine)free_upnp_timeout);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t/* Schedule the job */\n\treturn_code = TimerThreadSchedule(\n\t\t&gTimerThread,\n\t\tTimeOut - AUTO_RENEW_TIME,\n\t\tREL_SEC,\n\t\t&job, SHORT_TERM,\n\t\t&(RenewEvent->eventId));\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\tfree(RenewEvent);\n\t\tfree(RenewEventStruct);\n\t\tgoto end_function;\n\t}\n\n\tGenlibClientSubscription_set_RenewEventId(sub, RenewEvent->eventId);\n\n\treturn_code = GENA_SUCCESS;\n\nend_function:\n\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_set_ActualSID",
          "args": [
            "sub",
            "ActualSID"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetClientSubClientSID",
          "args": [
            "handle_info->ClientSubList",
            "in_sid"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "GetClientSubClientSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/client_table/client_table.c",
          "lines": "82-98",
          "snippet": "GenlibClientSubscription *GetClientSubClientSID(GenlibClientSubscription *head, const UpnpString *sid)\n{\n\tGenlibClientSubscription *next = head;\n\tint found = 0;\n\twhile (next) {\n\t\tfound = !strcmp(\n\t\t\tGenlibClientSubscription_get_SID_cstr(next),\n\t\t\tUpnpString_get_String(sid));\n\t\tif(found) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tnext = GenlibClientSubscription_get_Next(next);\n\t\t}\n\t}\n\n\treturn next;\n}",
          "includes": [
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"client_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for calloc(), free() */\n#include \"client_table.h\"\n#include \"config.h\"\n\nGenlibClientSubscription *GetClientSubClientSID(GenlibClientSubscription *head, const UpnpString *sid)\n{\n\tGenlibClientSubscription *next = head;\n\tint found = 0;\n\twhile (next) {\n\t\tfound = !strcmp(\n\t\t\tGenlibClientSubscription_get_SID_cstr(next),\n\t\t\tUpnpString_get_String(sid));\n\t\tif(found) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tnext = GenlibClientSubscription_get_Next(next);\n\t\t}\n\t}\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "client_handle",
            "&handle_info"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gena_subscribe",
          "args": [
            "GenlibClientSubscription_get_EventURL(sub_copy)",
            "TimeOut",
            "GenlibClientSubscription_get_ActualSID(sub_copy)",
            "ActualSID"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "gena_subscribe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "269-408",
          "snippet": "static int gena_subscribe(\n\t/*! [in] URL of service to subscribe. */\n\tIN const UpnpString *url,\n\t/*! [in,out] Subscription time desired (in secs). */\n\tINOUT int *timeout,\n\t/*! [in] for renewal, this contains a currently held subscription SID.\n\t * For first time subscription, this must be NULL. */\n\tIN const UpnpString *renewal_sid,\n\t/*! [out] SID returned by the subscription or renew msg. */\n\tOUT UpnpString *sid)\n{\n\tint return_code;\n\tint parse_ret = 0;\n\tint local_timeout = CP_MINIMUM_SUBSCRIPTION_TIME;\n\tmemptr sid_hdr;\n\tmemptr timeout_hdr;\n\tchar timeout_str[25];\n\tmembuffer request;\n\turi_type dest_url;\n\thttp_parser_t response;\n\tint rc = 0;\n\n\tUpnpString_clear(sid);\n\n\t/* request timeout to string */\n\tif (timeout == NULL) {\n\t\ttimeout = &local_timeout;\n\t}\n\tif (*timeout < 0) {\n\t\tmemset(timeout_str, 0, sizeof(timeout_str));\n\t\tstrncpy(timeout_str, \"infinite\", sizeof(timeout_str) - 1);\n\t} else if(*timeout < CP_MINIMUM_SUBSCRIPTION_TIME) {\n\t\trc = snprintf(timeout_str, sizeof(timeout_str),\n\t\t\t\"%d\", CP_MINIMUM_SUBSCRIPTION_TIME);\n\t} else {\n\t\trc = snprintf(timeout_str, sizeof(timeout_str), \"%d\", *timeout);\n\t}\n\tif (rc < 0 || (unsigned int) rc >= sizeof(timeout_str))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\t/* parse url */\n\treturn_code = http_FixStrUrl(\n\t\tUpnpString_get_String(url),\n\t\tUpnpString_get_Length(url),\n\t\t&dest_url);\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* make request msg */\n\tmembuffer_init(&request);\n\trequest.size_inc = 30;\n\tif (renewal_sid) {\n\t\t/* renew subscription */\n\t\treturn_code = http_MakeMessage(\n\t\t\t&request, 1, 1,\n\t\t\t\"q\" \"ssc\" \"sscc\",\n\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\"SID: \", UpnpString_get_String(renewal_sid),\n\t\t\t\"TIMEOUT: Second-\", timeout_str );\n\t} else {\n\t\t/* subscribe */\n\t\tif (dest_url.hostport.IPaddress.ss_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6* DestAddr6 = (struct sockaddr_in6*)&dest_url.hostport.IPaddress;\n\t\t\treturn_code = http_MakeMessage(\n\t\t\t\t&request, 1, 1,\n\t\t\t\t\"q\" \"sssdsc\" \"sc\" \"sscc\",\n\t\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\t\"CALLBACK: <http://[\",\n\t\t\t\t(IN6_IS_ADDR_LINKLOCAL(&DestAddr6->sin6_addr) || strlen(gIF_IPV6_ULA_GUA) == 0) ?\n\t\t\t\t\tgIF_IPV6 : gIF_IPV6_ULA_GUA,\n\t\t\t\t\"]:\", LOCAL_PORT_V6, \"/>\",\n\t\t\t\t\"NT: upnp:event\",\n\t\t\t\t\"TIMEOUT: Second-\", timeout_str);\n\t\t} else {\n\t\t\treturn_code = http_MakeMessage(\n\t\t\t\t&request, 1, 1,\n\t\t\t\t\"q\" \"sssdsc\" \"sc\" \"sscc\",\n\t\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\t\"CALLBACK: <http://\", gIF_IPV4, \":\", LOCAL_PORT_V4, \"/>\",\n\t\t\t\t\"NT: upnp:event\",\n\t\t\t\t\"TIMEOUT: Second-\", timeout_str);\n\t\t}\n\t}\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* send request and get reply */\n\treturn_code = http_RequestAndResponse(&dest_url, request.buf,\n\t\trequest.length,\n\t\tHTTPMETHOD_SUBSCRIBE,\n\t\tHTTP_DEFAULT_TIMEOUT,\n\t\t&response);\n\tmembuffer_destroy(&request);\n\n\tif (return_code != 0) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn return_code;\n\t}\n\tif (response.msg.status_code != HTTP_OK) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn UPNP_E_SUBSCRIBE_UNACCEPTED;\n\t}\n\n\t/* get SID and TIMEOUT */\n\tif (httpmsg_find_hdr(&response.msg, HDR_SID, &sid_hdr) == NULL ||\n\t    sid_hdr.length == 0 ||\n\t    httpmsg_find_hdr( &response.msg, HDR_TIMEOUT, &timeout_hdr ) == NULL ||\n\t    timeout_hdr.length == 0 ) {\n\t\thttpmsg_destroy( &response.msg );\n\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\n\t/* save timeout */\n\tparse_ret = matchstr(timeout_hdr.buf, timeout_hdr.length, \"%iSecond-%d%0\", timeout);\n\tif (parse_ret == PARSE_OK) {\n\t\t/* nothing to do */\n\t} else if (memptr_cmp_nocase(&timeout_hdr, \"Second-infinite\") == 0) {\n\t\t*timeout = -1;\n\t} else {\n\t\thttpmsg_destroy( &response.msg );\n\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\n\t/* save SID */\n\tUpnpString_set_StringN(sid, sid_hdr.buf, sid_hdr.length);\n\tif (UpnpString_get_String(sid) == NULL) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thttpmsg_destroy(&response.msg);\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic int gena_subscribe(\n\t/*! [in] URL of service to subscribe. */\n\tIN const UpnpString *url,\n\t/*! [in,out] Subscription time desired (in secs). */\n\tINOUT int *timeout,\n\t/*! [in] for renewal, this contains a currently held subscription SID.\n\t * For first time subscription, this must be NULL. */\n\tIN const UpnpString *renewal_sid,\n\t/*! [out] SID returned by the subscription or renew msg. */\n\tOUT UpnpString *sid)\n{\n\tint return_code;\n\tint parse_ret = 0;\n\tint local_timeout = CP_MINIMUM_SUBSCRIPTION_TIME;\n\tmemptr sid_hdr;\n\tmemptr timeout_hdr;\n\tchar timeout_str[25];\n\tmembuffer request;\n\turi_type dest_url;\n\thttp_parser_t response;\n\tint rc = 0;\n\n\tUpnpString_clear(sid);\n\n\t/* request timeout to string */\n\tif (timeout == NULL) {\n\t\ttimeout = &local_timeout;\n\t}\n\tif (*timeout < 0) {\n\t\tmemset(timeout_str, 0, sizeof(timeout_str));\n\t\tstrncpy(timeout_str, \"infinite\", sizeof(timeout_str) - 1);\n\t} else if(*timeout < CP_MINIMUM_SUBSCRIPTION_TIME) {\n\t\trc = snprintf(timeout_str, sizeof(timeout_str),\n\t\t\t\"%d\", CP_MINIMUM_SUBSCRIPTION_TIME);\n\t} else {\n\t\trc = snprintf(timeout_str, sizeof(timeout_str), \"%d\", *timeout);\n\t}\n\tif (rc < 0 || (unsigned int) rc >= sizeof(timeout_str))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\t/* parse url */\n\treturn_code = http_FixStrUrl(\n\t\tUpnpString_get_String(url),\n\t\tUpnpString_get_Length(url),\n\t\t&dest_url);\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* make request msg */\n\tmembuffer_init(&request);\n\trequest.size_inc = 30;\n\tif (renewal_sid) {\n\t\t/* renew subscription */\n\t\treturn_code = http_MakeMessage(\n\t\t\t&request, 1, 1,\n\t\t\t\"q\" \"ssc\" \"sscc\",\n\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\"SID: \", UpnpString_get_String(renewal_sid),\n\t\t\t\"TIMEOUT: Second-\", timeout_str );\n\t} else {\n\t\t/* subscribe */\n\t\tif (dest_url.hostport.IPaddress.ss_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6* DestAddr6 = (struct sockaddr_in6*)&dest_url.hostport.IPaddress;\n\t\t\treturn_code = http_MakeMessage(\n\t\t\t\t&request, 1, 1,\n\t\t\t\t\"q\" \"sssdsc\" \"sc\" \"sscc\",\n\t\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\t\"CALLBACK: <http://[\",\n\t\t\t\t(IN6_IS_ADDR_LINKLOCAL(&DestAddr6->sin6_addr) || strlen(gIF_IPV6_ULA_GUA) == 0) ?\n\t\t\t\t\tgIF_IPV6 : gIF_IPV6_ULA_GUA,\n\t\t\t\t\"]:\", LOCAL_PORT_V6, \"/>\",\n\t\t\t\t\"NT: upnp:event\",\n\t\t\t\t\"TIMEOUT: Second-\", timeout_str);\n\t\t} else {\n\t\t\treturn_code = http_MakeMessage(\n\t\t\t\t&request, 1, 1,\n\t\t\t\t\"q\" \"sssdsc\" \"sc\" \"sscc\",\n\t\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\t\"CALLBACK: <http://\", gIF_IPV4, \":\", LOCAL_PORT_V4, \"/>\",\n\t\t\t\t\"NT: upnp:event\",\n\t\t\t\t\"TIMEOUT: Second-\", timeout_str);\n\t\t}\n\t}\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* send request and get reply */\n\treturn_code = http_RequestAndResponse(&dest_url, request.buf,\n\t\trequest.length,\n\t\tHTTPMETHOD_SUBSCRIBE,\n\t\tHTTP_DEFAULT_TIMEOUT,\n\t\t&response);\n\tmembuffer_destroy(&request);\n\n\tif (return_code != 0) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn return_code;\n\t}\n\tif (response.msg.status_code != HTTP_OK) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn UPNP_E_SUBSCRIBE_UNACCEPTED;\n\t}\n\n\t/* get SID and TIMEOUT */\n\tif (httpmsg_find_hdr(&response.msg, HDR_SID, &sid_hdr) == NULL ||\n\t    sid_hdr.length == 0 ||\n\t    httpmsg_find_hdr( &response.msg, HDR_TIMEOUT, &timeout_hdr ) == NULL ||\n\t    timeout_hdr.length == 0 ) {\n\t\thttpmsg_destroy( &response.msg );\n\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\n\t/* save timeout */\n\tparse_ret = matchstr(timeout_hdr.buf, timeout_hdr.length, \"%iSecond-%d%0\", timeout);\n\tif (parse_ret == PARSE_OK) {\n\t\t/* nothing to do */\n\t} else if (memptr_cmp_nocase(&timeout_hdr, \"Second-infinite\") == 0) {\n\t\t*timeout = -1;\n\t} else {\n\t\thttpmsg_destroy( &response.msg );\n\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\n\t/* save SID */\n\tUpnpString_set_StringN(sid, sid_hdr.buf, sid_hdr.length);\n\tif (UpnpString_get_String(sid) == NULL) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thttpmsg_destroy(&response.msg);\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_get_ActualSID",
          "args": [
            "sub_copy"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_get_EventURL",
          "args": [
            "sub_copy"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_assign",
          "args": [
            "sub_copy",
            "sub"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_set_RenewEventId",
          "args": [
            "sub",
            "-1"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "GENA",
            "__FILE__",
            "__LINE__",
            "\"REMOVED AUTO RENEW  EVENT\""
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_upnp_timeout",
          "args": [
            "(upnp_timeout *)tempJob.arg"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "free_upnp_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/upnp_timeout.c",
          "lines": "50-58",
          "snippet": "void free_upnp_timeout(upnp_timeout *event)\n{\n\tif (event) {\n\t\tif (event->Event) {\n\t\t\tfree(event->Event);\n\t\t}\n\t\tfree(event);\n\t}\n}",
          "includes": [
            "#include <stdlib.h> /* for free() */",
            "#include \"upnp_timeout.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for free() */\n#include \"upnp_timeout.h\"\n#include \"config.h\"\n\nvoid free_upnp_timeout(upnp_timeout *event)\n{\n\tif (event) {\n\t\tif (event->Event) {\n\t\t\tfree(event->Event);\n\t\t}\n\t\tfree(event);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimerThreadRemove",
          "args": [
            "&gTimerThread",
            "GenlibClientSubscription_get_RenewEventId(sub)",
            "&tempJob"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_get_RenewEventId",
          "args": [
            "sub"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_new",
          "args": [],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "73-97",
          "snippet": "UpnpString *UpnpString_new()\n{\n\t/* All bytes are zero, and so is the length of the string. */\n\tstruct SUpnpString *p = calloc((size_t)1, sizeof (struct SUpnpString));\n\tif (p == NULL) {\n\t\tgoto error_handler1;\n\t}\n#if 0\n\tp->m_length = 0;\n#endif\n\n\t/* This byte is zero, calloc does initialize it. */\n\tp->m_string = calloc((size_t)1, (size_t)1);\n\tif (p->m_string == NULL) {\n\t\tgoto error_handler2;\n\t}\n\n\treturn (UpnpString *)p;\n\n\t/*free(p->m_string); */\nerror_handler2:\n\tfree(p);\nerror_handler1:\n\treturn NULL;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nUpnpString *UpnpString_new()\n{\n\t/* All bytes are zero, and so is the length of the string. */\n\tstruct SUpnpString *p = calloc((size_t)1, sizeof (struct SUpnpString));\n\tif (p == NULL) {\n\t\tgoto error_handler1;\n\t}\n#if 0\n\tp->m_length = 0;\n#endif\n\n\t/* This byte is zero, calloc does initialize it. */\n\tp->m_string = calloc((size_t)1, (size_t)1);\n\tif (p->m_string == NULL) {\n\t\tgoto error_handler2;\n\t}\n\n\treturn (UpnpString *)p;\n\n\t/*free(p->m_string); */\nerror_handler2:\n\tfree(p);\nerror_handler1:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_new",
          "args": [],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nint genaRenewSubscription(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid,\n\tint *TimeOut)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *sub = NULL;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\tstruct Handle_Info *handle_info;\n\tUpnpString *ActualSID = UpnpString_new();\n\tThreadPoolJob tempJob;\n\n\tHandleLock();\n\n\t/* validate handle and sid */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* remove old events */\n\tif (TimerThreadRemove(\n\t\t&gTimerThread,\n\t\tGenlibClientSubscription_get_RenewEventId(sub),\n\t\t&tempJob) == 0 ) {\n\t\tfree_upnp_timeout((upnp_timeout *)tempJob.arg);\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"REMOVED AUTO RENEW  EVENT\");\n\n\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\n\tHandleUnlock();\n\n\treturn_code = gena_subscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tTimeOut,\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\tActualSID);\n\n\tHandleLock();\n\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\t/* we just called GetHandleInfo, so we don't check for return value */\n\t/*GetHandleInfo(client_handle, &handle_info); */\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\t/* network failure (remove client sub) */\n\t\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\t/* get subscription */\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* store actual sid */\n\tGenlibClientSubscription_set_ActualSID(sub, ActualSID);\n\n\t/* start renew subscription timer */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, sub);\n\tif (return_code != GENA_SUCCESS) {\n\t\tRemoveClientSubClientSID(\n\t\t\t&handle_info->ClientSubList,\n\t\t\tGenlibClientSubscription_get_SID(sub));\n\t}\n\tfree_client_subscription(sub_copy);\n\tHandleUnlock();\n\nexit_function:\n\tUpnpString_delete(ActualSID);\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}"
  },
  {
    "function_name": "genaSubscribe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
    "lines": "509-594",
    "snippet": "int genaSubscribe(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *PublisherURL,\n\tint *TimeOut,\n\tUpnpString *out_sid)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *newSubscription = GenlibClientSubscription_new();\n\tuuid_upnp uid;\n\tUpnp_SID temp_sid;\n\tUpnp_SID temp_sid2;\n\tUpnpString *ActualSID = UpnpString_new();\n\tUpnpString *EventURL = UpnpString_new();\n\tstruct Handle_Info *handle_info;\n\tint rc = 0;\n\n\tmemset(temp_sid, 0, sizeof(temp_sid));\n\tmemset(temp_sid2, 0, sizeof(temp_sid2));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"GENA SUBSCRIBE BEGIN\");\n\n\tUpnpString_clear(out_sid);\n\n\tHandleReadLock();\n\t/* validate handle */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tSubscribeLock();\n\t\tgoto error_handler;\n\t}\n\tHandleUnlock();\n\n\t/* subscribe */\n\tSubscribeLock();\n\treturn_code = gena_subscribe(PublisherURL, TimeOut, NULL, ActualSID);\n\tHandleLock();\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf( UPNP_CRITICAL, GENA, __FILE__, __LINE__,\n\t\t\t\"SUBSCRIBE FAILED in transfer error code: %d returned\\n\",\n\t\t\treturn_code );\n\t\tgoto error_handler;\n\t}\n\n\tif(GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto error_handler;\n\t}\n\n\t/* generate client SID */\n\tuuid_create(&uid );\n\tuuid_unpack(&uid, temp_sid);\n\trc = snprintf(temp_sid2, sizeof(temp_sid2), \"uuid:%s\", temp_sid);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(temp_sid2)) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto error_handler;\n\t}\n\tUpnpString_set_String(out_sid, temp_sid2);\n\n\t/* create event url */\n\tUpnpString_assign(EventURL, PublisherURL);\n\n\t/* fill subscription */\n\tif (newSubscription == NULL) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto error_handler;\n\t}\n\tGenlibClientSubscription_set_RenewEventId(newSubscription, -1);\n\tGenlibClientSubscription_set_SID(newSubscription, out_sid);\n\tGenlibClientSubscription_set_ActualSID(newSubscription, ActualSID);\n\tGenlibClientSubscription_set_EventURL(newSubscription, EventURL);\n\tGenlibClientSubscription_set_Next(newSubscription, handle_info->ClientSubList);\n\thandle_info->ClientSubList = newSubscription;\n\n\t/* schedule expiration event */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, newSubscription);\n\nerror_handler:\n\tUpnpString_delete(ActualSID);\n\tUpnpString_delete(EventURL);\n\tif (return_code != UPNP_E_SUCCESS)\n\t\tGenlibClientSubscription_delete(newSubscription);\n\tHandleUnlock();\n\tSubscribeUnlock();\n\n\treturn return_code;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uuid.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"EventSubscribe.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SubscribeUnlock",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_delete",
          "args": [
            "newSubscription"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_delete",
          "args": [
            "EventURL"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "99-111",
          "snippet": "void UpnpString_delete(UpnpString *p)\n{\n\tstruct SUpnpString *q = (struct SUpnpString *)p;\n\t\t\n\tif (!q) return;\n\n\tq->m_length = (size_t)0;\n\n\tfree(q->m_string);\n\tq->m_string = NULL;\n\n\tfree(p);\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nvoid UpnpString_delete(UpnpString *p)\n{\n\tstruct SUpnpString *q = (struct SUpnpString *)p;\n\t\t\n\tif (!q) return;\n\n\tq->m_length = (size_t)0;\n\n\tfree(q->m_string);\n\tq->m_string = NULL;\n\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ScheduleGenaAutoRenew",
          "args": [
            "client_handle",
            "*TimeOut",
            "newSubscription"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "ScheduleGenaAutoRenew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "132-200",
          "snippet": "static int ScheduleGenaAutoRenew(\n\t/*! [in] Handle that also contains the subscription list. */\n\tIN int client_handle,\n\t/*! [in] The time out value of the subscription. */\n\tIN int TimeOut,\n\t/*! [in] Subscription being renewed. */\n\tIN GenlibClientSubscription *sub)\n{\n\tUpnpEventSubscribe *RenewEventStruct = NULL;\n\tupnp_timeout *RenewEvent = NULL;\n\tint return_code = GENA_SUCCESS;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tif (TimeOut == UPNP_INFINITE) {\n\t\treturn_code = GENA_SUCCESS;\n\t\tgoto end_function;\n\t}\n\n\tRenewEventStruct = UpnpEventSubscribe_new();\n\tif (RenewEventStruct == NULL) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto end_function;\n\t}\n\n\tRenewEvent = (upnp_timeout *) malloc(sizeof(upnp_timeout));\n\tif (RenewEvent == NULL) {\n\t\tfree(RenewEventStruct);\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto end_function;\n\t}\n\tmemset(RenewEvent, 0, sizeof(upnp_timeout));\n\n\t/* schedule expire event */\n\tUpnpEventSubscribe_set_ErrCode(RenewEventStruct, UPNP_E_SUCCESS);\n\tUpnpEventSubscribe_set_TimeOut(RenewEventStruct, TimeOut);\n\tUpnpEventSubscribe_set_SID(RenewEventStruct, GenlibClientSubscription_get_SID(sub));\n\tUpnpEventSubscribe_set_PublisherUrl(RenewEventStruct, GenlibClientSubscription_get_EventURL(sub));\n\n\t/* RenewEvent->EventType=UPNP_EVENT_SUBSCRIPTION_EXPIRE; */\n\tRenewEvent->handle = client_handle;\n\tRenewEvent->Event = RenewEventStruct;\n\n\tTPJobInit(&job, (start_routine) GenaAutoRenewSubscription, RenewEvent);\n\tTPJobSetFreeFunction(&job, (free_routine)free_upnp_timeout);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t/* Schedule the job */\n\treturn_code = TimerThreadSchedule(\n\t\t&gTimerThread,\n\t\tTimeOut - AUTO_RENEW_TIME,\n\t\tREL_SEC,\n\t\t&job, SHORT_TERM,\n\t\t&(RenewEvent->eventId));\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\tfree(RenewEvent);\n\t\tfree(RenewEventStruct);\n\t\tgoto end_function;\n\t}\n\n\tGenlibClientSubscription_set_RenewEventId(sub, RenewEvent->eventId);\n\n\treturn_code = GENA_SUCCESS;\n\nend_function:\n\n\treturn return_code;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nstatic int ScheduleGenaAutoRenew(\n\t/*! [in] Handle that also contains the subscription list. */\n\tIN int client_handle,\n\t/*! [in] The time out value of the subscription. */\n\tIN int TimeOut,\n\t/*! [in] Subscription being renewed. */\n\tIN GenlibClientSubscription *sub)\n{\n\tUpnpEventSubscribe *RenewEventStruct = NULL;\n\tupnp_timeout *RenewEvent = NULL;\n\tint return_code = GENA_SUCCESS;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tif (TimeOut == UPNP_INFINITE) {\n\t\treturn_code = GENA_SUCCESS;\n\t\tgoto end_function;\n\t}\n\n\tRenewEventStruct = UpnpEventSubscribe_new();\n\tif (RenewEventStruct == NULL) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto end_function;\n\t}\n\n\tRenewEvent = (upnp_timeout *) malloc(sizeof(upnp_timeout));\n\tif (RenewEvent == NULL) {\n\t\tfree(RenewEventStruct);\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto end_function;\n\t}\n\tmemset(RenewEvent, 0, sizeof(upnp_timeout));\n\n\t/* schedule expire event */\n\tUpnpEventSubscribe_set_ErrCode(RenewEventStruct, UPNP_E_SUCCESS);\n\tUpnpEventSubscribe_set_TimeOut(RenewEventStruct, TimeOut);\n\tUpnpEventSubscribe_set_SID(RenewEventStruct, GenlibClientSubscription_get_SID(sub));\n\tUpnpEventSubscribe_set_PublisherUrl(RenewEventStruct, GenlibClientSubscription_get_EventURL(sub));\n\n\t/* RenewEvent->EventType=UPNP_EVENT_SUBSCRIPTION_EXPIRE; */\n\tRenewEvent->handle = client_handle;\n\tRenewEvent->Event = RenewEventStruct;\n\n\tTPJobInit(&job, (start_routine) GenaAutoRenewSubscription, RenewEvent);\n\tTPJobSetFreeFunction(&job, (free_routine)free_upnp_timeout);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t/* Schedule the job */\n\treturn_code = TimerThreadSchedule(\n\t\t&gTimerThread,\n\t\tTimeOut - AUTO_RENEW_TIME,\n\t\tREL_SEC,\n\t\t&job, SHORT_TERM,\n\t\t&(RenewEvent->eventId));\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\tfree(RenewEvent);\n\t\tfree(RenewEventStruct);\n\t\tgoto end_function;\n\t}\n\n\tGenlibClientSubscription_set_RenewEventId(sub, RenewEvent->eventId);\n\n\treturn_code = GENA_SUCCESS;\n\nend_function:\n\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_set_Next",
          "args": [
            "newSubscription",
            "handle_info->ClientSubList"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_set_EventURL",
          "args": [
            "newSubscription",
            "EventURL"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_set_ActualSID",
          "args": [
            "newSubscription",
            "ActualSID"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_set_SID",
          "args": [
            "newSubscription",
            "out_sid"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_set_RenewEventId",
          "args": [
            "newSubscription",
            "-1"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_assign",
          "args": [
            "EventURL",
            "PublisherURL"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "134-139",
          "snippet": "void UpnpString_assign(UpnpString *p, const UpnpString *q)\n{\n\tif (p != q) {\n\t\tUpnpString_set_String(p, UpnpString_get_String(q));\n\t}\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nvoid UpnpString_assign(UpnpString *p, const UpnpString *q)\n{\n\tif (p != q) {\n\t\tUpnpString_set_String(p, UpnpString_get_String(q));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpString_set_String",
          "args": [
            "out_sid",
            "temp_sid2"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_set_String",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "160-170",
          "snippet": "int UpnpString_set_String(UpnpString *p, const char *s)\n{\n\tchar *q = strdup(s);\n\tif (!q) goto error_handler1;\n\tfree(((struct SUpnpString *)p)->m_string);\n\t((struct SUpnpString *)p)->m_length = strlen(q);\n\t((struct SUpnpString *)p)->m_string = q;\n\nerror_handler1:\n\treturn q != NULL;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nint UpnpString_set_String(UpnpString *p, const char *s)\n{\n\tchar *q = strdup(s);\n\tif (!q) goto error_handler1;\n\tfree(((struct SUpnpString *)p)->m_string);\n\t((struct SUpnpString *)p)->m_length = strlen(q);\n\t((struct SUpnpString *)p)->m_string = q;\n\nerror_handler1:\n\treturn q != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "temp_sid2",
            "sizeof(temp_sid2)",
            "\"uuid:%s\"",
            "temp_sid"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_unpack",
          "args": [
            "&uid",
            "temp_sid"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_unpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "85-96",
          "snippet": "void uuid_unpack(uuid_upnp * u, char *out)\n{\n\tsprintf(out,\n\t\t\"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\",\n\t\t(unsigned int)u->time_low,\n\t\tu->time_mid,\n\t\tu->time_hi_and_version,\n\t\tu->clock_seq_hi_and_reserved,\n\t\tu->clock_seq_low,\n\t\tu->node[0],\n\t\tu->node[1], u->node[2], u->node[3], u->node[4], u->node[5]);\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"uuid.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
            "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
            "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\n\nvoid uuid_unpack(uuid_upnp * u, char *out)\n{\n\tsprintf(out,\n\t\t\"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\",\n\t\t(unsigned int)u->time_low,\n\t\tu->time_mid,\n\t\tu->time_hi_and_version,\n\t\tu->clock_seq_hi_and_reserved,\n\t\tu->clock_seq_low,\n\t\tu->node[0],\n\t\tu->node[1], u->node[2], u->node[3], u->node[4], u->node[5]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_create",
          "args": [
            "&uid"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/uuid.c",
          "lines": "53-83",
          "snippet": "int uuid_create(uuid_upnp * uid)\n{\n\tuuid_time_t timestamp;\n\tuuid_time_t last_time;\n\tuint16_t clockseq;\n\tuuid_node_t node;\n\tuuid_node_t last_node;\n\tint f;\n\n\t/* acquire system wide lock so we're alone. */\n\tUUIDLock();\n\t/* get current time. */\n\tget_current_time(&timestamp);\n\t/* get node ID. */\n\tget_ieee_node_identifier(&node);\n\t/* get saved state from NV storage. */\n\tf = read_state(&clockseq, &last_time, &last_node);\n\t/* if no NV state, or if clock went backwards, or node ID changed\n\t * (e.g., net card swap) change clockseq. */\n\tif (!f || memcmp(&node, &last_node, sizeof(uuid_node_t)))\n\t\tclockseq = true_random();\n\telse if (timestamp < last_time)\n\t\tclockseq++;\n\t/* stuff fields into the UUID. */\n\tformat_uuid_v1(uid, clockseq, timestamp, node);\n\t/* save the state for next time. */\n\twrite_state(clockseq, timestamp, node);\n\tUUIDUnlock();\n\n\treturn 1;\n}",
          "includes": [
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"uuid.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);",
            "static void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);",
            "static void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);",
            "static void get_current_time(uuid_time_t *timestamp);",
            "static uint16_t true_random(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"UpnpStdInt.h\"\n#include \"UpnpInet.h\"\n#include \"uuid.h\"\n#include \"config.h\"\n\nstatic int read_state(uint16_t *clockseq,\n\t\t      uuid_time_t *timestamp, uuid_node_t * node);\nstatic void write_state(uint16_t clockseq,\n\t\t\tuuid_time_t timestamp, uuid_node_t node);\nstatic void format_uuid_v1(uuid_upnp *uid,\n\t\t\t   uint16_t clockseq,\n\t\t\t   uuid_time_t timestamp, uuid_node_t node);\nstatic void get_current_time(uuid_time_t *timestamp);\nstatic uint16_t true_random(void);\n\nint uuid_create(uuid_upnp * uid)\n{\n\tuuid_time_t timestamp;\n\tuuid_time_t last_time;\n\tuint16_t clockseq;\n\tuuid_node_t node;\n\tuuid_node_t last_node;\n\tint f;\n\n\t/* acquire system wide lock so we're alone. */\n\tUUIDLock();\n\t/* get current time. */\n\tget_current_time(&timestamp);\n\t/* get node ID. */\n\tget_ieee_node_identifier(&node);\n\t/* get saved state from NV storage. */\n\tf = read_state(&clockseq, &last_time, &last_node);\n\t/* if no NV state, or if clock went backwards, or node ID changed\n\t * (e.g., net card swap) change clockseq. */\n\tif (!f || memcmp(&node, &last_node, sizeof(uuid_node_t)))\n\t\tclockseq = true_random();\n\telse if (timestamp < last_time)\n\t\tclockseq++;\n\t/* stuff fields into the UUID. */\n\tformat_uuid_v1(uid, clockseq, timestamp, node);\n\t/* save the state for next time. */\n\twrite_state(clockseq, timestamp, node);\n\tUUIDUnlock();\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "client_handle",
            "&handle_info"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_CRITICAL",
            "GENA",
            "__FILE__",
            "__LINE__",
            "\"SUBSCRIBE FAILED in transfer error code: %d returned\\n\"",
            "return_code"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gena_subscribe",
          "args": [
            "PublisherURL",
            "TimeOut",
            "NULL",
            "ActualSID"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "gena_subscribe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "269-408",
          "snippet": "static int gena_subscribe(\n\t/*! [in] URL of service to subscribe. */\n\tIN const UpnpString *url,\n\t/*! [in,out] Subscription time desired (in secs). */\n\tINOUT int *timeout,\n\t/*! [in] for renewal, this contains a currently held subscription SID.\n\t * For first time subscription, this must be NULL. */\n\tIN const UpnpString *renewal_sid,\n\t/*! [out] SID returned by the subscription or renew msg. */\n\tOUT UpnpString *sid)\n{\n\tint return_code;\n\tint parse_ret = 0;\n\tint local_timeout = CP_MINIMUM_SUBSCRIPTION_TIME;\n\tmemptr sid_hdr;\n\tmemptr timeout_hdr;\n\tchar timeout_str[25];\n\tmembuffer request;\n\turi_type dest_url;\n\thttp_parser_t response;\n\tint rc = 0;\n\n\tUpnpString_clear(sid);\n\n\t/* request timeout to string */\n\tif (timeout == NULL) {\n\t\ttimeout = &local_timeout;\n\t}\n\tif (*timeout < 0) {\n\t\tmemset(timeout_str, 0, sizeof(timeout_str));\n\t\tstrncpy(timeout_str, \"infinite\", sizeof(timeout_str) - 1);\n\t} else if(*timeout < CP_MINIMUM_SUBSCRIPTION_TIME) {\n\t\trc = snprintf(timeout_str, sizeof(timeout_str),\n\t\t\t\"%d\", CP_MINIMUM_SUBSCRIPTION_TIME);\n\t} else {\n\t\trc = snprintf(timeout_str, sizeof(timeout_str), \"%d\", *timeout);\n\t}\n\tif (rc < 0 || (unsigned int) rc >= sizeof(timeout_str))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\t/* parse url */\n\treturn_code = http_FixStrUrl(\n\t\tUpnpString_get_String(url),\n\t\tUpnpString_get_Length(url),\n\t\t&dest_url);\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* make request msg */\n\tmembuffer_init(&request);\n\trequest.size_inc = 30;\n\tif (renewal_sid) {\n\t\t/* renew subscription */\n\t\treturn_code = http_MakeMessage(\n\t\t\t&request, 1, 1,\n\t\t\t\"q\" \"ssc\" \"sscc\",\n\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\"SID: \", UpnpString_get_String(renewal_sid),\n\t\t\t\"TIMEOUT: Second-\", timeout_str );\n\t} else {\n\t\t/* subscribe */\n\t\tif (dest_url.hostport.IPaddress.ss_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6* DestAddr6 = (struct sockaddr_in6*)&dest_url.hostport.IPaddress;\n\t\t\treturn_code = http_MakeMessage(\n\t\t\t\t&request, 1, 1,\n\t\t\t\t\"q\" \"sssdsc\" \"sc\" \"sscc\",\n\t\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\t\"CALLBACK: <http://[\",\n\t\t\t\t(IN6_IS_ADDR_LINKLOCAL(&DestAddr6->sin6_addr) || strlen(gIF_IPV6_ULA_GUA) == 0) ?\n\t\t\t\t\tgIF_IPV6 : gIF_IPV6_ULA_GUA,\n\t\t\t\t\"]:\", LOCAL_PORT_V6, \"/>\",\n\t\t\t\t\"NT: upnp:event\",\n\t\t\t\t\"TIMEOUT: Second-\", timeout_str);\n\t\t} else {\n\t\t\treturn_code = http_MakeMessage(\n\t\t\t\t&request, 1, 1,\n\t\t\t\t\"q\" \"sssdsc\" \"sc\" \"sscc\",\n\t\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\t\"CALLBACK: <http://\", gIF_IPV4, \":\", LOCAL_PORT_V4, \"/>\",\n\t\t\t\t\"NT: upnp:event\",\n\t\t\t\t\"TIMEOUT: Second-\", timeout_str);\n\t\t}\n\t}\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* send request and get reply */\n\treturn_code = http_RequestAndResponse(&dest_url, request.buf,\n\t\trequest.length,\n\t\tHTTPMETHOD_SUBSCRIBE,\n\t\tHTTP_DEFAULT_TIMEOUT,\n\t\t&response);\n\tmembuffer_destroy(&request);\n\n\tif (return_code != 0) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn return_code;\n\t}\n\tif (response.msg.status_code != HTTP_OK) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn UPNP_E_SUBSCRIBE_UNACCEPTED;\n\t}\n\n\t/* get SID and TIMEOUT */\n\tif (httpmsg_find_hdr(&response.msg, HDR_SID, &sid_hdr) == NULL ||\n\t    sid_hdr.length == 0 ||\n\t    httpmsg_find_hdr( &response.msg, HDR_TIMEOUT, &timeout_hdr ) == NULL ||\n\t    timeout_hdr.length == 0 ) {\n\t\thttpmsg_destroy( &response.msg );\n\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\n\t/* save timeout */\n\tparse_ret = matchstr(timeout_hdr.buf, timeout_hdr.length, \"%iSecond-%d%0\", timeout);\n\tif (parse_ret == PARSE_OK) {\n\t\t/* nothing to do */\n\t} else if (memptr_cmp_nocase(&timeout_hdr, \"Second-infinite\") == 0) {\n\t\t*timeout = -1;\n\t} else {\n\t\thttpmsg_destroy( &response.msg );\n\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\n\t/* save SID */\n\tUpnpString_set_StringN(sid, sid_hdr.buf, sid_hdr.length);\n\tif (UpnpString_get_String(sid) == NULL) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thttpmsg_destroy(&response.msg);\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic int gena_subscribe(\n\t/*! [in] URL of service to subscribe. */\n\tIN const UpnpString *url,\n\t/*! [in,out] Subscription time desired (in secs). */\n\tINOUT int *timeout,\n\t/*! [in] for renewal, this contains a currently held subscription SID.\n\t * For first time subscription, this must be NULL. */\n\tIN const UpnpString *renewal_sid,\n\t/*! [out] SID returned by the subscription or renew msg. */\n\tOUT UpnpString *sid)\n{\n\tint return_code;\n\tint parse_ret = 0;\n\tint local_timeout = CP_MINIMUM_SUBSCRIPTION_TIME;\n\tmemptr sid_hdr;\n\tmemptr timeout_hdr;\n\tchar timeout_str[25];\n\tmembuffer request;\n\turi_type dest_url;\n\thttp_parser_t response;\n\tint rc = 0;\n\n\tUpnpString_clear(sid);\n\n\t/* request timeout to string */\n\tif (timeout == NULL) {\n\t\ttimeout = &local_timeout;\n\t}\n\tif (*timeout < 0) {\n\t\tmemset(timeout_str, 0, sizeof(timeout_str));\n\t\tstrncpy(timeout_str, \"infinite\", sizeof(timeout_str) - 1);\n\t} else if(*timeout < CP_MINIMUM_SUBSCRIPTION_TIME) {\n\t\trc = snprintf(timeout_str, sizeof(timeout_str),\n\t\t\t\"%d\", CP_MINIMUM_SUBSCRIPTION_TIME);\n\t} else {\n\t\trc = snprintf(timeout_str, sizeof(timeout_str), \"%d\", *timeout);\n\t}\n\tif (rc < 0 || (unsigned int) rc >= sizeof(timeout_str))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\t/* parse url */\n\treturn_code = http_FixStrUrl(\n\t\tUpnpString_get_String(url),\n\t\tUpnpString_get_Length(url),\n\t\t&dest_url);\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* make request msg */\n\tmembuffer_init(&request);\n\trequest.size_inc = 30;\n\tif (renewal_sid) {\n\t\t/* renew subscription */\n\t\treturn_code = http_MakeMessage(\n\t\t\t&request, 1, 1,\n\t\t\t\"q\" \"ssc\" \"sscc\",\n\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\"SID: \", UpnpString_get_String(renewal_sid),\n\t\t\t\"TIMEOUT: Second-\", timeout_str );\n\t} else {\n\t\t/* subscribe */\n\t\tif (dest_url.hostport.IPaddress.ss_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6* DestAddr6 = (struct sockaddr_in6*)&dest_url.hostport.IPaddress;\n\t\t\treturn_code = http_MakeMessage(\n\t\t\t\t&request, 1, 1,\n\t\t\t\t\"q\" \"sssdsc\" \"sc\" \"sscc\",\n\t\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\t\"CALLBACK: <http://[\",\n\t\t\t\t(IN6_IS_ADDR_LINKLOCAL(&DestAddr6->sin6_addr) || strlen(gIF_IPV6_ULA_GUA) == 0) ?\n\t\t\t\t\tgIF_IPV6 : gIF_IPV6_ULA_GUA,\n\t\t\t\t\"]:\", LOCAL_PORT_V6, \"/>\",\n\t\t\t\t\"NT: upnp:event\",\n\t\t\t\t\"TIMEOUT: Second-\", timeout_str);\n\t\t} else {\n\t\t\treturn_code = http_MakeMessage(\n\t\t\t\t&request, 1, 1,\n\t\t\t\t\"q\" \"sssdsc\" \"sc\" \"sscc\",\n\t\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\t\"CALLBACK: <http://\", gIF_IPV4, \":\", LOCAL_PORT_V4, \"/>\",\n\t\t\t\t\"NT: upnp:event\",\n\t\t\t\t\"TIMEOUT: Second-\", timeout_str);\n\t\t}\n\t}\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* send request and get reply */\n\treturn_code = http_RequestAndResponse(&dest_url, request.buf,\n\t\trequest.length,\n\t\tHTTPMETHOD_SUBSCRIBE,\n\t\tHTTP_DEFAULT_TIMEOUT,\n\t\t&response);\n\tmembuffer_destroy(&request);\n\n\tif (return_code != 0) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn return_code;\n\t}\n\tif (response.msg.status_code != HTTP_OK) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn UPNP_E_SUBSCRIBE_UNACCEPTED;\n\t}\n\n\t/* get SID and TIMEOUT */\n\tif (httpmsg_find_hdr(&response.msg, HDR_SID, &sid_hdr) == NULL ||\n\t    sid_hdr.length == 0 ||\n\t    httpmsg_find_hdr( &response.msg, HDR_TIMEOUT, &timeout_hdr ) == NULL ||\n\t    timeout_hdr.length == 0 ) {\n\t\thttpmsg_destroy( &response.msg );\n\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\n\t/* save timeout */\n\tparse_ret = matchstr(timeout_hdr.buf, timeout_hdr.length, \"%iSecond-%d%0\", timeout);\n\tif (parse_ret == PARSE_OK) {\n\t\t/* nothing to do */\n\t} else if (memptr_cmp_nocase(&timeout_hdr, \"Second-infinite\") == 0) {\n\t\t*timeout = -1;\n\t} else {\n\t\thttpmsg_destroy( &response.msg );\n\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\n\t/* save SID */\n\tUpnpString_set_StringN(sid, sid_hdr.buf, sid_hdr.length);\n\tif (UpnpString_get_String(sid) == NULL) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thttpmsg_destroy(&response.msg);\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SubscribeLock",
          "args": [],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SubscribeLock",
          "args": [],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_clear",
          "args": [
            "out_sid"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "184-189",
          "snippet": "void UpnpString_clear(UpnpString *p)\n{\n\t((struct SUpnpString *)p)->m_length = (size_t)0;\n\t/* No need to realloc now, will do later when needed. */\n\t((struct SUpnpString *)p)->m_string[0] = 0;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nvoid UpnpString_clear(UpnpString *p)\n{\n\t((struct SUpnpString *)p)->m_length = (size_t)0;\n\t/* No need to realloc now, will do later when needed. */\n\t((struct SUpnpString *)p)->m_string[0] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "temp_sid2",
            "0",
            "sizeof(temp_sid2)"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpString_new",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "73-97",
          "snippet": "UpnpString *UpnpString_new()\n{\n\t/* All bytes are zero, and so is the length of the string. */\n\tstruct SUpnpString *p = calloc((size_t)1, sizeof (struct SUpnpString));\n\tif (p == NULL) {\n\t\tgoto error_handler1;\n\t}\n#if 0\n\tp->m_length = 0;\n#endif\n\n\t/* This byte is zero, calloc does initialize it. */\n\tp->m_string = calloc((size_t)1, (size_t)1);\n\tif (p->m_string == NULL) {\n\t\tgoto error_handler2;\n\t}\n\n\treturn (UpnpString *)p;\n\n\t/*free(p->m_string); */\nerror_handler2:\n\tfree(p);\nerror_handler1:\n\treturn NULL;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nUpnpString *UpnpString_new()\n{\n\t/* All bytes are zero, and so is the length of the string. */\n\tstruct SUpnpString *p = calloc((size_t)1, sizeof (struct SUpnpString));\n\tif (p == NULL) {\n\t\tgoto error_handler1;\n\t}\n#if 0\n\tp->m_length = 0;\n#endif\n\n\t/* This byte is zero, calloc does initialize it. */\n\tp->m_string = calloc((size_t)1, (size_t)1);\n\tif (p->m_string == NULL) {\n\t\tgoto error_handler2;\n\t}\n\n\treturn (UpnpString *)p;\n\n\t/*free(p->m_string); */\nerror_handler2:\n\tfree(p);\nerror_handler1:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_new",
          "args": [],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint genaSubscribe(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *PublisherURL,\n\tint *TimeOut,\n\tUpnpString *out_sid)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *newSubscription = GenlibClientSubscription_new();\n\tuuid_upnp uid;\n\tUpnp_SID temp_sid;\n\tUpnp_SID temp_sid2;\n\tUpnpString *ActualSID = UpnpString_new();\n\tUpnpString *EventURL = UpnpString_new();\n\tstruct Handle_Info *handle_info;\n\tint rc = 0;\n\n\tmemset(temp_sid, 0, sizeof(temp_sid));\n\tmemset(temp_sid2, 0, sizeof(temp_sid2));\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"GENA SUBSCRIBE BEGIN\");\n\n\tUpnpString_clear(out_sid);\n\n\tHandleReadLock();\n\t/* validate handle */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tSubscribeLock();\n\t\tgoto error_handler;\n\t}\n\tHandleUnlock();\n\n\t/* subscribe */\n\tSubscribeLock();\n\treturn_code = gena_subscribe(PublisherURL, TimeOut, NULL, ActualSID);\n\tHandleLock();\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\tUpnpPrintf( UPNP_CRITICAL, GENA, __FILE__, __LINE__,\n\t\t\t\"SUBSCRIBE FAILED in transfer error code: %d returned\\n\",\n\t\t\treturn_code );\n\t\tgoto error_handler;\n\t}\n\n\tif(GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto error_handler;\n\t}\n\n\t/* generate client SID */\n\tuuid_create(&uid );\n\tuuid_unpack(&uid, temp_sid);\n\trc = snprintf(temp_sid2, sizeof(temp_sid2), \"uuid:%s\", temp_sid);\n\tif (rc < 0 || (unsigned int) rc >= sizeof(temp_sid2)) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto error_handler;\n\t}\n\tUpnpString_set_String(out_sid, temp_sid2);\n\n\t/* create event url */\n\tUpnpString_assign(EventURL, PublisherURL);\n\n\t/* fill subscription */\n\tif (newSubscription == NULL) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto error_handler;\n\t}\n\tGenlibClientSubscription_set_RenewEventId(newSubscription, -1);\n\tGenlibClientSubscription_set_SID(newSubscription, out_sid);\n\tGenlibClientSubscription_set_ActualSID(newSubscription, ActualSID);\n\tGenlibClientSubscription_set_EventURL(newSubscription, EventURL);\n\tGenlibClientSubscription_set_Next(newSubscription, handle_info->ClientSubList);\n\thandle_info->ClientSubList = newSubscription;\n\n\t/* schedule expiration event */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, newSubscription);\n\nerror_handler:\n\tUpnpString_delete(ActualSID);\n\tUpnpString_delete(EventURL);\n\tif (return_code != UPNP_E_SUCCESS)\n\t\tGenlibClientSubscription_delete(newSubscription);\n\tHandleUnlock();\n\tSubscribeUnlock();\n\n\treturn return_code;\n}"
  },
  {
    "function_name": "genaUnSubscribe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
    "lines": "457-504",
    "snippet": "int genaUnSubscribe(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid)\n{\n\tGenlibClientSubscription *sub = NULL;\n\tint return_code = GENA_SUCCESS;\n\tstruct Handle_Info *handle_info;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\thttp_parser_t response;\n\n\t/* validate handle and sid */\n\tHandleLock();\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\tHandleUnlock();\n\n\treturn_code = gena_unsubscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\t&response);\n\tif (return_code == 0) {\n\t\thttpmsg_destroy(&response.msg);\n\t}\n\tfree_client_subscription(sub_copy);\n\n\tHandleLock();\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\tHandleUnlock();\n\nexit_function:\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uuid.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"EventSubscribe.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GenlibClientSubscription_delete",
          "args": [
            "sub_copy"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RemoveClientSubClientSID",
          "args": [
            "&handle_info->ClientSubList",
            "in_sid"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "RemoveClientSubClientSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/client_table/client_table.c",
          "lines": "55-79",
          "snippet": "void RemoveClientSubClientSID(GenlibClientSubscription **head, const UpnpString *sid)\n{\n\tGenlibClientSubscription *finger = *head;\n\tGenlibClientSubscription *previous = NULL;\n\tint found = 0;\n\twhile (finger) {\n\t\tfound = !strcmp(\n\t\t\tUpnpString_get_String(sid),\n\t\t\tGenlibClientSubscription_get_SID_cstr(finger));\n\t\tif (found) {\n\t\t\tif (previous) {\n\t\t\t\tGenlibClientSubscription_set_Next(previous,\n\t\t\t\t\tGenlibClientSubscription_get_Next(finger));\n\t\t\t} else {\n\t\t\t\t*head = GenlibClientSubscription_get_Next(finger);\n\t\t\t}\n\t\t\tGenlibClientSubscription_set_Next(finger, NULL);\n\t\t\tfreeClientSubList(finger);\n\t\t\tfinger = NULL;\n\t\t} else {\n\t\t\tprevious = finger;\n\t\t\tfinger = GenlibClientSubscription_get_Next(finger);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"client_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for calloc(), free() */\n#include \"client_table.h\"\n#include \"config.h\"\n\nvoid RemoveClientSubClientSID(GenlibClientSubscription **head, const UpnpString *sid)\n{\n\tGenlibClientSubscription *finger = *head;\n\tGenlibClientSubscription *previous = NULL;\n\tint found = 0;\n\twhile (finger) {\n\t\tfound = !strcmp(\n\t\t\tUpnpString_get_String(sid),\n\t\t\tGenlibClientSubscription_get_SID_cstr(finger));\n\t\tif (found) {\n\t\t\tif (previous) {\n\t\t\t\tGenlibClientSubscription_set_Next(previous,\n\t\t\t\t\tGenlibClientSubscription_get_Next(finger));\n\t\t\t} else {\n\t\t\t\t*head = GenlibClientSubscription_get_Next(finger);\n\t\t\t}\n\t\t\tGenlibClientSubscription_set_Next(finger, NULL);\n\t\t\tfreeClientSubList(finger);\n\t\t\tfinger = NULL;\n\t\t} else {\n\t\t\tprevious = finger;\n\t\t\tfinger = GenlibClientSubscription_get_Next(finger);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "client_handle",
            "&handle_info"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_client_subscription",
          "args": [
            "sub_copy"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_subscription",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/client_table/client_table.c",
          "lines": "22-40",
          "snippet": "void free_client_subscription(GenlibClientSubscription *sub)\n{\n\tupnp_timeout *event;\n\tThreadPoolJob tempJob;\n\tif (sub) {\n\t\tint renewEventId = GenlibClientSubscription_get_RenewEventId(sub);\n\t\tGenlibClientSubscription_strcpy_ActualSID(sub, \"\");\n\t\tGenlibClientSubscription_strcpy_EventURL(sub, \"\");\n\t\tif (renewEventId != -1) {\n\t\t\t/* do not remove timer event of copy */\n\t\t\t/* invalid timer event id */\n\t\t\tif (TimerThreadRemove(&gTimerThread, renewEventId, &tempJob) == 0) {\n\t\t\t\tevent = (upnp_timeout *)tempJob.arg;\n\t\t\t\tfree_upnp_timeout(event);\n\t\t\t}\n\t\t}\n\t\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\t}\n}",
          "includes": [
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"client_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for calloc(), free() */\n#include \"client_table.h\"\n#include \"config.h\"\n\nvoid free_client_subscription(GenlibClientSubscription *sub)\n{\n\tupnp_timeout *event;\n\tThreadPoolJob tempJob;\n\tif (sub) {\n\t\tint renewEventId = GenlibClientSubscription_get_RenewEventId(sub);\n\t\tGenlibClientSubscription_strcpy_ActualSID(sub, \"\");\n\t\tGenlibClientSubscription_strcpy_EventURL(sub, \"\");\n\t\tif (renewEventId != -1) {\n\t\t\t/* do not remove timer event of copy */\n\t\t\t/* invalid timer event id */\n\t\t\tif (TimerThreadRemove(&gTimerThread, renewEventId, &tempJob) == 0) {\n\t\t\t\tevent = (upnp_timeout *)tempJob.arg;\n\t\t\t\tfree_upnp_timeout(event);\n\t\t\t}\n\t\t}\n\t\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&response.msg"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "gena_unsubscribe",
          "args": [
            "GenlibClientSubscription_get_EventURL(sub_copy)",
            "GenlibClientSubscription_get_ActualSID(sub_copy)",
            "&response"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "gena_unsubscribe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "209-261",
          "snippet": "static int gena_unsubscribe(\n\t/*! [in] Event URL of the service. */\n\tIN const UpnpString *url,\n\t/*! [in] The subcription ID. */\n\tIN const UpnpString *sid,\n\t/*! [out] The UNSUBCRIBE response from the device. */\n\tOUT http_parser_t *response )\n{\n\tint return_code;\n\turi_type dest_url;\n\tmembuffer request;\n\n\t/* parse url */\n\treturn_code = http_FixStrUrl(\n\t\tUpnpString_get_String(url),\n\t\tUpnpString_get_Length(url),\n\t\t&dest_url);\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* make request msg */\n\tmembuffer_init(&request);\n\trequest.size_inc = 30;\n\treturn_code = http_MakeMessage(\n\t\t&request, 1, 1,\n\t\t\"q\" \"ssc\" \"Uc\",\n\t\tHTTPMETHOD_UNSUBSCRIBE, &dest_url,\n\t\t\"SID: \", UpnpString_get_String(sid));\n\n\t/* Not able to make the message so destroy the existing buffer */\n\tif (return_code != 0) {\n\t\tmembuffer_destroy(&request);\n\n\t\treturn return_code;\n\t}\n\n\t/* send request and get reply */\n\treturn_code = http_RequestAndResponse(\n\t\t&dest_url, request.buf, request.length,\n\t\tHTTPMETHOD_UNSUBSCRIBE, HTTP_DEFAULT_TIMEOUT, response);\n\tmembuffer_destroy(&request);\n\tif (return_code != 0) {\n\t\thttpmsg_destroy(&response->msg);\n\t}\n\n\tif (return_code == 0 && response->msg.status_code != HTTP_OK) {\n\t\treturn_code = UPNP_E_UNSUBSCRIBE_UNACCEPTED;\n\t\thttpmsg_destroy(&response->msg);\n\t}\n\n\treturn return_code;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nstatic int gena_unsubscribe(\n\t/*! [in] Event URL of the service. */\n\tIN const UpnpString *url,\n\t/*! [in] The subcription ID. */\n\tIN const UpnpString *sid,\n\t/*! [out] The UNSUBCRIBE response from the device. */\n\tOUT http_parser_t *response )\n{\n\tint return_code;\n\turi_type dest_url;\n\tmembuffer request;\n\n\t/* parse url */\n\treturn_code = http_FixStrUrl(\n\t\tUpnpString_get_String(url),\n\t\tUpnpString_get_Length(url),\n\t\t&dest_url);\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* make request msg */\n\tmembuffer_init(&request);\n\trequest.size_inc = 30;\n\treturn_code = http_MakeMessage(\n\t\t&request, 1, 1,\n\t\t\"q\" \"ssc\" \"Uc\",\n\t\tHTTPMETHOD_UNSUBSCRIBE, &dest_url,\n\t\t\"SID: \", UpnpString_get_String(sid));\n\n\t/* Not able to make the message so destroy the existing buffer */\n\tif (return_code != 0) {\n\t\tmembuffer_destroy(&request);\n\n\t\treturn return_code;\n\t}\n\n\t/* send request and get reply */\n\treturn_code = http_RequestAndResponse(\n\t\t&dest_url, request.buf, request.length,\n\t\tHTTPMETHOD_UNSUBSCRIBE, HTTP_DEFAULT_TIMEOUT, response);\n\tmembuffer_destroy(&request);\n\tif (return_code != 0) {\n\t\thttpmsg_destroy(&response->msg);\n\t}\n\n\tif (return_code == 0 && response->msg.status_code != HTTP_OK) {\n\t\treturn_code = UPNP_E_UNSUBSCRIBE_UNACCEPTED;\n\t\thttpmsg_destroy(&response->msg);\n\t}\n\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_get_ActualSID",
          "args": [
            "sub_copy"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_get_EventURL",
          "args": [
            "sub_copy"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_assign",
          "args": [
            "sub_copy",
            "sub"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetClientSubClientSID",
          "args": [
            "handle_info->ClientSubList",
            "in_sid"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "GetClientSubClientSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/client_table/client_table.c",
          "lines": "82-98",
          "snippet": "GenlibClientSubscription *GetClientSubClientSID(GenlibClientSubscription *head, const UpnpString *sid)\n{\n\tGenlibClientSubscription *next = head;\n\tint found = 0;\n\twhile (next) {\n\t\tfound = !strcmp(\n\t\t\tGenlibClientSubscription_get_SID_cstr(next),\n\t\t\tUpnpString_get_String(sid));\n\t\tif(found) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tnext = GenlibClientSubscription_get_Next(next);\n\t\t}\n\t}\n\n\treturn next;\n}",
          "includes": [
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"client_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for calloc(), free() */\n#include \"client_table.h\"\n#include \"config.h\"\n\nGenlibClientSubscription *GetClientSubClientSID(GenlibClientSubscription *head, const UpnpString *sid)\n{\n\tGenlibClientSubscription *next = head;\n\tint found = 0;\n\twhile (next) {\n\t\tfound = !strcmp(\n\t\t\tGenlibClientSubscription_get_SID_cstr(next),\n\t\t\tUpnpString_get_String(sid));\n\t\tif(found) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tnext = GenlibClientSubscription_get_Next(next);\n\t\t}\n\t}\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_new",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nint genaUnSubscribe(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid)\n{\n\tGenlibClientSubscription *sub = NULL;\n\tint return_code = GENA_SUCCESS;\n\tstruct Handle_Info *handle_info;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\thttp_parser_t response;\n\n\t/* validate handle and sid */\n\tHandleLock();\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\tHandleUnlock();\n\n\treturn_code = gena_unsubscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\t&response);\n\tif (return_code == 0) {\n\t\thttpmsg_destroy(&response.msg);\n\t}\n\tfree_client_subscription(sub_copy);\n\n\tHandleLock();\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\tHandleUnlock();\n\nexit_function:\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}"
  },
  {
    "function_name": "genaUnregisterClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
    "lines": "411-453",
    "snippet": "int genaUnregisterClient(UpnpClient_Handle client_handle)\n{\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\tint return_code = UPNP_E_SUCCESS;\n\tstruct Handle_Info *handle_info = NULL;\n\thttp_parser_t response;\n\n\twhile (TRUE) {\n\t\tHandleLock();\n\n\t\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\t\tHandleUnlock();\n\t\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\t\tgoto exit_function;\n\t\t}\n\t\tif (handle_info->ClientSubList == NULL) {\n\t\t\treturn_code = UPNP_E_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t\tGenlibClientSubscription_assign(sub_copy, handle_info->ClientSubList);\n\t\tRemoveClientSubClientSID(\n\t\t\t&handle_info->ClientSubList,\n\t\t\tGenlibClientSubscription_get_SID(sub_copy));\n\n\t\tHandleUnlock();\n\n\t\treturn_code = gena_unsubscribe(\n\t\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\t\t&response);\n\t\tif (return_code == 0) {\n\t\t\thttpmsg_destroy(&response.msg);\n\t\t}\n\t\tfree_client_subscription(sub_copy);\n\t}\n\n\tfreeClientSubList(handle_info->ClientSubList);\n\tHandleUnlock();\n\nexit_function:\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uuid.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"EventSubscribe.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GenlibClientSubscription_delete",
          "args": [
            "sub_copy"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeClientSubList",
          "args": [
            "handle_info->ClientSubList"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "freeClientSubList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/client_table/client_table.c",
          "lines": "43-52",
          "snippet": "void freeClientSubList(GenlibClientSubscription *list)\n{\n\tGenlibClientSubscription *next;\n\twhile (list) {\n\t\tfree_client_subscription(list);\n\t\tnext = GenlibClientSubscription_get_Next(list);\n\t\tGenlibClientSubscription_delete(list);\n\t\tlist = next;\n\t}\n}",
          "includes": [
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"client_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for calloc(), free() */\n#include \"client_table.h\"\n#include \"config.h\"\n\nvoid freeClientSubList(GenlibClientSubscription *list)\n{\n\tGenlibClientSubscription *next;\n\twhile (list) {\n\t\tfree_client_subscription(list);\n\t\tnext = GenlibClientSubscription_get_Next(list);\n\t\tGenlibClientSubscription_delete(list);\n\t\tlist = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_client_subscription",
          "args": [
            "sub_copy"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_subscription",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/client_table/client_table.c",
          "lines": "22-40",
          "snippet": "void free_client_subscription(GenlibClientSubscription *sub)\n{\n\tupnp_timeout *event;\n\tThreadPoolJob tempJob;\n\tif (sub) {\n\t\tint renewEventId = GenlibClientSubscription_get_RenewEventId(sub);\n\t\tGenlibClientSubscription_strcpy_ActualSID(sub, \"\");\n\t\tGenlibClientSubscription_strcpy_EventURL(sub, \"\");\n\t\tif (renewEventId != -1) {\n\t\t\t/* do not remove timer event of copy */\n\t\t\t/* invalid timer event id */\n\t\t\tif (TimerThreadRemove(&gTimerThread, renewEventId, &tempJob) == 0) {\n\t\t\t\tevent = (upnp_timeout *)tempJob.arg;\n\t\t\t\tfree_upnp_timeout(event);\n\t\t\t}\n\t\t}\n\t\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\t}\n}",
          "includes": [
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"client_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for calloc(), free() */\n#include \"client_table.h\"\n#include \"config.h\"\n\nvoid free_client_subscription(GenlibClientSubscription *sub)\n{\n\tupnp_timeout *event;\n\tThreadPoolJob tempJob;\n\tif (sub) {\n\t\tint renewEventId = GenlibClientSubscription_get_RenewEventId(sub);\n\t\tGenlibClientSubscription_strcpy_ActualSID(sub, \"\");\n\t\tGenlibClientSubscription_strcpy_EventURL(sub, \"\");\n\t\tif (renewEventId != -1) {\n\t\t\t/* do not remove timer event of copy */\n\t\t\t/* invalid timer event id */\n\t\t\tif (TimerThreadRemove(&gTimerThread, renewEventId, &tempJob) == 0) {\n\t\t\t\tevent = (upnp_timeout *)tempJob.arg;\n\t\t\t\tfree_upnp_timeout(event);\n\t\t\t}\n\t\t}\n\t\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&response.msg"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "gena_unsubscribe",
          "args": [
            "GenlibClientSubscription_get_EventURL(sub_copy)",
            "GenlibClientSubscription_get_ActualSID(sub_copy)",
            "&response"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "gena_unsubscribe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "209-261",
          "snippet": "static int gena_unsubscribe(\n\t/*! [in] Event URL of the service. */\n\tIN const UpnpString *url,\n\t/*! [in] The subcription ID. */\n\tIN const UpnpString *sid,\n\t/*! [out] The UNSUBCRIBE response from the device. */\n\tOUT http_parser_t *response )\n{\n\tint return_code;\n\turi_type dest_url;\n\tmembuffer request;\n\n\t/* parse url */\n\treturn_code = http_FixStrUrl(\n\t\tUpnpString_get_String(url),\n\t\tUpnpString_get_Length(url),\n\t\t&dest_url);\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* make request msg */\n\tmembuffer_init(&request);\n\trequest.size_inc = 30;\n\treturn_code = http_MakeMessage(\n\t\t&request, 1, 1,\n\t\t\"q\" \"ssc\" \"Uc\",\n\t\tHTTPMETHOD_UNSUBSCRIBE, &dest_url,\n\t\t\"SID: \", UpnpString_get_String(sid));\n\n\t/* Not able to make the message so destroy the existing buffer */\n\tif (return_code != 0) {\n\t\tmembuffer_destroy(&request);\n\n\t\treturn return_code;\n\t}\n\n\t/* send request and get reply */\n\treturn_code = http_RequestAndResponse(\n\t\t&dest_url, request.buf, request.length,\n\t\tHTTPMETHOD_UNSUBSCRIBE, HTTP_DEFAULT_TIMEOUT, response);\n\tmembuffer_destroy(&request);\n\tif (return_code != 0) {\n\t\thttpmsg_destroy(&response->msg);\n\t}\n\n\tif (return_code == 0 && response->msg.status_code != HTTP_OK) {\n\t\treturn_code = UPNP_E_UNSUBSCRIBE_UNACCEPTED;\n\t\thttpmsg_destroy(&response->msg);\n\t}\n\n\treturn return_code;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nstatic int gena_unsubscribe(\n\t/*! [in] Event URL of the service. */\n\tIN const UpnpString *url,\n\t/*! [in] The subcription ID. */\n\tIN const UpnpString *sid,\n\t/*! [out] The UNSUBCRIBE response from the device. */\n\tOUT http_parser_t *response )\n{\n\tint return_code;\n\turi_type dest_url;\n\tmembuffer request;\n\n\t/* parse url */\n\treturn_code = http_FixStrUrl(\n\t\tUpnpString_get_String(url),\n\t\tUpnpString_get_Length(url),\n\t\t&dest_url);\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* make request msg */\n\tmembuffer_init(&request);\n\trequest.size_inc = 30;\n\treturn_code = http_MakeMessage(\n\t\t&request, 1, 1,\n\t\t\"q\" \"ssc\" \"Uc\",\n\t\tHTTPMETHOD_UNSUBSCRIBE, &dest_url,\n\t\t\"SID: \", UpnpString_get_String(sid));\n\n\t/* Not able to make the message so destroy the existing buffer */\n\tif (return_code != 0) {\n\t\tmembuffer_destroy(&request);\n\n\t\treturn return_code;\n\t}\n\n\t/* send request and get reply */\n\treturn_code = http_RequestAndResponse(\n\t\t&dest_url, request.buf, request.length,\n\t\tHTTPMETHOD_UNSUBSCRIBE, HTTP_DEFAULT_TIMEOUT, response);\n\tmembuffer_destroy(&request);\n\tif (return_code != 0) {\n\t\thttpmsg_destroy(&response->msg);\n\t}\n\n\tif (return_code == 0 && response->msg.status_code != HTTP_OK) {\n\t\treturn_code = UPNP_E_UNSUBSCRIBE_UNACCEPTED;\n\t\thttpmsg_destroy(&response->msg);\n\t}\n\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_get_ActualSID",
          "args": [
            "sub_copy"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_get_EventURL",
          "args": [
            "sub_copy"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RemoveClientSubClientSID",
          "args": [
            "&handle_info->ClientSubList",
            "GenlibClientSubscription_get_SID(sub_copy)"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "RemoveClientSubClientSID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/client_table/client_table.c",
          "lines": "55-79",
          "snippet": "void RemoveClientSubClientSID(GenlibClientSubscription **head, const UpnpString *sid)\n{\n\tGenlibClientSubscription *finger = *head;\n\tGenlibClientSubscription *previous = NULL;\n\tint found = 0;\n\twhile (finger) {\n\t\tfound = !strcmp(\n\t\t\tUpnpString_get_String(sid),\n\t\t\tGenlibClientSubscription_get_SID_cstr(finger));\n\t\tif (found) {\n\t\t\tif (previous) {\n\t\t\t\tGenlibClientSubscription_set_Next(previous,\n\t\t\t\t\tGenlibClientSubscription_get_Next(finger));\n\t\t\t} else {\n\t\t\t\t*head = GenlibClientSubscription_get_Next(finger);\n\t\t\t}\n\t\t\tGenlibClientSubscription_set_Next(finger, NULL);\n\t\t\tfreeClientSubList(finger);\n\t\t\tfinger = NULL;\n\t\t} else {\n\t\t\tprevious = finger;\n\t\t\tfinger = GenlibClientSubscription_get_Next(finger);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"client_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for calloc(), free() */\n#include \"client_table.h\"\n#include \"config.h\"\n\nvoid RemoveClientSubClientSID(GenlibClientSubscription **head, const UpnpString *sid)\n{\n\tGenlibClientSubscription *finger = *head;\n\tGenlibClientSubscription *previous = NULL;\n\tint found = 0;\n\twhile (finger) {\n\t\tfound = !strcmp(\n\t\t\tUpnpString_get_String(sid),\n\t\t\tGenlibClientSubscription_get_SID_cstr(finger));\n\t\tif (found) {\n\t\t\tif (previous) {\n\t\t\t\tGenlibClientSubscription_set_Next(previous,\n\t\t\t\t\tGenlibClientSubscription_get_Next(finger));\n\t\t\t} else {\n\t\t\t\t*head = GenlibClientSubscription_get_Next(finger);\n\t\t\t}\n\t\t\tGenlibClientSubscription_set_Next(finger, NULL);\n\t\t\tfreeClientSubList(finger);\n\t\t\tfinger = NULL;\n\t\t} else {\n\t\t\tprevious = finger;\n\t\t\tfinger = GenlibClientSubscription_get_Next(finger);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_get_SID",
          "args": [
            "sub_copy"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_assign",
          "args": [
            "sub_copy",
            "handle_info->ClientSubList"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "client_handle",
            "&handle_info"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleLock",
          "args": [],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_new",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nint genaUnregisterClient(UpnpClient_Handle client_handle)\n{\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\tint return_code = UPNP_E_SUCCESS;\n\tstruct Handle_Info *handle_info = NULL;\n\thttp_parser_t response;\n\n\twhile (TRUE) {\n\t\tHandleLock();\n\n\t\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\t\tHandleUnlock();\n\t\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\t\tgoto exit_function;\n\t\t}\n\t\tif (handle_info->ClientSubList == NULL) {\n\t\t\treturn_code = UPNP_E_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t\tGenlibClientSubscription_assign(sub_copy, handle_info->ClientSubList);\n\t\tRemoveClientSubClientSID(\n\t\t\t&handle_info->ClientSubList,\n\t\t\tGenlibClientSubscription_get_SID(sub_copy));\n\n\t\tHandleUnlock();\n\n\t\treturn_code = gena_unsubscribe(\n\t\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\t\t&response);\n\t\tif (return_code == 0) {\n\t\t\thttpmsg_destroy(&response.msg);\n\t\t}\n\t\tfree_client_subscription(sub_copy);\n\t}\n\n\tfreeClientSubList(handle_info->ClientSubList);\n\tHandleUnlock();\n\nexit_function:\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}"
  },
  {
    "function_name": "gena_subscribe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
    "lines": "269-408",
    "snippet": "static int gena_subscribe(\n\t/*! [in] URL of service to subscribe. */\n\tIN const UpnpString *url,\n\t/*! [in,out] Subscription time desired (in secs). */\n\tINOUT int *timeout,\n\t/*! [in] for renewal, this contains a currently held subscription SID.\n\t * For first time subscription, this must be NULL. */\n\tIN const UpnpString *renewal_sid,\n\t/*! [out] SID returned by the subscription or renew msg. */\n\tOUT UpnpString *sid)\n{\n\tint return_code;\n\tint parse_ret = 0;\n\tint local_timeout = CP_MINIMUM_SUBSCRIPTION_TIME;\n\tmemptr sid_hdr;\n\tmemptr timeout_hdr;\n\tchar timeout_str[25];\n\tmembuffer request;\n\turi_type dest_url;\n\thttp_parser_t response;\n\tint rc = 0;\n\n\tUpnpString_clear(sid);\n\n\t/* request timeout to string */\n\tif (timeout == NULL) {\n\t\ttimeout = &local_timeout;\n\t}\n\tif (*timeout < 0) {\n\t\tmemset(timeout_str, 0, sizeof(timeout_str));\n\t\tstrncpy(timeout_str, \"infinite\", sizeof(timeout_str) - 1);\n\t} else if(*timeout < CP_MINIMUM_SUBSCRIPTION_TIME) {\n\t\trc = snprintf(timeout_str, sizeof(timeout_str),\n\t\t\t\"%d\", CP_MINIMUM_SUBSCRIPTION_TIME);\n\t} else {\n\t\trc = snprintf(timeout_str, sizeof(timeout_str), \"%d\", *timeout);\n\t}\n\tif (rc < 0 || (unsigned int) rc >= sizeof(timeout_str))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\t/* parse url */\n\treturn_code = http_FixStrUrl(\n\t\tUpnpString_get_String(url),\n\t\tUpnpString_get_Length(url),\n\t\t&dest_url);\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* make request msg */\n\tmembuffer_init(&request);\n\trequest.size_inc = 30;\n\tif (renewal_sid) {\n\t\t/* renew subscription */\n\t\treturn_code = http_MakeMessage(\n\t\t\t&request, 1, 1,\n\t\t\t\"q\" \"ssc\" \"sscc\",\n\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\"SID: \", UpnpString_get_String(renewal_sid),\n\t\t\t\"TIMEOUT: Second-\", timeout_str );\n\t} else {\n\t\t/* subscribe */\n\t\tif (dest_url.hostport.IPaddress.ss_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6* DestAddr6 = (struct sockaddr_in6*)&dest_url.hostport.IPaddress;\n\t\t\treturn_code = http_MakeMessage(\n\t\t\t\t&request, 1, 1,\n\t\t\t\t\"q\" \"sssdsc\" \"sc\" \"sscc\",\n\t\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\t\"CALLBACK: <http://[\",\n\t\t\t\t(IN6_IS_ADDR_LINKLOCAL(&DestAddr6->sin6_addr) || strlen(gIF_IPV6_ULA_GUA) == 0) ?\n\t\t\t\t\tgIF_IPV6 : gIF_IPV6_ULA_GUA,\n\t\t\t\t\"]:\", LOCAL_PORT_V6, \"/>\",\n\t\t\t\t\"NT: upnp:event\",\n\t\t\t\t\"TIMEOUT: Second-\", timeout_str);\n\t\t} else {\n\t\t\treturn_code = http_MakeMessage(\n\t\t\t\t&request, 1, 1,\n\t\t\t\t\"q\" \"sssdsc\" \"sc\" \"sscc\",\n\t\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\t\"CALLBACK: <http://\", gIF_IPV4, \":\", LOCAL_PORT_V4, \"/>\",\n\t\t\t\t\"NT: upnp:event\",\n\t\t\t\t\"TIMEOUT: Second-\", timeout_str);\n\t\t}\n\t}\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* send request and get reply */\n\treturn_code = http_RequestAndResponse(&dest_url, request.buf,\n\t\trequest.length,\n\t\tHTTPMETHOD_SUBSCRIBE,\n\t\tHTTP_DEFAULT_TIMEOUT,\n\t\t&response);\n\tmembuffer_destroy(&request);\n\n\tif (return_code != 0) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn return_code;\n\t}\n\tif (response.msg.status_code != HTTP_OK) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn UPNP_E_SUBSCRIBE_UNACCEPTED;\n\t}\n\n\t/* get SID and TIMEOUT */\n\tif (httpmsg_find_hdr(&response.msg, HDR_SID, &sid_hdr) == NULL ||\n\t    sid_hdr.length == 0 ||\n\t    httpmsg_find_hdr( &response.msg, HDR_TIMEOUT, &timeout_hdr ) == NULL ||\n\t    timeout_hdr.length == 0 ) {\n\t\thttpmsg_destroy( &response.msg );\n\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\n\t/* save timeout */\n\tparse_ret = matchstr(timeout_hdr.buf, timeout_hdr.length, \"%iSecond-%d%0\", timeout);\n\tif (parse_ret == PARSE_OK) {\n\t\t/* nothing to do */\n\t} else if (memptr_cmp_nocase(&timeout_hdr, \"Second-infinite\") == 0) {\n\t\t*timeout = -1;\n\t} else {\n\t\thttpmsg_destroy( &response.msg );\n\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\n\t/* save SID */\n\tUpnpString_set_StringN(sid, sid_hdr.buf, sid_hdr.length);\n\tif (UpnpString_get_String(sid) == NULL) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thttpmsg_destroy(&response.msg);\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uuid.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"EventSubscribe.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&response.msg"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpString_get_String",
          "args": [
            "sid"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_get_String",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "155-158",
          "snippet": "const char *UpnpString_get_String(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_string;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nconst char *UpnpString_get_String(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_string;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpString_set_StringN",
          "args": [
            "sid",
            "sid_hdr.buf",
            "sid_hdr.length"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_set_StringN",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "172-182",
          "snippet": "int UpnpString_set_StringN(UpnpString *p, const char *s, size_t n)\n{\n\tchar *q = strndup(s, n);\n\tif (!q) goto error_handler1;\n\tfree(((struct SUpnpString *)p)->m_string);\n\t((struct SUpnpString *)p)->m_length = strlen(q);\n\t((struct SUpnpString *)p)->m_string = q;\n\nerror_handler1:\n\treturn q != NULL;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nint UpnpString_set_StringN(UpnpString *p, const char *s, size_t n)\n{\n\tchar *q = strndup(s, n);\n\tif (!q) goto error_handler1;\n\tfree(((struct SUpnpString *)p)->m_string);\n\t((struct SUpnpString *)p)->m_length = strlen(q);\n\t((struct SUpnpString *)p)->m_string = q;\n\nerror_handler1:\n\treturn q != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memptr_cmp_nocase",
          "args": [
            "&timeout_hdr",
            "\"Second-infinite\""
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "memptr_cmp_nocase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "78-90",
          "snippet": "int memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "matchstr",
          "args": [
            "timeout_hdr.buf",
            "timeout_hdr.length",
            "\"%iSecond-%d%0\"",
            "timeout"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "matchstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1168-1203",
          "snippet": "parse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "&response.msg",
            "HDR_TIMEOUT",
            "&timeout_hdr"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&request"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_RequestAndResponse",
          "args": [
            "&dest_url",
            "request.buf",
            "request.length",
            "HTTPMETHOD_SUBSCRIBE",
            "HTTP_DEFAULT_TIMEOUT",
            "&response"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "http_RequestAndResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "638-690",
          "snippet": "int http_RequestAndResponse(\n\tIN uri_type *destination,\n\tIN const char *request,\n\tIN size_t request_length,\n\tIN http_method_t req_method,\n\tIN int timeout_secs,\n\tOUT http_parser_t *response)\n{\n\tSOCKET tcp_connection;\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tint http_error_code;\n\tSOCKINFO info;\n\n\ttcp_connection = socket(\n\t\t(int)destination->hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tparser_response_init(response, req_method);\n\t\treturn UPNP_E_SOCKET_ERROR;\n\t}\n\tif (sock_init(&info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto end_function;\n\t}\n\t/* connect */\n\tsockaddr_len = destination->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(info.socket,\n\t\t(struct sockaddr *)&(destination->hostport.IPaddress),\n\t\t(socklen_t)sockaddr_len);\n\tif (ret_code == -1) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto end_function;\n\t}\n\t/* send request */\n\tret_code = http_SendMessage(&info, &timeout_secs, \"b\",\n\t\trequest, request_length);\n\tif (ret_code != 0) {\n\t\tparser_response_init(response, req_method);\n\t\tgoto end_function;\n\t}\n\t/* recv response */\n\tret_code = http_RecvMessage(&info, response, req_method,\n\t\t&timeout_secs, &http_error_code);\n\nend_function:\n\t/* should shutdown completely */\n\tsock_destroy(&info, SD_BOTH);\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_RequestAndResponse(\n\tIN uri_type *destination,\n\tIN const char *request,\n\tIN size_t request_length,\n\tIN http_method_t req_method,\n\tIN int timeout_secs,\n\tOUT http_parser_t *response)\n{\n\tSOCKET tcp_connection;\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tint http_error_code;\n\tSOCKINFO info;\n\n\ttcp_connection = socket(\n\t\t(int)destination->hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tparser_response_init(response, req_method);\n\t\treturn UPNP_E_SOCKET_ERROR;\n\t}\n\tif (sock_init(&info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto end_function;\n\t}\n\t/* connect */\n\tsockaddr_len = destination->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(info.socket,\n\t\t(struct sockaddr *)&(destination->hostport.IPaddress),\n\t\t(socklen_t)sockaddr_len);\n\tif (ret_code == -1) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto end_function;\n\t}\n\t/* send request */\n\tret_code = http_SendMessage(&info, &timeout_secs, \"b\",\n\t\trequest, request_length);\n\tif (ret_code != 0) {\n\t\tparser_response_init(response, req_method);\n\t\tgoto end_function;\n\t}\n\t/* recv response */\n\tret_code = http_RecvMessage(&info, response, req_method,\n\t\t&timeout_secs, &http_error_code);\n\nend_function:\n\t/* should shutdown completely */\n\tsock_destroy(&info, SD_BOTH);\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&request",
            "1",
            "1",
            "\"q\" \"sssdsc\" \"sc\" \"sscc\"",
            "HTTPMETHOD_SUBSCRIBE",
            "&dest_url",
            "\"CALLBACK: <http://\"",
            "gIF_IPV4",
            "\":\"",
            "LOCAL_PORT_V4",
            "\"/>\"",
            "\"NT: upnp:event\"",
            "\"TIMEOUT: Second-\"",
            "timeout_str"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "gIF_IPV6_ULA_GUA"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_LINKLOCAL",
          "args": [
            "&DestAddr6->sin6_addr"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&request"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_FixStrUrl",
          "args": [
            "UpnpString_get_String(url)",
            "UpnpString_get_Length(url)",
            "&dest_url"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "http_FixStrUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "259-271",
          "snippet": "int http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpString_get_Length",
          "args": [
            "url"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_get_Length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "141-144",
          "snippet": "size_t UpnpString_get_Length(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_length;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nsize_t UpnpString_get_Length(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "timeout_str",
            "sizeof(timeout_str)",
            "\"%d\"",
            "*timeout"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "timeout_str",
            "sizeof(timeout_str)",
            "\"%d\"",
            "CP_MINIMUM_SUBSCRIPTION_TIME"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "timeout_str",
            "\"infinite\"",
            "sizeof(timeout_str) - 1"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "timeout_str",
            "0",
            "sizeof(timeout_str)"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpString_clear",
          "args": [
            "sid"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "184-189",
          "snippet": "void UpnpString_clear(UpnpString *p)\n{\n\t((struct SUpnpString *)p)->m_length = (size_t)0;\n\t/* No need to realloc now, will do later when needed. */\n\t((struct SUpnpString *)p)->m_string[0] = 0;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nvoid UpnpString_clear(UpnpString *p)\n{\n\t((struct SUpnpString *)p)->m_length = (size_t)0;\n\t/* No need to realloc now, will do later when needed. */\n\t((struct SUpnpString *)p)->m_string[0] = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nstatic int gena_subscribe(\n\t/*! [in] URL of service to subscribe. */\n\tIN const UpnpString *url,\n\t/*! [in,out] Subscription time desired (in secs). */\n\tINOUT int *timeout,\n\t/*! [in] for renewal, this contains a currently held subscription SID.\n\t * For first time subscription, this must be NULL. */\n\tIN const UpnpString *renewal_sid,\n\t/*! [out] SID returned by the subscription or renew msg. */\n\tOUT UpnpString *sid)\n{\n\tint return_code;\n\tint parse_ret = 0;\n\tint local_timeout = CP_MINIMUM_SUBSCRIPTION_TIME;\n\tmemptr sid_hdr;\n\tmemptr timeout_hdr;\n\tchar timeout_str[25];\n\tmembuffer request;\n\turi_type dest_url;\n\thttp_parser_t response;\n\tint rc = 0;\n\n\tUpnpString_clear(sid);\n\n\t/* request timeout to string */\n\tif (timeout == NULL) {\n\t\ttimeout = &local_timeout;\n\t}\n\tif (*timeout < 0) {\n\t\tmemset(timeout_str, 0, sizeof(timeout_str));\n\t\tstrncpy(timeout_str, \"infinite\", sizeof(timeout_str) - 1);\n\t} else if(*timeout < CP_MINIMUM_SUBSCRIPTION_TIME) {\n\t\trc = snprintf(timeout_str, sizeof(timeout_str),\n\t\t\t\"%d\", CP_MINIMUM_SUBSCRIPTION_TIME);\n\t} else {\n\t\trc = snprintf(timeout_str, sizeof(timeout_str), \"%d\", *timeout);\n\t}\n\tif (rc < 0 || (unsigned int) rc >= sizeof(timeout_str))\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\n\t/* parse url */\n\treturn_code = http_FixStrUrl(\n\t\tUpnpString_get_String(url),\n\t\tUpnpString_get_Length(url),\n\t\t&dest_url);\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* make request msg */\n\tmembuffer_init(&request);\n\trequest.size_inc = 30;\n\tif (renewal_sid) {\n\t\t/* renew subscription */\n\t\treturn_code = http_MakeMessage(\n\t\t\t&request, 1, 1,\n\t\t\t\"q\" \"ssc\" \"sscc\",\n\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\"SID: \", UpnpString_get_String(renewal_sid),\n\t\t\t\"TIMEOUT: Second-\", timeout_str );\n\t} else {\n\t\t/* subscribe */\n\t\tif (dest_url.hostport.IPaddress.ss_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6* DestAddr6 = (struct sockaddr_in6*)&dest_url.hostport.IPaddress;\n\t\t\treturn_code = http_MakeMessage(\n\t\t\t\t&request, 1, 1,\n\t\t\t\t\"q\" \"sssdsc\" \"sc\" \"sscc\",\n\t\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\t\"CALLBACK: <http://[\",\n\t\t\t\t(IN6_IS_ADDR_LINKLOCAL(&DestAddr6->sin6_addr) || strlen(gIF_IPV6_ULA_GUA) == 0) ?\n\t\t\t\t\tgIF_IPV6 : gIF_IPV6_ULA_GUA,\n\t\t\t\t\"]:\", LOCAL_PORT_V6, \"/>\",\n\t\t\t\t\"NT: upnp:event\",\n\t\t\t\t\"TIMEOUT: Second-\", timeout_str);\n\t\t} else {\n\t\t\treturn_code = http_MakeMessage(\n\t\t\t\t&request, 1, 1,\n\t\t\t\t\"q\" \"sssdsc\" \"sc\" \"sscc\",\n\t\t\t\tHTTPMETHOD_SUBSCRIBE, &dest_url,\n\t\t\t\t\"CALLBACK: <http://\", gIF_IPV4, \":\", LOCAL_PORT_V4, \"/>\",\n\t\t\t\t\"NT: upnp:event\",\n\t\t\t\t\"TIMEOUT: Second-\", timeout_str);\n\t\t}\n\t}\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* send request and get reply */\n\treturn_code = http_RequestAndResponse(&dest_url, request.buf,\n\t\trequest.length,\n\t\tHTTPMETHOD_SUBSCRIBE,\n\t\tHTTP_DEFAULT_TIMEOUT,\n\t\t&response);\n\tmembuffer_destroy(&request);\n\n\tif (return_code != 0) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn return_code;\n\t}\n\tif (response.msg.status_code != HTTP_OK) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn UPNP_E_SUBSCRIBE_UNACCEPTED;\n\t}\n\n\t/* get SID and TIMEOUT */\n\tif (httpmsg_find_hdr(&response.msg, HDR_SID, &sid_hdr) == NULL ||\n\t    sid_hdr.length == 0 ||\n\t    httpmsg_find_hdr( &response.msg, HDR_TIMEOUT, &timeout_hdr ) == NULL ||\n\t    timeout_hdr.length == 0 ) {\n\t\thttpmsg_destroy( &response.msg );\n\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\n\t/* save timeout */\n\tparse_ret = matchstr(timeout_hdr.buf, timeout_hdr.length, \"%iSecond-%d%0\", timeout);\n\tif (parse_ret == PARSE_OK) {\n\t\t/* nothing to do */\n\t} else if (memptr_cmp_nocase(&timeout_hdr, \"Second-infinite\") == 0) {\n\t\t*timeout = -1;\n\t} else {\n\t\thttpmsg_destroy( &response.msg );\n\n\t\treturn UPNP_E_BAD_RESPONSE;\n\t}\n\n\t/* save SID */\n\tUpnpString_set_StringN(sid, sid_hdr.buf, sid_hdr.length);\n\tif (UpnpString_get_String(sid) == NULL) {\n\t\thttpmsg_destroy(&response.msg);\n\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thttpmsg_destroy(&response.msg);\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "gena_unsubscribe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
    "lines": "209-261",
    "snippet": "static int gena_unsubscribe(\n\t/*! [in] Event URL of the service. */\n\tIN const UpnpString *url,\n\t/*! [in] The subcription ID. */\n\tIN const UpnpString *sid,\n\t/*! [out] The UNSUBCRIBE response from the device. */\n\tOUT http_parser_t *response )\n{\n\tint return_code;\n\turi_type dest_url;\n\tmembuffer request;\n\n\t/* parse url */\n\treturn_code = http_FixStrUrl(\n\t\tUpnpString_get_String(url),\n\t\tUpnpString_get_Length(url),\n\t\t&dest_url);\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* make request msg */\n\tmembuffer_init(&request);\n\trequest.size_inc = 30;\n\treturn_code = http_MakeMessage(\n\t\t&request, 1, 1,\n\t\t\"q\" \"ssc\" \"Uc\",\n\t\tHTTPMETHOD_UNSUBSCRIBE, &dest_url,\n\t\t\"SID: \", UpnpString_get_String(sid));\n\n\t/* Not able to make the message so destroy the existing buffer */\n\tif (return_code != 0) {\n\t\tmembuffer_destroy(&request);\n\n\t\treturn return_code;\n\t}\n\n\t/* send request and get reply */\n\treturn_code = http_RequestAndResponse(\n\t\t&dest_url, request.buf, request.length,\n\t\tHTTPMETHOD_UNSUBSCRIBE, HTTP_DEFAULT_TIMEOUT, response);\n\tmembuffer_destroy(&request);\n\tif (return_code != 0) {\n\t\thttpmsg_destroy(&response->msg);\n\t}\n\n\tif (return_code == 0 && response->msg.status_code != HTTP_OK) {\n\t\treturn_code = UPNP_E_UNSUBSCRIBE_UNACCEPTED;\n\t\thttpmsg_destroy(&response->msg);\n\t}\n\n\treturn return_code;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uuid.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"EventSubscribe.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "httpmsg_destroy",
          "args": [
            "&response->msg"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "424-435",
          "snippet": "void httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nvoid httpmsg_destroy( INOUT http_message_t * msg )\n{\n    assert( msg != NULL );\n\n    if( msg->initialized == 1 ) {\n        ListDestroy( &msg->headers, 1 );\n        membuffer_destroy( &msg->msg );\n        membuffer_destroy( &msg->status_msg );\n        free( msg->urlbuf );\n        msg->initialized = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&request"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_RequestAndResponse",
          "args": [
            "&dest_url",
            "request.buf",
            "request.length",
            "HTTPMETHOD_UNSUBSCRIBE",
            "HTTP_DEFAULT_TIMEOUT",
            "response"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "http_RequestAndResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "638-690",
          "snippet": "int http_RequestAndResponse(\n\tIN uri_type *destination,\n\tIN const char *request,\n\tIN size_t request_length,\n\tIN http_method_t req_method,\n\tIN int timeout_secs,\n\tOUT http_parser_t *response)\n{\n\tSOCKET tcp_connection;\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tint http_error_code;\n\tSOCKINFO info;\n\n\ttcp_connection = socket(\n\t\t(int)destination->hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tparser_response_init(response, req_method);\n\t\treturn UPNP_E_SOCKET_ERROR;\n\t}\n\tif (sock_init(&info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto end_function;\n\t}\n\t/* connect */\n\tsockaddr_len = destination->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(info.socket,\n\t\t(struct sockaddr *)&(destination->hostport.IPaddress),\n\t\t(socklen_t)sockaddr_len);\n\tif (ret_code == -1) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto end_function;\n\t}\n\t/* send request */\n\tret_code = http_SendMessage(&info, &timeout_secs, \"b\",\n\t\trequest, request_length);\n\tif (ret_code != 0) {\n\t\tparser_response_init(response, req_method);\n\t\tgoto end_function;\n\t}\n\t/* recv response */\n\tret_code = http_RecvMessage(&info, response, req_method,\n\t\t&timeout_secs, &http_error_code);\n\nend_function:\n\t/* should shutdown completely */\n\tsock_destroy(&info, SD_BOTH);\n\n\treturn ret_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_RequestAndResponse(\n\tIN uri_type *destination,\n\tIN const char *request,\n\tIN size_t request_length,\n\tIN http_method_t req_method,\n\tIN int timeout_secs,\n\tOUT http_parser_t *response)\n{\n\tSOCKET tcp_connection;\n\tint ret_code;\n\tsize_t sockaddr_len;\n\tint http_error_code;\n\tSOCKINFO info;\n\n\ttcp_connection = socket(\n\t\t(int)destination->hostport.IPaddress.ss_family, SOCK_STREAM, 0);\n\tif (tcp_connection == INVALID_SOCKET) {\n\t\tparser_response_init(response, req_method);\n\t\treturn UPNP_E_SOCKET_ERROR;\n\t}\n\tif (sock_init(&info, tcp_connection) != UPNP_E_SUCCESS) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_ERROR;\n\t\tgoto end_function;\n\t}\n\t/* connect */\n\tsockaddr_len = destination->hostport.IPaddress.ss_family == AF_INET6 ?\n\t\tsizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n\tret_code = private_connect(info.socket,\n\t\t(struct sockaddr *)&(destination->hostport.IPaddress),\n\t\t(socklen_t)sockaddr_len);\n\tif (ret_code == -1) {\n\t\tparser_response_init(response, req_method);\n\t\tret_code = UPNP_E_SOCKET_CONNECT;\n\t\tgoto end_function;\n\t}\n\t/* send request */\n\tret_code = http_SendMessage(&info, &timeout_secs, \"b\",\n\t\trequest, request_length);\n\tif (ret_code != 0) {\n\t\tparser_response_init(response, req_method);\n\t\tgoto end_function;\n\t}\n\t/* recv response */\n\tret_code = http_RecvMessage(&info, response, req_method,\n\t\t&timeout_secs, &http_error_code);\n\nend_function:\n\t/* should shutdown completely */\n\tsock_destroy(&info, SD_BOTH);\n\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&request",
            "1",
            "1",
            "\"q\" \"ssc\" \"Uc\"",
            "HTTPMETHOD_UNSUBSCRIBE",
            "&dest_url",
            "\"SID: \"",
            "UpnpString_get_String(sid)"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpString_get_String",
          "args": [
            "sid"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_get_String",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "155-158",
          "snippet": "const char *UpnpString_get_String(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_string;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nconst char *UpnpString_get_String(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_string;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&request"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_FixStrUrl",
          "args": [
            "UpnpString_get_String(url)",
            "UpnpString_get_Length(url)",
            "&dest_url"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "http_FixStrUrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "259-271",
          "snippet": "int http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_FixStrUrl(\n\tIN const char *urlstr,\n\tIN size_t urlstrlen,\n\tOUT uri_type *fixed_url)\n{\n\turi_type url;\n\n\tif (parse_uri(urlstr, urlstrlen, &url) != HTTP_SUCCESS) {\n\t\treturn UPNP_E_INVALID_URL;\n\t}\n\n\treturn http_FixUrl(&url, fixed_url);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpString_get_Length",
          "args": [
            "url"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_get_Length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "141-144",
          "snippet": "size_t UpnpString_get_Length(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_length;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nsize_t UpnpString_get_Length(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_length;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nstatic int gena_unsubscribe(\n\t/*! [in] Event URL of the service. */\n\tIN const UpnpString *url,\n\t/*! [in] The subcription ID. */\n\tIN const UpnpString *sid,\n\t/*! [out] The UNSUBCRIBE response from the device. */\n\tOUT http_parser_t *response )\n{\n\tint return_code;\n\turi_type dest_url;\n\tmembuffer request;\n\n\t/* parse url */\n\treturn_code = http_FixStrUrl(\n\t\tUpnpString_get_String(url),\n\t\tUpnpString_get_Length(url),\n\t\t&dest_url);\n\tif (return_code != 0) {\n\t\treturn return_code;\n\t}\n\n\t/* make request msg */\n\tmembuffer_init(&request);\n\trequest.size_inc = 30;\n\treturn_code = http_MakeMessage(\n\t\t&request, 1, 1,\n\t\t\"q\" \"ssc\" \"Uc\",\n\t\tHTTPMETHOD_UNSUBSCRIBE, &dest_url,\n\t\t\"SID: \", UpnpString_get_String(sid));\n\n\t/* Not able to make the message so destroy the existing buffer */\n\tif (return_code != 0) {\n\t\tmembuffer_destroy(&request);\n\n\t\treturn return_code;\n\t}\n\n\t/* send request and get reply */\n\treturn_code = http_RequestAndResponse(\n\t\t&dest_url, request.buf, request.length,\n\t\tHTTPMETHOD_UNSUBSCRIBE, HTTP_DEFAULT_TIMEOUT, response);\n\tmembuffer_destroy(&request);\n\tif (return_code != 0) {\n\t\thttpmsg_destroy(&response->msg);\n\t}\n\n\tif (return_code == 0 && response->msg.status_code != HTTP_OK) {\n\t\treturn_code = UPNP_E_UNSUBSCRIBE_UNACCEPTED;\n\t\thttpmsg_destroy(&response->msg);\n\t}\n\n\treturn return_code;\n}"
  },
  {
    "function_name": "ScheduleGenaAutoRenew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
    "lines": "132-200",
    "snippet": "static int ScheduleGenaAutoRenew(\n\t/*! [in] Handle that also contains the subscription list. */\n\tIN int client_handle,\n\t/*! [in] The time out value of the subscription. */\n\tIN int TimeOut,\n\t/*! [in] Subscription being renewed. */\n\tIN GenlibClientSubscription *sub)\n{\n\tUpnpEventSubscribe *RenewEventStruct = NULL;\n\tupnp_timeout *RenewEvent = NULL;\n\tint return_code = GENA_SUCCESS;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tif (TimeOut == UPNP_INFINITE) {\n\t\treturn_code = GENA_SUCCESS;\n\t\tgoto end_function;\n\t}\n\n\tRenewEventStruct = UpnpEventSubscribe_new();\n\tif (RenewEventStruct == NULL) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto end_function;\n\t}\n\n\tRenewEvent = (upnp_timeout *) malloc(sizeof(upnp_timeout));\n\tif (RenewEvent == NULL) {\n\t\tfree(RenewEventStruct);\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto end_function;\n\t}\n\tmemset(RenewEvent, 0, sizeof(upnp_timeout));\n\n\t/* schedule expire event */\n\tUpnpEventSubscribe_set_ErrCode(RenewEventStruct, UPNP_E_SUCCESS);\n\tUpnpEventSubscribe_set_TimeOut(RenewEventStruct, TimeOut);\n\tUpnpEventSubscribe_set_SID(RenewEventStruct, GenlibClientSubscription_get_SID(sub));\n\tUpnpEventSubscribe_set_PublisherUrl(RenewEventStruct, GenlibClientSubscription_get_EventURL(sub));\n\n\t/* RenewEvent->EventType=UPNP_EVENT_SUBSCRIPTION_EXPIRE; */\n\tRenewEvent->handle = client_handle;\n\tRenewEvent->Event = RenewEventStruct;\n\n\tTPJobInit(&job, (start_routine) GenaAutoRenewSubscription, RenewEvent);\n\tTPJobSetFreeFunction(&job, (free_routine)free_upnp_timeout);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t/* Schedule the job */\n\treturn_code = TimerThreadSchedule(\n\t\t&gTimerThread,\n\t\tTimeOut - AUTO_RENEW_TIME,\n\t\tREL_SEC,\n\t\t&job, SHORT_TERM,\n\t\t&(RenewEvent->eventId));\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\tfree(RenewEvent);\n\t\tfree(RenewEventStruct);\n\t\tgoto end_function;\n\t}\n\n\tGenlibClientSubscription_set_RenewEventId(sub, RenewEvent->eventId);\n\n\treturn_code = GENA_SUCCESS;\n\nend_function:\n\n\treturn return_code;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uuid.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"EventSubscribe.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GenlibClientSubscription_set_RenewEventId",
          "args": [
            "sub",
            "RenewEvent->eventId"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "RenewEventStruct"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimerThreadSchedule",
          "args": [
            "&gTimerThread",
            "TimeOut - AUTO_RENEW_TIME",
            "REL_SEC",
            "&job",
            "SHORT_TERM",
            "&(RenewEvent->eventId)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetPriority",
          "args": [
            "&job",
            "MED_PRIORITY"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobSetFreeFunction",
          "args": [
            "&job",
            "(free_routine)free_upnp_timeout"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPJobInit",
          "args": [
            "&job",
            "(start_routine) GenaAutoRenewSubscription",
            "RenewEvent"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_PublisherUrl",
          "args": [
            "RenewEventStruct",
            "GenlibClientSubscription_get_EventURL(sub)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_get_EventURL",
          "args": [
            "sub"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_SID",
          "args": [
            "RenewEventStruct",
            "GenlibClientSubscription_get_SID(sub)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenlibClientSubscription_get_SID",
          "args": [
            "sub"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_TimeOut",
          "args": [
            "RenewEventStruct",
            "TimeOut"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_ErrCode",
          "args": [
            "RenewEventStruct",
            "UPNP_E_SUCCESS"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "RenewEvent",
            "0",
            "sizeof(upnp_timeout)"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(upnp_timeout)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_new",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nstatic int ScheduleGenaAutoRenew(\n\t/*! [in] Handle that also contains the subscription list. */\n\tIN int client_handle,\n\t/*! [in] The time out value of the subscription. */\n\tIN int TimeOut,\n\t/*! [in] Subscription being renewed. */\n\tIN GenlibClientSubscription *sub)\n{\n\tUpnpEventSubscribe *RenewEventStruct = NULL;\n\tupnp_timeout *RenewEvent = NULL;\n\tint return_code = GENA_SUCCESS;\n\tThreadPoolJob job;\n\n\tmemset(&job, 0, sizeof(job));\n\n\tif (TimeOut == UPNP_INFINITE) {\n\t\treturn_code = GENA_SUCCESS;\n\t\tgoto end_function;\n\t}\n\n\tRenewEventStruct = UpnpEventSubscribe_new();\n\tif (RenewEventStruct == NULL) {\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto end_function;\n\t}\n\n\tRenewEvent = (upnp_timeout *) malloc(sizeof(upnp_timeout));\n\tif (RenewEvent == NULL) {\n\t\tfree(RenewEventStruct);\n\t\treturn_code = UPNP_E_OUTOF_MEMORY;\n\t\tgoto end_function;\n\t}\n\tmemset(RenewEvent, 0, sizeof(upnp_timeout));\n\n\t/* schedule expire event */\n\tUpnpEventSubscribe_set_ErrCode(RenewEventStruct, UPNP_E_SUCCESS);\n\tUpnpEventSubscribe_set_TimeOut(RenewEventStruct, TimeOut);\n\tUpnpEventSubscribe_set_SID(RenewEventStruct, GenlibClientSubscription_get_SID(sub));\n\tUpnpEventSubscribe_set_PublisherUrl(RenewEventStruct, GenlibClientSubscription_get_EventURL(sub));\n\n\t/* RenewEvent->EventType=UPNP_EVENT_SUBSCRIPTION_EXPIRE; */\n\tRenewEvent->handle = client_handle;\n\tRenewEvent->Event = RenewEventStruct;\n\n\tTPJobInit(&job, (start_routine) GenaAutoRenewSubscription, RenewEvent);\n\tTPJobSetFreeFunction(&job, (free_routine)free_upnp_timeout);\n\tTPJobSetPriority(&job, MED_PRIORITY);\n\n\t/* Schedule the job */\n\treturn_code = TimerThreadSchedule(\n\t\t&gTimerThread,\n\t\tTimeOut - AUTO_RENEW_TIME,\n\t\tREL_SEC,\n\t\t&job, SHORT_TERM,\n\t\t&(RenewEvent->eventId));\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\tfree(RenewEvent);\n\t\tfree(RenewEventStruct);\n\t\tgoto end_function;\n\t}\n\n\tGenlibClientSubscription_set_RenewEventId(sub, RenewEvent->eventId);\n\n\treturn_code = GENA_SUCCESS;\n\nend_function:\n\n\treturn return_code;\n}"
  },
  {
    "function_name": "GenaAutoRenewSubscription",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
    "lines": "67-123",
    "snippet": "static void GenaAutoRenewSubscription(\n\t/*! [in] Thread data(upnp_timeout *) needed to send the renewal. */\n\tIN void *input)\n{\n\tupnp_timeout *event = (upnp_timeout *) input;\n\tUpnpEventSubscribe *sub_struct = (UpnpEventSubscribe *)event->Event;\n\tvoid *cookie;\n\tUpnp_FunPtr callback_fun;\n\tstruct Handle_Info *handle_info;\n\tint send_callback = 0;\n\tint eventType = 0;\n\tint timeout = 0;\n\tint errCode = 0;\n\n\tif (AUTO_RENEW_TIME == 0) {\n\t\tUpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__, \"GENA SUB EXPIRED\");\n\t\tUpnpEventSubscribe_set_ErrCode(sub_struct, UPNP_E_SUCCESS);\n\t\tsend_callback = 1;\n\t\teventType = UPNP_EVENT_SUBSCRIPTION_EXPIRED;\n\t} else {\n\t\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"GENA AUTO RENEW\");\n\t\ttimeout = UpnpEventSubscribe_get_TimeOut(sub_struct);\n\t\terrCode = genaRenewSubscription(\n\t\t\tevent->handle,\n\t\t\tUpnpEventSubscribe_get_SID(sub_struct),\n\t\t\t&timeout);\n\t\tUpnpEventSubscribe_set_ErrCode(sub_struct, errCode);\n\t\tUpnpEventSubscribe_set_TimeOut(sub_struct, timeout);\n\t\tif (errCode != UPNP_E_SUCCESS &&\n\t\t    errCode != GENA_E_BAD_SID &&\n\t\t    errCode != GENA_E_BAD_HANDLE) {\n\t\t\tsend_callback = 1;\n\t\t\teventType = UPNP_EVENT_AUTORENEWAL_FAILED;\n\t\t}\n\t}\n\n\tif (send_callback) {\n\t\tHandleReadLock();\n\t\tif( GetHandleInfo( event->handle, &handle_info ) != HND_CLIENT ) {\n\t\t\tHandleUnlock();\n\t\t\tfree_upnp_timeout(event);\n\t\t\tgoto end_function;\n\t\t}\n\t\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"HANDLE IS VALID\");\n\n\t\t/* make callback */\n\t\tcallback_fun = handle_info->Callback;\n\t\tcookie = handle_info->Cookie;\n\t\tHandleUnlock();\n\t\tcallback_fun(eventType, event->Event, cookie);\n\t}\n\n\tfree_upnp_timeout(event);\n\nend_function:\n\treturn;\n}",
    "includes": [
      "#include \"upnpapi.h\"",
      "#include \"uuid.h\"",
      "#include \"sysdep.h\"",
      "#include \"statcodes.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"gena.h\"",
      "#include \"EventSubscribe.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_upnp_timeout",
          "args": [
            "event"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "free_upnp_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/upnp_timeout.c",
          "lines": "50-58",
          "snippet": "void free_upnp_timeout(upnp_timeout *event)\n{\n\tif (event) {\n\t\tif (event->Event) {\n\t\t\tfree(event->Event);\n\t\t}\n\t\tfree(event);\n\t}\n}",
          "includes": [
            "#include <stdlib.h> /* for free() */",
            "#include \"upnp_timeout.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h> /* for free() */\n#include \"upnp_timeout.h\"\n#include \"config.h\"\n\nvoid free_upnp_timeout(upnp_timeout *event)\n{\n\tif (event) {\n\t\tif (event->Event) {\n\t\t\tfree(event->Event);\n\t\t}\n\t\tfree(event);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "callback_fun",
          "args": [
            "eventType",
            "event->Event",
            "cookie"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "GENA",
            "__FILE__",
            "__LINE__",
            "\"HANDLE IS VALID\""
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandleInfo",
          "args": [
            "event->handle",
            "&handle_info"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3881-3905",
          "snippet": "Upnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "static void *HandleTable[NUM_HANDLE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nstatic void *HandleTable[NUM_HANDLE];\n\nUpnp_Handle_Type GetHandleInfo(\n\tUpnpClient_Handle Hnd,\n\tstruct Handle_Info **HndInfo)\n{\n\tUpnp_Handle_Type ret = HND_INVALID;\n\n\tUpnpPrintf( UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\"GetHandleInfo: entering, Handle is %d\\n\", Hnd);\n\n\tif (Hnd < 1 || Hnd >= NUM_HANDLE) {\n\t\tUpnpPrintf(UPNP_INFO, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: Handle out of range\\n\");\n\t} else if (HandleTable[Hnd] == NULL) {\n\t\tUpnpPrintf(UPNP_CRITICAL, API, __FILE__, __LINE__,\n\t\t\t\"GetHandleInfo: HandleTable[%d] is NULL\\n\",\n\t\t\tHnd);\n\t} else if (HandleTable[Hnd] != NULL) {\n\t\t*HndInfo = (struct Handle_Info *)HandleTable[Hnd];\n\t\tret = ((struct Handle_Info *)*HndInfo)->HType;\n\t}\n\n\tUpnpPrintf(UPNP_ALL, API, __FILE__, __LINE__, \"GetHandleInfo: exiting\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_TimeOut",
          "args": [
            "sub_struct",
            "timeout"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_ErrCode",
          "args": [
            "sub_struct",
            "errCode"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genaRenewSubscription",
          "args": [
            "event->handle",
            "UpnpEventSubscribe_get_SID(sub_struct)",
            "&timeout"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "genaRenewSubscription",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_ctrlpt.c",
          "lines": "598-693",
          "snippet": "int genaRenewSubscription(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid,\n\tint *TimeOut)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *sub = NULL;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\tstruct Handle_Info *handle_info;\n\tUpnpString *ActualSID = UpnpString_new();\n\tThreadPoolJob tempJob;\n\n\tHandleLock();\n\n\t/* validate handle and sid */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* remove old events */\n\tif (TimerThreadRemove(\n\t\t&gTimerThread,\n\t\tGenlibClientSubscription_get_RenewEventId(sub),\n\t\t&tempJob) == 0 ) {\n\t\tfree_upnp_timeout((upnp_timeout *)tempJob.arg);\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"REMOVED AUTO RENEW  EVENT\");\n\n\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\n\tHandleUnlock();\n\n\treturn_code = gena_subscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tTimeOut,\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\tActualSID);\n\n\tHandleLock();\n\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\t/* we just called GetHandleInfo, so we don't check for return value */\n\t/*GetHandleInfo(client_handle, &handle_info); */\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\t/* network failure (remove client sub) */\n\t\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\t/* get subscription */\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* store actual sid */\n\tGenlibClientSubscription_set_ActualSID(sub, ActualSID);\n\n\t/* start renew subscription timer */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, sub);\n\tif (return_code != GENA_SUCCESS) {\n\t\tRemoveClientSubClientSID(\n\t\t\t&handle_info->ClientSubList,\n\t\t\tGenlibClientSubscription_get_SID(sub));\n\t}\n\tfree_client_subscription(sub_copy);\n\tHandleUnlock();\n\nexit_function:\n\tUpnpString_delete(ActualSID);\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uuid.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"EventSubscribe.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nint genaRenewSubscription(\n\tUpnpClient_Handle client_handle,\n\tconst UpnpString *in_sid,\n\tint *TimeOut)\n{\n\tint return_code = GENA_SUCCESS;\n\tGenlibClientSubscription *sub = NULL;\n\tGenlibClientSubscription *sub_copy = GenlibClientSubscription_new();\n\tstruct Handle_Info *handle_info;\n\tUpnpString *ActualSID = UpnpString_new();\n\tThreadPoolJob tempJob;\n\n\tHandleLock();\n\n\t/* validate handle and sid */\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tHandleUnlock();\n\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* remove old events */\n\tif (TimerThreadRemove(\n\t\t&gTimerThread,\n\t\tGenlibClientSubscription_get_RenewEventId(sub),\n\t\t&tempJob) == 0 ) {\n\t\tfree_upnp_timeout((upnp_timeout *)tempJob.arg);\n\t}\n\n\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"REMOVED AUTO RENEW  EVENT\");\n\n\tGenlibClientSubscription_set_RenewEventId(sub, -1);\n\tGenlibClientSubscription_assign(sub_copy, sub);\n\n\tHandleUnlock();\n\n\treturn_code = gena_subscribe(\n\t\tGenlibClientSubscription_get_EventURL(sub_copy),\n\t\tTimeOut,\n\t\tGenlibClientSubscription_get_ActualSID(sub_copy),\n\t\tActualSID);\n\n\tHandleLock();\n\n\tif (GetHandleInfo(client_handle, &handle_info) != HND_CLIENT) {\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_HANDLE;\n\t\tgoto exit_function;\n\t}\n\n\t/* we just called GetHandleInfo, so we don't check for return value */\n\t/*GetHandleInfo(client_handle, &handle_info); */\n\tif (return_code != UPNP_E_SUCCESS) {\n\t\t/* network failure (remove client sub) */\n\t\tRemoveClientSubClientSID(&handle_info->ClientSubList, in_sid);\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\tgoto exit_function;\n\t}\n\n\t/* get subscription */\n\tsub = GetClientSubClientSID(handle_info->ClientSubList, in_sid);\n\tif (sub == NULL) {\n\t\tfree_client_subscription(sub_copy);\n\t\tHandleUnlock();\n\t\treturn_code = GENA_E_BAD_SID;\n\t\tgoto exit_function;\n\t}\n\n\t/* store actual sid */\n\tGenlibClientSubscription_set_ActualSID(sub, ActualSID);\n\n\t/* start renew subscription timer */\n\treturn_code = ScheduleGenaAutoRenew(client_handle, *TimeOut, sub);\n\tif (return_code != GENA_SUCCESS) {\n\t\tRemoveClientSubClientSID(\n\t\t\t&handle_info->ClientSubList,\n\t\t\tGenlibClientSubscription_get_SID(sub));\n\t}\n\tfree_client_subscription(sub_copy);\n\tHandleUnlock();\n\nexit_function:\n\tUpnpString_delete(ActualSID);\n\tGenlibClientSubscription_delete(sub_copy);\n\treturn return_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_get_SID",
          "args": [
            "sub_struct"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_get_TimeOut",
          "args": [
            "sub_struct"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpEventSubscribe_set_ErrCode",
          "args": [
            "sub_struct",
            "UPNP_E_SUCCESS"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uuid.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"EventSubscribe.h\"\n#include \"config.h\"\n\nstatic void GenaAutoRenewSubscription(\n\t/*! [in] Thread data(upnp_timeout *) needed to send the renewal. */\n\tIN void *input)\n{\n\tupnp_timeout *event = (upnp_timeout *) input;\n\tUpnpEventSubscribe *sub_struct = (UpnpEventSubscribe *)event->Event;\n\tvoid *cookie;\n\tUpnp_FunPtr callback_fun;\n\tstruct Handle_Info *handle_info;\n\tint send_callback = 0;\n\tint eventType = 0;\n\tint timeout = 0;\n\tint errCode = 0;\n\n\tif (AUTO_RENEW_TIME == 0) {\n\t\tUpnpPrintf( UPNP_INFO, GENA, __FILE__, __LINE__, \"GENA SUB EXPIRED\");\n\t\tUpnpEventSubscribe_set_ErrCode(sub_struct, UPNP_E_SUCCESS);\n\t\tsend_callback = 1;\n\t\teventType = UPNP_EVENT_SUBSCRIPTION_EXPIRED;\n\t} else {\n\t\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"GENA AUTO RENEW\");\n\t\ttimeout = UpnpEventSubscribe_get_TimeOut(sub_struct);\n\t\terrCode = genaRenewSubscription(\n\t\t\tevent->handle,\n\t\t\tUpnpEventSubscribe_get_SID(sub_struct),\n\t\t\t&timeout);\n\t\tUpnpEventSubscribe_set_ErrCode(sub_struct, errCode);\n\t\tUpnpEventSubscribe_set_TimeOut(sub_struct, timeout);\n\t\tif (errCode != UPNP_E_SUCCESS &&\n\t\t    errCode != GENA_E_BAD_SID &&\n\t\t    errCode != GENA_E_BAD_HANDLE) {\n\t\t\tsend_callback = 1;\n\t\t\teventType = UPNP_EVENT_AUTORENEWAL_FAILED;\n\t\t}\n\t}\n\n\tif (send_callback) {\n\t\tHandleReadLock();\n\t\tif( GetHandleInfo( event->handle, &handle_info ) != HND_CLIENT ) {\n\t\t\tHandleUnlock();\n\t\t\tfree_upnp_timeout(event);\n\t\t\tgoto end_function;\n\t\t}\n\t\tUpnpPrintf(UPNP_INFO, GENA, __FILE__, __LINE__, \"HANDLE IS VALID\");\n\n\t\t/* make callback */\n\t\tcallback_fun = handle_info->Callback;\n\t\tcookie = handle_info->Cookie;\n\t\tHandleUnlock();\n\t\tcallback_fun(eventType, event->Event, cookie);\n\t}\n\n\tfree_upnp_timeout(event);\n\nend_function:\n\treturn;\n}"
  }
]