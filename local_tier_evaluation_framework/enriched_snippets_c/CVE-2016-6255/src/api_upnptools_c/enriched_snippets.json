[
  {
    "function_name": "UpnpAddToPropertySet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
    "lines": "458-497",
    "snippet": "int UpnpAddToPropertySet(\n\tIXML_Document **PropSet,\n\tconst char *ArgName,\n\tconst char *ArgValue)\n{\n\tchar BlankDoc[] =\n\t\t\"<e:propertyset xmlns:e=\\\"urn:schemas-upnp-org:event-1-0\\\">\"\n\t\t\"</e:propertyset>\";\n\tIXML_Node *node;\n\tIXML_Element *Ele;\n\tIXML_Element *Ele1;\n\tIXML_Node *Txt;\n\tint rc;\n\n\tif (ArgName == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (*PropSet == NULL) {\n\t\trc = ixmlParseBufferEx(BlankDoc, PropSet);\n\t\tif (rc != IXML_SUCCESS) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t}\n\n\tnode = ixmlNode_getFirstChild((IXML_Node *)*PropSet);\n\n\tEle1 = ixmlDocument_createElement(*PropSet, \"e:property\");\n\tEle = ixmlDocument_createElement(*PropSet, ArgName);\n\n\tif (ArgValue) {\n\t\tTxt = ixmlDocument_createTextNode(*PropSet, ArgValue);\n\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t}\n\n\tixmlNode_appendChild((IXML_Node *)Ele1, (IXML_Node *)Ele);\n\tixmlNode_appendChild(node, (IXML_Node *)Ele1);\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"uri.h\"",
      "#include \"upnptools.h\"",
      "#include \"upnp.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ixmlNode_appendChild",
          "args": [
            "node",
            "(IXML_Node *)Ele1"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_appendChild",
          "args": [
            "(IXML_Node *)Ele1",
            "(IXML_Node *)Ele"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_appendChild",
          "args": [
            "(IXML_Node *)Ele",
            "Txt"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_createTextNode",
          "args": [
            "*PropSet",
            "ArgValue"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_createElement",
          "args": [
            "*PropSet",
            "ArgName"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_createElement",
          "args": [
            "*PropSet",
            "\"e:property\""
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "(IXML_Node *)*PropSet"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "BlankDoc",
            "PropSet"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\nint UpnpAddToPropertySet(\n\tIXML_Document **PropSet,\n\tconst char *ArgName,\n\tconst char *ArgValue)\n{\n\tchar BlankDoc[] =\n\t\t\"<e:propertyset xmlns:e=\\\"urn:schemas-upnp-org:event-1-0\\\">\"\n\t\t\"</e:propertyset>\";\n\tIXML_Node *node;\n\tIXML_Element *Ele;\n\tIXML_Element *Ele1;\n\tIXML_Node *Txt;\n\tint rc;\n\n\tif (ArgName == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (*PropSet == NULL) {\n\t\trc = ixmlParseBufferEx(BlankDoc, PropSet);\n\t\tif (rc != IXML_SUCCESS) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\t}\n\n\tnode = ixmlNode_getFirstChild((IXML_Node *)*PropSet);\n\n\tEle1 = ixmlDocument_createElement(*PropSet, \"e:property\");\n\tEle = ixmlDocument_createElement(*PropSet, ArgName);\n\n\tif (ArgValue) {\n\t\tTxt = ixmlDocument_createTextNode(*PropSet, ArgValue);\n\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t}\n\n\tixmlNode_appendChild((IXML_Node *)Ele1, (IXML_Node *)Ele);\n\tixmlNode_appendChild(node, (IXML_Node *)Ele1);\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpCreatePropertySet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
    "lines": "409-455",
    "snippet": "IXML_Document *UpnpCreatePropertySet(\n\tint NumArg,\n\tconst char *Arg,\n\t...)\n{\n\tva_list ArgList;\n\tint Idx = 0;\n\tchar BlankDoc[] =\n\t\t\"<e:propertyset xmlns:e=\\\"urn:schemas-upnp-org:event-1-0\\\">\"\n\t\t\"</e:propertyset>\";\n\tconst char *ArgName,\n\t*ArgValue;\n\tIXML_Node *node;\n\tIXML_Element *Ele;\n\tIXML_Element *Ele1;\n\tIXML_Node *Txt;\n\tIXML_Document *PropSet;\n\n\tif(ixmlParseBufferEx(BlankDoc, &PropSet) != IXML_SUCCESS) {\n\t\treturn NULL;\n\t}\n\n\tif (NumArg < 1) {\n\t\treturn PropSet;\n\t}\n\n\tva_start(ArgList, Arg);\n\tArgName = Arg;\n\twhile (Idx++ != NumArg) {\n\t\tArgValue = va_arg(ArgList, const char *);\n\t\tif (ArgName != NULL /*&& ArgValue != NULL */) {\n\t\t\tnode = ixmlNode_getFirstChild((IXML_Node *)PropSet);\n\t\t\tEle1 = ixmlDocument_createElement(PropSet, \"e:property\");\n\t\t\tEle = ixmlDocument_createElement(PropSet, ArgName);\n\t\t\tif (ArgValue) {\n\t\t\t\tTxt = ixmlDocument_createTextNode(PropSet, ArgValue);\n\t\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t\t}\n\t\t\tixmlNode_appendChild((IXML_Node *)Ele1, (IXML_Node *)Ele);\n\t\t\tixmlNode_appendChild(             node, (IXML_Node *)Ele1);\n\t\t}\n\t\tArgName = va_arg(ArgList, const char *);\n\t}\n\tva_end(ArgList);\n\n\treturn PropSet;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"uri.h\"",
      "#include \"upnptools.h\"",
      "#include \"upnp.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ArgList"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "ArgList",
            "constchar *"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_appendChild",
          "args": [
            "node",
            "(IXML_Node *)Ele1"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_appendChild",
          "args": [
            "(IXML_Node *)Ele1",
            "(IXML_Node *)Ele"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_appendChild",
          "args": [
            "(IXML_Node *)Ele",
            "Txt"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_createTextNode",
          "args": [
            "PropSet",
            "ArgValue"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_createElement",
          "args": [
            "PropSet",
            "ArgName"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_createElement",
          "args": [
            "PropSet",
            "\"e:property\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "(IXML_Node *)PropSet"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "ArgList",
            "constchar *"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ArgList",
            "Arg"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "BlankDoc",
            "&PropSet"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\nIXML_Document *UpnpCreatePropertySet(\n\tint NumArg,\n\tconst char *Arg,\n\t...)\n{\n\tva_list ArgList;\n\tint Idx = 0;\n\tchar BlankDoc[] =\n\t\t\"<e:propertyset xmlns:e=\\\"urn:schemas-upnp-org:event-1-0\\\">\"\n\t\t\"</e:propertyset>\";\n\tconst char *ArgName,\n\t*ArgValue;\n\tIXML_Node *node;\n\tIXML_Element *Ele;\n\tIXML_Element *Ele1;\n\tIXML_Node *Txt;\n\tIXML_Document *PropSet;\n\n\tif(ixmlParseBufferEx(BlankDoc, &PropSet) != IXML_SUCCESS) {\n\t\treturn NULL;\n\t}\n\n\tif (NumArg < 1) {\n\t\treturn PropSet;\n\t}\n\n\tva_start(ArgList, Arg);\n\tArgName = Arg;\n\twhile (Idx++ != NumArg) {\n\t\tArgValue = va_arg(ArgList, const char *);\n\t\tif (ArgName != NULL /*&& ArgValue != NULL */) {\n\t\t\tnode = ixmlNode_getFirstChild((IXML_Node *)PropSet);\n\t\t\tEle1 = ixmlDocument_createElement(PropSet, \"e:property\");\n\t\t\tEle = ixmlDocument_createElement(PropSet, ArgName);\n\t\t\tif (ArgValue) {\n\t\t\t\tTxt = ixmlDocument_createTextNode(PropSet, ArgValue);\n\t\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t\t}\n\t\t\tixmlNode_appendChild((IXML_Node *)Ele1, (IXML_Node *)Ele);\n\t\t\tixmlNode_appendChild(             node, (IXML_Node *)Ele1);\n\t\t}\n\t\tArgName = va_arg(ArgList, const char *);\n\t}\n\tva_end(ArgList);\n\n\treturn PropSet;\n}"
  },
  {
    "function_name": "UpnpAddToActionResponse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
    "lines": "398-406",
    "snippet": "int UpnpAddToActionResponse(\n\tIXML_Document **ActionResponse,\n\tconst char *ActionName,\n\tconst char *ServType,\n\tconst char *ArgName,\n\tconst char *ArgValue)\n{\n\treturn addToAction(1, ActionResponse, ActionName, ServType, ArgName, ArgValue);\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"uri.h\"",
      "#include \"upnptools.h\"",
      "#include \"upnp.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addToAction",
          "args": [
            "1",
            "ActionResponse",
            "ActionName",
            "ServType",
            "ArgName",
            "ArgValue"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "addToAction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
          "lines": "196-262",
          "snippet": "static int addToAction(\n\t/*! [in] flag to tell if the ActionDoc is for response or request. */\n\tint response,\n\t/*! [in,out] Request or response document. */\n\tIXML_Document **ActionDoc,\n\t/*! [in] Name of the action request or response. */\n\tconst char *ActionName,\n\t/*! [in] Service type. */\n\tconst char *ServType,\n\t/*! [in] Name of the argument. */\n\tconst char *ArgName,\n\t/*! [in] Value of the argument. */\n\tconst char *ArgValue)\n{\n\tchar *ActBuff = NULL;\n\tIXML_Node *node = NULL;\n\tIXML_Element *Ele = NULL;\n\tIXML_Node *Txt = NULL;\n\tint rc = 0;\n\n\tif (ActionName == NULL || ServType == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (*ActionDoc == NULL) {\n\t\tActBuff = (char *)malloc(HEADER_LENGTH);\n\t\tif (ActBuff == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\n\t\tif (response) {\n\t\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\t\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\",\n\t\t\t\tActionName, ServType, ActionName);\n\t\t} else {\n\t\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\t\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\",\n\t\t\t\tActionName, ServType, ActionName);\n\t\t}\n\t\tif (rc < 0 || (unsigned int) rc >= HEADER_LENGTH) {\n\t\t\tfree(ActBuff);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\n\t\trc = ixmlParseBufferEx(ActBuff, ActionDoc);\n\t\tfree(ActBuff);\n\t\tif (rc != IXML_SUCCESS) {\n\t\t\tif (rc == IXML_INSUFFICIENT_MEMORY) {\n\t\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t\t} else {\n\t\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ArgName != NULL /*&& ArgValue != NULL */) {\n\t\tnode = ixmlNode_getFirstChild((IXML_Node *)*ActionDoc);\n\t\tEle = ixmlDocument_createElement(*ActionDoc, ArgName);\n\t\tif(ArgValue) {\n\t\t\tTxt = ixmlDocument_createTextNode(*ActionDoc, ArgValue);\n\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t}\n\t\tixmlNode_appendChild(node, (IXML_Node *)Ele);\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"uri.h\"",
            "#include \"upnptools.h\"",
            "#include \"upnp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf",
            "#define HEADER_LENGTH 2000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n#define HEADER_LENGTH 2000\n\nstatic int addToAction(\n\t/*! [in] flag to tell if the ActionDoc is for response or request. */\n\tint response,\n\t/*! [in,out] Request or response document. */\n\tIXML_Document **ActionDoc,\n\t/*! [in] Name of the action request or response. */\n\tconst char *ActionName,\n\t/*! [in] Service type. */\n\tconst char *ServType,\n\t/*! [in] Name of the argument. */\n\tconst char *ArgName,\n\t/*! [in] Value of the argument. */\n\tconst char *ArgValue)\n{\n\tchar *ActBuff = NULL;\n\tIXML_Node *node = NULL;\n\tIXML_Element *Ele = NULL;\n\tIXML_Node *Txt = NULL;\n\tint rc = 0;\n\n\tif (ActionName == NULL || ServType == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (*ActionDoc == NULL) {\n\t\tActBuff = (char *)malloc(HEADER_LENGTH);\n\t\tif (ActBuff == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\n\t\tif (response) {\n\t\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\t\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\",\n\t\t\t\tActionName, ServType, ActionName);\n\t\t} else {\n\t\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\t\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\",\n\t\t\t\tActionName, ServType, ActionName);\n\t\t}\n\t\tif (rc < 0 || (unsigned int) rc >= HEADER_LENGTH) {\n\t\t\tfree(ActBuff);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\n\t\trc = ixmlParseBufferEx(ActBuff, ActionDoc);\n\t\tfree(ActBuff);\n\t\tif (rc != IXML_SUCCESS) {\n\t\t\tif (rc == IXML_INSUFFICIENT_MEMORY) {\n\t\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t\t} else {\n\t\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ArgName != NULL /*&& ArgValue != NULL */) {\n\t\tnode = ixmlNode_getFirstChild((IXML_Node *)*ActionDoc);\n\t\tEle = ixmlDocument_createElement(*ActionDoc, ArgName);\n\t\tif(ArgValue) {\n\t\t\tTxt = ixmlDocument_createTextNode(*ActionDoc, ArgValue);\n\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t}\n\t\tixmlNode_appendChild(node, (IXML_Node *)Ele);\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\nint UpnpAddToActionResponse(\n\tIXML_Document **ActionResponse,\n\tconst char *ActionName,\n\tconst char *ServType,\n\tconst char *ArgName,\n\tconst char *ArgValue)\n{\n\treturn addToAction(1, ActionResponse, ActionName, ServType, ArgName, ArgValue);\n}"
  },
  {
    "function_name": "UpnpAddToAction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
    "lines": "387-395",
    "snippet": "int UpnpAddToAction(\n\tIXML_Document **ActionDoc,\n\tconst char *ActionName,\n\tconst char *ServType,\n\tconst char *ArgName,\n\tconst char *ArgValue)\n{\n\treturn addToAction(0, ActionDoc, ActionName, ServType, ArgName, ArgValue);\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"uri.h\"",
      "#include \"upnptools.h\"",
      "#include \"upnp.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addToAction",
          "args": [
            "0",
            "ActionDoc",
            "ActionName",
            "ServType",
            "ArgName",
            "ArgValue"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "addToAction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
          "lines": "196-262",
          "snippet": "static int addToAction(\n\t/*! [in] flag to tell if the ActionDoc is for response or request. */\n\tint response,\n\t/*! [in,out] Request or response document. */\n\tIXML_Document **ActionDoc,\n\t/*! [in] Name of the action request or response. */\n\tconst char *ActionName,\n\t/*! [in] Service type. */\n\tconst char *ServType,\n\t/*! [in] Name of the argument. */\n\tconst char *ArgName,\n\t/*! [in] Value of the argument. */\n\tconst char *ArgValue)\n{\n\tchar *ActBuff = NULL;\n\tIXML_Node *node = NULL;\n\tIXML_Element *Ele = NULL;\n\tIXML_Node *Txt = NULL;\n\tint rc = 0;\n\n\tif (ActionName == NULL || ServType == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (*ActionDoc == NULL) {\n\t\tActBuff = (char *)malloc(HEADER_LENGTH);\n\t\tif (ActBuff == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\n\t\tif (response) {\n\t\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\t\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\",\n\t\t\t\tActionName, ServType, ActionName);\n\t\t} else {\n\t\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\t\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\",\n\t\t\t\tActionName, ServType, ActionName);\n\t\t}\n\t\tif (rc < 0 || (unsigned int) rc >= HEADER_LENGTH) {\n\t\t\tfree(ActBuff);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\n\t\trc = ixmlParseBufferEx(ActBuff, ActionDoc);\n\t\tfree(ActBuff);\n\t\tif (rc != IXML_SUCCESS) {\n\t\t\tif (rc == IXML_INSUFFICIENT_MEMORY) {\n\t\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t\t} else {\n\t\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ArgName != NULL /*&& ArgValue != NULL */) {\n\t\tnode = ixmlNode_getFirstChild((IXML_Node *)*ActionDoc);\n\t\tEle = ixmlDocument_createElement(*ActionDoc, ArgName);\n\t\tif(ArgValue) {\n\t\t\tTxt = ixmlDocument_createTextNode(*ActionDoc, ArgValue);\n\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t}\n\t\tixmlNode_appendChild(node, (IXML_Node *)Ele);\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"uri.h\"",
            "#include \"upnptools.h\"",
            "#include \"upnp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf",
            "#define HEADER_LENGTH 2000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n#define HEADER_LENGTH 2000\n\nstatic int addToAction(\n\t/*! [in] flag to tell if the ActionDoc is for response or request. */\n\tint response,\n\t/*! [in,out] Request or response document. */\n\tIXML_Document **ActionDoc,\n\t/*! [in] Name of the action request or response. */\n\tconst char *ActionName,\n\t/*! [in] Service type. */\n\tconst char *ServType,\n\t/*! [in] Name of the argument. */\n\tconst char *ArgName,\n\t/*! [in] Value of the argument. */\n\tconst char *ArgValue)\n{\n\tchar *ActBuff = NULL;\n\tIXML_Node *node = NULL;\n\tIXML_Element *Ele = NULL;\n\tIXML_Node *Txt = NULL;\n\tint rc = 0;\n\n\tif (ActionName == NULL || ServType == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (*ActionDoc == NULL) {\n\t\tActBuff = (char *)malloc(HEADER_LENGTH);\n\t\tif (ActBuff == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\n\t\tif (response) {\n\t\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\t\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\",\n\t\t\t\tActionName, ServType, ActionName);\n\t\t} else {\n\t\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\t\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\",\n\t\t\t\tActionName, ServType, ActionName);\n\t\t}\n\t\tif (rc < 0 || (unsigned int) rc >= HEADER_LENGTH) {\n\t\t\tfree(ActBuff);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\n\t\trc = ixmlParseBufferEx(ActBuff, ActionDoc);\n\t\tfree(ActBuff);\n\t\tif (rc != IXML_SUCCESS) {\n\t\t\tif (rc == IXML_INSUFFICIENT_MEMORY) {\n\t\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t\t} else {\n\t\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ArgName != NULL /*&& ArgValue != NULL */) {\n\t\tnode = ixmlNode_getFirstChild((IXML_Node *)*ActionDoc);\n\t\tEle = ixmlDocument_createElement(*ActionDoc, ArgName);\n\t\tif(ArgValue) {\n\t\t\tTxt = ixmlDocument_createTextNode(*ActionDoc, ArgValue);\n\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t}\n\t\tixmlNode_appendChild(node, (IXML_Node *)Ele);\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\nint UpnpAddToAction(\n\tIXML_Document **ActionDoc,\n\tconst char *ActionName,\n\tconst char *ServType,\n\tconst char *ArgName,\n\tconst char *ArgValue)\n{\n\treturn addToAction(0, ActionDoc, ActionName, ServType, ArgName, ArgValue);\n}"
  },
  {
    "function_name": "UpnpMakeActionResponse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
    "lines": "369-384",
    "snippet": "IXML_Document *UpnpMakeActionResponse(\n\tconst char *ActionName,\n\tconst char *ServType,\n\tint NumArg,\n\tconst char *Arg,\n\t...)\n{\n\tva_list ArgList;\n\tIXML_Document *out = NULL;\n\n\tva_start(ArgList, Arg);\n\tout = makeAction(1, ActionName, ServType, NumArg, Arg, ArgList);\n\tva_end(ArgList);\n\n\treturn out;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"uri.h\"",
      "#include \"upnptools.h\"",
      "#include \"upnp.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ArgList"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeAction",
          "args": [
            "1",
            "ActionName",
            "ServType",
            "NumArg",
            "Arg",
            "ArgList"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "makeAction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
          "lines": "271-348",
          "snippet": "static IXML_Document *makeAction(\n\t/*! [in] flag to tell if the ActionDoc is for response or request. */\n\tint response,\n\t/*! [in] Name of the action request or response. */\n\tconst char *ActionName,\n\t/*! [in] Service type. */\n\tconst char *ServType,\n\t/*! [in] Number of arguments in the action request or response. */\n\tint NumArg,\n\t/*! [in] pointer to the first argument. */\n\tconst char *Arg,\n\t/*! [in] Argument list. */\n\tva_list ArgList)\n{\n\tconst char *ArgName;\n\tconst char *ArgValue;\n\tchar *ActBuff;\n\tint Idx = 0;\n\tIXML_Document *ActionDoc;\n\tIXML_Node *node;\n\tIXML_Element *Ele;\n\tIXML_Node *Txt = NULL;\n\tint rc = 0;\n\n\tif (ActionName == NULL || ServType == NULL) {\n\t\treturn NULL;\n\t}\n\n\tActBuff = (char *)malloc(HEADER_LENGTH);\n\tif (ActBuff == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (response) {\n\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\",\n\t\t\tActionName, ServType, ActionName);\n\t} else {\n\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\",\n\t\t\tActionName, ServType, ActionName);\n\t}\n\tif (rc < 0 || (unsigned int) rc >= HEADER_LENGTH ||\n\t\tixmlParseBufferEx(ActBuff, &ActionDoc) != IXML_SUCCESS) {\n\t\tfree(ActBuff);\n\t\treturn NULL;\n\t}\n\n\tfree(ActBuff);\n\tif(ActionDoc == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (NumArg > 0) {\n\t\t/*va_start(ArgList, Arg); */\n\t\tArgName = Arg;\n\t\tfor ( ; ; ) {\n\t\t\tArgValue = va_arg(ArgList, const char *);\n\t\t\tif (ArgName != NULL) {\n\t\t\t\tnode = ixmlNode_getFirstChild((IXML_Node *)ActionDoc);\n\t\t\t\tEle = ixmlDocument_createElement(ActionDoc, ArgName);\n\t\t\t\tif (ArgValue) {\n\t\t\t\t\tTxt = ixmlDocument_createTextNode(ActionDoc, ArgValue);\n\t\t\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t\t\t}\n\t\t\t\tixmlNode_appendChild(node, (IXML_Node *)Ele);\n\t\t\t}\n\t\t\tif (++Idx < NumArg) {\n\t\t\t\tArgName = va_arg(ArgList, const char *);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*va_end(ArgList); */\n\t}\n\n\treturn ActionDoc;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"uri.h\"",
            "#include \"upnptools.h\"",
            "#include \"upnp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf",
            "#define HEADER_LENGTH 2000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n#define HEADER_LENGTH 2000\n\nstatic IXML_Document *makeAction(\n\t/*! [in] flag to tell if the ActionDoc is for response or request. */\n\tint response,\n\t/*! [in] Name of the action request or response. */\n\tconst char *ActionName,\n\t/*! [in] Service type. */\n\tconst char *ServType,\n\t/*! [in] Number of arguments in the action request or response. */\n\tint NumArg,\n\t/*! [in] pointer to the first argument. */\n\tconst char *Arg,\n\t/*! [in] Argument list. */\n\tva_list ArgList)\n{\n\tconst char *ArgName;\n\tconst char *ArgValue;\n\tchar *ActBuff;\n\tint Idx = 0;\n\tIXML_Document *ActionDoc;\n\tIXML_Node *node;\n\tIXML_Element *Ele;\n\tIXML_Node *Txt = NULL;\n\tint rc = 0;\n\n\tif (ActionName == NULL || ServType == NULL) {\n\t\treturn NULL;\n\t}\n\n\tActBuff = (char *)malloc(HEADER_LENGTH);\n\tif (ActBuff == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (response) {\n\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\",\n\t\t\tActionName, ServType, ActionName);\n\t} else {\n\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\",\n\t\t\tActionName, ServType, ActionName);\n\t}\n\tif (rc < 0 || (unsigned int) rc >= HEADER_LENGTH ||\n\t\tixmlParseBufferEx(ActBuff, &ActionDoc) != IXML_SUCCESS) {\n\t\tfree(ActBuff);\n\t\treturn NULL;\n\t}\n\n\tfree(ActBuff);\n\tif(ActionDoc == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (NumArg > 0) {\n\t\t/*va_start(ArgList, Arg); */\n\t\tArgName = Arg;\n\t\tfor ( ; ; ) {\n\t\t\tArgValue = va_arg(ArgList, const char *);\n\t\t\tif (ArgName != NULL) {\n\t\t\t\tnode = ixmlNode_getFirstChild((IXML_Node *)ActionDoc);\n\t\t\t\tEle = ixmlDocument_createElement(ActionDoc, ArgName);\n\t\t\t\tif (ArgValue) {\n\t\t\t\t\tTxt = ixmlDocument_createTextNode(ActionDoc, ArgValue);\n\t\t\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t\t\t}\n\t\t\t\tixmlNode_appendChild(node, (IXML_Node *)Ele);\n\t\t\t}\n\t\t\tif (++Idx < NumArg) {\n\t\t\t\tArgName = va_arg(ArgList, const char *);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*va_end(ArgList); */\n\t}\n\n\treturn ActionDoc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ArgList",
            "Arg"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\nIXML_Document *UpnpMakeActionResponse(\n\tconst char *ActionName,\n\tconst char *ServType,\n\tint NumArg,\n\tconst char *Arg,\n\t...)\n{\n\tva_list ArgList;\n\tIXML_Document *out = NULL;\n\n\tva_start(ArgList, Arg);\n\tout = makeAction(1, ActionName, ServType, NumArg, Arg, ArgList);\n\tva_end(ArgList);\n\n\treturn out;\n}"
  },
  {
    "function_name": "UpnpMakeAction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
    "lines": "351-366",
    "snippet": "IXML_Document *UpnpMakeAction(\n\tconst char *ActionName,\n\tconst char *ServType,\n\tint NumArg,\n\tconst char *Arg,\n\t...)\n{\n\tva_list ArgList;\n\tIXML_Document *out = NULL;\n\n\tva_start(ArgList, Arg);\n\tout = makeAction(0, ActionName, ServType, NumArg, Arg, ArgList);\n\tva_end(ArgList);\n\n\treturn out;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"uri.h\"",
      "#include \"upnptools.h\"",
      "#include \"upnp.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ArgList"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeAction",
          "args": [
            "0",
            "ActionName",
            "ServType",
            "NumArg",
            "Arg",
            "ArgList"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "makeAction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
          "lines": "271-348",
          "snippet": "static IXML_Document *makeAction(\n\t/*! [in] flag to tell if the ActionDoc is for response or request. */\n\tint response,\n\t/*! [in] Name of the action request or response. */\n\tconst char *ActionName,\n\t/*! [in] Service type. */\n\tconst char *ServType,\n\t/*! [in] Number of arguments in the action request or response. */\n\tint NumArg,\n\t/*! [in] pointer to the first argument. */\n\tconst char *Arg,\n\t/*! [in] Argument list. */\n\tva_list ArgList)\n{\n\tconst char *ArgName;\n\tconst char *ArgValue;\n\tchar *ActBuff;\n\tint Idx = 0;\n\tIXML_Document *ActionDoc;\n\tIXML_Node *node;\n\tIXML_Element *Ele;\n\tIXML_Node *Txt = NULL;\n\tint rc = 0;\n\n\tif (ActionName == NULL || ServType == NULL) {\n\t\treturn NULL;\n\t}\n\n\tActBuff = (char *)malloc(HEADER_LENGTH);\n\tif (ActBuff == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (response) {\n\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\",\n\t\t\tActionName, ServType, ActionName);\n\t} else {\n\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\",\n\t\t\tActionName, ServType, ActionName);\n\t}\n\tif (rc < 0 || (unsigned int) rc >= HEADER_LENGTH ||\n\t\tixmlParseBufferEx(ActBuff, &ActionDoc) != IXML_SUCCESS) {\n\t\tfree(ActBuff);\n\t\treturn NULL;\n\t}\n\n\tfree(ActBuff);\n\tif(ActionDoc == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (NumArg > 0) {\n\t\t/*va_start(ArgList, Arg); */\n\t\tArgName = Arg;\n\t\tfor ( ; ; ) {\n\t\t\tArgValue = va_arg(ArgList, const char *);\n\t\t\tif (ArgName != NULL) {\n\t\t\t\tnode = ixmlNode_getFirstChild((IXML_Node *)ActionDoc);\n\t\t\t\tEle = ixmlDocument_createElement(ActionDoc, ArgName);\n\t\t\t\tif (ArgValue) {\n\t\t\t\t\tTxt = ixmlDocument_createTextNode(ActionDoc, ArgValue);\n\t\t\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t\t\t}\n\t\t\t\tixmlNode_appendChild(node, (IXML_Node *)Ele);\n\t\t\t}\n\t\t\tif (++Idx < NumArg) {\n\t\t\t\tArgName = va_arg(ArgList, const char *);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*va_end(ArgList); */\n\t}\n\n\treturn ActionDoc;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"uri.h\"",
            "#include \"upnptools.h\"",
            "#include \"upnp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf",
            "#define HEADER_LENGTH 2000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n#define HEADER_LENGTH 2000\n\nstatic IXML_Document *makeAction(\n\t/*! [in] flag to tell if the ActionDoc is for response or request. */\n\tint response,\n\t/*! [in] Name of the action request or response. */\n\tconst char *ActionName,\n\t/*! [in] Service type. */\n\tconst char *ServType,\n\t/*! [in] Number of arguments in the action request or response. */\n\tint NumArg,\n\t/*! [in] pointer to the first argument. */\n\tconst char *Arg,\n\t/*! [in] Argument list. */\n\tva_list ArgList)\n{\n\tconst char *ArgName;\n\tconst char *ArgValue;\n\tchar *ActBuff;\n\tint Idx = 0;\n\tIXML_Document *ActionDoc;\n\tIXML_Node *node;\n\tIXML_Element *Ele;\n\tIXML_Node *Txt = NULL;\n\tint rc = 0;\n\n\tif (ActionName == NULL || ServType == NULL) {\n\t\treturn NULL;\n\t}\n\n\tActBuff = (char *)malloc(HEADER_LENGTH);\n\tif (ActBuff == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (response) {\n\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\",\n\t\t\tActionName, ServType, ActionName);\n\t} else {\n\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\",\n\t\t\tActionName, ServType, ActionName);\n\t}\n\tif (rc < 0 || (unsigned int) rc >= HEADER_LENGTH ||\n\t\tixmlParseBufferEx(ActBuff, &ActionDoc) != IXML_SUCCESS) {\n\t\tfree(ActBuff);\n\t\treturn NULL;\n\t}\n\n\tfree(ActBuff);\n\tif(ActionDoc == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (NumArg > 0) {\n\t\t/*va_start(ArgList, Arg); */\n\t\tArgName = Arg;\n\t\tfor ( ; ; ) {\n\t\t\tArgValue = va_arg(ArgList, const char *);\n\t\t\tif (ArgName != NULL) {\n\t\t\t\tnode = ixmlNode_getFirstChild((IXML_Node *)ActionDoc);\n\t\t\t\tEle = ixmlDocument_createElement(ActionDoc, ArgName);\n\t\t\t\tif (ArgValue) {\n\t\t\t\t\tTxt = ixmlDocument_createTextNode(ActionDoc, ArgValue);\n\t\t\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t\t\t}\n\t\t\t\tixmlNode_appendChild(node, (IXML_Node *)Ele);\n\t\t\t}\n\t\t\tif (++Idx < NumArg) {\n\t\t\t\tArgName = va_arg(ArgList, const char *);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*va_end(ArgList); */\n\t}\n\n\treturn ActionDoc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ArgList",
            "Arg"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\nIXML_Document *UpnpMakeAction(\n\tconst char *ActionName,\n\tconst char *ServType,\n\tint NumArg,\n\tconst char *Arg,\n\t...)\n{\n\tva_list ArgList;\n\tIXML_Document *out = NULL;\n\n\tva_start(ArgList, Arg);\n\tout = makeAction(0, ActionName, ServType, NumArg, Arg, ArgList);\n\tva_end(ArgList);\n\n\treturn out;\n}"
  },
  {
    "function_name": "makeAction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
    "lines": "271-348",
    "snippet": "static IXML_Document *makeAction(\n\t/*! [in] flag to tell if the ActionDoc is for response or request. */\n\tint response,\n\t/*! [in] Name of the action request or response. */\n\tconst char *ActionName,\n\t/*! [in] Service type. */\n\tconst char *ServType,\n\t/*! [in] Number of arguments in the action request or response. */\n\tint NumArg,\n\t/*! [in] pointer to the first argument. */\n\tconst char *Arg,\n\t/*! [in] Argument list. */\n\tva_list ArgList)\n{\n\tconst char *ArgName;\n\tconst char *ArgValue;\n\tchar *ActBuff;\n\tint Idx = 0;\n\tIXML_Document *ActionDoc;\n\tIXML_Node *node;\n\tIXML_Element *Ele;\n\tIXML_Node *Txt = NULL;\n\tint rc = 0;\n\n\tif (ActionName == NULL || ServType == NULL) {\n\t\treturn NULL;\n\t}\n\n\tActBuff = (char *)malloc(HEADER_LENGTH);\n\tif (ActBuff == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (response) {\n\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\",\n\t\t\tActionName, ServType, ActionName);\n\t} else {\n\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\",\n\t\t\tActionName, ServType, ActionName);\n\t}\n\tif (rc < 0 || (unsigned int) rc >= HEADER_LENGTH ||\n\t\tixmlParseBufferEx(ActBuff, &ActionDoc) != IXML_SUCCESS) {\n\t\tfree(ActBuff);\n\t\treturn NULL;\n\t}\n\n\tfree(ActBuff);\n\tif(ActionDoc == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (NumArg > 0) {\n\t\t/*va_start(ArgList, Arg); */\n\t\tArgName = Arg;\n\t\tfor ( ; ; ) {\n\t\t\tArgValue = va_arg(ArgList, const char *);\n\t\t\tif (ArgName != NULL) {\n\t\t\t\tnode = ixmlNode_getFirstChild((IXML_Node *)ActionDoc);\n\t\t\t\tEle = ixmlDocument_createElement(ActionDoc, ArgName);\n\t\t\t\tif (ArgValue) {\n\t\t\t\t\tTxt = ixmlDocument_createTextNode(ActionDoc, ArgValue);\n\t\t\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t\t\t}\n\t\t\t\tixmlNode_appendChild(node, (IXML_Node *)Ele);\n\t\t\t}\n\t\t\tif (++Idx < NumArg) {\n\t\t\t\tArgName = va_arg(ArgList, const char *);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*va_end(ArgList); */\n\t}\n\n\treturn ActionDoc;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"uri.h\"",
      "#include \"upnptools.h\"",
      "#include \"upnp.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf",
      "#define HEADER_LENGTH 2000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "ArgList",
            "constchar *"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_appendChild",
          "args": [
            "node",
            "(IXML_Node *)Ele"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_appendChild",
          "args": [
            "(IXML_Node *)Ele",
            "Txt"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_createTextNode",
          "args": [
            "ActionDoc",
            "ArgValue"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_createElement",
          "args": [
            "ActionDoc",
            "ArgName"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "(IXML_Node *)ActionDoc"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "ArgList",
            "constchar *"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ActBuff"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "ActBuff",
            "&ActionDoc"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ActBuff",
            "HEADER_LENGTH",
            "\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\"",
            "ActionName",
            "ServType",
            "ActionName"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ActBuff",
            "HEADER_LENGTH",
            "\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\"",
            "ActionName",
            "ServType",
            "ActionName"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "HEADER_LENGTH"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n#define HEADER_LENGTH 2000\n\nstatic IXML_Document *makeAction(\n\t/*! [in] flag to tell if the ActionDoc is for response or request. */\n\tint response,\n\t/*! [in] Name of the action request or response. */\n\tconst char *ActionName,\n\t/*! [in] Service type. */\n\tconst char *ServType,\n\t/*! [in] Number of arguments in the action request or response. */\n\tint NumArg,\n\t/*! [in] pointer to the first argument. */\n\tconst char *Arg,\n\t/*! [in] Argument list. */\n\tva_list ArgList)\n{\n\tconst char *ArgName;\n\tconst char *ArgValue;\n\tchar *ActBuff;\n\tint Idx = 0;\n\tIXML_Document *ActionDoc;\n\tIXML_Node *node;\n\tIXML_Element *Ele;\n\tIXML_Node *Txt = NULL;\n\tint rc = 0;\n\n\tif (ActionName == NULL || ServType == NULL) {\n\t\treturn NULL;\n\t}\n\n\tActBuff = (char *)malloc(HEADER_LENGTH);\n\tif (ActBuff == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (response) {\n\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\",\n\t\t\tActionName, ServType, ActionName);\n\t} else {\n\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\",\n\t\t\tActionName, ServType, ActionName);\n\t}\n\tif (rc < 0 || (unsigned int) rc >= HEADER_LENGTH ||\n\t\tixmlParseBufferEx(ActBuff, &ActionDoc) != IXML_SUCCESS) {\n\t\tfree(ActBuff);\n\t\treturn NULL;\n\t}\n\n\tfree(ActBuff);\n\tif(ActionDoc == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (NumArg > 0) {\n\t\t/*va_start(ArgList, Arg); */\n\t\tArgName = Arg;\n\t\tfor ( ; ; ) {\n\t\t\tArgValue = va_arg(ArgList, const char *);\n\t\t\tif (ArgName != NULL) {\n\t\t\t\tnode = ixmlNode_getFirstChild((IXML_Node *)ActionDoc);\n\t\t\t\tEle = ixmlDocument_createElement(ActionDoc, ArgName);\n\t\t\t\tif (ArgValue) {\n\t\t\t\t\tTxt = ixmlDocument_createTextNode(ActionDoc, ArgValue);\n\t\t\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t\t\t}\n\t\t\t\tixmlNode_appendChild(node, (IXML_Node *)Ele);\n\t\t\t}\n\t\t\tif (++Idx < NumArg) {\n\t\t\t\tArgName = va_arg(ArgList, const char *);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*va_end(ArgList); */\n\t}\n\n\treturn ActionDoc;\n}"
  },
  {
    "function_name": "addToAction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
    "lines": "196-262",
    "snippet": "static int addToAction(\n\t/*! [in] flag to tell if the ActionDoc is for response or request. */\n\tint response,\n\t/*! [in,out] Request or response document. */\n\tIXML_Document **ActionDoc,\n\t/*! [in] Name of the action request or response. */\n\tconst char *ActionName,\n\t/*! [in] Service type. */\n\tconst char *ServType,\n\t/*! [in] Name of the argument. */\n\tconst char *ArgName,\n\t/*! [in] Value of the argument. */\n\tconst char *ArgValue)\n{\n\tchar *ActBuff = NULL;\n\tIXML_Node *node = NULL;\n\tIXML_Element *Ele = NULL;\n\tIXML_Node *Txt = NULL;\n\tint rc = 0;\n\n\tif (ActionName == NULL || ServType == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (*ActionDoc == NULL) {\n\t\tActBuff = (char *)malloc(HEADER_LENGTH);\n\t\tif (ActBuff == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\n\t\tif (response) {\n\t\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\t\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\",\n\t\t\t\tActionName, ServType, ActionName);\n\t\t} else {\n\t\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\t\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\",\n\t\t\t\tActionName, ServType, ActionName);\n\t\t}\n\t\tif (rc < 0 || (unsigned int) rc >= HEADER_LENGTH) {\n\t\t\tfree(ActBuff);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\n\t\trc = ixmlParseBufferEx(ActBuff, ActionDoc);\n\t\tfree(ActBuff);\n\t\tif (rc != IXML_SUCCESS) {\n\t\t\tif (rc == IXML_INSUFFICIENT_MEMORY) {\n\t\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t\t} else {\n\t\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ArgName != NULL /*&& ArgValue != NULL */) {\n\t\tnode = ixmlNode_getFirstChild((IXML_Node *)*ActionDoc);\n\t\tEle = ixmlDocument_createElement(*ActionDoc, ArgName);\n\t\tif(ArgValue) {\n\t\t\tTxt = ixmlDocument_createTextNode(*ActionDoc, ArgValue);\n\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t}\n\t\tixmlNode_appendChild(node, (IXML_Node *)Ele);\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"uri.h\"",
      "#include \"upnptools.h\"",
      "#include \"upnp.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define snprintf _snprintf",
      "#define HEADER_LENGTH 2000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ixmlNode_appendChild",
          "args": [
            "node",
            "(IXML_Node *)Ele"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_appendChild",
          "args": [
            "(IXML_Node *)Ele",
            "Txt"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_createTextNode",
          "args": [
            "*ActionDoc",
            "ArgValue"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_createElement",
          "args": [
            "*ActionDoc",
            "ArgName"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "(IXML_Node *)*ActionDoc"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ActBuff"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "ActBuff",
            "ActionDoc"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ActBuff",
            "HEADER_LENGTH",
            "\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\"",
            "ActionName",
            "ServType",
            "ActionName"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ActBuff",
            "HEADER_LENGTH",
            "\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\"",
            "ActionName",
            "ServType",
            "ActionName"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "HEADER_LENGTH"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n#define HEADER_LENGTH 2000\n\nstatic int addToAction(\n\t/*! [in] flag to tell if the ActionDoc is for response or request. */\n\tint response,\n\t/*! [in,out] Request or response document. */\n\tIXML_Document **ActionDoc,\n\t/*! [in] Name of the action request or response. */\n\tconst char *ActionName,\n\t/*! [in] Service type. */\n\tconst char *ServType,\n\t/*! [in] Name of the argument. */\n\tconst char *ArgName,\n\t/*! [in] Value of the argument. */\n\tconst char *ArgValue)\n{\n\tchar *ActBuff = NULL;\n\tIXML_Node *node = NULL;\n\tIXML_Element *Ele = NULL;\n\tIXML_Node *Txt = NULL;\n\tint rc = 0;\n\n\tif (ActionName == NULL || ServType == NULL) {\n\t\treturn UPNP_E_INVALID_PARAM;\n\t}\n\n\tif (*ActionDoc == NULL) {\n\t\tActBuff = (char *)malloc(HEADER_LENGTH);\n\t\tif (ActBuff == NULL) {\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\n\t\tif (response) {\n\t\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\t\"<u:%sResponse xmlns:u=\\\"%s\\\">\\r\\n</u:%sResponse>\",\n\t\t\t\tActionName, ServType, ActionName);\n\t\t} else {\n\t\t\trc = snprintf(ActBuff, HEADER_LENGTH,\n\t\t\t\t\"<u:%s xmlns:u=\\\"%s\\\">\\r\\n</u:%s>\",\n\t\t\t\tActionName, ServType, ActionName);\n\t\t}\n\t\tif (rc < 0 || (unsigned int) rc >= HEADER_LENGTH) {\n\t\t\tfree(ActBuff);\n\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t}\n\n\t\trc = ixmlParseBufferEx(ActBuff, ActionDoc);\n\t\tfree(ActBuff);\n\t\tif (rc != IXML_SUCCESS) {\n\t\t\tif (rc == IXML_INSUFFICIENT_MEMORY) {\n\t\t\t\treturn UPNP_E_OUTOF_MEMORY;\n\t\t\t} else {\n\t\t\t\treturn UPNP_E_INVALID_DESC;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ArgName != NULL /*&& ArgValue != NULL */) {\n\t\tnode = ixmlNode_getFirstChild((IXML_Node *)*ActionDoc);\n\t\tEle = ixmlDocument_createElement(*ActionDoc, ArgName);\n\t\tif(ArgValue) {\n\t\t\tTxt = ixmlDocument_createTextNode(*ActionDoc, ArgValue);\n\t\t\tixmlNode_appendChild((IXML_Node *)Ele, Txt);\n\t\t}\n\t\tixmlNode_appendChild(node, (IXML_Node *)Ele);\n\t}\n\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "UpnpResolveURL2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
    "lines": "168-185",
    "snippet": "int UpnpResolveURL2(\n\tconst char *BaseURL,\n\tconst char *RelURL,\n\tchar **AbsURL)\n{\n\tint ret = UPNP_E_SUCCESS;\n\n\tif (!RelURL) {\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto ExitFunction;\n\t}\n\t*AbsURL = resolve_rel_url((char *)BaseURL, (char *)RelURL);\n\tif (!*AbsURL)\n\t\tret = UPNP_E_INVALID_URL;\n\nExitFunction:\n\treturn ret;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"uri.h\"",
      "#include \"upnptools.h\"",
      "#include \"upnp.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resolve_rel_url",
          "args": [
            "(char *)BaseURL",
            "(char *)RelURL"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_rel_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "593-704",
          "snippet": "char *resolve_rel_url(char *base_url, char *rel_url)\n{\n    uri_type base;\n    uri_type rel;\n    int rv;\n\n    if (!base_url) {\n        if (!rel_url)\n            return NULL;\n        return strdup(rel_url);\n    }\n\n    size_t len_rel = strlen(rel_url);\n    if (parse_uri(rel_url, len_rel, &rel) != HTTP_SUCCESS)\n        return NULL;\n    if (rel.type == (enum uriType)ABSOLUTE)\n        return strdup(rel_url);\n\n    size_t len_base = strlen(base_url);\n    if ((parse_uri(base_url, len_base, &base) != HTTP_SUCCESS)\n            || (base.type != (enum uriType)ABSOLUTE))\n        return NULL;\n    if (len_rel == (size_t)0)\n        return strdup(base_url);\n\n    size_t len = len_base + len_rel + (size_t)2;\n    char *out = (char *)malloc(len);\n    if (out == NULL)\n        return NULL;\n    memset(out, 0, len);\n    char *out_finger = out;\n\n    /* scheme */\n    rv = snprintf(out_finger, len, \"%.*s:\", (int)base.scheme.size, base.scheme.buff);\n    if (rv < 0 || rv >= len)\n        goto error;\n    out_finger += rv;\n    len -= rv;\n\n    /* authority */\n    if (rel.hostport.text.size > (size_t)0) {\n        rv = snprintf(out_finger, len, \"%s\", rel_url);\n        if (rv < 0 || rv >= len)\n            goto error;\n        return out;\n    }\n    if (base.hostport.text.size > (size_t)0) {\n\trv = snprintf(out_finger, len, \"//%.*s\", (int)base.hostport.text.size, base.hostport.text.buff);\n\tif (rv < 0 || rv >= len)\n\t    goto error;\n\tout_finger += rv;\n\tlen -= rv;\n    }\n\n    /* path */\n    char *path = out_finger;\n    if (rel.path_type == (enum pathType)ABS_PATH) {\n\trv = snprintf(out_finger, len, \"%s\", rel_url);\n    } else if (base.pathquery.size == (size_t)0) {\n\trv = snprintf(out_finger, len, \"/%s\", rel_url);\n    } else {\n\tif (rel.pathquery.size == (size_t)0) {\n\t    rv = snprintf(out_finger, len, \"%.*s\", (int)base.pathquery.size, base.pathquery.buff);\n\t} else {\n\t    if (len < base.pathquery.size)\n\t\tgoto error;\n\t    size_t i = (size_t)0, prefix = (size_t)1;\n\t    while (i < base.pathquery.size) {\n\t\tout_finger[i] = base.pathquery.buff[i];\n\t\tswitch (base.pathquery.buff[i++]) {\n\t\t    case '/':\n\t\t\tprefix = i;\n\t\t\t/* fall-through */\n\t\t    default:\n\t\t\tcontinue;\n\t\t    case '?': /* query */\n\t\t\tif (rel.pathquery.buff[0] == '?')\n\t\t\t    prefix = --i;\n\t\t}\n\t\tbreak;\n\t    }\n\t    out_finger += prefix;\n\t    len -= prefix;\n\t    rv = snprintf(out_finger, len, \"%.*s\", (int)rel.pathquery.size, rel.pathquery.buff);\n\t}\n\tif (rv < 0 || rv >= len)\n\t    goto error;\n\tout_finger += rv;\n\tlen -= rv;\n\n\t/* fragment */\n\tif (rel.fragment.size > (size_t)0)\n\t    rv = snprintf(out_finger, len, \"#%.*s\", (int)rel.fragment.size, rel.fragment.buff);\n\telse if (base.fragment.size > (size_t)0)\n\t    rv = snprintf(out_finger, len, \"#%.*s\", (int)base.fragment.size, base.fragment.buff);\n\telse\n\t    rv = 0;\n    }\n    if (rv < 0 || rv >= len)\n\tgoto error;\n    out_finger += rv;\n    len -= rv;\n\n    if (remove_dots(path, out_finger - path) != UPNP_E_SUCCESS)\n\tgoto error;\n\n    return out;\n\nerror:\n    free(out);\n    return NULL;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\n#define snprintf _snprintf\n\nchar *resolve_rel_url(char *base_url, char *rel_url)\n{\n    uri_type base;\n    uri_type rel;\n    int rv;\n\n    if (!base_url) {\n        if (!rel_url)\n            return NULL;\n        return strdup(rel_url);\n    }\n\n    size_t len_rel = strlen(rel_url);\n    if (parse_uri(rel_url, len_rel, &rel) != HTTP_SUCCESS)\n        return NULL;\n    if (rel.type == (enum uriType)ABSOLUTE)\n        return strdup(rel_url);\n\n    size_t len_base = strlen(base_url);\n    if ((parse_uri(base_url, len_base, &base) != HTTP_SUCCESS)\n            || (base.type != (enum uriType)ABSOLUTE))\n        return NULL;\n    if (len_rel == (size_t)0)\n        return strdup(base_url);\n\n    size_t len = len_base + len_rel + (size_t)2;\n    char *out = (char *)malloc(len);\n    if (out == NULL)\n        return NULL;\n    memset(out, 0, len);\n    char *out_finger = out;\n\n    /* scheme */\n    rv = snprintf(out_finger, len, \"%.*s:\", (int)base.scheme.size, base.scheme.buff);\n    if (rv < 0 || rv >= len)\n        goto error;\n    out_finger += rv;\n    len -= rv;\n\n    /* authority */\n    if (rel.hostport.text.size > (size_t)0) {\n        rv = snprintf(out_finger, len, \"%s\", rel_url);\n        if (rv < 0 || rv >= len)\n            goto error;\n        return out;\n    }\n    if (base.hostport.text.size > (size_t)0) {\n\trv = snprintf(out_finger, len, \"//%.*s\", (int)base.hostport.text.size, base.hostport.text.buff);\n\tif (rv < 0 || rv >= len)\n\t    goto error;\n\tout_finger += rv;\n\tlen -= rv;\n    }\n\n    /* path */\n    char *path = out_finger;\n    if (rel.path_type == (enum pathType)ABS_PATH) {\n\trv = snprintf(out_finger, len, \"%s\", rel_url);\n    } else if (base.pathquery.size == (size_t)0) {\n\trv = snprintf(out_finger, len, \"/%s\", rel_url);\n    } else {\n\tif (rel.pathquery.size == (size_t)0) {\n\t    rv = snprintf(out_finger, len, \"%.*s\", (int)base.pathquery.size, base.pathquery.buff);\n\t} else {\n\t    if (len < base.pathquery.size)\n\t\tgoto error;\n\t    size_t i = (size_t)0, prefix = (size_t)1;\n\t    while (i < base.pathquery.size) {\n\t\tout_finger[i] = base.pathquery.buff[i];\n\t\tswitch (base.pathquery.buff[i++]) {\n\t\t    case '/':\n\t\t\tprefix = i;\n\t\t\t/* fall-through */\n\t\t    default:\n\t\t\tcontinue;\n\t\t    case '?': /* query */\n\t\t\tif (rel.pathquery.buff[0] == '?')\n\t\t\t    prefix = --i;\n\t\t}\n\t\tbreak;\n\t    }\n\t    out_finger += prefix;\n\t    len -= prefix;\n\t    rv = snprintf(out_finger, len, \"%.*s\", (int)rel.pathquery.size, rel.pathquery.buff);\n\t}\n\tif (rv < 0 || rv >= len)\n\t    goto error;\n\tout_finger += rv;\n\tlen -= rv;\n\n\t/* fragment */\n\tif (rel.fragment.size > (size_t)0)\n\t    rv = snprintf(out_finger, len, \"#%.*s\", (int)rel.fragment.size, rel.fragment.buff);\n\telse if (base.fragment.size > (size_t)0)\n\t    rv = snprintf(out_finger, len, \"#%.*s\", (int)base.fragment.size, base.fragment.buff);\n\telse\n\t    rv = 0;\n    }\n    if (rv < 0 || rv >= len)\n\tgoto error;\n    out_finger += rv;\n    len -= rv;\n\n    if (remove_dots(path, out_finger - path) != UPNP_E_SUCCESS)\n\tgoto error;\n\n    return out;\n\nerror:\n    free(out);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\nint UpnpResolveURL2(\n\tconst char *BaseURL,\n\tconst char *RelURL,\n\tchar **AbsURL)\n{\n\tint ret = UPNP_E_SUCCESS;\n\n\tif (!RelURL) {\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto ExitFunction;\n\t}\n\t*AbsURL = resolve_rel_url((char *)BaseURL, (char *)RelURL);\n\tif (!*AbsURL)\n\t\tret = UPNP_E_INVALID_URL;\n\nExitFunction:\n\treturn ret;\n}"
  },
  {
    "function_name": "UpnpResolveURL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
    "lines": "144-165",
    "snippet": "int UpnpResolveURL(\n\tconst char *BaseURL,\n\tconst char *RelURL,\n\tchar *AbsURL)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar *tempRel = NULL;\n\n\tif (!RelURL) {\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto ExitFunction;\n\t}\n\ttempRel = resolve_rel_url((char *)BaseURL, (char *)RelURL);\n\tif (tempRel) {\n\t\tstrcpy(AbsURL, tempRel);\n\t\tfree(tempRel);\n\t} else\n\t\tret = UPNP_E_INVALID_URL;\n\nExitFunction:\n\treturn ret;\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"uri.h\"",
      "#include \"upnptools.h\"",
      "#include \"upnp.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tempRel"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "AbsURL",
            "tempRel"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve_rel_url",
          "args": [
            "(char *)BaseURL",
            "(char *)RelURL"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_rel_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/uri/uri.c",
          "lines": "593-704",
          "snippet": "char *resolve_rel_url(char *base_url, char *rel_url)\n{\n    uri_type base;\n    uri_type rel;\n    int rv;\n\n    if (!base_url) {\n        if (!rel_url)\n            return NULL;\n        return strdup(rel_url);\n    }\n\n    size_t len_rel = strlen(rel_url);\n    if (parse_uri(rel_url, len_rel, &rel) != HTTP_SUCCESS)\n        return NULL;\n    if (rel.type == (enum uriType)ABSOLUTE)\n        return strdup(rel_url);\n\n    size_t len_base = strlen(base_url);\n    if ((parse_uri(base_url, len_base, &base) != HTTP_SUCCESS)\n            || (base.type != (enum uriType)ABSOLUTE))\n        return NULL;\n    if (len_rel == (size_t)0)\n        return strdup(base_url);\n\n    size_t len = len_base + len_rel + (size_t)2;\n    char *out = (char *)malloc(len);\n    if (out == NULL)\n        return NULL;\n    memset(out, 0, len);\n    char *out_finger = out;\n\n    /* scheme */\n    rv = snprintf(out_finger, len, \"%.*s:\", (int)base.scheme.size, base.scheme.buff);\n    if (rv < 0 || rv >= len)\n        goto error;\n    out_finger += rv;\n    len -= rv;\n\n    /* authority */\n    if (rel.hostport.text.size > (size_t)0) {\n        rv = snprintf(out_finger, len, \"%s\", rel_url);\n        if (rv < 0 || rv >= len)\n            goto error;\n        return out;\n    }\n    if (base.hostport.text.size > (size_t)0) {\n\trv = snprintf(out_finger, len, \"//%.*s\", (int)base.hostport.text.size, base.hostport.text.buff);\n\tif (rv < 0 || rv >= len)\n\t    goto error;\n\tout_finger += rv;\n\tlen -= rv;\n    }\n\n    /* path */\n    char *path = out_finger;\n    if (rel.path_type == (enum pathType)ABS_PATH) {\n\trv = snprintf(out_finger, len, \"%s\", rel_url);\n    } else if (base.pathquery.size == (size_t)0) {\n\trv = snprintf(out_finger, len, \"/%s\", rel_url);\n    } else {\n\tif (rel.pathquery.size == (size_t)0) {\n\t    rv = snprintf(out_finger, len, \"%.*s\", (int)base.pathquery.size, base.pathquery.buff);\n\t} else {\n\t    if (len < base.pathquery.size)\n\t\tgoto error;\n\t    size_t i = (size_t)0, prefix = (size_t)1;\n\t    while (i < base.pathquery.size) {\n\t\tout_finger[i] = base.pathquery.buff[i];\n\t\tswitch (base.pathquery.buff[i++]) {\n\t\t    case '/':\n\t\t\tprefix = i;\n\t\t\t/* fall-through */\n\t\t    default:\n\t\t\tcontinue;\n\t\t    case '?': /* query */\n\t\t\tif (rel.pathquery.buff[0] == '?')\n\t\t\t    prefix = --i;\n\t\t}\n\t\tbreak;\n\t    }\n\t    out_finger += prefix;\n\t    len -= prefix;\n\t    rv = snprintf(out_finger, len, \"%.*s\", (int)rel.pathquery.size, rel.pathquery.buff);\n\t}\n\tif (rv < 0 || rv >= len)\n\t    goto error;\n\tout_finger += rv;\n\tlen -= rv;\n\n\t/* fragment */\n\tif (rel.fragment.size > (size_t)0)\n\t    rv = snprintf(out_finger, len, \"#%.*s\", (int)rel.fragment.size, rel.fragment.buff);\n\telse if (base.fragment.size > (size_t)0)\n\t    rv = snprintf(out_finger, len, \"#%.*s\", (int)base.fragment.size, base.fragment.buff);\n\telse\n\t    rv = 0;\n    }\n    if (rv < 0 || rv >= len)\n\tgoto error;\n    out_finger += rv;\n    len -= rv;\n\n    if (remove_dots(path, out_finger - path) != UPNP_E_SUCCESS)\n\tgoto error;\n\n    return out;\n\nerror:\n    free(out);\n    return NULL;\n}",
          "includes": [
            "#include \"upnpapi.h\"",
            "#include \"uri.h\"",
            "#include \"config.h\"",
            "#include <assert.h>",
            "#include <lwres/netdb.h>",
            "#include <osreldate.h>"
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"upnpapi.h\"\n#include \"uri.h\"\n#include \"config.h\"\n#include <assert.h>\n#include <lwres/netdb.h>\n#include <osreldate.h>\n\n#define snprintf _snprintf\n\nchar *resolve_rel_url(char *base_url, char *rel_url)\n{\n    uri_type base;\n    uri_type rel;\n    int rv;\n\n    if (!base_url) {\n        if (!rel_url)\n            return NULL;\n        return strdup(rel_url);\n    }\n\n    size_t len_rel = strlen(rel_url);\n    if (parse_uri(rel_url, len_rel, &rel) != HTTP_SUCCESS)\n        return NULL;\n    if (rel.type == (enum uriType)ABSOLUTE)\n        return strdup(rel_url);\n\n    size_t len_base = strlen(base_url);\n    if ((parse_uri(base_url, len_base, &base) != HTTP_SUCCESS)\n            || (base.type != (enum uriType)ABSOLUTE))\n        return NULL;\n    if (len_rel == (size_t)0)\n        return strdup(base_url);\n\n    size_t len = len_base + len_rel + (size_t)2;\n    char *out = (char *)malloc(len);\n    if (out == NULL)\n        return NULL;\n    memset(out, 0, len);\n    char *out_finger = out;\n\n    /* scheme */\n    rv = snprintf(out_finger, len, \"%.*s:\", (int)base.scheme.size, base.scheme.buff);\n    if (rv < 0 || rv >= len)\n        goto error;\n    out_finger += rv;\n    len -= rv;\n\n    /* authority */\n    if (rel.hostport.text.size > (size_t)0) {\n        rv = snprintf(out_finger, len, \"%s\", rel_url);\n        if (rv < 0 || rv >= len)\n            goto error;\n        return out;\n    }\n    if (base.hostport.text.size > (size_t)0) {\n\trv = snprintf(out_finger, len, \"//%.*s\", (int)base.hostport.text.size, base.hostport.text.buff);\n\tif (rv < 0 || rv >= len)\n\t    goto error;\n\tout_finger += rv;\n\tlen -= rv;\n    }\n\n    /* path */\n    char *path = out_finger;\n    if (rel.path_type == (enum pathType)ABS_PATH) {\n\trv = snprintf(out_finger, len, \"%s\", rel_url);\n    } else if (base.pathquery.size == (size_t)0) {\n\trv = snprintf(out_finger, len, \"/%s\", rel_url);\n    } else {\n\tif (rel.pathquery.size == (size_t)0) {\n\t    rv = snprintf(out_finger, len, \"%.*s\", (int)base.pathquery.size, base.pathquery.buff);\n\t} else {\n\t    if (len < base.pathquery.size)\n\t\tgoto error;\n\t    size_t i = (size_t)0, prefix = (size_t)1;\n\t    while (i < base.pathquery.size) {\n\t\tout_finger[i] = base.pathquery.buff[i];\n\t\tswitch (base.pathquery.buff[i++]) {\n\t\t    case '/':\n\t\t\tprefix = i;\n\t\t\t/* fall-through */\n\t\t    default:\n\t\t\tcontinue;\n\t\t    case '?': /* query */\n\t\t\tif (rel.pathquery.buff[0] == '?')\n\t\t\t    prefix = --i;\n\t\t}\n\t\tbreak;\n\t    }\n\t    out_finger += prefix;\n\t    len -= prefix;\n\t    rv = snprintf(out_finger, len, \"%.*s\", (int)rel.pathquery.size, rel.pathquery.buff);\n\t}\n\tif (rv < 0 || rv >= len)\n\t    goto error;\n\tout_finger += rv;\n\tlen -= rv;\n\n\t/* fragment */\n\tif (rel.fragment.size > (size_t)0)\n\t    rv = snprintf(out_finger, len, \"#%.*s\", (int)rel.fragment.size, rel.fragment.buff);\n\telse if (base.fragment.size > (size_t)0)\n\t    rv = snprintf(out_finger, len, \"#%.*s\", (int)base.fragment.size, base.fragment.buff);\n\telse\n\t    rv = 0;\n    }\n    if (rv < 0 || rv >= len)\n\tgoto error;\n    out_finger += rv;\n    len -= rv;\n\n    if (remove_dots(path, out_finger - path) != UPNP_E_SUCCESS)\n\tgoto error;\n\n    return out;\n\nerror:\n    free(out);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\nint UpnpResolveURL(\n\tconst char *BaseURL,\n\tconst char *RelURL,\n\tchar *AbsURL)\n{\n\tint ret = UPNP_E_SUCCESS;\n\tchar *tempRel = NULL;\n\n\tif (!RelURL) {\n\t\tret = UPNP_E_INVALID_PARAM;\n\t\tgoto ExitFunction;\n\t}\n\ttempRel = resolve_rel_url((char *)BaseURL, (char *)RelURL);\n\tif (tempRel) {\n\t\tstrcpy(AbsURL, tempRel);\n\t\tfree(tempRel);\n\t} else\n\t\tret = UPNP_E_INVALID_URL;\n\nExitFunction:\n\treturn ret;\n}"
  },
  {
    "function_name": "UpnpGetErrorMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnptools.c",
    "lines": "126-137",
    "snippet": "const char *UpnpGetErrorMessage(int rc)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < sizeof (ErrorMessages) / sizeof (ErrorMessages[0]); ++i) {\n\t\tif (rc == ErrorMessages[i].rc) {\n\t\t\treturn ErrorMessages[i].rcError;\n\t\t}\n\t}\n\n\treturn \"Unknown error code\";\n}",
    "includes": [
      "#include <stdio.h>",
      "#include <stdarg.h>",
      "#include \"uri.h\"",
      "#include \"upnptools.h\"",
      "#include \"upnp.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"uri.h\"\n#include \"upnptools.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\nconst char *UpnpGetErrorMessage(int rc)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < sizeof (ErrorMessages) / sizeof (ErrorMessages[0]); ++i) {\n\t\tif (rc == ErrorMessages[i].rc) {\n\t\t\treturn ErrorMessages[i].rcError;\n\t\t}\n\t}\n\n\treturn \"Unknown error code\";\n}"
  }
]