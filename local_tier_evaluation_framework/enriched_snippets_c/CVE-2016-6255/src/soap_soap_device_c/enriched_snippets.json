[
  {
    "function_name": "soap_device_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
    "lines": "701-780",
    "snippet": "void soap_device_callback(\n\t/*! [in] Parsed request received by the device. */\n\thttp_parser_t *parser,\n\t/*! [in] HTTP request. */\n\thttp_message_t *request,\n\t/*! [in,out] Socket info. */\n\tSOCKINFO *info)\n{\n\tint err_code;\n\tIXML_Document *xml_doc = NULL;\n\tsoap_devserv_t *soap_info = NULL;\n\tIXML_Node *req_node = NULL;\n\n\t/* get device/service identified by the request-URI */\n\tsoap_info = malloc(sizeof(soap_devserv_t));\n\tif (NULL == soap_info) {\n\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\tgoto error_handler;\n\t}\n\tif (get_dev_service(request,\n\t\t\tinfo->foreign_sockaddr.ss_family, soap_info) < 0) {\n\t\terr_code = HTTP_NOT_FOUND;\n\t\tgoto error_handler;\n\t}\n\t/* validate: content-type == text/xml */\n\tif (!has_xml_content_type(request)) {\n\t\terr_code = HTTP_UNSUPPORTED_MEDIA_TYPE;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAPACTION HTTP header */\n\terr_code = check_soapaction_hdr(request, soap_info);\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\tswitch (err_code) {\n\t\tcase SREQ_NOT_EXTENDED:\n\t\t\terr_code = HTTP_NOT_EXTENDED;\n\t\t\tbreak;\n\t\tcase UPNP_E_OUTOF_MEMORY:\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\t\tbreak;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* parse XML */\n\terr_code = ixmlParseBufferEx(request->entity.buf, &xml_doc);\n\tif (err_code != IXML_SUCCESS) {\n\t\tif (IXML_INSUFFICIENT_MEMORY == err_code)\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\telse\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAP body */\n\tif (check_soap_request(soap_info, xml_doc, &req_node) < 0)\n\t{\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* process SOAP request */\n\tif (NULL == soap_info->action_name.buf)\n\t\t/* query var */\n\t\thandle_query_variable(info, request, soap_info, req_node);\n\telse\n\t\t/* invoke action */\n\t\thandle_invoke_action(info, request, soap_info, req_node);\n\n\terr_code = HTTP_OK;\n\nerror_handler:\n\tixmlDocument_free(xml_doc);\n\tfree(soap_info);\n\tif (err_code != HTTP_OK) {\n\t\thttp_SendStatusResponse(info, err_code, request->major_version,\n\t\t\t\trequest->minor_version);\n\t}\n\treturn;\n\tparser = parser;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"soaplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ActionRequest.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SREQ_NOT_EXTENDED\t -3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "http_SendStatusResponse",
          "args": [
            "info",
            "err_code",
            "request->major_version",
            "request->minor_version"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendStatusResponse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1445-1468",
          "snippet": "int http_SendStatusResponse(IN SOCKINFO *info, IN int http_status_code,\n\tIN int request_major_version, IN int request_minor_version)\n{\n\tint response_major, response_minor;\n\tmembuffer membuf;\n\tint ret;\n\tint timeout;\n\n\thttp_CalcResponseVersion(request_major_version, request_minor_version,\n\t\t\t\t &response_major, &response_minor);\n\tmembuffer_init(&membuf);\n\tmembuf.size_inc = (size_t)70;\n\t/* response start line */\n\tret = http_MakeMessage(&membuf, response_major, response_minor, \"RSCB\",\n\t\t\t       http_status_code, http_status_code);\n\tif (ret == 0) {\n\t\ttimeout = HTTP_DEFAULT_TIMEOUT;\n\t\tret = http_SendMessage(info, &timeout, \"b\",\n\t\t       membuf.buf, membuf.length);\n\t}\n\tmembuffer_destroy(&membuf);\n\n\treturn ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nint http_SendStatusResponse(IN SOCKINFO *info, IN int http_status_code,\n\tIN int request_major_version, IN int request_minor_version)\n{\n\tint response_major, response_minor;\n\tmembuffer membuf;\n\tint ret;\n\tint timeout;\n\n\thttp_CalcResponseVersion(request_major_version, request_minor_version,\n\t\t\t\t &response_major, &response_minor);\n\tmembuffer_init(&membuf);\n\tmembuf.size_inc = (size_t)70;\n\t/* response start line */\n\tret = http_MakeMessage(&membuf, response_major, response_minor, \"RSCB\",\n\t\t\t       http_status_code, http_status_code);\n\tif (ret == 0) {\n\t\ttimeout = HTTP_DEFAULT_TIMEOUT;\n\t\tret = http_SendMessage(info, &timeout, \"b\",\n\t\t       membuf.buf, membuf.length);\n\t}\n\tmembuffer_destroy(&membuf);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "soap_info"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "free_notify_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/gena/gena_device.c",
          "lines": "144-157",
          "snippet": "static void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}",
          "includes": [
            "#include \"uuid.h\"",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"sysdep.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"gena.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uuid.h\"\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"sysdep.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"gena.h\"\n#include \"config.h\"\n\nstatic void free_notify_struct(\n\t/*! [in] Notify structure. */\n\tnotify_thread_struct *input)\n{\n\t(*input->reference_count)--;\n\tif (*input->reference_count == 0) {\n\t\tfree(input->headers);\n\t\tixmlFreeDOMString(input->propertySet);\n\t\tfree(input->servId);\n\t\tfree(input->UDN);\n\t\tfree(input->reference_count);\n\t}\n\tfree(input);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "xml_doc"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_invoke_action",
          "args": [
            "info",
            "request",
            "soap_info",
            "req_node"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "handle_invoke_action",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "352-433",
          "snippet": "static void handle_invoke_action(\n\t\t/*! [in] Socket info. */\n\t\tSOCKINFO *info,\n\t\t/*! [in] HTTP Request. */\n\t\thttp_message_t *request,\n\t\t/*! [in] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info,\n\t\t/*! [in] Node containing the SOAP action request. */\n\t\tIXML_Node *req_node)\n{\n\tchar save_char;\n\tUpnpActionRequest *action = UpnpActionRequest_new();\n\tIXML_Document *actionRequestDoc = NULL;\n\tIXML_Document *actionResultDoc = NULL;\n\tint err_code;\n\tconst char *err_str;\n\tmemptr action_name;\n\tDOMString act_node = NULL;\n\n\t/* null-terminate */\n\taction_name = soap_info->action_name;\n\tsave_char = action_name.buf[action_name.length];\n\taction_name.buf[action_name.length] = '\\0';\n\t/* get action node */\n\tact_node = ixmlPrintNode(req_node);\n\tif (!act_node) {\n\t\terr_code = SOAP_MEMORY_OUT;\n\t\terr_str = Soap_Memory_out;\n\t\tgoto error_handler;\n\t}\n\terr_code = ixmlParseBufferEx(act_node, &actionRequestDoc);\n\tif (err_code != IXML_SUCCESS) {\n\t\tif (IXML_INSUFFICIENT_MEMORY == err_code) {\n\t\t\terr_code = SOAP_MEMORY_OUT;\n\t\t\terr_str = Soap_Memory_out;\n\t\t} else {\n\t\t\terr_code = SOAP_INVALID_ACTION;\n\t\t\terr_str = Soap_Invalid_Action;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\tUpnpActionRequest_set_ErrCode(action, UPNP_E_SUCCESS);\n\tUpnpActionRequest_strcpy_ActionName(action, action_name.buf);\n\tUpnpActionRequest_strcpy_DevUDN(action, soap_info->dev_udn);\n\tUpnpActionRequest_strcpy_ServiceID(action, soap_info->service_id);\n\tUpnpActionRequest_set_ActionRequest(action, actionRequestDoc);\n\tUpnpActionRequest_set_ActionResult(action, NULL);\n\tUpnpActionRequest_set_CtrlPtIPAddr(action, &info->foreign_sockaddr);\n\n\tUpnpPrintf(UPNP_INFO, SOAP, __FILE__, __LINE__, \"Calling Callback\\n\");\n\tsoap_info->callback(UPNP_CONTROL_ACTION_REQUEST, action, soap_info->cookie);\n\terr_code = UpnpActionRequest_get_ErrCode(action);\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\terr_str = UpnpActionRequest_get_ErrStr_cstr(action);\n\t\tif (strlen(err_str) <= 0) {\n\t\t\terr_code = SOAP_ACTION_FAILED;\n\t\t\terr_str = Soap_Action_Failed;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* validate, and handle action error */\n\tactionResultDoc = UpnpActionRequest_get_ActionResult(action);\n\tif (actionResultDoc == NULL) {\n\t\terr_code = SOAP_ACTION_FAILED;\n\t\terr_str = Soap_Action_Failed;\n\t\tgoto error_handler;\n\t}\n\t/* send response */\n\tsend_action_response(info, actionResultDoc, request);\n\terr_code = 0;\n\n\t/* error handling and cleanup */\nerror_handler:\n\tixmlDocument_free(actionResultDoc);\n\tixmlDocument_free(actionRequestDoc);\n\tixmlFreeDOMString(act_node);\n\t/* restore */\n\taction_name.buf[action_name.length] = save_char;\n\tif (err_code != 0)\n\t\tsend_error_response(info, err_code, err_str, request);\n\tUpnpActionRequest_delete(action);\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_MEMORY_OUT\t\t603",
            "#define SOAP_ACTION_FAILED\t501",
            "#define SOAP_INVALID_ACTION 401"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SOAP_MEMORY_OUT\t\t603\n#define SOAP_ACTION_FAILED\t501\n#define SOAP_INVALID_ACTION 401\n\nstatic void handle_invoke_action(\n\t\t/*! [in] Socket info. */\n\t\tSOCKINFO *info,\n\t\t/*! [in] HTTP Request. */\n\t\thttp_message_t *request,\n\t\t/*! [in] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info,\n\t\t/*! [in] Node containing the SOAP action request. */\n\t\tIXML_Node *req_node)\n{\n\tchar save_char;\n\tUpnpActionRequest *action = UpnpActionRequest_new();\n\tIXML_Document *actionRequestDoc = NULL;\n\tIXML_Document *actionResultDoc = NULL;\n\tint err_code;\n\tconst char *err_str;\n\tmemptr action_name;\n\tDOMString act_node = NULL;\n\n\t/* null-terminate */\n\taction_name = soap_info->action_name;\n\tsave_char = action_name.buf[action_name.length];\n\taction_name.buf[action_name.length] = '\\0';\n\t/* get action node */\n\tact_node = ixmlPrintNode(req_node);\n\tif (!act_node) {\n\t\terr_code = SOAP_MEMORY_OUT;\n\t\terr_str = Soap_Memory_out;\n\t\tgoto error_handler;\n\t}\n\terr_code = ixmlParseBufferEx(act_node, &actionRequestDoc);\n\tif (err_code != IXML_SUCCESS) {\n\t\tif (IXML_INSUFFICIENT_MEMORY == err_code) {\n\t\t\terr_code = SOAP_MEMORY_OUT;\n\t\t\terr_str = Soap_Memory_out;\n\t\t} else {\n\t\t\terr_code = SOAP_INVALID_ACTION;\n\t\t\terr_str = Soap_Invalid_Action;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\tUpnpActionRequest_set_ErrCode(action, UPNP_E_SUCCESS);\n\tUpnpActionRequest_strcpy_ActionName(action, action_name.buf);\n\tUpnpActionRequest_strcpy_DevUDN(action, soap_info->dev_udn);\n\tUpnpActionRequest_strcpy_ServiceID(action, soap_info->service_id);\n\tUpnpActionRequest_set_ActionRequest(action, actionRequestDoc);\n\tUpnpActionRequest_set_ActionResult(action, NULL);\n\tUpnpActionRequest_set_CtrlPtIPAddr(action, &info->foreign_sockaddr);\n\n\tUpnpPrintf(UPNP_INFO, SOAP, __FILE__, __LINE__, \"Calling Callback\\n\");\n\tsoap_info->callback(UPNP_CONTROL_ACTION_REQUEST, action, soap_info->cookie);\n\terr_code = UpnpActionRequest_get_ErrCode(action);\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\terr_str = UpnpActionRequest_get_ErrStr_cstr(action);\n\t\tif (strlen(err_str) <= 0) {\n\t\t\terr_code = SOAP_ACTION_FAILED;\n\t\t\terr_str = Soap_Action_Failed;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* validate, and handle action error */\n\tactionResultDoc = UpnpActionRequest_get_ActionResult(action);\n\tif (actionResultDoc == NULL) {\n\t\terr_code = SOAP_ACTION_FAILED;\n\t\terr_str = Soap_Action_Failed;\n\t\tgoto error_handler;\n\t}\n\t/* send response */\n\tsend_action_response(info, actionResultDoc, request);\n\terr_code = 0;\n\n\t/* error handling and cleanup */\nerror_handler:\n\tixmlDocument_free(actionResultDoc);\n\tixmlDocument_free(actionRequestDoc);\n\tixmlFreeDOMString(act_node);\n\t/* restore */\n\taction_name.buf[action_name.length] = save_char;\n\tif (err_code != 0)\n\t\tsend_error_response(info, err_code, err_str, request);\n\tUpnpActionRequest_delete(action);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_query_variable",
          "args": [
            "info",
            "request",
            "soap_info",
            "req_node"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "handle_query_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "291-347",
          "snippet": "static UPNP_INLINE void handle_query_variable(\n\t\t/*! [in] Socket info. */\n\t\tSOCKINFO *info,\n\t\t/*! [in] HTTP Request. */\n\t\thttp_message_t *request,\n\t\t/*! [in] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info,\n\t\t/*! [in] Node containing variable name. */\n\t\tIXML_Node *req_node)\n{\n\tUpnpStateVarRequest *variable = UpnpStateVarRequest_new();\n\tconst char *err_str;\n\tint err_code;\n\tconst DOMString var_name;\n\n\t/* set default error */\n\terr_code = SOAP_INVALID_VAR;\n\terr_str = Soap_Invalid_Var;\n\n\tif (variable == NULL) {\n\t\terr_code = SOAP_MEMORY_OUT;\n\t\terr_str = Soap_Memory_out;\n\t\tgoto error_handler;\n\t}\n\n\tUpnpStateVarRequest_set_ErrCode(variable, UPNP_E_SUCCESS);\n\tUpnpStateVarRequest_strcpy_DevUDN(variable, soap_info->dev_udn);\n\tUpnpStateVarRequest_strcpy_ServiceID(variable, soap_info->service_id);\n\tvar_name = ixmlNode_getNodeValue(req_node);\n\tUpnpStateVarRequest_strcpy_StateVarName(variable, var_name);\n\tUpnpStateVarRequest_set_CtrlPtIPAddr(variable, &info->foreign_sockaddr);\n\n\t/* send event */\n\tsoap_info->callback(UPNP_CONTROL_GET_VAR_REQUEST, variable,\n\t\t\tsoap_info->cookie);\n\tUpnpPrintf(UPNP_INFO, SOAP, __FILE__, __LINE__,\n\t\t\"Return from callback for var request\\n\");\n\t/* validate, and handle result */\n\tif (UpnpStateVarRequest_get_CurrentVal(variable) == NULL)\n\t\tgoto error_handler;\n\tif (UpnpStateVarRequest_get_ErrCode(variable) != UPNP_E_SUCCESS) {\n\t\tif (UpnpString_get_Length(UpnpStateVarRequest_get_ErrStr(variable)) > 0) {\n\t\t\terr_code = UpnpStateVarRequest_get_ErrCode(variable);\n\t\t\terr_str = UpnpStateVarRequest_get_ErrStr_cstr(variable);\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* send response */\n\tsend_var_query_response(info, UpnpStateVarRequest_get_CurrentVal(variable), request);\n\terr_code = 0;\n\n\t/* error handling and cleanup */\nerror_handler:\n\tUpnpStateVarRequest_delete(variable);\n\tif (err_code != 0)\n\t\tsend_error_response(info, err_code, err_str, request);\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_MEMORY_OUT\t\t603",
            "#define SOAP_INVALID_VAR\t404"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SOAP_MEMORY_OUT\t\t603\n#define SOAP_INVALID_VAR\t404\n\nstatic UPNP_INLINE void handle_query_variable(\n\t\t/*! [in] Socket info. */\n\t\tSOCKINFO *info,\n\t\t/*! [in] HTTP Request. */\n\t\thttp_message_t *request,\n\t\t/*! [in] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info,\n\t\t/*! [in] Node containing variable name. */\n\t\tIXML_Node *req_node)\n{\n\tUpnpStateVarRequest *variable = UpnpStateVarRequest_new();\n\tconst char *err_str;\n\tint err_code;\n\tconst DOMString var_name;\n\n\t/* set default error */\n\terr_code = SOAP_INVALID_VAR;\n\terr_str = Soap_Invalid_Var;\n\n\tif (variable == NULL) {\n\t\terr_code = SOAP_MEMORY_OUT;\n\t\terr_str = Soap_Memory_out;\n\t\tgoto error_handler;\n\t}\n\n\tUpnpStateVarRequest_set_ErrCode(variable, UPNP_E_SUCCESS);\n\tUpnpStateVarRequest_strcpy_DevUDN(variable, soap_info->dev_udn);\n\tUpnpStateVarRequest_strcpy_ServiceID(variable, soap_info->service_id);\n\tvar_name = ixmlNode_getNodeValue(req_node);\n\tUpnpStateVarRequest_strcpy_StateVarName(variable, var_name);\n\tUpnpStateVarRequest_set_CtrlPtIPAddr(variable, &info->foreign_sockaddr);\n\n\t/* send event */\n\tsoap_info->callback(UPNP_CONTROL_GET_VAR_REQUEST, variable,\n\t\t\tsoap_info->cookie);\n\tUpnpPrintf(UPNP_INFO, SOAP, __FILE__, __LINE__,\n\t\t\"Return from callback for var request\\n\");\n\t/* validate, and handle result */\n\tif (UpnpStateVarRequest_get_CurrentVal(variable) == NULL)\n\t\tgoto error_handler;\n\tif (UpnpStateVarRequest_get_ErrCode(variable) != UPNP_E_SUCCESS) {\n\t\tif (UpnpString_get_Length(UpnpStateVarRequest_get_ErrStr(variable)) > 0) {\n\t\t\terr_code = UpnpStateVarRequest_get_ErrCode(variable);\n\t\t\terr_str = UpnpStateVarRequest_get_ErrStr_cstr(variable);\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* send response */\n\tsend_var_query_response(info, UpnpStateVarRequest_get_CurrentVal(variable), request);\n\terr_code = 0;\n\n\t/* error handling and cleanup */\nerror_handler:\n\tUpnpStateVarRequest_delete(variable);\n\tif (err_code != 0)\n\t\tsend_error_response(info, err_code, err_str, request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_soap_request",
          "args": [
            "soap_info",
            "xml_doc",
            "&req_node"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "check_soap_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "612-693",
          "snippet": "static int check_soap_request(\n\t\t/*! [in] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info,\n\t\t/*! [in] Document containing the SOAP action request. */\n\t\tIN IXML_Document *xml_doc,\n\t\t/*! [out] Node containing the SOAP action request/variable name. */\n\t\tIXML_Node **req_node)\n{\n\tIXML_Node *envp_node = NULL;\n\tIXML_Node *body_node = NULL;\n\tIXML_Node *action_node = NULL;\n\tconst DOMString local_name = NULL;\n\tconst DOMString ns_uri = NULL;\n\tint ret_val = -1;\n\n\t/* Got the Envelop node here */\n\tenvp_node = ixmlNode_getFirstChild((IXML_Node *) xml_doc);\n\tif (NULL == envp_node) {\n\t\tgoto error_handler;\n\t}\n\tns_uri = ixmlNode_getNamespaceURI(envp_node);\n\tif (NULL == ns_uri || strcmp(ns_uri, SOAP_URN) != 0) {\n\t\tgoto error_handler;\n\t}\n\t/* Got Body here */\n\tbody_node = ixmlNode_getFirstChild(envp_node);\n\tif (NULL == body_node) {\n\t\tgoto error_handler;\n\t}\n\tlocal_name = ixmlNode_getLocalName(body_node);\n\tif (NULL == local_name || strcmp(local_name, SOAP_BODY) != 0) {\n\t\tgoto error_handler;\n\t}\n\t/* Got action node here */\n\taction_node = ixmlNode_getFirstChild(body_node);\n\tif (NULL == action_node) {\n\t\tgoto error_handler;\n\t}\n\t/* check local name and namespace of action node */\n\tns_uri = ixmlNode_getNamespaceURI(action_node);\n\tif (NULL == ns_uri) {\n\t\tgoto error_handler;\n\t}\n\tlocal_name = ixmlNode_getLocalName(action_node);\n\tif (NULL == local_name) {\n\t\tgoto error_handler;\n\t}\n\tif (NULL == soap_info->action_name.buf) {\n\t\tIXML_Node *varname_node = NULL;\n\t\tIXML_Node *nametxt_node = NULL;\n\t\tif (strcmp(ns_uri, QUERY_STATE_VAR_URN) != 0 ||\n\t\t\tstrcmp(local_name, \"QueryStateVariable\") != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tvarname_node = ixmlNode_getFirstChild(action_node);\n\t\tif(NULL == varname_node) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tlocal_name = ixmlNode_getLocalName(varname_node);\n\t\tif (strcmp(local_name, \"varName\") != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tnametxt_node = ixmlNode_getFirstChild(varname_node);\n\t\tif (NULL == nametxt_node ||\n\t\t\tixmlNode_getNodeType(nametxt_node) != eTEXT_NODE) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t*req_node = nametxt_node;\n\t} else {\n\t\t/* check service type against SOAPACTION header */\n\t\tif (strcmp(soap_info->service_type, ns_uri) != 0 ||\n\t\t\tmemptr_cmp(&soap_info->action_name, local_name) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t*req_node = action_node;\n\t}\n\t/* success */\n\tret_val = 0;\n\nerror_handler:\n\treturn ret_val;\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\nstatic int check_soap_request(\n\t\t/*! [in] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info,\n\t\t/*! [in] Document containing the SOAP action request. */\n\t\tIN IXML_Document *xml_doc,\n\t\t/*! [out] Node containing the SOAP action request/variable name. */\n\t\tIXML_Node **req_node)\n{\n\tIXML_Node *envp_node = NULL;\n\tIXML_Node *body_node = NULL;\n\tIXML_Node *action_node = NULL;\n\tconst DOMString local_name = NULL;\n\tconst DOMString ns_uri = NULL;\n\tint ret_val = -1;\n\n\t/* Got the Envelop node here */\n\tenvp_node = ixmlNode_getFirstChild((IXML_Node *) xml_doc);\n\tif (NULL == envp_node) {\n\t\tgoto error_handler;\n\t}\n\tns_uri = ixmlNode_getNamespaceURI(envp_node);\n\tif (NULL == ns_uri || strcmp(ns_uri, SOAP_URN) != 0) {\n\t\tgoto error_handler;\n\t}\n\t/* Got Body here */\n\tbody_node = ixmlNode_getFirstChild(envp_node);\n\tif (NULL == body_node) {\n\t\tgoto error_handler;\n\t}\n\tlocal_name = ixmlNode_getLocalName(body_node);\n\tif (NULL == local_name || strcmp(local_name, SOAP_BODY) != 0) {\n\t\tgoto error_handler;\n\t}\n\t/* Got action node here */\n\taction_node = ixmlNode_getFirstChild(body_node);\n\tif (NULL == action_node) {\n\t\tgoto error_handler;\n\t}\n\t/* check local name and namespace of action node */\n\tns_uri = ixmlNode_getNamespaceURI(action_node);\n\tif (NULL == ns_uri) {\n\t\tgoto error_handler;\n\t}\n\tlocal_name = ixmlNode_getLocalName(action_node);\n\tif (NULL == local_name) {\n\t\tgoto error_handler;\n\t}\n\tif (NULL == soap_info->action_name.buf) {\n\t\tIXML_Node *varname_node = NULL;\n\t\tIXML_Node *nametxt_node = NULL;\n\t\tif (strcmp(ns_uri, QUERY_STATE_VAR_URN) != 0 ||\n\t\t\tstrcmp(local_name, \"QueryStateVariable\") != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tvarname_node = ixmlNode_getFirstChild(action_node);\n\t\tif(NULL == varname_node) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tlocal_name = ixmlNode_getLocalName(varname_node);\n\t\tif (strcmp(local_name, \"varName\") != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tnametxt_node = ixmlNode_getFirstChild(varname_node);\n\t\tif (NULL == nametxt_node ||\n\t\t\tixmlNode_getNodeType(nametxt_node) != eTEXT_NODE) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t*req_node = nametxt_node;\n\t} else {\n\t\t/* check service type against SOAPACTION header */\n\t\tif (strcmp(soap_info->service_type, ns_uri) != 0 ||\n\t\t\tmemptr_cmp(&soap_info->action_name, local_name) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t*req_node = action_node;\n\t}\n\t/* success */\n\tret_val = 0;\n\nerror_handler:\n\treturn ret_val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "request->entity.buf",
            "&xml_doc"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_soapaction_hdr",
          "args": [
            "request",
            "soap_info"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "check_soapaction_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "533-604",
          "snippet": "static int check_soapaction_hdr(\n\t\t/*! [in] HTTP request. */\n\t\thttp_message_t *request,\n\t\t/*! [in, out] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info)\n{\n\tmemptr value;\n\tchar save_char;\n\tchar *hash_pos = NULL;\n\tchar *col_pos1, *col_pos2, *serv_type;\n\tint ret_code;\n\n\t/* find SOAPACTION header */\n\tif (SOAPMETHOD_POST == request->method) {\n\t\tif (!httpmsg_find_hdr(request, HDR_SOAPACTION, &value))\n\t\t\treturn SREQ_HDR_NOT_FOUND;\n\t} else {\n\t\tret_code = get_mpost_acton_hdrval(request, &value);\n\t\tif (ret_code != UPNP_E_SUCCESS) {\n\t\t\treturn ret_code;\n\t\t}\n\t}\n\n\t/* error by default */\n\tret_code = SREQ_BAD_HDR_FORMAT;\n\t/* get action name*/\n\tsave_char = value.buf[value.length];\n\tvalue.buf[value.length] = '\\0';\n\thash_pos = strchr(value.buf, '#');\n\tif (NULL == hash_pos) {\n\t\tgoto error_handler;\n\t}\n\t*hash_pos = '\\0';\n\tif (matchstr(hash_pos+1,\n\t\t\tvalue.length - (size_t)(hash_pos+1 - value.buf),\n\t\t\t\"%s\", &soap_info->action_name) != PARSE_OK) {\n\t\tgoto error_handler;\n\t}\n\n\t/* check service type */\n\tif (value.buf[0] != '\\\"') {\n\t\tgoto error_handler;\n\t}\n\tserv_type = &value.buf[1];\n\tcol_pos1 = strrchr(serv_type, ':');\n\tif (NULL == col_pos1) {\n\t\tgoto error_handler;\n\t}\n\tcol_pos2 = strrchr(soap_info->service_type, ':');\n\t/* XXX: this should be checked when service list is generated */\n\tassert(col_pos2 != NULL);\n\tif (col_pos2-soap_info->service_type == col_pos1-serv_type &&\n\t\tstrncmp(soap_info->service_type, serv_type, col_pos1-serv_type) == 0) {\n\t\t/* for action invocation, update the version information */\n\t\tnamecopy(soap_info->service_type, serv_type);\n\t} else if (strcmp(serv_type, QUERY_STATE_VAR_URN) == 0 &&\n\t\t\tmemptr_cmp(&soap_info->action_name, \"QueryStateVariable\") == 0) {\n\t\t/* query variable */\n\t\tsoap_info->action_name.buf = NULL;\n\t\tsoap_info->action_name.length = 0;\n\t} else {\n\t\tgoto error_handler;\n\t}\n\tret_code = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (hash_pos != NULL) {\n\t\t*hash_pos = '#';\n\t}\n\tvalue.buf[value.length] = save_char;\n\treturn ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SREQ_BAD_HDR_FORMAT\t -2",
            "#define SREQ_HDR_NOT_FOUND\t -1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SREQ_BAD_HDR_FORMAT\t -2\n#define SREQ_HDR_NOT_FOUND\t -1\n\nstatic int check_soapaction_hdr(\n\t\t/*! [in] HTTP request. */\n\t\thttp_message_t *request,\n\t\t/*! [in, out] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info)\n{\n\tmemptr value;\n\tchar save_char;\n\tchar *hash_pos = NULL;\n\tchar *col_pos1, *col_pos2, *serv_type;\n\tint ret_code;\n\n\t/* find SOAPACTION header */\n\tif (SOAPMETHOD_POST == request->method) {\n\t\tif (!httpmsg_find_hdr(request, HDR_SOAPACTION, &value))\n\t\t\treturn SREQ_HDR_NOT_FOUND;\n\t} else {\n\t\tret_code = get_mpost_acton_hdrval(request, &value);\n\t\tif (ret_code != UPNP_E_SUCCESS) {\n\t\t\treturn ret_code;\n\t\t}\n\t}\n\n\t/* error by default */\n\tret_code = SREQ_BAD_HDR_FORMAT;\n\t/* get action name*/\n\tsave_char = value.buf[value.length];\n\tvalue.buf[value.length] = '\\0';\n\thash_pos = strchr(value.buf, '#');\n\tif (NULL == hash_pos) {\n\t\tgoto error_handler;\n\t}\n\t*hash_pos = '\\0';\n\tif (matchstr(hash_pos+1,\n\t\t\tvalue.length - (size_t)(hash_pos+1 - value.buf),\n\t\t\t\"%s\", &soap_info->action_name) != PARSE_OK) {\n\t\tgoto error_handler;\n\t}\n\n\t/* check service type */\n\tif (value.buf[0] != '\\\"') {\n\t\tgoto error_handler;\n\t}\n\tserv_type = &value.buf[1];\n\tcol_pos1 = strrchr(serv_type, ':');\n\tif (NULL == col_pos1) {\n\t\tgoto error_handler;\n\t}\n\tcol_pos2 = strrchr(soap_info->service_type, ':');\n\t/* XXX: this should be checked when service list is generated */\n\tassert(col_pos2 != NULL);\n\tif (col_pos2-soap_info->service_type == col_pos1-serv_type &&\n\t\tstrncmp(soap_info->service_type, serv_type, col_pos1-serv_type) == 0) {\n\t\t/* for action invocation, update the version information */\n\t\tnamecopy(soap_info->service_type, serv_type);\n\t} else if (strcmp(serv_type, QUERY_STATE_VAR_URN) == 0 &&\n\t\t\tmemptr_cmp(&soap_info->action_name, \"QueryStateVariable\") == 0) {\n\t\t/* query variable */\n\t\tsoap_info->action_name.buf = NULL;\n\t\tsoap_info->action_name.length = 0;\n\t} else {\n\t\tgoto error_handler;\n\t}\n\tret_code = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (hash_pos != NULL) {\n\t\t*hash_pos = '#';\n\t}\n\tvalue.buf[value.length] = save_char;\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_xml_content_type",
          "args": [
            "request"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "has_xml_content_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/parsetools.c",
          "lines": "48-64",
          "snippet": "int has_xml_content_type(http_message_t *hmsg)\n{\n\tmemptr hdr_value;\n\n\tassert(hmsg);\n\n\t/* find 'content-type' header which must have text/xml */\n\tif (httpmsg_find_hdr(hmsg, HDR_CONTENT_TYPE, &hdr_value)) {\n\t\tswitch (matchstr(hdr_value.buf, hdr_value.length, \"%itext%w/%wxml\" )) {\n\t\tcase PARSE_OK:\n\t\t\treturn TRUE;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn FALSE;\n}",
          "includes": [
            "#include \"parsetools.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnputil.h\"",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"parsetools.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"membuffer.h\"\n#include \"upnputil.h\"\n#include <assert.h>\n#include \"config.h\"\n\nint has_xml_content_type(http_message_t *hmsg)\n{\n\tmemptr hdr_value;\n\n\tassert(hmsg);\n\n\t/* find 'content-type' header which must have text/xml */\n\tif (httpmsg_find_hdr(hmsg, HDR_CONTENT_TYPE, &hdr_value)) {\n\t\tswitch (matchstr(hdr_value.buf, hdr_value.length, \"%itext%w/%wxml\" )) {\n\t\tcase PARSE_OK:\n\t\t\treturn TRUE;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dev_service",
          "args": [
            "request",
            "info->foreign_sockaddr.ss_family",
            "soap_info"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "get_dev_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "442-485",
          "snippet": "static int get_dev_service(\n\t\t/*! [in] HTTP request. */\n\t\thttp_message_t *request,\n\t\t/*! [in] Address family: AF_INET or AF_INET6. */\n\t\tint AddressFamily,\n\t\t/*! [out] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info)\n{\n\tstruct Handle_Info *device_info;\n\tint device_hnd;\n\tservice_info *serv_info;\n\tchar save_char;\n\t/* error by default */\n\tint ret_code = -1;\n\tconst char *control_url;\n\n\t/* null-terminate pathquery of url */\n\tcontrol_url = request->uri.pathquery.buff;\n\tsave_char = control_url[request->uri.pathquery.size];\n\t((char *)control_url)[request->uri.pathquery.size] = '\\0';\n\n\tHandleReadLock();\n\n\tif (GetDeviceHandleInfo(AddressFamily, &device_hnd,\n\t\t\t\t&device_info) != HND_DEVICE)\n\t\tgoto error_handler;\n\tserv_info = FindServiceControlURLPath(\n\t\t&device_info->ServiceTable, control_url);\n\tif (!serv_info)\n\t\tgoto error_handler;\n\n\tnamecopy(soap_info->dev_udn, serv_info->UDN);\n\tnamecopy(soap_info->service_type, serv_info->serviceType);\n\tnamecopy(soap_info->service_id, serv_info->serviceId);\n\tsoap_info->callback = device_info->Callback;\n\tsoap_info->cookie = device_info->Cookie;\n\tret_code = 0;\n\n error_handler:\n\t/* restore */\n\t((char *)control_url)[request->uri.pathquery.size] = save_char;\n\tHandleUnlock();\n\treturn ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\nstatic int get_dev_service(\n\t\t/*! [in] HTTP request. */\n\t\thttp_message_t *request,\n\t\t/*! [in] Address family: AF_INET or AF_INET6. */\n\t\tint AddressFamily,\n\t\t/*! [out] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info)\n{\n\tstruct Handle_Info *device_info;\n\tint device_hnd;\n\tservice_info *serv_info;\n\tchar save_char;\n\t/* error by default */\n\tint ret_code = -1;\n\tconst char *control_url;\n\n\t/* null-terminate pathquery of url */\n\tcontrol_url = request->uri.pathquery.buff;\n\tsave_char = control_url[request->uri.pathquery.size];\n\t((char *)control_url)[request->uri.pathquery.size] = '\\0';\n\n\tHandleReadLock();\n\n\tif (GetDeviceHandleInfo(AddressFamily, &device_hnd,\n\t\t\t\t&device_info) != HND_DEVICE)\n\t\tgoto error_handler;\n\tserv_info = FindServiceControlURLPath(\n\t\t&device_info->ServiceTable, control_url);\n\tif (!serv_info)\n\t\tgoto error_handler;\n\n\tnamecopy(soap_info->dev_udn, serv_info->UDN);\n\tnamecopy(soap_info->service_type, serv_info->serviceType);\n\tnamecopy(soap_info->service_id, serv_info->serviceId);\n\tsoap_info->callback = device_info->Callback;\n\tsoap_info->cookie = device_info->Cookie;\n\tret_code = 0;\n\n error_handler:\n\t/* restore */\n\t((char *)control_url)[request->uri.pathquery.size] = save_char;\n\tHandleUnlock();\n\treturn ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(soap_devserv_t)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SREQ_NOT_EXTENDED\t -3\n\nvoid soap_device_callback(\n\t/*! [in] Parsed request received by the device. */\n\thttp_parser_t *parser,\n\t/*! [in] HTTP request. */\n\thttp_message_t *request,\n\t/*! [in,out] Socket info. */\n\tSOCKINFO *info)\n{\n\tint err_code;\n\tIXML_Document *xml_doc = NULL;\n\tsoap_devserv_t *soap_info = NULL;\n\tIXML_Node *req_node = NULL;\n\n\t/* get device/service identified by the request-URI */\n\tsoap_info = malloc(sizeof(soap_devserv_t));\n\tif (NULL == soap_info) {\n\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\tgoto error_handler;\n\t}\n\tif (get_dev_service(request,\n\t\t\tinfo->foreign_sockaddr.ss_family, soap_info) < 0) {\n\t\terr_code = HTTP_NOT_FOUND;\n\t\tgoto error_handler;\n\t}\n\t/* validate: content-type == text/xml */\n\tif (!has_xml_content_type(request)) {\n\t\terr_code = HTTP_UNSUPPORTED_MEDIA_TYPE;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAPACTION HTTP header */\n\terr_code = check_soapaction_hdr(request, soap_info);\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\tswitch (err_code) {\n\t\tcase SREQ_NOT_EXTENDED:\n\t\t\terr_code = HTTP_NOT_EXTENDED;\n\t\t\tbreak;\n\t\tcase UPNP_E_OUTOF_MEMORY:\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\t\tbreak;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* parse XML */\n\terr_code = ixmlParseBufferEx(request->entity.buf, &xml_doc);\n\tif (err_code != IXML_SUCCESS) {\n\t\tif (IXML_INSUFFICIENT_MEMORY == err_code)\n\t\t\terr_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\telse\n\t\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* check SOAP body */\n\tif (check_soap_request(soap_info, xml_doc, &req_node) < 0)\n\t{\n\t\terr_code = HTTP_BAD_REQUEST;\n\t\tgoto error_handler;\n\t}\n\t/* process SOAP request */\n\tif (NULL == soap_info->action_name.buf)\n\t\t/* query var */\n\t\thandle_query_variable(info, request, soap_info, req_node);\n\telse\n\t\t/* invoke action */\n\t\thandle_invoke_action(info, request, soap_info, req_node);\n\n\terr_code = HTTP_OK;\n\nerror_handler:\n\tixmlDocument_free(xml_doc);\n\tfree(soap_info);\n\tif (err_code != HTTP_OK) {\n\t\thttp_SendStatusResponse(info, err_code, request->major_version,\n\t\t\t\trequest->minor_version);\n\t}\n\treturn;\n\tparser = parser;\n}"
  },
  {
    "function_name": "check_soap_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
    "lines": "612-693",
    "snippet": "static int check_soap_request(\n\t\t/*! [in] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info,\n\t\t/*! [in] Document containing the SOAP action request. */\n\t\tIN IXML_Document *xml_doc,\n\t\t/*! [out] Node containing the SOAP action request/variable name. */\n\t\tIXML_Node **req_node)\n{\n\tIXML_Node *envp_node = NULL;\n\tIXML_Node *body_node = NULL;\n\tIXML_Node *action_node = NULL;\n\tconst DOMString local_name = NULL;\n\tconst DOMString ns_uri = NULL;\n\tint ret_val = -1;\n\n\t/* Got the Envelop node here */\n\tenvp_node = ixmlNode_getFirstChild((IXML_Node *) xml_doc);\n\tif (NULL == envp_node) {\n\t\tgoto error_handler;\n\t}\n\tns_uri = ixmlNode_getNamespaceURI(envp_node);\n\tif (NULL == ns_uri || strcmp(ns_uri, SOAP_URN) != 0) {\n\t\tgoto error_handler;\n\t}\n\t/* Got Body here */\n\tbody_node = ixmlNode_getFirstChild(envp_node);\n\tif (NULL == body_node) {\n\t\tgoto error_handler;\n\t}\n\tlocal_name = ixmlNode_getLocalName(body_node);\n\tif (NULL == local_name || strcmp(local_name, SOAP_BODY) != 0) {\n\t\tgoto error_handler;\n\t}\n\t/* Got action node here */\n\taction_node = ixmlNode_getFirstChild(body_node);\n\tif (NULL == action_node) {\n\t\tgoto error_handler;\n\t}\n\t/* check local name and namespace of action node */\n\tns_uri = ixmlNode_getNamespaceURI(action_node);\n\tif (NULL == ns_uri) {\n\t\tgoto error_handler;\n\t}\n\tlocal_name = ixmlNode_getLocalName(action_node);\n\tif (NULL == local_name) {\n\t\tgoto error_handler;\n\t}\n\tif (NULL == soap_info->action_name.buf) {\n\t\tIXML_Node *varname_node = NULL;\n\t\tIXML_Node *nametxt_node = NULL;\n\t\tif (strcmp(ns_uri, QUERY_STATE_VAR_URN) != 0 ||\n\t\t\tstrcmp(local_name, \"QueryStateVariable\") != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tvarname_node = ixmlNode_getFirstChild(action_node);\n\t\tif(NULL == varname_node) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tlocal_name = ixmlNode_getLocalName(varname_node);\n\t\tif (strcmp(local_name, \"varName\") != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tnametxt_node = ixmlNode_getFirstChild(varname_node);\n\t\tif (NULL == nametxt_node ||\n\t\t\tixmlNode_getNodeType(nametxt_node) != eTEXT_NODE) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t*req_node = nametxt_node;\n\t} else {\n\t\t/* check service type against SOAPACTION header */\n\t\tif (strcmp(soap_info->service_type, ns_uri) != 0 ||\n\t\t\tmemptr_cmp(&soap_info->action_name, local_name) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t*req_node = action_node;\n\t}\n\t/* success */\n\tret_val = 0;\n\nerror_handler:\n\treturn ret_val;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"soaplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ActionRequest.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memptr_cmp",
          "args": [
            "&soap_info->action_name",
            "local_name"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "memptr_cmp_nocase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "78-90",
          "snippet": "int memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "soap_info->service_type",
            "ns_uri"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNodeType",
          "args": [
            "nametxt_node"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "varname_node"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "local_name",
            "\"varName\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getLocalName",
          "args": [
            "varname_node"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "action_node"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "local_name",
            "\"QueryStateVariable\""
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ns_uri",
            "QUERY_STATE_VAR_URN"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getLocalName",
          "args": [
            "action_node"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNamespaceURI",
          "args": [
            "action_node"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "body_node"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "local_name",
            "SOAP_BODY"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getLocalName",
          "args": [
            "body_node"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "envp_node"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ns_uri",
            "SOAP_URN"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNamespaceURI",
          "args": [
            "envp_node"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getFirstChild",
          "args": [
            "(IXML_Node *) xml_doc"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\nstatic int check_soap_request(\n\t\t/*! [in] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info,\n\t\t/*! [in] Document containing the SOAP action request. */\n\t\tIN IXML_Document *xml_doc,\n\t\t/*! [out] Node containing the SOAP action request/variable name. */\n\t\tIXML_Node **req_node)\n{\n\tIXML_Node *envp_node = NULL;\n\tIXML_Node *body_node = NULL;\n\tIXML_Node *action_node = NULL;\n\tconst DOMString local_name = NULL;\n\tconst DOMString ns_uri = NULL;\n\tint ret_val = -1;\n\n\t/* Got the Envelop node here */\n\tenvp_node = ixmlNode_getFirstChild((IXML_Node *) xml_doc);\n\tif (NULL == envp_node) {\n\t\tgoto error_handler;\n\t}\n\tns_uri = ixmlNode_getNamespaceURI(envp_node);\n\tif (NULL == ns_uri || strcmp(ns_uri, SOAP_URN) != 0) {\n\t\tgoto error_handler;\n\t}\n\t/* Got Body here */\n\tbody_node = ixmlNode_getFirstChild(envp_node);\n\tif (NULL == body_node) {\n\t\tgoto error_handler;\n\t}\n\tlocal_name = ixmlNode_getLocalName(body_node);\n\tif (NULL == local_name || strcmp(local_name, SOAP_BODY) != 0) {\n\t\tgoto error_handler;\n\t}\n\t/* Got action node here */\n\taction_node = ixmlNode_getFirstChild(body_node);\n\tif (NULL == action_node) {\n\t\tgoto error_handler;\n\t}\n\t/* check local name and namespace of action node */\n\tns_uri = ixmlNode_getNamespaceURI(action_node);\n\tif (NULL == ns_uri) {\n\t\tgoto error_handler;\n\t}\n\tlocal_name = ixmlNode_getLocalName(action_node);\n\tif (NULL == local_name) {\n\t\tgoto error_handler;\n\t}\n\tif (NULL == soap_info->action_name.buf) {\n\t\tIXML_Node *varname_node = NULL;\n\t\tIXML_Node *nametxt_node = NULL;\n\t\tif (strcmp(ns_uri, QUERY_STATE_VAR_URN) != 0 ||\n\t\t\tstrcmp(local_name, \"QueryStateVariable\") != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tvarname_node = ixmlNode_getFirstChild(action_node);\n\t\tif(NULL == varname_node) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tlocal_name = ixmlNode_getLocalName(varname_node);\n\t\tif (strcmp(local_name, \"varName\") != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\tnametxt_node = ixmlNode_getFirstChild(varname_node);\n\t\tif (NULL == nametxt_node ||\n\t\t\tixmlNode_getNodeType(nametxt_node) != eTEXT_NODE) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t*req_node = nametxt_node;\n\t} else {\n\t\t/* check service type against SOAPACTION header */\n\t\tif (strcmp(soap_info->service_type, ns_uri) != 0 ||\n\t\t\tmemptr_cmp(&soap_info->action_name, local_name) != 0) {\n\t\t\tgoto error_handler;\n\t\t}\n\t\t*req_node = action_node;\n\t}\n\t/* success */\n\tret_val = 0;\n\nerror_handler:\n\treturn ret_val;\n}"
  },
  {
    "function_name": "check_soapaction_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
    "lines": "533-604",
    "snippet": "static int check_soapaction_hdr(\n\t\t/*! [in] HTTP request. */\n\t\thttp_message_t *request,\n\t\t/*! [in, out] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info)\n{\n\tmemptr value;\n\tchar save_char;\n\tchar *hash_pos = NULL;\n\tchar *col_pos1, *col_pos2, *serv_type;\n\tint ret_code;\n\n\t/* find SOAPACTION header */\n\tif (SOAPMETHOD_POST == request->method) {\n\t\tif (!httpmsg_find_hdr(request, HDR_SOAPACTION, &value))\n\t\t\treturn SREQ_HDR_NOT_FOUND;\n\t} else {\n\t\tret_code = get_mpost_acton_hdrval(request, &value);\n\t\tif (ret_code != UPNP_E_SUCCESS) {\n\t\t\treturn ret_code;\n\t\t}\n\t}\n\n\t/* error by default */\n\tret_code = SREQ_BAD_HDR_FORMAT;\n\t/* get action name*/\n\tsave_char = value.buf[value.length];\n\tvalue.buf[value.length] = '\\0';\n\thash_pos = strchr(value.buf, '#');\n\tif (NULL == hash_pos) {\n\t\tgoto error_handler;\n\t}\n\t*hash_pos = '\\0';\n\tif (matchstr(hash_pos+1,\n\t\t\tvalue.length - (size_t)(hash_pos+1 - value.buf),\n\t\t\t\"%s\", &soap_info->action_name) != PARSE_OK) {\n\t\tgoto error_handler;\n\t}\n\n\t/* check service type */\n\tif (value.buf[0] != '\\\"') {\n\t\tgoto error_handler;\n\t}\n\tserv_type = &value.buf[1];\n\tcol_pos1 = strrchr(serv_type, ':');\n\tif (NULL == col_pos1) {\n\t\tgoto error_handler;\n\t}\n\tcol_pos2 = strrchr(soap_info->service_type, ':');\n\t/* XXX: this should be checked when service list is generated */\n\tassert(col_pos2 != NULL);\n\tif (col_pos2-soap_info->service_type == col_pos1-serv_type &&\n\t\tstrncmp(soap_info->service_type, serv_type, col_pos1-serv_type) == 0) {\n\t\t/* for action invocation, update the version information */\n\t\tnamecopy(soap_info->service_type, serv_type);\n\t} else if (strcmp(serv_type, QUERY_STATE_VAR_URN) == 0 &&\n\t\t\tmemptr_cmp(&soap_info->action_name, \"QueryStateVariable\") == 0) {\n\t\t/* query variable */\n\t\tsoap_info->action_name.buf = NULL;\n\t\tsoap_info->action_name.length = 0;\n\t} else {\n\t\tgoto error_handler;\n\t}\n\tret_code = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (hash_pos != NULL) {\n\t\t*hash_pos = '#';\n\t}\n\tvalue.buf[value.length] = save_char;\n\treturn ret_code;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"soaplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ActionRequest.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SREQ_BAD_HDR_FORMAT\t -2",
      "#define SREQ_HDR_NOT_FOUND\t -1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memptr_cmp",
          "args": [
            "&soap_info->action_name",
            "\"QueryStateVariable\""
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "memptr_cmp_nocase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "78-90",
          "snippet": "int memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint memptr_cmp_nocase(memptr * m, const char *s)\n{\n\tint cmp;\n\n\tcmp = strncasecmp(m->buf, s, m->length);\n\tif (cmp == 0 && m->length < strlen(s)) {\n\t\t/* both strings equal for 'm->length' chars */\n\t\t/*  if m is shorter than s, then s is greater */\n\t\treturn -1;\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "serv_type",
            "QUERY_STATE_VAR_URN"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namecopy",
          "args": [
            "soap_info->service_type",
            "serv_type"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "namecopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/util.c",
          "lines": "53-58",
          "snippet": "void namecopy(char dest[NAME_SIZE], const char *src)\n{\n\tstrncpy(dest, src, NAME_SIZE - (size_t)1);\n\t/* null-terminate if len(src) >= NAME_SIZE. */\n\tdest[NAME_SIZE - 1] = '\\0';\n}",
          "includes": [
            "#include <string.h>",
            "#include \"upnputil.h\"",
            "#include \"upnp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"upnputil.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\nvoid namecopy(char dest[NAME_SIZE], const char *src)\n{\n\tstrncpy(dest, src, NAME_SIZE - (size_t)1);\n\t/* null-terminate if len(src) >= NAME_SIZE. */\n\tdest[NAME_SIZE - 1] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "soap_info->service_type",
            "serv_type",
            "col_pos1-serv_type"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "col_pos2 != NULL"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "soap_info->service_type",
            "':'"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "serv_type",
            "':'"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matchstr",
          "args": [
            "hash_pos+1",
            "value.length - (size_t)(hash_pos+1 - value.buf)",
            "\"%s\"",
            "&soap_info->action_name"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "matchstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1168-1203",
          "snippet": "parse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "value.buf",
            "'#'"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mpost_acton_hdrval",
          "args": [
            "request",
            "&value"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "get_mpost_acton_hdrval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "492-525",
          "snippet": "static int get_mpost_acton_hdrval(\n\t\t/*! [in] HTTP request. */\n\t\thttp_message_t *request,\n\t\t/*! [out] Buffer to get the header value */\n\t\tmemptr *val)\n{\n\thttp_header_t *hdr;\n\tmemptr ns_value, dummy_quote, value;\n\tmembuffer soap_action_name;\n\n\tassert(HTTPMETHOD_MPOST == request->method);\n\thdr = httpmsg_find_hdr(request, HDR_MAN, &value);\n\tif (NULL == hdr)\n\t\treturn SREQ_NOT_EXTENDED;\n\tif (matchstr(value.buf, value.length, \"%q%i ; ns = %s\",\n\t\t     &dummy_quote, &ns_value) != PARSE_OK)\n\t\treturn SREQ_NOT_EXTENDED;\n\t/* create soapaction name header */\n\tmembuffer_init(&soap_action_name);\n\tif (membuffer_assign(&soap_action_name,\n\t\tns_value.buf, ns_value.length) == UPNP_E_OUTOF_MEMORY ||\n\t    membuffer_append_str(&soap_action_name,\n\t\t\"-SOAPACTION\") == UPNP_E_OUTOF_MEMORY) {\n\t\tmembuffer_destroy(&soap_action_name);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thdr = httpmsg_find_hdr_str(request, soap_action_name.buf);\n\tmembuffer_destroy(&soap_action_name);\n\tif (NULL == hdr)\n\t\treturn SREQ_HDR_NOT_FOUND;\n\tval->buf = hdr->value.buf;\n\tval->length = hdr->value.length;\n\treturn UPNP_E_SUCCESS;\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SREQ_NOT_EXTENDED\t -3",
            "#define SREQ_HDR_NOT_FOUND\t -1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SREQ_NOT_EXTENDED\t -3\n#define SREQ_HDR_NOT_FOUND\t -1\n\nstatic int get_mpost_acton_hdrval(\n\t\t/*! [in] HTTP request. */\n\t\thttp_message_t *request,\n\t\t/*! [out] Buffer to get the header value */\n\t\tmemptr *val)\n{\n\thttp_header_t *hdr;\n\tmemptr ns_value, dummy_quote, value;\n\tmembuffer soap_action_name;\n\n\tassert(HTTPMETHOD_MPOST == request->method);\n\thdr = httpmsg_find_hdr(request, HDR_MAN, &value);\n\tif (NULL == hdr)\n\t\treturn SREQ_NOT_EXTENDED;\n\tif (matchstr(value.buf, value.length, \"%q%i ; ns = %s\",\n\t\t     &dummy_quote, &ns_value) != PARSE_OK)\n\t\treturn SREQ_NOT_EXTENDED;\n\t/* create soapaction name header */\n\tmembuffer_init(&soap_action_name);\n\tif (membuffer_assign(&soap_action_name,\n\t\tns_value.buf, ns_value.length) == UPNP_E_OUTOF_MEMORY ||\n\t    membuffer_append_str(&soap_action_name,\n\t\t\"-SOAPACTION\") == UPNP_E_OUTOF_MEMORY) {\n\t\tmembuffer_destroy(&soap_action_name);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thdr = httpmsg_find_hdr_str(request, soap_action_name.buf);\n\tmembuffer_destroy(&soap_action_name);\n\tif (NULL == hdr)\n\t\treturn SREQ_HDR_NOT_FOUND;\n\tval->buf = hdr->value.buf;\n\tval->length = hdr->value.length;\n\treturn UPNP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "request",
            "HDR_SOAPACTION",
            "&value"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SREQ_BAD_HDR_FORMAT\t -2\n#define SREQ_HDR_NOT_FOUND\t -1\n\nstatic int check_soapaction_hdr(\n\t\t/*! [in] HTTP request. */\n\t\thttp_message_t *request,\n\t\t/*! [in, out] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info)\n{\n\tmemptr value;\n\tchar save_char;\n\tchar *hash_pos = NULL;\n\tchar *col_pos1, *col_pos2, *serv_type;\n\tint ret_code;\n\n\t/* find SOAPACTION header */\n\tif (SOAPMETHOD_POST == request->method) {\n\t\tif (!httpmsg_find_hdr(request, HDR_SOAPACTION, &value))\n\t\t\treturn SREQ_HDR_NOT_FOUND;\n\t} else {\n\t\tret_code = get_mpost_acton_hdrval(request, &value);\n\t\tif (ret_code != UPNP_E_SUCCESS) {\n\t\t\treturn ret_code;\n\t\t}\n\t}\n\n\t/* error by default */\n\tret_code = SREQ_BAD_HDR_FORMAT;\n\t/* get action name*/\n\tsave_char = value.buf[value.length];\n\tvalue.buf[value.length] = '\\0';\n\thash_pos = strchr(value.buf, '#');\n\tif (NULL == hash_pos) {\n\t\tgoto error_handler;\n\t}\n\t*hash_pos = '\\0';\n\tif (matchstr(hash_pos+1,\n\t\t\tvalue.length - (size_t)(hash_pos+1 - value.buf),\n\t\t\t\"%s\", &soap_info->action_name) != PARSE_OK) {\n\t\tgoto error_handler;\n\t}\n\n\t/* check service type */\n\tif (value.buf[0] != '\\\"') {\n\t\tgoto error_handler;\n\t}\n\tserv_type = &value.buf[1];\n\tcol_pos1 = strrchr(serv_type, ':');\n\tif (NULL == col_pos1) {\n\t\tgoto error_handler;\n\t}\n\tcol_pos2 = strrchr(soap_info->service_type, ':');\n\t/* XXX: this should be checked when service list is generated */\n\tassert(col_pos2 != NULL);\n\tif (col_pos2-soap_info->service_type == col_pos1-serv_type &&\n\t\tstrncmp(soap_info->service_type, serv_type, col_pos1-serv_type) == 0) {\n\t\t/* for action invocation, update the version information */\n\t\tnamecopy(soap_info->service_type, serv_type);\n\t} else if (strcmp(serv_type, QUERY_STATE_VAR_URN) == 0 &&\n\t\t\tmemptr_cmp(&soap_info->action_name, \"QueryStateVariable\") == 0) {\n\t\t/* query variable */\n\t\tsoap_info->action_name.buf = NULL;\n\t\tsoap_info->action_name.length = 0;\n\t} else {\n\t\tgoto error_handler;\n\t}\n\tret_code = UPNP_E_SUCCESS;\n\nerror_handler:\n\tif (hash_pos != NULL) {\n\t\t*hash_pos = '#';\n\t}\n\tvalue.buf[value.length] = save_char;\n\treturn ret_code;\n}"
  },
  {
    "function_name": "get_mpost_acton_hdrval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
    "lines": "492-525",
    "snippet": "static int get_mpost_acton_hdrval(\n\t\t/*! [in] HTTP request. */\n\t\thttp_message_t *request,\n\t\t/*! [out] Buffer to get the header value */\n\t\tmemptr *val)\n{\n\thttp_header_t *hdr;\n\tmemptr ns_value, dummy_quote, value;\n\tmembuffer soap_action_name;\n\n\tassert(HTTPMETHOD_MPOST == request->method);\n\thdr = httpmsg_find_hdr(request, HDR_MAN, &value);\n\tif (NULL == hdr)\n\t\treturn SREQ_NOT_EXTENDED;\n\tif (matchstr(value.buf, value.length, \"%q%i ; ns = %s\",\n\t\t     &dummy_quote, &ns_value) != PARSE_OK)\n\t\treturn SREQ_NOT_EXTENDED;\n\t/* create soapaction name header */\n\tmembuffer_init(&soap_action_name);\n\tif (membuffer_assign(&soap_action_name,\n\t\tns_value.buf, ns_value.length) == UPNP_E_OUTOF_MEMORY ||\n\t    membuffer_append_str(&soap_action_name,\n\t\t\"-SOAPACTION\") == UPNP_E_OUTOF_MEMORY) {\n\t\tmembuffer_destroy(&soap_action_name);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thdr = httpmsg_find_hdr_str(request, soap_action_name.buf);\n\tmembuffer_destroy(&soap_action_name);\n\tif (NULL == hdr)\n\t\treturn SREQ_HDR_NOT_FOUND;\n\tval->buf = hdr->value.buf;\n\tval->length = hdr->value.length;\n\treturn UPNP_E_SUCCESS;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"soaplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ActionRequest.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SREQ_NOT_EXTENDED\t -3",
      "#define SREQ_HDR_NOT_FOUND\t -1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&soap_action_name"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr_str",
          "args": [
            "request",
            "soap_action_name.buf"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "452-472",
          "snippet": "http_header_t *httpmsg_find_hdr_str(\n\tIN http_message_t *msg,\n\tIN const char *header_name)\n{\n    http_header_t *header;\n\n    ListNode *node;\n\n    node = ListHead( &msg->headers );\n    while( node != NULL ) {\n\n        header = ( http_header_t * ) node->item;\n\n        if( memptr_cmp_nocase( &header->name, header_name ) == 0 ) {\n            return header;\n        }\n\n        node = ListNext( &msg->headers, node );\n    }\n    return NULL;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr_str(\n\tIN http_message_t *msg,\n\tIN const char *header_name)\n{\n    http_header_t *header;\n\n    ListNode *node;\n\n    node = ListHead( &msg->headers );\n    while( node != NULL ) {\n\n        header = ( http_header_t * ) node->item;\n\n        if( memptr_cmp_nocase( &header->name, header_name ) == 0 ) {\n            return header;\n        }\n\n        node = ListNext( &msg->headers, node );\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_append_str",
          "args": [
            "&soap_action_name",
            "\"-SOAPACTION\""
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_append_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "207-210",
          "snippet": "int membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_append_str(membuffer *m, const char *c_str)\n{\n\treturn membuffer_insert(m, c_str, strlen(c_str), m->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_assign",
          "args": [
            "&soap_action_name",
            "ns_value.buf",
            "ns_value.length"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "170-193",
          "snippet": "int membuffer_assign(membuffer *m, const void *buf, size_t buf_len)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\t/* set value to null */\n\tif (buf == NULL) {\n\t\tmembuffer_destroy(m);\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, buf_len);\n\tif (return_code != 0)\n\t\treturn return_code;\n\t/* copy */\n\tif (buf_len) {\n\t\tmemcpy(m->buf, buf, buf_len);\n\t\tm->buf[buf_len] = 0;\t/* null-terminate */\n\t}\n\tm->length = buf_len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nint membuffer_assign(membuffer *m, const void *buf, size_t buf_len)\n{\n\tint return_code;\n\n\tassert(m != NULL);\n\n\t/* set value to null */\n\tif (buf == NULL) {\n\t\tmembuffer_destroy(m);\n\t\treturn 0;\n\t}\n\t/* alloc mem */\n\treturn_code = membuffer_set_size(m, buf_len);\n\tif (return_code != 0)\n\t\treturn return_code;\n\t/* copy */\n\tif (buf_len) {\n\t\tmemcpy(m->buf, buf, buf_len);\n\t\tm->buf[buf_len] = 0;\t/* null-terminate */\n\t}\n\tm->length = buf_len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&soap_action_name"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "matchstr",
          "args": [
            "value.buf",
            "value.length",
            "\"%q%i ; ns = %s\"",
            "&dummy_quote",
            "&ns_value"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "matchstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "1168-1203",
          "snippet": "parse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nparse_status_t\nmatchstr( IN char *str,\n          IN size_t slen,\n          IN const char *fmt,\n          ... )\n{\n    parse_status_t ret_code;\n    char save_char;\n    scanner_t scanner;\n    membuffer buf;\n    va_list arg_list;\n\n    /* null terminate str */\n    save_char = str[slen];\n    str[slen] = '\\0';\n\n    membuffer_init( &buf );\n\n    /* under no circumstances should this buffer be modifed because its memory */\n    /*  might have not come from malloc() */\n    membuffer_attach( &buf, str, slen );\n\n    scanner_init( &scanner, &buf );\n    scanner.entire_msg_loaded = TRUE;\n\n    va_start( arg_list, fmt );\n    ret_code = vfmatch( &scanner, fmt, arg_list );\n    va_end( arg_list );\n\n    /* restore str */\n    str[slen] = save_char;\n\n    /* don't destroy buf */\n\n    return ret_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "httpmsg_find_hdr",
          "args": [
            "request",
            "HDR_MAN",
            "&value"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "httpmsg_find_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpparser.c",
          "lines": "489-510",
          "snippet": "http_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include <assert.h>",
            "#include \"upnpdebug.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"httpparser.h\"",
            "#include \"strintmap.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <ctype.h>\n#include <assert.h>\n#include \"upnpdebug.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"httpparser.h\"\n#include \"strintmap.h\"\n#include \"config.h\"\n\nhttp_header_t *httpmsg_find_hdr(\n\tIN http_message_t *msg,\n\tIN int header_name_id,\n\tOUT memptr *value)\n{\n    http_header_t header;       /* temp header for searching */\n    ListNode *node;\n    http_header_t *data;\n\n    header.name_id = header_name_id;\n    node = ListFind( &msg->headers, NULL, &header );\n    if( node == NULL ) {\n        return NULL;\n    }\n    data = ( http_header_t * ) node->item;\n    if( value != NULL ) {\n        value->buf = data->value.buf;\n        value->length = data->value.length;\n    }\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "HTTPMETHOD_MPOST == request->method"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SREQ_NOT_EXTENDED\t -3\n#define SREQ_HDR_NOT_FOUND\t -1\n\nstatic int get_mpost_acton_hdrval(\n\t\t/*! [in] HTTP request. */\n\t\thttp_message_t *request,\n\t\t/*! [out] Buffer to get the header value */\n\t\tmemptr *val)\n{\n\thttp_header_t *hdr;\n\tmemptr ns_value, dummy_quote, value;\n\tmembuffer soap_action_name;\n\n\tassert(HTTPMETHOD_MPOST == request->method);\n\thdr = httpmsg_find_hdr(request, HDR_MAN, &value);\n\tif (NULL == hdr)\n\t\treturn SREQ_NOT_EXTENDED;\n\tif (matchstr(value.buf, value.length, \"%q%i ; ns = %s\",\n\t\t     &dummy_quote, &ns_value) != PARSE_OK)\n\t\treturn SREQ_NOT_EXTENDED;\n\t/* create soapaction name header */\n\tmembuffer_init(&soap_action_name);\n\tif (membuffer_assign(&soap_action_name,\n\t\tns_value.buf, ns_value.length) == UPNP_E_OUTOF_MEMORY ||\n\t    membuffer_append_str(&soap_action_name,\n\t\t\"-SOAPACTION\") == UPNP_E_OUTOF_MEMORY) {\n\t\tmembuffer_destroy(&soap_action_name);\n\t\treturn UPNP_E_OUTOF_MEMORY;\n\t}\n\thdr = httpmsg_find_hdr_str(request, soap_action_name.buf);\n\tmembuffer_destroy(&soap_action_name);\n\tif (NULL == hdr)\n\t\treturn SREQ_HDR_NOT_FOUND;\n\tval->buf = hdr->value.buf;\n\tval->length = hdr->value.length;\n\treturn UPNP_E_SUCCESS;\n}"
  },
  {
    "function_name": "get_dev_service",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
    "lines": "442-485",
    "snippet": "static int get_dev_service(\n\t\t/*! [in] HTTP request. */\n\t\thttp_message_t *request,\n\t\t/*! [in] Address family: AF_INET or AF_INET6. */\n\t\tint AddressFamily,\n\t\t/*! [out] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info)\n{\n\tstruct Handle_Info *device_info;\n\tint device_hnd;\n\tservice_info *serv_info;\n\tchar save_char;\n\t/* error by default */\n\tint ret_code = -1;\n\tconst char *control_url;\n\n\t/* null-terminate pathquery of url */\n\tcontrol_url = request->uri.pathquery.buff;\n\tsave_char = control_url[request->uri.pathquery.size];\n\t((char *)control_url)[request->uri.pathquery.size] = '\\0';\n\n\tHandleReadLock();\n\n\tif (GetDeviceHandleInfo(AddressFamily, &device_hnd,\n\t\t\t\t&device_info) != HND_DEVICE)\n\t\tgoto error_handler;\n\tserv_info = FindServiceControlURLPath(\n\t\t&device_info->ServiceTable, control_url);\n\tif (!serv_info)\n\t\tgoto error_handler;\n\n\tnamecopy(soap_info->dev_udn, serv_info->UDN);\n\tnamecopy(soap_info->service_type, serv_info->serviceType);\n\tnamecopy(soap_info->service_id, serv_info->serviceId);\n\tsoap_info->callback = device_info->Callback;\n\tsoap_info->cookie = device_info->Cookie;\n\tret_code = 0;\n\n error_handler:\n\t/* restore */\n\t((char *)control_url)[request->uri.pathquery.size] = save_char;\n\tHandleUnlock();\n\treturn ret_code;\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"soaplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ActionRequest.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleUnlock",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namecopy",
          "args": [
            "soap_info->service_id",
            "serv_info->serviceId"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "namecopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/util.c",
          "lines": "53-58",
          "snippet": "void namecopy(char dest[NAME_SIZE], const char *src)\n{\n\tstrncpy(dest, src, NAME_SIZE - (size_t)1);\n\t/* null-terminate if len(src) >= NAME_SIZE. */\n\tdest[NAME_SIZE - 1] = '\\0';\n}",
          "includes": [
            "#include <string.h>",
            "#include \"upnputil.h\"",
            "#include \"upnp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"upnputil.h\"\n#include \"upnp.h\"\n#include \"config.h\"\n\nvoid namecopy(char dest[NAME_SIZE], const char *src)\n{\n\tstrncpy(dest, src, NAME_SIZE - (size_t)1);\n\t/* null-terminate if len(src) >= NAME_SIZE. */\n\tdest[NAME_SIZE - 1] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindServiceControlURLPath",
          "args": [
            "&device_info->ServiceTable",
            "control_url"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "FindServiceControlURLPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/service_table/service_table.c",
          "lines": "346-376",
          "snippet": "service_info *\nFindServiceControlURLPath( service_table * table,\n                           const char *controlURLPath )\n{\n    service_info *finger = NULL;\n    uri_type parsed_url;\n    uri_type parsed_url_in;\n\n    if( ( table )\n        &&\n        ( parse_uri\n          ( controlURLPath, strlen( controlURLPath ),\n            &parsed_url_in ) == HTTP_SUCCESS ) ) {\n        finger = table->serviceList;\n        while( finger ) {\n            if( finger->controlURL )\n                if( ( parse_uri\n                      ( finger->controlURL, strlen( finger->controlURL ),\n                        &parsed_url ) == HTTP_SUCCESS) ) {\n                    if( !token_cmp\n                        ( &parsed_url.pathquery,\n                          &parsed_url_in.pathquery ) )\n                        return finger;\n                }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n\n}",
          "includes": [
            "#include \"service_table.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"service_table.h\"\n#include \"config.h\"\n\nservice_info *\nFindServiceControlURLPath( service_table * table,\n                           const char *controlURLPath )\n{\n    service_info *finger = NULL;\n    uri_type parsed_url;\n    uri_type parsed_url_in;\n\n    if( ( table )\n        &&\n        ( parse_uri\n          ( controlURLPath, strlen( controlURLPath ),\n            &parsed_url_in ) == HTTP_SUCCESS ) ) {\n        finger = table->serviceList;\n        while( finger ) {\n            if( finger->controlURL )\n                if( ( parse_uri\n                      ( finger->controlURL, strlen( finger->controlURL ),\n                        &parsed_url ) == HTTP_SUCCESS) ) {\n                    if( !token_cmp\n                        ( &parsed_url.pathquery,\n                          &parsed_url_in.pathquery ) )\n                        return finger;\n                }\n            finger = finger->next;\n        }\n    }\n\n    return NULL;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDeviceHandleInfo",
          "args": [
            "AddressFamily",
            "&device_hnd",
            "&device_info"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "GetDeviceHandleInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpapi.c",
          "lines": "3849-3878",
          "snippet": "Upnp_Handle_Type GetDeviceHandleInfo(\n\tint AddressFamily,\n\tUpnpDevice_Handle *device_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\t/* Check if we've got a registered device of the address family specified. */\n\tif ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||\n\t    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {\n\t\t*device_handle_out = -1;\n\t\treturn HND_INVALID;\n\t}\n\n\t/* Find it. */\n\tfor (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {\n\t\tswitch (GetHandleInfo(*device_handle_out, HndInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tif ((*HndInfo)->DeviceAf == AddressFamily) {\n\t\t\t\treturn HND_DEVICE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif /* INCLUDE_DEVICE_APIS */\n\n\t*device_handle_out = -1;\n\treturn HND_INVALID;\n}",
          "includes": [
            "#include <openssl/ssl.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <assert.h>",
            "#include <sys/stat.h>",
            "#include \"webserver.h\"",
            "#include \"VirtualDir.h\"",
            "#include \"urlconfig.h\"",
            "#include \"service_table.h\"",
            "#include \"miniserver.h\"",
            "#include \"gena.h\"",
            "#include \"uuid.h\"",
            "#include \"UpnpUniStd.h\" /* for close() */",
            "#include \"UpnpStdInt.h\"",
            "#include \"ThreadPool.h\"",
            "#include \"sysdep.h\"",
            "#include \"soaplib.h\"",
            "#include \"ssdplib.h\"",
            "#include \"membuffer.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"upnpapi.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define NUM_HANDLE 200"
          ],
          "globals_used": [
            "int UpnpSdkDeviceRegisteredV4 = 0;",
            "int UpnpSdkDeviceregisteredV6 = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ssl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/ioctl.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include \"webserver.h\"\n#include \"VirtualDir.h\"\n#include \"urlconfig.h\"\n#include \"service_table.h\"\n#include \"miniserver.h\"\n#include \"gena.h\"\n#include \"uuid.h\"\n#include \"UpnpUniStd.h\" /* for close() */\n#include \"UpnpStdInt.h\"\n#include \"ThreadPool.h\"\n#include \"sysdep.h\"\n#include \"soaplib.h\"\n#include \"ssdplib.h\"\n#include \"membuffer.h\"\n#include \"httpreadwrite.h\"\n#include \"upnpapi.h\"\n#include \"config.h\"\n\n#define NUM_HANDLE 200\n\nint UpnpSdkDeviceRegisteredV4 = 0;\nint UpnpSdkDeviceregisteredV6 = 0;\n\nUpnp_Handle_Type GetDeviceHandleInfo(\n\tint AddressFamily,\n\tUpnpDevice_Handle *device_handle_out,\n\tstruct Handle_Info **HndInfo)\n{\n#ifdef INCLUDE_DEVICE_APIS\n\t/* Check if we've got a registered device of the address family specified. */\n\tif ((AddressFamily == AF_INET  && UpnpSdkDeviceRegisteredV4 == 0) ||\n\t    (AddressFamily == AF_INET6 && UpnpSdkDeviceregisteredV6 == 0)) {\n\t\t*device_handle_out = -1;\n\t\treturn HND_INVALID;\n\t}\n\n\t/* Find it. */\n\tfor (*device_handle_out=1; *device_handle_out < NUM_HANDLE; (*device_handle_out)++) {\n\t\tswitch (GetHandleInfo(*device_handle_out, HndInfo)) {\n\t\tcase HND_DEVICE:\n\t\t\tif ((*HndInfo)->DeviceAf == AddressFamily) {\n\t\t\t\treturn HND_DEVICE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n#endif /* INCLUDE_DEVICE_APIS */\n\n\t*device_handle_out = -1;\n\treturn HND_INVALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HandleReadLock",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\nstatic int get_dev_service(\n\t\t/*! [in] HTTP request. */\n\t\thttp_message_t *request,\n\t\t/*! [in] Address family: AF_INET or AF_INET6. */\n\t\tint AddressFamily,\n\t\t/*! [out] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info)\n{\n\tstruct Handle_Info *device_info;\n\tint device_hnd;\n\tservice_info *serv_info;\n\tchar save_char;\n\t/* error by default */\n\tint ret_code = -1;\n\tconst char *control_url;\n\n\t/* null-terminate pathquery of url */\n\tcontrol_url = request->uri.pathquery.buff;\n\tsave_char = control_url[request->uri.pathquery.size];\n\t((char *)control_url)[request->uri.pathquery.size] = '\\0';\n\n\tHandleReadLock();\n\n\tif (GetDeviceHandleInfo(AddressFamily, &device_hnd,\n\t\t\t\t&device_info) != HND_DEVICE)\n\t\tgoto error_handler;\n\tserv_info = FindServiceControlURLPath(\n\t\t&device_info->ServiceTable, control_url);\n\tif (!serv_info)\n\t\tgoto error_handler;\n\n\tnamecopy(soap_info->dev_udn, serv_info->UDN);\n\tnamecopy(soap_info->service_type, serv_info->serviceType);\n\tnamecopy(soap_info->service_id, serv_info->serviceId);\n\tsoap_info->callback = device_info->Callback;\n\tsoap_info->cookie = device_info->Cookie;\n\tret_code = 0;\n\n error_handler:\n\t/* restore */\n\t((char *)control_url)[request->uri.pathquery.size] = save_char;\n\tHandleUnlock();\n\treturn ret_code;\n}"
  },
  {
    "function_name": "handle_invoke_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
    "lines": "352-433",
    "snippet": "static void handle_invoke_action(\n\t\t/*! [in] Socket info. */\n\t\tSOCKINFO *info,\n\t\t/*! [in] HTTP Request. */\n\t\thttp_message_t *request,\n\t\t/*! [in] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info,\n\t\t/*! [in] Node containing the SOAP action request. */\n\t\tIXML_Node *req_node)\n{\n\tchar save_char;\n\tUpnpActionRequest *action = UpnpActionRequest_new();\n\tIXML_Document *actionRequestDoc = NULL;\n\tIXML_Document *actionResultDoc = NULL;\n\tint err_code;\n\tconst char *err_str;\n\tmemptr action_name;\n\tDOMString act_node = NULL;\n\n\t/* null-terminate */\n\taction_name = soap_info->action_name;\n\tsave_char = action_name.buf[action_name.length];\n\taction_name.buf[action_name.length] = '\\0';\n\t/* get action node */\n\tact_node = ixmlPrintNode(req_node);\n\tif (!act_node) {\n\t\terr_code = SOAP_MEMORY_OUT;\n\t\terr_str = Soap_Memory_out;\n\t\tgoto error_handler;\n\t}\n\terr_code = ixmlParseBufferEx(act_node, &actionRequestDoc);\n\tif (err_code != IXML_SUCCESS) {\n\t\tif (IXML_INSUFFICIENT_MEMORY == err_code) {\n\t\t\terr_code = SOAP_MEMORY_OUT;\n\t\t\terr_str = Soap_Memory_out;\n\t\t} else {\n\t\t\terr_code = SOAP_INVALID_ACTION;\n\t\t\terr_str = Soap_Invalid_Action;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\tUpnpActionRequest_set_ErrCode(action, UPNP_E_SUCCESS);\n\tUpnpActionRequest_strcpy_ActionName(action, action_name.buf);\n\tUpnpActionRequest_strcpy_DevUDN(action, soap_info->dev_udn);\n\tUpnpActionRequest_strcpy_ServiceID(action, soap_info->service_id);\n\tUpnpActionRequest_set_ActionRequest(action, actionRequestDoc);\n\tUpnpActionRequest_set_ActionResult(action, NULL);\n\tUpnpActionRequest_set_CtrlPtIPAddr(action, &info->foreign_sockaddr);\n\n\tUpnpPrintf(UPNP_INFO, SOAP, __FILE__, __LINE__, \"Calling Callback\\n\");\n\tsoap_info->callback(UPNP_CONTROL_ACTION_REQUEST, action, soap_info->cookie);\n\terr_code = UpnpActionRequest_get_ErrCode(action);\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\terr_str = UpnpActionRequest_get_ErrStr_cstr(action);\n\t\tif (strlen(err_str) <= 0) {\n\t\t\terr_code = SOAP_ACTION_FAILED;\n\t\t\terr_str = Soap_Action_Failed;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* validate, and handle action error */\n\tactionResultDoc = UpnpActionRequest_get_ActionResult(action);\n\tif (actionResultDoc == NULL) {\n\t\terr_code = SOAP_ACTION_FAILED;\n\t\terr_str = Soap_Action_Failed;\n\t\tgoto error_handler;\n\t}\n\t/* send response */\n\tsend_action_response(info, actionResultDoc, request);\n\terr_code = 0;\n\n\t/* error handling and cleanup */\nerror_handler:\n\tixmlDocument_free(actionResultDoc);\n\tixmlDocument_free(actionRequestDoc);\n\tixmlFreeDOMString(act_node);\n\t/* restore */\n\taction_name.buf[action_name.length] = save_char;\n\tif (err_code != 0)\n\t\tsend_error_response(info, err_code, err_str, request);\n\tUpnpActionRequest_delete(action);\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"soaplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ActionRequest.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SOAP_MEMORY_OUT\t\t603",
      "#define SOAP_ACTION_FAILED\t501",
      "#define SOAP_INVALID_ACTION 401"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpnpActionRequest_delete",
          "args": [
            "action"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_error_response",
          "args": [
            "info",
            "err_code",
            "err_str",
            "request"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "send_error_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "97-163",
          "snippet": "static void send_error_response(\n\t/*! [in] Socket info. */\n\tIN SOCKINFO *info,\n\t/*! [in] Error code. */\n\tIN int error_code,\n\t/*! [in] Error message. */\n\tIN const char *err_msg,\n\t/*! [in] HTTP request. */\n\tIN http_message_t *hmsg)\n{\n\toff_t content_length;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tint major;\n\tint minor;\n\tconst char *start_body =\n/*\t\t\"<?xml version=\\\"1.0\\\"?>\\n\" required?? */\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\"\n\t\t\"<s:Body>\\n\"\n\t\t\"<s:Fault>\\n\"\n\t\t\"<faultcode>s:Client</faultcode>\\n\"\n\t\t\"<faultstring>UPnPError</faultstring>\\n\"\n\t\t\"<detail>\\n\"\n\t\t\"<UPnPError xmlns=\\\"urn:schemas-upnp-org:control-1-0\\\">\\n\"\n\t\t\"<errorCode>\";\n\tconst char *mid_body =\n\t\t\"</errorCode>\\n\"\n\t\t\"<errorDescription>\";\n\tconst char *end_body =\n\t\t\"</errorDescription>\\n\"\n\t\t\"</UPnPError>\\n\"\n\t\t\"</detail>\\n\"\n\t\t\"</s:Fault>\\n\"\n\t\t\"</s:Body>\\n\"\n\t\t\"</s:Envelope>\\n\";\n\tchar err_code_str[30];\n\tmembuffer headers;\n\n\tmemset(err_code_str, 0, sizeof(err_code_str));\n\tsnprintf(err_code_str, sizeof(err_code_str), \"%d\", error_code);\n\t/* calc body len */\n\tcontent_length = (off_t) (strlen(start_body) + strlen(err_code_str) +\n\t\t\t\t  strlen(mid_body) + strlen(err_msg) +\n\t\t\t\t  strlen(end_body));\n\thttp_CalcResponseVersion(hmsg->major_version, hmsg->minor_version,\n\t\t\t\t &major, &minor);\n\t/* make headers */\n\tmembuffer_init(&headers);\n\tif (http_MakeMessage(&headers, major, minor,\n\t\t\t\"RNsDsSXcc\" \"sssss\",\n\t\t\t500,\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\",\n\t\t\tX_USER_AGENT,\n\t\t\tstart_body, err_code_str, mid_body, err_msg,\n\t\t\tend_body) != 0) {\n\t\tmembuffer_destroy(&headers);\n\t\t/* out of mem */\n\t\treturn;\n\t}\n\t/* send err msg */\n\thttp_SendMessage(info, &timeout_secs, \"b\",\n\t\theaders.buf, headers.length);\n\tmembuffer_destroy(&headers);\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_TIMEOUT UPNP_TIMEOUT",
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SOAP_TIMEOUT UPNP_TIMEOUT\n#define snprintf _snprintf\n\nstatic void send_error_response(\n\t/*! [in] Socket info. */\n\tIN SOCKINFO *info,\n\t/*! [in] Error code. */\n\tIN int error_code,\n\t/*! [in] Error message. */\n\tIN const char *err_msg,\n\t/*! [in] HTTP request. */\n\tIN http_message_t *hmsg)\n{\n\toff_t content_length;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tint major;\n\tint minor;\n\tconst char *start_body =\n/*\t\t\"<?xml version=\\\"1.0\\\"?>\\n\" required?? */\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\"\n\t\t\"<s:Body>\\n\"\n\t\t\"<s:Fault>\\n\"\n\t\t\"<faultcode>s:Client</faultcode>\\n\"\n\t\t\"<faultstring>UPnPError</faultstring>\\n\"\n\t\t\"<detail>\\n\"\n\t\t\"<UPnPError xmlns=\\\"urn:schemas-upnp-org:control-1-0\\\">\\n\"\n\t\t\"<errorCode>\";\n\tconst char *mid_body =\n\t\t\"</errorCode>\\n\"\n\t\t\"<errorDescription>\";\n\tconst char *end_body =\n\t\t\"</errorDescription>\\n\"\n\t\t\"</UPnPError>\\n\"\n\t\t\"</detail>\\n\"\n\t\t\"</s:Fault>\\n\"\n\t\t\"</s:Body>\\n\"\n\t\t\"</s:Envelope>\\n\";\n\tchar err_code_str[30];\n\tmembuffer headers;\n\n\tmemset(err_code_str, 0, sizeof(err_code_str));\n\tsnprintf(err_code_str, sizeof(err_code_str), \"%d\", error_code);\n\t/* calc body len */\n\tcontent_length = (off_t) (strlen(start_body) + strlen(err_code_str) +\n\t\t\t\t  strlen(mid_body) + strlen(err_msg) +\n\t\t\t\t  strlen(end_body));\n\thttp_CalcResponseVersion(hmsg->major_version, hmsg->minor_version,\n\t\t\t\t &major, &minor);\n\t/* make headers */\n\tmembuffer_init(&headers);\n\tif (http_MakeMessage(&headers, major, minor,\n\t\t\t\"RNsDsSXcc\" \"sssss\",\n\t\t\t500,\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\",\n\t\t\tX_USER_AGENT,\n\t\t\tstart_body, err_code_str, mid_body, err_msg,\n\t\t\tend_body) != 0) {\n\t\tmembuffer_destroy(&headers);\n\t\t/* out of mem */\n\t\treturn;\n\t}\n\t/* send err msg */\n\thttp_SendMessage(info, &timeout_secs, \"b\",\n\t\theaders.buf, headers.length);\n\tmembuffer_destroy(&headers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "act_node"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "actionRequestDoc"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlDocument_free",
          "args": [
            "actionResultDoc"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_action_response",
          "args": [
            "info",
            "actionResultDoc",
            "request"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "send_action_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "220-284",
          "snippet": "static UPNP_INLINE void send_action_response(\n\t/*! [in] Socket info. */\n\tSOCKINFO *info,\n\t/*! [in] The response document. */\n\tIXML_Document *action_resp,\n\t/*! [in] Action request document. */\n\thttp_message_t *request)\n{\n\tchar *xml_response = NULL;\n\tmembuffer headers;\n\tint major, minor;\n\tint err_code;\n\toff_t content_length;\n\tint ret_code;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tstatic const char *start_body =\n\t\t/*\"<?xml version=\\\"1.0\\\"?>\" required?? */\n\t\t\"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.\"\n\t\t\"org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.\"\n\t\t\"org/soap/encoding/\\\"><s:Body>\\n\";\n\tstatic const char *end_body = \"</s:Body> </s:Envelope>\";\n\n\t/* init */\n\thttp_CalcResponseVersion(request->major_version, request->minor_version,\n\t\t&major, &minor);\n\tmembuffer_init(&headers);\n\terr_code = UPNP_E_OUTOF_MEMORY;\t/* one error only */\n\t/* get xml */\n\txml_response = ixmlPrintNode((IXML_Node *) action_resp);\n\tif (!xml_response)\n\t\tgoto error_handler;\n\tcontent_length = (off_t)(strlen(start_body) + strlen(xml_response) +\n\t\tstrlen(end_body));\n\t/* make headers */\n\tif (http_MakeMessage(&headers, major, minor,\n\t\t\t\"RNsDsSXcc\",\n\t\t\tHTTP_OK,\t/* status code */\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\", X_USER_AGENT) != 0) {\n\t\tgoto error_handler;\n\t}\n\t/* send whole msg */\n\tret_code = http_SendMessage(\n\t\tinfo, &timeout_secs, \"bbbb\",\n\t\theaders.buf, headers.length,\n\t\tstart_body, strlen(start_body),\n\t\txml_response, strlen(xml_response),\n\t\tend_body, strlen(end_body));\n\tif (ret_code != 0) {\n\t\tUpnpPrintf(UPNP_INFO, SOAP, __FILE__, __LINE__,\n\t\t\t   \"Failed to send response: err code = %d\\n\",\n\t\t\t   ret_code);\n\t}\n\terr_code = 0;\n\nerror_handler:\n\tixmlFreeDOMString(xml_response);\n\tmembuffer_destroy(&headers);\n\tif (err_code != 0) {\n\t\t/* only one type of error to worry about - out of mem */\n\t\tsend_error_response(info, SOAP_ACTION_FAILED, \"Out of memory\",\n\t\t\trequest);\n\t}\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_ACTION_FAILED\t501",
            "#define SOAP_TIMEOUT UPNP_TIMEOUT"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SOAP_ACTION_FAILED\t501\n#define SOAP_TIMEOUT UPNP_TIMEOUT\n\nstatic UPNP_INLINE void send_action_response(\n\t/*! [in] Socket info. */\n\tSOCKINFO *info,\n\t/*! [in] The response document. */\n\tIXML_Document *action_resp,\n\t/*! [in] Action request document. */\n\thttp_message_t *request)\n{\n\tchar *xml_response = NULL;\n\tmembuffer headers;\n\tint major, minor;\n\tint err_code;\n\toff_t content_length;\n\tint ret_code;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tstatic const char *start_body =\n\t\t/*\"<?xml version=\\\"1.0\\\"?>\" required?? */\n\t\t\"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.\"\n\t\t\"org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.\"\n\t\t\"org/soap/encoding/\\\"><s:Body>\\n\";\n\tstatic const char *end_body = \"</s:Body> </s:Envelope>\";\n\n\t/* init */\n\thttp_CalcResponseVersion(request->major_version, request->minor_version,\n\t\t&major, &minor);\n\tmembuffer_init(&headers);\n\terr_code = UPNP_E_OUTOF_MEMORY;\t/* one error only */\n\t/* get xml */\n\txml_response = ixmlPrintNode((IXML_Node *) action_resp);\n\tif (!xml_response)\n\t\tgoto error_handler;\n\tcontent_length = (off_t)(strlen(start_body) + strlen(xml_response) +\n\t\tstrlen(end_body));\n\t/* make headers */\n\tif (http_MakeMessage(&headers, major, minor,\n\t\t\t\"RNsDsSXcc\",\n\t\t\tHTTP_OK,\t/* status code */\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\", X_USER_AGENT) != 0) {\n\t\tgoto error_handler;\n\t}\n\t/* send whole msg */\n\tret_code = http_SendMessage(\n\t\tinfo, &timeout_secs, \"bbbb\",\n\t\theaders.buf, headers.length,\n\t\tstart_body, strlen(start_body),\n\t\txml_response, strlen(xml_response),\n\t\tend_body, strlen(end_body));\n\tif (ret_code != 0) {\n\t\tUpnpPrintf(UPNP_INFO, SOAP, __FILE__, __LINE__,\n\t\t\t   \"Failed to send response: err code = %d\\n\",\n\t\t\t   ret_code);\n\t}\n\terr_code = 0;\n\nerror_handler:\n\tixmlFreeDOMString(xml_response);\n\tmembuffer_destroy(&headers);\n\tif (err_code != 0) {\n\t\t/* only one type of error to worry about - out of mem */\n\t\tsend_error_response(info, SOAP_ACTION_FAILED, \"Out of memory\",\n\t\t\trequest);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpActionRequest_get_ActionResult",
          "args": [
            "action"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "err_str"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionRequest_get_ErrStr_cstr",
          "args": [
            "action"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionRequest_get_ErrCode",
          "args": [
            "action"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "soap_info->callback",
          "args": [
            "UPNP_CONTROL_ACTION_REQUEST",
            "action",
            "soap_info->cookie"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "SOAP",
            "__FILE__",
            "__LINE__",
            "\"Calling Callback\\n\""
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpActionRequest_set_CtrlPtIPAddr",
          "args": [
            "action",
            "&info->foreign_sockaddr"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionRequest_set_ActionResult",
          "args": [
            "action",
            "NULL"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionRequest_set_ActionRequest",
          "args": [
            "action",
            "actionRequestDoc"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionRequest_strcpy_ServiceID",
          "args": [
            "action",
            "soap_info->service_id"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionRequest_strcpy_DevUDN",
          "args": [
            "action",
            "soap_info->dev_udn"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionRequest_strcpy_ActionName",
          "args": [
            "action",
            "action_name.buf"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionRequest_set_ErrCode",
          "args": [
            "action",
            "UPNP_E_SUCCESS"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlParseBufferEx",
          "args": [
            "act_node",
            "&actionRequestDoc"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "req_node"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpActionRequest_new",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SOAP_MEMORY_OUT\t\t603\n#define SOAP_ACTION_FAILED\t501\n#define SOAP_INVALID_ACTION 401\n\nstatic void handle_invoke_action(\n\t\t/*! [in] Socket info. */\n\t\tSOCKINFO *info,\n\t\t/*! [in] HTTP Request. */\n\t\thttp_message_t *request,\n\t\t/*! [in] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info,\n\t\t/*! [in] Node containing the SOAP action request. */\n\t\tIXML_Node *req_node)\n{\n\tchar save_char;\n\tUpnpActionRequest *action = UpnpActionRequest_new();\n\tIXML_Document *actionRequestDoc = NULL;\n\tIXML_Document *actionResultDoc = NULL;\n\tint err_code;\n\tconst char *err_str;\n\tmemptr action_name;\n\tDOMString act_node = NULL;\n\n\t/* null-terminate */\n\taction_name = soap_info->action_name;\n\tsave_char = action_name.buf[action_name.length];\n\taction_name.buf[action_name.length] = '\\0';\n\t/* get action node */\n\tact_node = ixmlPrintNode(req_node);\n\tif (!act_node) {\n\t\terr_code = SOAP_MEMORY_OUT;\n\t\terr_str = Soap_Memory_out;\n\t\tgoto error_handler;\n\t}\n\terr_code = ixmlParseBufferEx(act_node, &actionRequestDoc);\n\tif (err_code != IXML_SUCCESS) {\n\t\tif (IXML_INSUFFICIENT_MEMORY == err_code) {\n\t\t\terr_code = SOAP_MEMORY_OUT;\n\t\t\terr_str = Soap_Memory_out;\n\t\t} else {\n\t\t\terr_code = SOAP_INVALID_ACTION;\n\t\t\terr_str = Soap_Invalid_Action;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\tUpnpActionRequest_set_ErrCode(action, UPNP_E_SUCCESS);\n\tUpnpActionRequest_strcpy_ActionName(action, action_name.buf);\n\tUpnpActionRequest_strcpy_DevUDN(action, soap_info->dev_udn);\n\tUpnpActionRequest_strcpy_ServiceID(action, soap_info->service_id);\n\tUpnpActionRequest_set_ActionRequest(action, actionRequestDoc);\n\tUpnpActionRequest_set_ActionResult(action, NULL);\n\tUpnpActionRequest_set_CtrlPtIPAddr(action, &info->foreign_sockaddr);\n\n\tUpnpPrintf(UPNP_INFO, SOAP, __FILE__, __LINE__, \"Calling Callback\\n\");\n\tsoap_info->callback(UPNP_CONTROL_ACTION_REQUEST, action, soap_info->cookie);\n\terr_code = UpnpActionRequest_get_ErrCode(action);\n\tif (err_code != UPNP_E_SUCCESS) {\n\t\terr_str = UpnpActionRequest_get_ErrStr_cstr(action);\n\t\tif (strlen(err_str) <= 0) {\n\t\t\terr_code = SOAP_ACTION_FAILED;\n\t\t\terr_str = Soap_Action_Failed;\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* validate, and handle action error */\n\tactionResultDoc = UpnpActionRequest_get_ActionResult(action);\n\tif (actionResultDoc == NULL) {\n\t\terr_code = SOAP_ACTION_FAILED;\n\t\terr_str = Soap_Action_Failed;\n\t\tgoto error_handler;\n\t}\n\t/* send response */\n\tsend_action_response(info, actionResultDoc, request);\n\terr_code = 0;\n\n\t/* error handling and cleanup */\nerror_handler:\n\tixmlDocument_free(actionResultDoc);\n\tixmlDocument_free(actionRequestDoc);\n\tixmlFreeDOMString(act_node);\n\t/* restore */\n\taction_name.buf[action_name.length] = save_char;\n\tif (err_code != 0)\n\t\tsend_error_response(info, err_code, err_str, request);\n\tUpnpActionRequest_delete(action);\n}"
  },
  {
    "function_name": "handle_query_variable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
    "lines": "291-347",
    "snippet": "static UPNP_INLINE void handle_query_variable(\n\t\t/*! [in] Socket info. */\n\t\tSOCKINFO *info,\n\t\t/*! [in] HTTP Request. */\n\t\thttp_message_t *request,\n\t\t/*! [in] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info,\n\t\t/*! [in] Node containing variable name. */\n\t\tIXML_Node *req_node)\n{\n\tUpnpStateVarRequest *variable = UpnpStateVarRequest_new();\n\tconst char *err_str;\n\tint err_code;\n\tconst DOMString var_name;\n\n\t/* set default error */\n\terr_code = SOAP_INVALID_VAR;\n\terr_str = Soap_Invalid_Var;\n\n\tif (variable == NULL) {\n\t\terr_code = SOAP_MEMORY_OUT;\n\t\terr_str = Soap_Memory_out;\n\t\tgoto error_handler;\n\t}\n\n\tUpnpStateVarRequest_set_ErrCode(variable, UPNP_E_SUCCESS);\n\tUpnpStateVarRequest_strcpy_DevUDN(variable, soap_info->dev_udn);\n\tUpnpStateVarRequest_strcpy_ServiceID(variable, soap_info->service_id);\n\tvar_name = ixmlNode_getNodeValue(req_node);\n\tUpnpStateVarRequest_strcpy_StateVarName(variable, var_name);\n\tUpnpStateVarRequest_set_CtrlPtIPAddr(variable, &info->foreign_sockaddr);\n\n\t/* send event */\n\tsoap_info->callback(UPNP_CONTROL_GET_VAR_REQUEST, variable,\n\t\t\tsoap_info->cookie);\n\tUpnpPrintf(UPNP_INFO, SOAP, __FILE__, __LINE__,\n\t\t\"Return from callback for var request\\n\");\n\t/* validate, and handle result */\n\tif (UpnpStateVarRequest_get_CurrentVal(variable) == NULL)\n\t\tgoto error_handler;\n\tif (UpnpStateVarRequest_get_ErrCode(variable) != UPNP_E_SUCCESS) {\n\t\tif (UpnpString_get_Length(UpnpStateVarRequest_get_ErrStr(variable)) > 0) {\n\t\t\terr_code = UpnpStateVarRequest_get_ErrCode(variable);\n\t\t\terr_str = UpnpStateVarRequest_get_ErrStr_cstr(variable);\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* send response */\n\tsend_var_query_response(info, UpnpStateVarRequest_get_CurrentVal(variable), request);\n\terr_code = 0;\n\n\t/* error handling and cleanup */\nerror_handler:\n\tUpnpStateVarRequest_delete(variable);\n\tif (err_code != 0)\n\t\tsend_error_response(info, err_code, err_str, request);\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"soaplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ActionRequest.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SOAP_MEMORY_OUT\t\t603",
      "#define SOAP_INVALID_VAR\t404"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_error_response",
          "args": [
            "info",
            "err_code",
            "err_str",
            "request"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "send_error_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "97-163",
          "snippet": "static void send_error_response(\n\t/*! [in] Socket info. */\n\tIN SOCKINFO *info,\n\t/*! [in] Error code. */\n\tIN int error_code,\n\t/*! [in] Error message. */\n\tIN const char *err_msg,\n\t/*! [in] HTTP request. */\n\tIN http_message_t *hmsg)\n{\n\toff_t content_length;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tint major;\n\tint minor;\n\tconst char *start_body =\n/*\t\t\"<?xml version=\\\"1.0\\\"?>\\n\" required?? */\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\"\n\t\t\"<s:Body>\\n\"\n\t\t\"<s:Fault>\\n\"\n\t\t\"<faultcode>s:Client</faultcode>\\n\"\n\t\t\"<faultstring>UPnPError</faultstring>\\n\"\n\t\t\"<detail>\\n\"\n\t\t\"<UPnPError xmlns=\\\"urn:schemas-upnp-org:control-1-0\\\">\\n\"\n\t\t\"<errorCode>\";\n\tconst char *mid_body =\n\t\t\"</errorCode>\\n\"\n\t\t\"<errorDescription>\";\n\tconst char *end_body =\n\t\t\"</errorDescription>\\n\"\n\t\t\"</UPnPError>\\n\"\n\t\t\"</detail>\\n\"\n\t\t\"</s:Fault>\\n\"\n\t\t\"</s:Body>\\n\"\n\t\t\"</s:Envelope>\\n\";\n\tchar err_code_str[30];\n\tmembuffer headers;\n\n\tmemset(err_code_str, 0, sizeof(err_code_str));\n\tsnprintf(err_code_str, sizeof(err_code_str), \"%d\", error_code);\n\t/* calc body len */\n\tcontent_length = (off_t) (strlen(start_body) + strlen(err_code_str) +\n\t\t\t\t  strlen(mid_body) + strlen(err_msg) +\n\t\t\t\t  strlen(end_body));\n\thttp_CalcResponseVersion(hmsg->major_version, hmsg->minor_version,\n\t\t\t\t &major, &minor);\n\t/* make headers */\n\tmembuffer_init(&headers);\n\tif (http_MakeMessage(&headers, major, minor,\n\t\t\t\"RNsDsSXcc\" \"sssss\",\n\t\t\t500,\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\",\n\t\t\tX_USER_AGENT,\n\t\t\tstart_body, err_code_str, mid_body, err_msg,\n\t\t\tend_body) != 0) {\n\t\tmembuffer_destroy(&headers);\n\t\t/* out of mem */\n\t\treturn;\n\t}\n\t/* send err msg */\n\thttp_SendMessage(info, &timeout_secs, \"b\",\n\t\theaders.buf, headers.length);\n\tmembuffer_destroy(&headers);\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_TIMEOUT UPNP_TIMEOUT",
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SOAP_TIMEOUT UPNP_TIMEOUT\n#define snprintf _snprintf\n\nstatic void send_error_response(\n\t/*! [in] Socket info. */\n\tIN SOCKINFO *info,\n\t/*! [in] Error code. */\n\tIN int error_code,\n\t/*! [in] Error message. */\n\tIN const char *err_msg,\n\t/*! [in] HTTP request. */\n\tIN http_message_t *hmsg)\n{\n\toff_t content_length;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tint major;\n\tint minor;\n\tconst char *start_body =\n/*\t\t\"<?xml version=\\\"1.0\\\"?>\\n\" required?? */\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\"\n\t\t\"<s:Body>\\n\"\n\t\t\"<s:Fault>\\n\"\n\t\t\"<faultcode>s:Client</faultcode>\\n\"\n\t\t\"<faultstring>UPnPError</faultstring>\\n\"\n\t\t\"<detail>\\n\"\n\t\t\"<UPnPError xmlns=\\\"urn:schemas-upnp-org:control-1-0\\\">\\n\"\n\t\t\"<errorCode>\";\n\tconst char *mid_body =\n\t\t\"</errorCode>\\n\"\n\t\t\"<errorDescription>\";\n\tconst char *end_body =\n\t\t\"</errorDescription>\\n\"\n\t\t\"</UPnPError>\\n\"\n\t\t\"</detail>\\n\"\n\t\t\"</s:Fault>\\n\"\n\t\t\"</s:Body>\\n\"\n\t\t\"</s:Envelope>\\n\";\n\tchar err_code_str[30];\n\tmembuffer headers;\n\n\tmemset(err_code_str, 0, sizeof(err_code_str));\n\tsnprintf(err_code_str, sizeof(err_code_str), \"%d\", error_code);\n\t/* calc body len */\n\tcontent_length = (off_t) (strlen(start_body) + strlen(err_code_str) +\n\t\t\t\t  strlen(mid_body) + strlen(err_msg) +\n\t\t\t\t  strlen(end_body));\n\thttp_CalcResponseVersion(hmsg->major_version, hmsg->minor_version,\n\t\t\t\t &major, &minor);\n\t/* make headers */\n\tmembuffer_init(&headers);\n\tif (http_MakeMessage(&headers, major, minor,\n\t\t\t\"RNsDsSXcc\" \"sssss\",\n\t\t\t500,\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\",\n\t\t\tX_USER_AGENT,\n\t\t\tstart_body, err_code_str, mid_body, err_msg,\n\t\t\tend_body) != 0) {\n\t\tmembuffer_destroy(&headers);\n\t\t/* out of mem */\n\t\treturn;\n\t}\n\t/* send err msg */\n\thttp_SendMessage(info, &timeout_secs, \"b\",\n\t\theaders.buf, headers.length);\n\tmembuffer_destroy(&headers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_delete",
          "args": [
            "variable"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_var_query_response",
          "args": [
            "info",
            "UpnpStateVarRequest_get_CurrentVal(variable)",
            "request"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "send_var_query_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "168-214",
          "snippet": "static UPNP_INLINE void send_var_query_response(\n\t/*! [in] Socket info. */\n\tSOCKINFO *info,\n\t/*! [in] Value of the state variable. */\n\tconst char *var_value,\n\t/*! [in] HTTP request. */\n\thttp_message_t *hmsg)\n{\n\toff_t content_length;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tint major;\n\tint minor;\n\tconst char *start_body =\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\"\n\t\t\"<s:Body>\\n\"\n\t\t\"<u:QueryStateVariableResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:control-1-0\\\">\\n\" \"<return>\";\n\tconst char *end_body =\n\t\t\"</return>\\n\"\n\t\t\"</u:QueryStateVariableResponse>\\n\" \"</s:Body>\\n\" \"</s:Envelope>\\n\";\n\tmembuffer response;\n\n\thttp_CalcResponseVersion(hmsg->major_version, hmsg->minor_version,\n\t\t\t\t &major, &minor);\n\tcontent_length = (off_t) (strlen(start_body) + strlen(var_value) +\n\t\t\t\t  strlen(end_body));\n\t/* make headers */\n\tmembuffer_init(&response);\n\tif (http_MakeMessage(&response, major, minor,\n\t\t\t\"RNsDsSXcc\" \"sss\",\n\t\t\tHTTP_OK,\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\",\n\t\t\tX_USER_AGENT,\n\t\t\tstart_body, var_value, end_body) != 0) {\n\t\tmembuffer_destroy(&response);\n\t\t/* out of mem */\n\t\treturn;\n\t}\n\t/* send msg */\n\thttp_SendMessage(info, &timeout_secs, \"b\",\n\t\tresponse.buf, response.length);\n\tmembuffer_destroy(&response);\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_TIMEOUT UPNP_TIMEOUT"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SOAP_TIMEOUT UPNP_TIMEOUT\n\nstatic UPNP_INLINE void send_var_query_response(\n\t/*! [in] Socket info. */\n\tSOCKINFO *info,\n\t/*! [in] Value of the state variable. */\n\tconst char *var_value,\n\t/*! [in] HTTP request. */\n\thttp_message_t *hmsg)\n{\n\toff_t content_length;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tint major;\n\tint minor;\n\tconst char *start_body =\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\"\n\t\t\"<s:Body>\\n\"\n\t\t\"<u:QueryStateVariableResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:control-1-0\\\">\\n\" \"<return>\";\n\tconst char *end_body =\n\t\t\"</return>\\n\"\n\t\t\"</u:QueryStateVariableResponse>\\n\" \"</s:Body>\\n\" \"</s:Envelope>\\n\";\n\tmembuffer response;\n\n\thttp_CalcResponseVersion(hmsg->major_version, hmsg->minor_version,\n\t\t\t\t &major, &minor);\n\tcontent_length = (off_t) (strlen(start_body) + strlen(var_value) +\n\t\t\t\t  strlen(end_body));\n\t/* make headers */\n\tmembuffer_init(&response);\n\tif (http_MakeMessage(&response, major, minor,\n\t\t\t\"RNsDsSXcc\" \"sss\",\n\t\t\tHTTP_OK,\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\",\n\t\t\tX_USER_AGENT,\n\t\t\tstart_body, var_value, end_body) != 0) {\n\t\tmembuffer_destroy(&response);\n\t\t/* out of mem */\n\t\treturn;\n\t}\n\t/* send msg */\n\thttp_SendMessage(info, &timeout_secs, \"b\",\n\t\tresponse.buf, response.length);\n\tmembuffer_destroy(&response);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_get_CurrentVal",
          "args": [
            "variable"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_get_ErrStr_cstr",
          "args": [
            "variable"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_get_ErrCode",
          "args": [
            "variable"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpString_get_Length",
          "args": [
            "UpnpStateVarRequest_get_ErrStr(variable)"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpString_get_Length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/UpnpString.c",
          "lines": "141-144",
          "snippet": "size_t UpnpString_get_Length(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_length;\n}",
          "includes": [
            "#include <string.h> /* for strlen(), strdup() */",
            "#include <stdlib.h> /* for calloc(), free() */",
            "#include \"UpnpString.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h> /* for strlen(), strdup() */\n#include <stdlib.h> /* for calloc(), free() */\n#include \"UpnpString.h\"\n#include \"config.h\"\n\nsize_t UpnpString_get_Length(const UpnpString *p)\n{\n\treturn ((struct SUpnpString *)p)->m_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_get_ErrStr",
          "args": [
            "variable"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_get_ErrCode",
          "args": [
            "variable"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_get_CurrentVal",
          "args": [
            "variable"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "SOAP",
            "__FILE__",
            "__LINE__",
            "\"Return from callback for var request\\n\""
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "soap_info->callback",
          "args": [
            "UPNP_CONTROL_GET_VAR_REQUEST",
            "variable",
            "soap_info->cookie"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_set_CtrlPtIPAddr",
          "args": [
            "variable",
            "&info->foreign_sockaddr"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_strcpy_StateVarName",
          "args": [
            "variable",
            "var_name"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlNode_getNodeValue",
          "args": [
            "req_node"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_strcpy_ServiceID",
          "args": [
            "variable",
            "soap_info->service_id"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_strcpy_DevUDN",
          "args": [
            "variable",
            "soap_info->dev_udn"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_set_ErrCode",
          "args": [
            "variable",
            "UPNP_E_SUCCESS"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpStateVarRequest_new",
          "args": [],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SOAP_MEMORY_OUT\t\t603\n#define SOAP_INVALID_VAR\t404\n\nstatic UPNP_INLINE void handle_query_variable(\n\t\t/*! [in] Socket info. */\n\t\tSOCKINFO *info,\n\t\t/*! [in] HTTP Request. */\n\t\thttp_message_t *request,\n\t\t/*! [in] SOAP device/service information. */\n\t\tsoap_devserv_t *soap_info,\n\t\t/*! [in] Node containing variable name. */\n\t\tIXML_Node *req_node)\n{\n\tUpnpStateVarRequest *variable = UpnpStateVarRequest_new();\n\tconst char *err_str;\n\tint err_code;\n\tconst DOMString var_name;\n\n\t/* set default error */\n\terr_code = SOAP_INVALID_VAR;\n\terr_str = Soap_Invalid_Var;\n\n\tif (variable == NULL) {\n\t\terr_code = SOAP_MEMORY_OUT;\n\t\terr_str = Soap_Memory_out;\n\t\tgoto error_handler;\n\t}\n\n\tUpnpStateVarRequest_set_ErrCode(variable, UPNP_E_SUCCESS);\n\tUpnpStateVarRequest_strcpy_DevUDN(variable, soap_info->dev_udn);\n\tUpnpStateVarRequest_strcpy_ServiceID(variable, soap_info->service_id);\n\tvar_name = ixmlNode_getNodeValue(req_node);\n\tUpnpStateVarRequest_strcpy_StateVarName(variable, var_name);\n\tUpnpStateVarRequest_set_CtrlPtIPAddr(variable, &info->foreign_sockaddr);\n\n\t/* send event */\n\tsoap_info->callback(UPNP_CONTROL_GET_VAR_REQUEST, variable,\n\t\t\tsoap_info->cookie);\n\tUpnpPrintf(UPNP_INFO, SOAP, __FILE__, __LINE__,\n\t\t\"Return from callback for var request\\n\");\n\t/* validate, and handle result */\n\tif (UpnpStateVarRequest_get_CurrentVal(variable) == NULL)\n\t\tgoto error_handler;\n\tif (UpnpStateVarRequest_get_ErrCode(variable) != UPNP_E_SUCCESS) {\n\t\tif (UpnpString_get_Length(UpnpStateVarRequest_get_ErrStr(variable)) > 0) {\n\t\t\terr_code = UpnpStateVarRequest_get_ErrCode(variable);\n\t\t\terr_str = UpnpStateVarRequest_get_ErrStr_cstr(variable);\n\t\t}\n\t\tgoto error_handler;\n\t}\n\t/* send response */\n\tsend_var_query_response(info, UpnpStateVarRequest_get_CurrentVal(variable), request);\n\terr_code = 0;\n\n\t/* error handling and cleanup */\nerror_handler:\n\tUpnpStateVarRequest_delete(variable);\n\tif (err_code != 0)\n\t\tsend_error_response(info, err_code, err_str, request);\n}"
  },
  {
    "function_name": "send_action_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
    "lines": "220-284",
    "snippet": "static UPNP_INLINE void send_action_response(\n\t/*! [in] Socket info. */\n\tSOCKINFO *info,\n\t/*! [in] The response document. */\n\tIXML_Document *action_resp,\n\t/*! [in] Action request document. */\n\thttp_message_t *request)\n{\n\tchar *xml_response = NULL;\n\tmembuffer headers;\n\tint major, minor;\n\tint err_code;\n\toff_t content_length;\n\tint ret_code;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tstatic const char *start_body =\n\t\t/*\"<?xml version=\\\"1.0\\\"?>\" required?? */\n\t\t\"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.\"\n\t\t\"org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.\"\n\t\t\"org/soap/encoding/\\\"><s:Body>\\n\";\n\tstatic const char *end_body = \"</s:Body> </s:Envelope>\";\n\n\t/* init */\n\thttp_CalcResponseVersion(request->major_version, request->minor_version,\n\t\t&major, &minor);\n\tmembuffer_init(&headers);\n\terr_code = UPNP_E_OUTOF_MEMORY;\t/* one error only */\n\t/* get xml */\n\txml_response = ixmlPrintNode((IXML_Node *) action_resp);\n\tif (!xml_response)\n\t\tgoto error_handler;\n\tcontent_length = (off_t)(strlen(start_body) + strlen(xml_response) +\n\t\tstrlen(end_body));\n\t/* make headers */\n\tif (http_MakeMessage(&headers, major, minor,\n\t\t\t\"RNsDsSXcc\",\n\t\t\tHTTP_OK,\t/* status code */\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\", X_USER_AGENT) != 0) {\n\t\tgoto error_handler;\n\t}\n\t/* send whole msg */\n\tret_code = http_SendMessage(\n\t\tinfo, &timeout_secs, \"bbbb\",\n\t\theaders.buf, headers.length,\n\t\tstart_body, strlen(start_body),\n\t\txml_response, strlen(xml_response),\n\t\tend_body, strlen(end_body));\n\tif (ret_code != 0) {\n\t\tUpnpPrintf(UPNP_INFO, SOAP, __FILE__, __LINE__,\n\t\t\t   \"Failed to send response: err code = %d\\n\",\n\t\t\t   ret_code);\n\t}\n\terr_code = 0;\n\nerror_handler:\n\tixmlFreeDOMString(xml_response);\n\tmembuffer_destroy(&headers);\n\tif (err_code != 0) {\n\t\t/* only one type of error to worry about - out of mem */\n\t\tsend_error_response(info, SOAP_ACTION_FAILED, \"Out of memory\",\n\t\t\trequest);\n\t}\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"soaplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ActionRequest.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SOAP_ACTION_FAILED\t501",
      "#define SOAP_TIMEOUT UPNP_TIMEOUT"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_error_response",
          "args": [
            "info",
            "SOAP_ACTION_FAILED",
            "\"Out of memory\"",
            "request"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "send_error_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
          "lines": "97-163",
          "snippet": "static void send_error_response(\n\t/*! [in] Socket info. */\n\tIN SOCKINFO *info,\n\t/*! [in] Error code. */\n\tIN int error_code,\n\t/*! [in] Error message. */\n\tIN const char *err_msg,\n\t/*! [in] HTTP request. */\n\tIN http_message_t *hmsg)\n{\n\toff_t content_length;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tint major;\n\tint minor;\n\tconst char *start_body =\n/*\t\t\"<?xml version=\\\"1.0\\\"?>\\n\" required?? */\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\"\n\t\t\"<s:Body>\\n\"\n\t\t\"<s:Fault>\\n\"\n\t\t\"<faultcode>s:Client</faultcode>\\n\"\n\t\t\"<faultstring>UPnPError</faultstring>\\n\"\n\t\t\"<detail>\\n\"\n\t\t\"<UPnPError xmlns=\\\"urn:schemas-upnp-org:control-1-0\\\">\\n\"\n\t\t\"<errorCode>\";\n\tconst char *mid_body =\n\t\t\"</errorCode>\\n\"\n\t\t\"<errorDescription>\";\n\tconst char *end_body =\n\t\t\"</errorDescription>\\n\"\n\t\t\"</UPnPError>\\n\"\n\t\t\"</detail>\\n\"\n\t\t\"</s:Fault>\\n\"\n\t\t\"</s:Body>\\n\"\n\t\t\"</s:Envelope>\\n\";\n\tchar err_code_str[30];\n\tmembuffer headers;\n\n\tmemset(err_code_str, 0, sizeof(err_code_str));\n\tsnprintf(err_code_str, sizeof(err_code_str), \"%d\", error_code);\n\t/* calc body len */\n\tcontent_length = (off_t) (strlen(start_body) + strlen(err_code_str) +\n\t\t\t\t  strlen(mid_body) + strlen(err_msg) +\n\t\t\t\t  strlen(end_body));\n\thttp_CalcResponseVersion(hmsg->major_version, hmsg->minor_version,\n\t\t\t\t &major, &minor);\n\t/* make headers */\n\tmembuffer_init(&headers);\n\tif (http_MakeMessage(&headers, major, minor,\n\t\t\t\"RNsDsSXcc\" \"sssss\",\n\t\t\t500,\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\",\n\t\t\tX_USER_AGENT,\n\t\t\tstart_body, err_code_str, mid_body, err_msg,\n\t\t\tend_body) != 0) {\n\t\tmembuffer_destroy(&headers);\n\t\t/* out of mem */\n\t\treturn;\n\t}\n\t/* send err msg */\n\thttp_SendMessage(info, &timeout_secs, \"b\",\n\t\theaders.buf, headers.length);\n\tmembuffer_destroy(&headers);\n}",
          "includes": [
            "#include <string.h>",
            "#include <assert.h>",
            "#include \"upnpapi.h\"",
            "#include \"unixutil.h\"",
            "#include \"statcodes.h\"",
            "#include \"ssdplib.h\"",
            "#include \"soaplib.h\"",
            "#include \"parsetools.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"httpparser.h\"",
            "#include \"ActionRequest.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define SOAP_TIMEOUT UPNP_TIMEOUT",
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SOAP_TIMEOUT UPNP_TIMEOUT\n#define snprintf _snprintf\n\nstatic void send_error_response(\n\t/*! [in] Socket info. */\n\tIN SOCKINFO *info,\n\t/*! [in] Error code. */\n\tIN int error_code,\n\t/*! [in] Error message. */\n\tIN const char *err_msg,\n\t/*! [in] HTTP request. */\n\tIN http_message_t *hmsg)\n{\n\toff_t content_length;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tint major;\n\tint minor;\n\tconst char *start_body =\n/*\t\t\"<?xml version=\\\"1.0\\\"?>\\n\" required?? */\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\"\n\t\t\"<s:Body>\\n\"\n\t\t\"<s:Fault>\\n\"\n\t\t\"<faultcode>s:Client</faultcode>\\n\"\n\t\t\"<faultstring>UPnPError</faultstring>\\n\"\n\t\t\"<detail>\\n\"\n\t\t\"<UPnPError xmlns=\\\"urn:schemas-upnp-org:control-1-0\\\">\\n\"\n\t\t\"<errorCode>\";\n\tconst char *mid_body =\n\t\t\"</errorCode>\\n\"\n\t\t\"<errorDescription>\";\n\tconst char *end_body =\n\t\t\"</errorDescription>\\n\"\n\t\t\"</UPnPError>\\n\"\n\t\t\"</detail>\\n\"\n\t\t\"</s:Fault>\\n\"\n\t\t\"</s:Body>\\n\"\n\t\t\"</s:Envelope>\\n\";\n\tchar err_code_str[30];\n\tmembuffer headers;\n\n\tmemset(err_code_str, 0, sizeof(err_code_str));\n\tsnprintf(err_code_str, sizeof(err_code_str), \"%d\", error_code);\n\t/* calc body len */\n\tcontent_length = (off_t) (strlen(start_body) + strlen(err_code_str) +\n\t\t\t\t  strlen(mid_body) + strlen(err_msg) +\n\t\t\t\t  strlen(end_body));\n\thttp_CalcResponseVersion(hmsg->major_version, hmsg->minor_version,\n\t\t\t\t &major, &minor);\n\t/* make headers */\n\tmembuffer_init(&headers);\n\tif (http_MakeMessage(&headers, major, minor,\n\t\t\t\"RNsDsSXcc\" \"sssss\",\n\t\t\t500,\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\",\n\t\t\tX_USER_AGENT,\n\t\t\tstart_body, err_code_str, mid_body, err_msg,\n\t\t\tend_body) != 0) {\n\t\tmembuffer_destroy(&headers);\n\t\t/* out of mem */\n\t\treturn;\n\t}\n\t/* send err msg */\n\thttp_SendMessage(info, &timeout_secs, \"b\",\n\t\theaders.buf, headers.length);\n\tmembuffer_destroy(&headers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&headers"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ixmlFreeDOMString",
          "args": [
            "xml_response"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpnpPrintf",
          "args": [
            "UPNP_INFO",
            "SOAP",
            "__FILE__",
            "__LINE__",
            "\"Failed to send response: err code = %d\\n\"",
            "ret_code"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "UpnpPrintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/api/upnpdebug.c",
          "lines": "124-154",
          "snippet": "void UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include \"upnpdebug.h\"",
            "#include \"upnp.h\"",
            "#include \"ixml.h\"",
            "#include \"ithread.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"upnpdebug.h\"\n#include \"upnp.h\"\n#include \"ixml.h\"\n#include \"ithread.h\"\n#include \"config.h\"\n\nvoid UpnpPrintf(Upnp_LogLevel DLevel,\n\t\tDbg_Module Module,\n\t\tconst char *DbgFileName, int DbgLineNo, const char *FmtStr, ...)\n{\n\tva_list ArgList;\n\n\tif (!DebugAtThisLevel(DLevel, Module))\n\t\treturn;\n\tithread_mutex_lock(&GlobalDebugMutex);\n\tva_start(ArgList, FmtStr);\n\tif (!DEBUG_TARGET) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(stdout, DbgFileName, DbgLineNo);\n\t\tvfprintf(stdout, FmtStr, ArgList);\n\t\tfflush(stdout);\n\t} else if (DLevel == 0) {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(ErrFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(ErrFileHnd, FmtStr, ArgList);\n\t\tfflush(ErrFileHnd);\n\t} else {\n\t\tif (DbgFileName)\n\t\t\tUpnpDisplayFileAndLine(InfoFileHnd, DbgFileName,\n\t\t\t\t\t       DbgLineNo);\n\t\tvfprintf(InfoFileHnd, FmtStr, ArgList);\n\t\tfflush(InfoFileHnd);\n\t}\n\tva_end(ArgList);\n\tithread_mutex_unlock(&GlobalDebugMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_SendMessage",
          "args": [
            "info",
            "&timeout_secs",
            "\"bbbb\"",
            "headers.buf",
            "headers.length",
            "start_body",
            "strlen(start_body)",
            "xml_response",
            "strlen(xml_response)",
            "end_body",
            "strlen(end_body)"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "437-613",
          "snippet": "int http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CHUNK_TAIL_SIZE (size_t)10",
            "#define CHUNK_HEADER_SIZE (size_t)10",
            "#define snprintf _snprintf",
            "#define fseeko fseek"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n#define snprintf _snprintf\n#define fseeko fseek\n\nint http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "end_body"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_response"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "start_body"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&headers",
            "major",
            "minor",
            "\"RNsDsSXcc\"",
            "HTTP_OK",
            "/* status code */content_length",
            "ContentTypeHeader",
            "\"EXT:\\r\\n\"",
            "X_USER_AGENT"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "strlen(start_body) + strlen(xml_response) +\n\t\tstrlen(end_body)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "end_body"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xml_response"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "start_body"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ixmlPrintNode",
          "args": [
            "(IXML_Node *) action_resp"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&headers"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_CalcResponseVersion",
          "args": [
            "request->major_version",
            "request->minor_version",
            "&major",
            "&minor"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "http_CalcResponseVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1720-1733",
          "snippet": "void http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nvoid http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SOAP_ACTION_FAILED\t501\n#define SOAP_TIMEOUT UPNP_TIMEOUT\n\nstatic UPNP_INLINE void send_action_response(\n\t/*! [in] Socket info. */\n\tSOCKINFO *info,\n\t/*! [in] The response document. */\n\tIXML_Document *action_resp,\n\t/*! [in] Action request document. */\n\thttp_message_t *request)\n{\n\tchar *xml_response = NULL;\n\tmembuffer headers;\n\tint major, minor;\n\tint err_code;\n\toff_t content_length;\n\tint ret_code;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tstatic const char *start_body =\n\t\t/*\"<?xml version=\\\"1.0\\\"?>\" required?? */\n\t\t\"<s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.\"\n\t\t\"org/soap/envelope/\\\" s:encodingStyle=\\\"http://schemas.xmlsoap.\"\n\t\t\"org/soap/encoding/\\\"><s:Body>\\n\";\n\tstatic const char *end_body = \"</s:Body> </s:Envelope>\";\n\n\t/* init */\n\thttp_CalcResponseVersion(request->major_version, request->minor_version,\n\t\t&major, &minor);\n\tmembuffer_init(&headers);\n\terr_code = UPNP_E_OUTOF_MEMORY;\t/* one error only */\n\t/* get xml */\n\txml_response = ixmlPrintNode((IXML_Node *) action_resp);\n\tif (!xml_response)\n\t\tgoto error_handler;\n\tcontent_length = (off_t)(strlen(start_body) + strlen(xml_response) +\n\t\tstrlen(end_body));\n\t/* make headers */\n\tif (http_MakeMessage(&headers, major, minor,\n\t\t\t\"RNsDsSXcc\",\n\t\t\tHTTP_OK,\t/* status code */\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\", X_USER_AGENT) != 0) {\n\t\tgoto error_handler;\n\t}\n\t/* send whole msg */\n\tret_code = http_SendMessage(\n\t\tinfo, &timeout_secs, \"bbbb\",\n\t\theaders.buf, headers.length,\n\t\tstart_body, strlen(start_body),\n\t\txml_response, strlen(xml_response),\n\t\tend_body, strlen(end_body));\n\tif (ret_code != 0) {\n\t\tUpnpPrintf(UPNP_INFO, SOAP, __FILE__, __LINE__,\n\t\t\t   \"Failed to send response: err code = %d\\n\",\n\t\t\t   ret_code);\n\t}\n\terr_code = 0;\n\nerror_handler:\n\tixmlFreeDOMString(xml_response);\n\tmembuffer_destroy(&headers);\n\tif (err_code != 0) {\n\t\t/* only one type of error to worry about - out of mem */\n\t\tsend_error_response(info, SOAP_ACTION_FAILED, \"Out of memory\",\n\t\t\trequest);\n\t}\n}"
  },
  {
    "function_name": "send_var_query_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
    "lines": "168-214",
    "snippet": "static UPNP_INLINE void send_var_query_response(\n\t/*! [in] Socket info. */\n\tSOCKINFO *info,\n\t/*! [in] Value of the state variable. */\n\tconst char *var_value,\n\t/*! [in] HTTP request. */\n\thttp_message_t *hmsg)\n{\n\toff_t content_length;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tint major;\n\tint minor;\n\tconst char *start_body =\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\"\n\t\t\"<s:Body>\\n\"\n\t\t\"<u:QueryStateVariableResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:control-1-0\\\">\\n\" \"<return>\";\n\tconst char *end_body =\n\t\t\"</return>\\n\"\n\t\t\"</u:QueryStateVariableResponse>\\n\" \"</s:Body>\\n\" \"</s:Envelope>\\n\";\n\tmembuffer response;\n\n\thttp_CalcResponseVersion(hmsg->major_version, hmsg->minor_version,\n\t\t\t\t &major, &minor);\n\tcontent_length = (off_t) (strlen(start_body) + strlen(var_value) +\n\t\t\t\t  strlen(end_body));\n\t/* make headers */\n\tmembuffer_init(&response);\n\tif (http_MakeMessage(&response, major, minor,\n\t\t\t\"RNsDsSXcc\" \"sss\",\n\t\t\tHTTP_OK,\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\",\n\t\t\tX_USER_AGENT,\n\t\t\tstart_body, var_value, end_body) != 0) {\n\t\tmembuffer_destroy(&response);\n\t\t/* out of mem */\n\t\treturn;\n\t}\n\t/* send msg */\n\thttp_SendMessage(info, &timeout_secs, \"b\",\n\t\tresponse.buf, response.length);\n\tmembuffer_destroy(&response);\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"soaplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ActionRequest.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SOAP_TIMEOUT UPNP_TIMEOUT"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&response"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_SendMessage",
          "args": [
            "info",
            "&timeout_secs",
            "\"b\"",
            "response.buf",
            "response.length"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "437-613",
          "snippet": "int http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CHUNK_TAIL_SIZE (size_t)10",
            "#define CHUNK_HEADER_SIZE (size_t)10",
            "#define snprintf _snprintf",
            "#define fseeko fseek"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n#define snprintf _snprintf\n#define fseeko fseek\n\nint http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&response",
            "major",
            "minor",
            "\"RNsDsSXcc\" \"sss\"",
            "HTTP_OK",
            "content_length",
            "ContentTypeHeader",
            "\"EXT:\\r\\n\"",
            "X_USER_AGENT",
            "start_body",
            "var_value",
            "end_body"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&response"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "strlen(start_body) + strlen(var_value) +\n\t\t\t\t  strlen(end_body)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "end_body"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "var_value"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "start_body"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "http_CalcResponseVersion",
          "args": [
            "hmsg->major_version",
            "hmsg->minor_version",
            "&major",
            "&minor"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "http_CalcResponseVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1720-1733",
          "snippet": "void http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nvoid http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SOAP_TIMEOUT UPNP_TIMEOUT\n\nstatic UPNP_INLINE void send_var_query_response(\n\t/*! [in] Socket info. */\n\tSOCKINFO *info,\n\t/*! [in] Value of the state variable. */\n\tconst char *var_value,\n\t/*! [in] HTTP request. */\n\thttp_message_t *hmsg)\n{\n\toff_t content_length;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tint major;\n\tint minor;\n\tconst char *start_body =\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\"\n\t\t\"<s:Body>\\n\"\n\t\t\"<u:QueryStateVariableResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:control-1-0\\\">\\n\" \"<return>\";\n\tconst char *end_body =\n\t\t\"</return>\\n\"\n\t\t\"</u:QueryStateVariableResponse>\\n\" \"</s:Body>\\n\" \"</s:Envelope>\\n\";\n\tmembuffer response;\n\n\thttp_CalcResponseVersion(hmsg->major_version, hmsg->minor_version,\n\t\t\t\t &major, &minor);\n\tcontent_length = (off_t) (strlen(start_body) + strlen(var_value) +\n\t\t\t\t  strlen(end_body));\n\t/* make headers */\n\tmembuffer_init(&response);\n\tif (http_MakeMessage(&response, major, minor,\n\t\t\t\"RNsDsSXcc\" \"sss\",\n\t\t\tHTTP_OK,\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\",\n\t\t\tX_USER_AGENT,\n\t\t\tstart_body, var_value, end_body) != 0) {\n\t\tmembuffer_destroy(&response);\n\t\t/* out of mem */\n\t\treturn;\n\t}\n\t/* send msg */\n\thttp_SendMessage(info, &timeout_secs, \"b\",\n\t\tresponse.buf, response.length);\n\tmembuffer_destroy(&response);\n}"
  },
  {
    "function_name": "send_error_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/soap/soap_device.c",
    "lines": "97-163",
    "snippet": "static void send_error_response(\n\t/*! [in] Socket info. */\n\tIN SOCKINFO *info,\n\t/*! [in] Error code. */\n\tIN int error_code,\n\t/*! [in] Error message. */\n\tIN const char *err_msg,\n\t/*! [in] HTTP request. */\n\tIN http_message_t *hmsg)\n{\n\toff_t content_length;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tint major;\n\tint minor;\n\tconst char *start_body =\n/*\t\t\"<?xml version=\\\"1.0\\\"?>\\n\" required?? */\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\"\n\t\t\"<s:Body>\\n\"\n\t\t\"<s:Fault>\\n\"\n\t\t\"<faultcode>s:Client</faultcode>\\n\"\n\t\t\"<faultstring>UPnPError</faultstring>\\n\"\n\t\t\"<detail>\\n\"\n\t\t\"<UPnPError xmlns=\\\"urn:schemas-upnp-org:control-1-0\\\">\\n\"\n\t\t\"<errorCode>\";\n\tconst char *mid_body =\n\t\t\"</errorCode>\\n\"\n\t\t\"<errorDescription>\";\n\tconst char *end_body =\n\t\t\"</errorDescription>\\n\"\n\t\t\"</UPnPError>\\n\"\n\t\t\"</detail>\\n\"\n\t\t\"</s:Fault>\\n\"\n\t\t\"</s:Body>\\n\"\n\t\t\"</s:Envelope>\\n\";\n\tchar err_code_str[30];\n\tmembuffer headers;\n\n\tmemset(err_code_str, 0, sizeof(err_code_str));\n\tsnprintf(err_code_str, sizeof(err_code_str), \"%d\", error_code);\n\t/* calc body len */\n\tcontent_length = (off_t) (strlen(start_body) + strlen(err_code_str) +\n\t\t\t\t  strlen(mid_body) + strlen(err_msg) +\n\t\t\t\t  strlen(end_body));\n\thttp_CalcResponseVersion(hmsg->major_version, hmsg->minor_version,\n\t\t\t\t &major, &minor);\n\t/* make headers */\n\tmembuffer_init(&headers);\n\tif (http_MakeMessage(&headers, major, minor,\n\t\t\t\"RNsDsSXcc\" \"sssss\",\n\t\t\t500,\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\",\n\t\t\tX_USER_AGENT,\n\t\t\tstart_body, err_code_str, mid_body, err_msg,\n\t\t\tend_body) != 0) {\n\t\tmembuffer_destroy(&headers);\n\t\t/* out of mem */\n\t\treturn;\n\t}\n\t/* send err msg */\n\thttp_SendMessage(info, &timeout_secs, \"b\",\n\t\theaders.buf, headers.length);\n\tmembuffer_destroy(&headers);\n}",
    "includes": [
      "#include <string.h>",
      "#include <assert.h>",
      "#include \"upnpapi.h\"",
      "#include \"unixutil.h\"",
      "#include \"statcodes.h\"",
      "#include \"ssdplib.h\"",
      "#include \"soaplib.h\"",
      "#include \"parsetools.h\"",
      "#include \"httpreadwrite.h\"",
      "#include \"httpparser.h\"",
      "#include \"ActionRequest.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define SOAP_TIMEOUT UPNP_TIMEOUT",
      "#define snprintf _snprintf"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuffer_destroy",
          "args": [
            "&headers"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "160-168",
          "snippet": "void membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_destroy(membuffer *m)\n{\n\tif (m == NULL) {\n\t\treturn;\n\t}\n\n\tfree(m->buf);\n\tmembuffer_init(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_SendMessage",
          "args": [
            "info",
            "&timeout_secs",
            "\"b\"",
            "headers.buf",
            "headers.length"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "http_SendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "437-613",
          "snippet": "int http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define CHUNK_TAIL_SIZE (size_t)10",
            "#define CHUNK_HEADER_SIZE (size_t)10",
            "#define snprintf _snprintf",
            "#define fseeko fseek"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define CHUNK_TAIL_SIZE (size_t)10\n#define CHUNK_HEADER_SIZE (size_t)10\n#define snprintf _snprintf\n#define fseeko fseek\n\nint http_SendMessage(SOCKINFO *info, int *TimeOut, const char *fmt, ...)\n{\n#if EXCLUDE_WEB_SERVER == 0\n\tFILE *Fp;\n\tstruct SendInstruction *Instr = NULL;\n\tchar *filename = NULL;\n\tchar *file_buf = NULL;\n\tchar *ChunkBuf = NULL;\n\t/* 10 byte allocated for chunk header. */\n\tchar Chunk_Header[CHUNK_HEADER_SIZE];\n\tsize_t num_read;\n\tsize_t amount_to_be_read = (size_t)0;\n\tsize_t Data_Buf_Size = WEB_SERVER_BUF_SIZE;\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_list argp;\n\tchar *buf = NULL;\n\tchar c;\n\tint nw;\n\tint RetVal = 0;\n\tsize_t buf_length;\n\tsize_t num_written;\n\n#if EXCLUDE_WEB_SERVER == 0\n\tmemset(Chunk_Header, 0, sizeof(Chunk_Header));\n#endif /* EXCLUDE_WEB_SERVER */\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n#if EXCLUDE_WEB_SERVER == 0\n\t\tif (c == 'I') {\n\t\t\tInstr = va_arg(argp, struct SendInstruction *);\n\t\t\tif (Instr->ReadSendSize >= 0)\n\t\t\t\tamount_to_be_read = (size_t)Instr->ReadSendSize;\n\t\t\telse\n\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\tif (amount_to_be_read < WEB_SERVER_BUF_SIZE)\n\t\t\t\tData_Buf_Size = amount_to_be_read;\n\t\t\tChunkBuf = malloc((size_t)\n\t\t\t\t(Data_Buf_Size + CHUNK_HEADER_SIZE +\n\t\t\t\tCHUNK_TAIL_SIZE));\n\t\t\tif (!ChunkBuf) {\n\t\t\t\tRetVal = UPNP_E_OUTOF_MEMORY;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tfile_buf = ChunkBuf + CHUNK_HEADER_SIZE;\n\t\t} else if (c == 'f') {\n\t\t\t/* file name */\n\t\t\tfilename = va_arg(argp, char *);\n\t\t\tif (Instr && Instr->IsVirtualFile)\n\t\t\t\tFp = (virtualDirCallback.open)(filename, UPNP_READ);\n\t\t\telse\n\t\t\t\tFp = fopen(filename, \"rb\");\n\t\t\tif (Fp == NULL) {\n\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t\tif (Instr && Instr->IsRangeActive && Instr->IsVirtualFile) {\n\t\t\t\tif (virtualDirCallback.seek(Fp, Instr->RangeOffset,\n\t\t\t\t    SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t} else if (Instr && Instr->IsRangeActive) {\n\t\t\t\tif (fseeko(Fp, Instr->RangeOffset, SEEK_CUR) != 0) {\n\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (amount_to_be_read) {\n\t\t\t\tif (Instr) {\n\t\t\t\t\tint nr;\n\t\t\t\t\tsize_t n = amount_to_be_read >= Data_Buf_Size ?\n\t\t\t\t\t    \tData_Buf_Size : amount_to_be_read;\n\t\t\t\t\tif (Instr->IsVirtualFile) {\n\t\t\t\t\t\tnr = virtualDirCallback.read(Fp, file_buf, n);\n\t\t\t\t\t\tnum_read = (size_t)nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, n, Fp);\n\t\t\t\t\t}\n\t\t\t\t\tamount_to_be_read -= num_read;\n\t\t\t\t\tif (Instr->ReadSendSize < 0) {\n\t\t\t\t\t\t/* read until close */\n\t\t\t\t\t\tamount_to_be_read = Data_Buf_Size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnum_read = fread(file_buf, (size_t)1, Data_Buf_Size, Fp);\n\t\t\t\t}\n\t\t\t\tif (num_read == (size_t)0) {\n\t\t\t\t\t/* EOF so no more to send. */\n\t\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\t\tconst char *str = \"0\\r\\n\\r\\n\";\n\t\t\t\t\t\tnw = sock_write(info, str,\n\t\t\t\t\t\t\t       strlen(str),\n\t\t\t\t\t\t\t       TimeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRetVal = UPNP_E_FILE_READ_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t}\n\t\t\t\t/* Create chunk for the current buffer. */\n\t\t\t\tif (Instr && Instr->IsChunkActive) {\n\t\t\t\t\tint rc;\n\t\t\t\t\t/* Copy CRLF at the end of the chunk */\n\t\t\t\t\tmemcpy(file_buf + num_read, \"\\r\\n\", (size_t)2);\n\t\t\t\t\t/* Hex length for the chunk size. */\n\t\t\t\t\tmemset(Chunk_Header, 0,\n\t\t\t\t\t\tsizeof(Chunk_Header));\n\t\t\t\t\trc = snprintf(Chunk_Header,\n\t\t\t\t\t\tsizeof(Chunk_Header),\n\t\t\t\t\t\t\"%\" PRIzx \"\\r\\n\", num_read);\n\t\t\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(Chunk_Header)) {\n\t\t\t\t\t\tRetVal = UPNP_E_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t\t/* Copy the chunk size header  */\n\t\t\t\t\tmemcpy(file_buf - strlen(Chunk_Header),\n\t\t\t\t\t       Chunk_Header,\n\t\t\t\t\t       strlen(Chunk_Header));\n\t\t\t\t\t/* on the top of the buffer. */\n\t\t\t\t\t/*file_buf[num_read+strlen(Chunk_Header)] = NULL; */\n\t\t\t\t\t/*printf(\"Sending %s\\n\",file_buf-strlen(Chunk_Header)); */\n\t\t\t\t\tnw = sock_write(info,\n\t\t\t\t\t\tfile_buf - strlen(Chunk_Header),\n\t\t\t\t\t\tnum_read + strlen(Chunk_Header) + (size_t)2,\n\t\t\t\t\t\tTimeOut);\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read + strlen(Chunk_Header) + (size_t)2)\n\t\t\t\t\t\t/* Send error nothing we can do. */\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t} else {\n\t\t\t\t\t/* write data */\n\t\t\t\t\tnw = sock_write(info, file_buf, num_read, TimeOut);\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t   \">>> (SENT) >>>\\n%.*s\\n------------\\n\",\n\t\t\t\t\t\t   nw, file_buf);\n\t\t\t\t\t/* Send error nothing we can do */\n\t\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\t\tif (nw <= 0 || num_written != num_read) {\n\t\t\t\t\t\tgoto Cleanup_File;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} /* while */\nCleanup_File:\n\t\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\t\tvirtualDirCallback.close(Fp);\n\t\t\t} else {\n\t\t\t\tfclose(Fp);\n\t\t\t}\n\t\t\tgoto ExitFunction;\n\t\t} else\n#endif /* EXCLUDE_WEB_SERVER */\n\t\tif (c == 'b') {\n\t\t\t/* memory buffer */\n\t\t\tbuf = va_arg(argp, char *);\n\t\t\tbuf_length = va_arg(argp, size_t);\n\t\t\tif (buf_length > (size_t)0) {\n\t\t\t\tnw = sock_write(info, buf, buf_length, TimeOut);\n\t\t\t\tnum_written = (size_t)nw;\n\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t   \">>> (SENT) >>>\\n\"\n\t\t\t\t\t   \"%.*s\\nbuf_length=%\" PRIzd \", num_written=%\" PRIzd \"\\n\"\n\t\t\t\t\t   \"------------\\n\",\n\t\t\t\t\t   (int)buf_length, buf, buf_length, num_written);\n\t\t\t\tif (num_written != buf_length) {\n\t\t\t\t\tRetVal = 0;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExitFunction:\n\tva_end(argp);\n#if EXCLUDE_WEB_SERVER == 0\n\tfree(ChunkBuf);\n#endif /* EXCLUDE_WEB_SERVER */\n\treturn RetVal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_MakeMessage",
          "args": [
            "&headers",
            "major",
            "minor",
            "\"RNsDsSXcc\" \"sssss\"",
            "500",
            "content_length",
            "ContentTypeHeader",
            "\"EXT:\\r\\n\"",
            "X_USER_AGENT",
            "start_body",
            "err_code_str",
            "mid_body",
            "err_msg",
            "end_body"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "http_MakeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1470-1703",
          "snippet": "int http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define snprintf _snprintf"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\n#define snprintf _snprintf\n\nint http_MakeMessage(membuffer *buf, int http_major_version,\n\tint http_minor_version, const char *fmt, ...)\n{\n\tchar c;\n\tchar *s = NULL;\n\tsize_t num;\n\toff_t bignum;\n\tsize_t length;\n\ttime_t *loc_time;\n\ttime_t curr_time;\n\tstruct tm date_storage;\n\tstruct tm *date;\n\tconst char *start_str;\n\tconst char *end_str;\n\tint status_code;\n\tconst char *status_msg;\n\thttp_method_t method;\n\tconst char *method_str;\n\tconst char *url_str;\n\tconst char *temp_str;\n\turi_type url;\n\turi_type *uri_ptr;\n\tint error_code = 0;\n\tva_list argp;\n\tchar tempbuf[200];\n\tconst char *weekday_str = \"Sun\\0Mon\\0Tue\\0Wed\\0Thu\\0Fri\\0Sat\";\n\tconst char *month_str = \"Jan\\0Feb\\0Mar\\0Apr\\0May\\0Jun\\0\"\n\t    \"Jul\\0Aug\\0Sep\\0Oct\\0Nov\\0Dec\";\n\tint rc = 0;\n\n\tmemset(tempbuf, 0, sizeof(tempbuf));\n\tva_start(argp, fmt);\n\twhile ((c = *fmt++)) {\n\t\tif (c == 's') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t   \"Adding a string : %s\\n\", s);\n\t\t\tif (membuffer_append(buf, s, strlen(s)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'K') {\n\t\t\t/* Add Chunky header */\n\t\t\tif (membuffer_append(buf, \"TRANSFER-ENCODING: chunked\\r\\n\",\n\t\t\t\tstrlen(\"Transfer-Encoding: chunked\\r\\n\")))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'G') {\n\t\t\t/* Add Range header */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\t/* connection header */\n\t\t\tif (membuffer_append(buf, RespInstr->RangeHeader,\n\t\t\t\tstrlen(RespInstr->RangeHeader)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'b') {\n\t\t\t/* mem buffer */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tUpnpPrintf(UPNP_ALL, HTTP, __FILE__, __LINE__,\n\t\t\t\t\"Adding a char Buffer starting with: %c\\n\", (int)s[0]);\n\t\t\tassert(s);\n\t\t\tlength = (size_t) va_arg(argp, size_t);\n\t\t\tif (membuffer_append(buf, s, length))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'c') {\n\t\t\t/* crlf */\n\t\t\tif (membuffer_append(buf, \"\\r\\n\", (size_t)2))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'd') {\n\t\t\t/* integer */\n\t\t\tnum = (size_t)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRIzu, num);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'h') {\n\t\t\t/* off_t */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%\" PRId64,\n\t\t\t\t(int64_t) bignum);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 't' || c == 'D') {\n\t\t\t/* date */\n\t\t\tif (c == 'D') {\n\t\t\t\t/* header */\n\t\t\t\tstart_str = \"DATE: \";\n\t\t\t\tend_str = \"\\r\\n\";\n\t\t\t\tcurr_time = time(NULL);\n\t\t\t\tloc_time = &curr_time;\n\t\t\t} else {\n\t\t\t\t/* date value only */\n\t\t\t\tstart_str = end_str = \"\";\n\t\t\t\tloc_time = (time_t *)va_arg(argp, time_t *);\n\t\t\t}\n\t\t\tassert(loc_time);\n\t\t\tdate = http_gmtime_r(loc_time, &date_storage);\n\t\t\tif (date == NULL)\n\t\t\t\tgoto error_handler;\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf),\n\t\t\t\t\"%s%s, %02d %s %d %02d:%02d:%02d GMT%s\",\n\t\t\t\tstart_str, &weekday_str[date->tm_wday * 4],\n\t\t\t\tdate->tm_mday, &month_str[date->tm_mon * 4],\n\t\t\t\tdate->tm_year + 1900, date->tm_hour,\n\t\t\t\tdate->tm_min, date->tm_sec, end_str);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\tmembuffer_append(buf, tempbuf, strlen(tempbuf)))\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'L') {\n\t\t\t/* Add CONTENT-LANGUAGE header only if WEB_SERVER_CONTENT_LANGUAGE */\n\t\t\t/* is not empty and if Accept-Language header is not empty */\n\t\t\tstruct SendInstruction *RespInstr;\n\t\t\tRespInstr = (struct SendInstruction *)\n\t\t\t    va_arg(argp, struct SendInstruction *);\n\t\t\tassert(RespInstr);\n\t\t\tif (strcmp(RespInstr->AcceptLanguageHeader, \"\") &&\n\t\t\t    strcmp(WEB_SERVER_CONTENT_LANGUAGE, \"\") &&\n\t\t\t    http_MakeMessage(buf, http_major_version,\n\t\t\t\t\thttp_minor_version, \"ssc\",\n\t\t\t\t\t\"CONTENT-LANGUAGE: \",\n\t\t\t\t\tWEB_SERVER_CONTENT_LANGUAGE) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'C') {\n\t\t\tif ((http_major_version > 1) ||\n\t\t\t    (http_major_version == 1 && http_minor_version == 1)\n\t\t\t    ) {\n\t\t\t\t/* connection header */\n\t\t\t\tif (membuffer_append_str(buf, \"CONNECTION: close\\r\\n\"))\n\t\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t} else if (c == 'N') {\n\t\t\t/* content-length header */\n\t\t\tbignum = (off_t) va_arg(argp, off_t);\n\t\t\tassert(bignum >= 0);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"shc\", \"CONTENT-LENGTH: \", bignum) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'S' || c == 'U') {\n\t\t\t/* SERVER or USER-AGENT header */\n\t\t\ttemp_str = (c == 'S') ? \"SERVER: \" : \"USER-AGENT: \";\n\t\t\tget_sdk_info(tempbuf, sizeof(tempbuf));\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ss\", temp_str, tempbuf) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'X') {\n\t\t\t/* C string */\n\t\t\ts = (char *)va_arg(argp, char *);\n\t\t\tassert(s);\n\t\t\tif (membuffer_append_str(buf, \"X-User-Agent: \") != 0)\n\t\t\t\tgoto error_handler;\n\t\t\tif (membuffer_append(buf, s, strlen(s)) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'R') {\n\t\t\t/* response start line */\n\t\t\t/*   e.g.: 'HTTP/1.1 200 OK' code */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\tassert(status_code > 0);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"HTTP/%d.%d %d \",\n\t\t\t\thttp_major_version, http_minor_version,\n\t\t\t\tstatus_code);\n\t\t\t/* str */\n\t\t\tstatus_msg = http_get_code_text(status_code);\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf) ||\n\t\t\t\thttp_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", tempbuf, status_msg) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'B') {\n\t\t\t/* body of a simple reply */\n\t\t\tstatus_code = (int)va_arg(argp, int);\n\t\t\trc = snprintf(tempbuf, sizeof(tempbuf), \"%s%d %s%s\",\n\t\t\t\t\"<html><body><h1>\",\n\t\t\t\tstatus_code, http_get_code_text(status_code),\n\t\t\t\t\"</h1></body></html>\");\n\t\t\tif (rc < 0 || (unsigned int) rc >= sizeof(tempbuf))\n\t\t\t\tgoto error_handler;\n\t\t\tbignum = (off_t)strlen(tempbuf);\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"NTcs\", bignum,\t/* content-length */\n\t\t\t\t\t     \"text/html\",\t/* content-type */\n\t\t\t\t\t     tempbuf) != 0\t/* body */\n\t\t\t    )\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'Q') {\n\t\t\t/* request start line */\n\t\t\t/* GET /foo/bar.html HTTP/1.1\\r\\n */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\tmethod_str = method_to_str(method);\n\t\t\turl_str = (const char *)va_arg(argp, const char *);\n\t\t\tnum = (size_t) va_arg(argp, size_t);\t\t/* length of url_str */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssbsdsdc\", method_str,\t/* method */\n\t\t\t\t\t     \" \", url_str, num,\t\t/* url */\n\t\t\t\t\t     \" HTTP/\", http_major_version, \".\",\n\t\t\t\t\t     http_minor_version) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'q') {\n\t\t\t/* request start line and HOST header */\n\t\t\tmethod = (http_method_t) va_arg(argp, http_method_t);\n\t\t\turi_ptr = (uri_type *) va_arg(argp, uri_type *);\n\t\t\tassert(uri_ptr);\n\t\t\tif (http_FixUrl(uri_ptr, &url) != 0) {\n\t\t\t\terror_code = UPNP_E_INVALID_URL;\n\t\t\t\tgoto error_handler;\n\t\t\t}\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t\"Q\" \"sbc\", method, url.pathquery.buff,\n\t\t\t\t\turl.pathquery.size, \"HOST: \",\n\t\t\t\t\turl.hostport.text.buff,\n\t\t\t\t\turl.hostport.text.size) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else if (c == 'T') {\n\t\t\t/* content type header */\n\t\t\ttemp_str = (const char *)va_arg(argp, const char *);\t/* type/subtype format */\n\t\t\tif (http_MakeMessage(buf, http_major_version, http_minor_version,\n\t\t\t\t\t     \"ssc\", \"CONTENT-TYPE: \", temp_str) != 0)\n\t\t\t\tgoto error_handler;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n\tgoto ExitFunction;\n\nerror_handler:\n\t/* Default is out of memory error. */\n\tif (!error_code)\n\t\terror_code = UPNP_E_OUTOF_MEMORY;\n\tmembuffer_destroy(buf);\n\nExitFunction:\n\tva_end(argp);\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuffer_init",
          "args": [
            "&headers"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "membuffer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/util/membuffer.c",
          "lines": "152-158",
          "snippet": "void membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}",
          "includes": [
            "#include \"unixutil.h\"",
            "#include \"upnp.h\"",
            "#include \"membuffer.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <assert.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"unixutil.h\"\n#include \"upnp.h\"\n#include \"membuffer.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"config.h\"\n\nvoid membuffer_init(membuffer *m)\n{\n\tassert(m != NULL);\n\n\tm->size_inc = MEMBUF_DEF_SIZE_INC;\n\tmembuffer_initialize(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "http_CalcResponseVersion",
          "args": [
            "hmsg->major_version",
            "hmsg->minor_version",
            "&major",
            "&minor"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "http_CalcResponseVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/genlib/net/http/httpreadwrite.c",
          "lines": "1720-1733",
          "snippet": "void http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <sys/wait.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <arpa/inet.h>",
            "#include <malloc.h>",
            "#include <stdarg.h>",
            "#include <assert.h>",
            "#include \"webserver.h\"",
            "#include \"UpnpStdInt.h\"",
            "#include \"UpnpIntTypes.h\"",
            "#include \"UpnpInet.h\"",
            "#include \"sock.h\"",
            "#include \"statcodes.h\"",
            "#include \"uri.h\"",
            "#include \"membuffer.h\"",
            "#include \"upnpapi.h\"",
            "#include \"upnp.h\"",
            "#include \"unixutil.h\"",
            "#include \"httpreadwrite.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <sys/wait.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <arpa/inet.h>\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include \"webserver.h\"\n#include \"UpnpStdInt.h\"\n#include \"UpnpIntTypes.h\"\n#include \"UpnpInet.h\"\n#include \"sock.h\"\n#include \"statcodes.h\"\n#include \"uri.h\"\n#include \"membuffer.h\"\n#include \"upnpapi.h\"\n#include \"upnp.h\"\n#include \"unixutil.h\"\n#include \"httpreadwrite.h\"\n#include \"config.h\"\n\nvoid http_CalcResponseVersion( IN int request_major_vers,\n                          IN int request_minor_vers,\n                          OUT int *response_major_vers,\n                          OUT int *response_minor_vers)\n{\n\tif ((request_major_vers > 1) ||\n\t    (request_major_vers == 1 && request_minor_vers >= 1)) {\n\t\t*response_major_vers = 1;\n\t\t*response_minor_vers = 1;\n\t} else {\n\t\t*response_major_vers = request_major_vers;\n\t\t*response_minor_vers = request_minor_vers;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "strlen(start_body) + strlen(err_code_str) +\n\t\t\t\t  strlen(mid_body) + strlen(err_msg) +\n\t\t\t\t  strlen(end_body)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "end_body"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "err_msg"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mid_body"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "err_code_str"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "start_body"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "err_code_str",
            "sizeof(err_code_str)",
            "\"%d\"",
            "error_code"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "err_code_str",
            "0",
            "sizeof(err_code_str)"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "MD5_memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-6255/repo/upnp/src/uuid/md5.c",
          "lines": "345-352",
          "snippet": "static void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}",
          "includes": [
            "#include \"md5.h\"",
            "#include \"global.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MD5_memset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"global.h\"\n#include \"config.h\"\n\nstatic void MD5_memset;\n\nstatic void\nMD5_memset(POINTER output, int value, unsigned int len)\n{\n\tunsigned int i;\n\tfor (i = 0; i < len; ++i) {\n\t\t((char *)output)[i] = (char)value;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <assert.h>\n#include \"upnpapi.h\"\n#include \"unixutil.h\"\n#include \"statcodes.h\"\n#include \"ssdplib.h\"\n#include \"soaplib.h\"\n#include \"parsetools.h\"\n#include \"httpreadwrite.h\"\n#include \"httpparser.h\"\n#include \"ActionRequest.h\"\n#include \"config.h\"\n\n#define SOAP_TIMEOUT UPNP_TIMEOUT\n#define snprintf _snprintf\n\nstatic void send_error_response(\n\t/*! [in] Socket info. */\n\tIN SOCKINFO *info,\n\t/*! [in] Error code. */\n\tIN int error_code,\n\t/*! [in] Error message. */\n\tIN const char *err_msg,\n\t/*! [in] HTTP request. */\n\tIN http_message_t *hmsg)\n{\n\toff_t content_length;\n\tint timeout_secs = SOAP_TIMEOUT;\n\tint major;\n\tint minor;\n\tconst char *start_body =\n/*\t\t\"<?xml version=\\\"1.0\\\"?>\\n\" required?? */\n\t\t\"<s:Envelope \"\n\t\t\"xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n\t\t\"s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\\n\"\n\t\t\"<s:Body>\\n\"\n\t\t\"<s:Fault>\\n\"\n\t\t\"<faultcode>s:Client</faultcode>\\n\"\n\t\t\"<faultstring>UPnPError</faultstring>\\n\"\n\t\t\"<detail>\\n\"\n\t\t\"<UPnPError xmlns=\\\"urn:schemas-upnp-org:control-1-0\\\">\\n\"\n\t\t\"<errorCode>\";\n\tconst char *mid_body =\n\t\t\"</errorCode>\\n\"\n\t\t\"<errorDescription>\";\n\tconst char *end_body =\n\t\t\"</errorDescription>\\n\"\n\t\t\"</UPnPError>\\n\"\n\t\t\"</detail>\\n\"\n\t\t\"</s:Fault>\\n\"\n\t\t\"</s:Body>\\n\"\n\t\t\"</s:Envelope>\\n\";\n\tchar err_code_str[30];\n\tmembuffer headers;\n\n\tmemset(err_code_str, 0, sizeof(err_code_str));\n\tsnprintf(err_code_str, sizeof(err_code_str), \"%d\", error_code);\n\t/* calc body len */\n\tcontent_length = (off_t) (strlen(start_body) + strlen(err_code_str) +\n\t\t\t\t  strlen(mid_body) + strlen(err_msg) +\n\t\t\t\t  strlen(end_body));\n\thttp_CalcResponseVersion(hmsg->major_version, hmsg->minor_version,\n\t\t\t\t &major, &minor);\n\t/* make headers */\n\tmembuffer_init(&headers);\n\tif (http_MakeMessage(&headers, major, minor,\n\t\t\t\"RNsDsSXcc\" \"sssss\",\n\t\t\t500,\n\t\t\tcontent_length,\n\t\t\tContentTypeHeader,\n\t\t\t\"EXT:\\r\\n\",\n\t\t\tX_USER_AGENT,\n\t\t\tstart_body, err_code_str, mid_body, err_msg,\n\t\t\tend_body) != 0) {\n\t\tmembuffer_destroy(&headers);\n\t\t/* out of mem */\n\t\treturn;\n\t}\n\t/* send err msg */\n\thttp_SendMessage(info, &timeout_secs, \"b\",\n\t\theaders.buf, headers.length);\n\tmembuffer_destroy(&headers);\n}"
  }
]